<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_E2EPJLR_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2EPJLR_requirements_AUTOSAR_SWS_E2ETransformer_PJLR.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2EPJLR_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2EPJLR_requirements_JLR_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2EPJLR_requirements_TL_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2E_requirements_E2EXf_Pxx_AUTOSAR_SWS_E2ETransformer_PXX.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2E_requirements_TL_ProfilesGeneral_TL_Requirements_General.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/common_req/E2EPJLR_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_OldCImporter/reqm_TCS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 22:13:41 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_E2EPJLR_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2EPJLR_requirements_AUTOSAR_SWS_E2ETransformer_PJLR.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2EPJLR_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2EPJLR_requirements_JLR_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2EPJLR_requirements_TL_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2E_requirements_E2EXf_Pxx_AUTOSAR_SWS_E2ETransformer_PXX.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_Native/asc_E2E_requirements_TL_ProfilesGeneral_TL_Requirements_General.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/common_req/E2EPJLR_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/ReqM2_OldCImporter/reqm_TCS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/2018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>feavc</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swpad</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swts</regex>
      <regex>pdoc</regex>       <!-- since 10/2018: introduced for updated tracing model-->
      <regex>dev</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swadvc</regex>     <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swuvc</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/2020: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>
      <regex>doc</regex>

      <!-- legacy items -->
      <regex>req</regex>        <!-- deprecated 10/2017: old swrs type -->
      <regex>dsn</regex>        <!-- deprecated 10/2017: old swdd -->
      <regex>src</regex>        <!-- deprecated 10/2017: old impl type -->
      <regex>tcs</regex>        <!-- deprecated 10/2017: replaced by swintts and swuts -->
      <regex>dsn_arch</regex>   <!-- deprecated 10/2017: old swad type -->
      <regex>man</regex>
      <regex>tso</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='req') and (../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.rejected</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.count</name>
      <description>Requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='req') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='req') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.req.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[((../@doctype='req') or (../@doctype='swrs')) and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dsn.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[((../@doctype='swdd') or (../@doctype='dsn')) and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.doctypes</name>
      <description>Requirements can be covered only by req, dsn_arch, dev, lim, dsn, src, tcs, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='req')]</applyto>
          <condition>(./needscoverage/needsobj="req" or ./needscoverage/needsobj="dsn_arch" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swad, dev, lim, swurs, swdd, src, swuts, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dsn.needscoverage.doctypes</name>
      <description>Design elements can only be covered by dsn, src, tcs, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dsn')]</applyto>
          <condition>(./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>
    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.tcs.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.src.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='src')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="tsc" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes") )</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="dsn_arch" or ./fulfilledby/ffbObj/ffbType="dsn_arch" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>



    <rule>
      <name>ERR.dsn_arch.needscoverage.doctypes</name>
      <description>Architectural design objects can only be covered by dsn_arch, dsn, src, tcs, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dsn_arch')]</applyto>
          <condition>(./needscoverage/needsobj="dsn_arch" or ./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, req, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
         </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.tcs.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>
  </rules>
    <oreqmRules>
          <rule>
            <name>WRN.tsc.needscoverage.count</name>
            <description>Violated if there are more than 10 tsc specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='tcs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='tsc'])) &gt; 10]/furtherinfo</applyto>
                    <regex>tsc.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.req.needscoverage.count</name>
            <description>Violated if there are more than 10 req specobjects covering one specobject and no appropriate information is provided in furtherinfo, refinement on req to req are excluded. Refinements of requirements Req to Req and Req to Fea are excluded from this rule since this is tracing on the same level. The justification in furtherinfo must contain the rule name.</description>
           <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(../@doctype != 'req') and (../@doctype != 'fea') and ((count(./needscoverage/needscov[needsobj='req']/coveredby/linkedfrom)) &gt; 10)]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='req'])) &gt; 10]/furtherinfo</applyto>
                    <regex>req.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
     </rule>

        <rule>
            <name>WRN.src.needscoverage.count</name>
            <description>Violated if there are more than 10 src specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='src']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.dsn.needscoverage.count</name>
            <description>Violated if there are more than 10 dsn specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='dsn']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.dsn_arch.needscoverage.count</name>
            <description>Violated if there are more than 10 dsn_arch specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='dsn_arch']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn_arch'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn_arch.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="req">

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00102.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In-place E2EXf_&lt;transformerId&gt; shall perform the following
            two precondition checks, without continuing further processing:
            1.  (buffer == NULL)
                ||
                (buffer != NULL &amp;&amp; inputBufferLength  &lt;
                  EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
            2.  bufferLength == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(buffer == NULL &amp;&amp; inputBufferLength != 0)' to '(buffer == NULL)'
            in point 1, see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06001_IOValidParamCheck</srcid><srcstatus/><internalId>268</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00102</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00106.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            Out-of-place E2EXf_&lt;transformerId&gt; shall perform the
            following three precondition checks, without continuing further processing:
            1.  (inputBuffer == NULL)
                ||
                (inputBuffer != NULL &amp;&amp; inputBufferLength  &lt;
                EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
            2.  bufferLength == NULL
            3.  buffer == NULL
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer == NULL &amp;&amp; inputBufferLength != 0)' to
            '(inputBuffer == NULL)' in point 1,
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07001_IOValidParamCheck</srcid><srcstatus/><internalId>282</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00106</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00108.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), in-place
            E2EXf_&lt;transformerId&gt; shall copy the amount upperHeaderBitsToShift bits,
            in parameter buffer, with starting offset of BufferProperties.headerLength, in
            direction left by 'distance' of BufferProperties.headerLength. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163: Rewrite
            '(buffer != NULL &amp;&amp; EndToEndTransformationDescription.upperHeaderBitsToShift
            &gt; 0)' to '(EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06002_CopyUpperHeader</srcid><srcstatus/><internalId>269</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00108</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00109.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), out-of-place
            E2EXf_&lt;transformerId&gt; shall copy the first upperHeaderBitsToShift bits from
            inputBuffer to buffer, and then copy the remaining part of inputBuffer (i.e. starting
            with offset upperHeaderBitsToShift) to parameter buffer starting with the destination
            offset of (upperHeaderBitsToShift+ BufferProperties.headerLength). (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)' to
            '(EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07002_CopyUpperHeader</srcid><srcstatus/><internalId>283</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00109</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00115.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), out-of-place
            E2EXf_&lt;transformerId&gt; shall copy inputBuffer to buffer starting with the
            destination offset of BufferProperties.headerLength. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift == 0)' to
            '(EndToEndTransformationDescription.upperHeaderBitsToShift == 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_08000_CopyUpperHeader</srcid><srcstatus/><internalId>295</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00115</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00111.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            E2EXf_&lt;transformerId&gt; shall set
            *bufferLength = inputBufferLength + BufferProperties.headerLength/8.
            (RS_E2E_08538)
         </description>
         <comment>
            Incorporated RfC 69897 'Inconsequent usage of bits and bytes for
            BufferProperties.headerLength'.
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06003_BufLength</srcid><srcstatus/><internalId>270</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07003_BufLength</srcid><srcstatus/><internalId>284</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00111</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00139.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02, the function E2EXf_&lt;transformerId&gt;
            shall perform a check of the *bufferLength (after the computation of *bufferLength):
            If (*bufferLength != config-&gt;DataLength / 8), then the function shall return
            immediately E_SAFETY_HARD_RUNTIMEERROR, i.e. without calling an E2E Library function.
            (RS_E2E_08538)
         </description>
         <comment>This requirement is informational only.</comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00139</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00107.PJLR</id>
         <status>approved</status> <!-- draft in R22-11 -->
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            If DataTransformationStatusForwarding is set to
            noTransformerStatusForwarding and PXX is P01 ,P02 ,P04 ,P05 ,P06 ,P07 ,P08 ,P11
            ,P22 or P44, the function E2EXf_&lt;transformerId&gt;() shall invoke E2E_PXXProtect(),
            passing to that function the appropriate Config and State structures (see
            [SWS_E2EXf_00125] and [SWS_E2EXf_00126]) that are associated with
            &lt;transformerId&gt;, as well as buffer and bufferLength (only for P04, P05, P06, P07,
            P08 ,P11 ,P22 and P44) that were updated in above requirements SWS_E2EXf_00108,
            SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06004_InvokeProtect</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07004_InvokeProtect</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_11000_FWCodeStatusCheck</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_12000_FWCodeStatusCheck</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00107</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00018.PJLR</id>
         <status>approved</status> <!-- draft in R22-11 -->
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            In case E2E_PXXProtect() or E2E_PXXForward() returns E2E_E_OK, then
            E2EXf_&lt;transformerId&gt; shall return E_OK, otherwise E2EXf_&lt;transformerId&gt;
            shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06005_RetValProtect</srcid><srcstatus/><internalId>272</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07005_RetValProtect</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00018</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00105.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In-place E2EXf_Inv_&lt;transformerId&gt; shall perform the
            following two precondition checks, without continuing further processing:
             1.  (buffer == NULL &amp;&amp; inputBufferLength != 0)
                 ||
                 (buffer != NULL &amp;&amp; inputBufferLength &lt; BufferProperties.headerLength/8u
                 + EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  bufferLength == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06101_IOValidParamCheck</srcid><srcstatus/><internalId>274</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00105</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00103.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            Out-of-place E2EXf_Inv_&lt;transformerId&gt; shall perform the
            following three precondition checks, without continuing further processing:
             1.  (inputBuffer == NULL &amp;&amp; inputBufferLength != 0)
                 ||
                 (inputBuffer != NULL &amp;&amp; inputBufferLength &lt;
                 BufferProperties.headerLength/8u +
                 EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  If (bufferLength == NULL)
             3.  If (buffer == NULL).
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07101_IOValidParamCheck</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00103</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00140.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            For PXX = 01 or 02 (i.e. for profile 1 and 2), the out-of-place
            function E2EXf_Inv_&lt;transformerId&gt; shall
             1.  if(inputBuffer == NULL and inputBufferLength == 0), then
                 -  variable NewDataAvailable of state object of type
                    E2E_PXXCheckStateType (see [SWS_E2EXf_00125]) associated with
                    &lt;transformerId&gt; shall be set to FALSE
             2.  else if (inputBufferLength == config-&gt;DataLength/8), then
                 -  variable NewDataAvailable of state object of type
                    E2E_PXXCheckState Type (see [SWS_E2EXf_00125]) associated with
                    &lt;transformerId&gt; shall be set to TRUE.
             3. else return E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
          </description>
          <comment>This requirement is informational only.</comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00140</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00123.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the out-of-place function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that
            function:
              -  Config,
              -  State,
              -  Data
            Concerning pointer to Data: if(inputBuffer == NULL and inputBufferLength == 0), then
            it shall pass a pointer to a 1-byte variable of E2E transformer, otherwise it shall pass
            inputBuffer.(RS_E2E_08538)
         </description>
         <comment>
           This requirement is informational only.
           Incorporated RfC 70069
           'Incorrect specification of call of E2E_PXXCheck for profile 01 and 02',
           see https://www.autosar.org/bugzilla/show_bug.cgi?id=70069.
           For the case (inputBuffer == NULL and inputBufferLength == 0) it should be sufficient to
           have a valid pointer to data. From the dummy variable where it points to is never read.
           The size of the variable where it points to is considered as an implementation detail and
           thus not important for the fulfillment of this requirement.
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00123</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00141.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the in-place
            function E2EXf_Inv_&lt;transformerId&gt; shall
            1.  If(buffer == NULL and inputBufferLength == 0), then
                - variable NewDataAvailable of state object of type
                   E2E_PXXCheckStateType (see [SWS_E2EXf_00125]) associated with
                   &lt;transformerId&gt; shall be set to FALSE.
            2.  Else if (inputBufferLength == config-&gt;DataLength/8), then
                - variable NewDataAvailable of state object of type E2E_PXXCheckState
                  Type (see [SWS_E2EXf_00125]) associated with &lt;transformerId&gt; shall
                  be set to TRUE.
            3.  Else return E_SAFETY_HARD_RUNTIMEERROR.
            (RS_E2E_08538)
         </description>
         <comment>This requirement is informational only.</comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00141</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00124.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the in-place function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that
            function:
              -  Config,
              -  State,
              -  Data
            Concerning pointer to Data: if(buffer == NULL and inputBufferLength == 0), then it shall
            pass a pointer to a 1-byte variable of E2E transformer, otherwise it shall pass buffer.
            (RS_E2E_08538)
         </description>
         <comment>
            This requirement is informational only.
            Incorporated RfC 70069
            'Incorrect specification of call of E2E_PXXCheck for profile 01 and 02',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=70069.
            For the case (inputBuffer == NULL and inputBufferLength == 0) it should be sufficient to
            have a valid pointer to data. From the dummy variable where it points to is never read.
            The size of the variable where it points to is considered as an implementation detail
            and thus not important for the fulfillment of this requirement.
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00124</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00142.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If configuration parameter profileBehavior is PRE_R4_2, then
            for PXX = 01 or 02, E2EXf_Inv_&lt;transformerId&gt;() shall set the variable
            MaxDeltaCounter of the state object to the value of variable MaxDeltaCounterInit of
            the corresponding configuration object. (RS_E2E_08538)
         </description>
         <comment>This requirement is informational only.</comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00142</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00104.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 04, 05, 06, 07, 11, 22: the function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that function:
              -  config,
              -  state,
              -  data length: inputBufferLength
            pointer to data: inputBuffer (out-of-place version) or buffer (in-place
            version). (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06102_InvokeCheck</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07102_InvokeCheck</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00104</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00029.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_Inv_&lt;transformerId&gt; shall invoke
            E2E_PXXMapStatusToSM(), passing to that function the return value of E2E_PXXCheck
            and the profiles check Status (variable Status of state object of type
            E2E_PXXCheckStateType, see [SWS_E2EXf_00125]), to obtain the profile-
            independent check status. For P1/P2 mapping functions, there is an additional call
            parameter profileBehavior:
            -  if configuration parameter profileBehavior is R4_2, then E2E_PXXMapStatusToSM()
               shall be invoked with the call parameter profileBehavior = 1
            -  if configuration parameter profileBehavior is PRE_R4_2, then
               E2E_PXXMapStatusToSM() shall be invoked with call parameter profileBehavior = 0
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06103_InvokeMapStatusToSM</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07103_InvokeMapStatusToSM</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00029</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00028.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_Inv_&lt;transformerId&gt; shall invoke the
            E2E_SMCheck() function, passing to that function the configuration object of type
            E2E_SMConfigType (see [SWS_E2EXf_00126] and [SWS_E2EXf_00088]) and state
            object of type E2E_SMCheckStateType (see [SWS_E2EXf_00125]) that are
            associated with &lt;transformerId&gt;, plus the profile-independent check status that
            was computed by E2E_PXXMapStatusToSM() in SWS_E2EXf_00029. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06104_InvokeSMCheck</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07104_InvokeSMCheck</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00028</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00027.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            If E2E_SMCheck() returns E2E_E_OK and disableEndToEndStateMachine is FALSE, then:
            - the high nibble of the return
              of the function E2EXf_Inv_&lt;transformerId&gt; shall be set to the low nibble
              of the state of the state machine (member SMState of object of type
              E2E_SMStateType that is associated with &lt;transformerId&gt;, see
              [SWS_E2EXf_00125]).
            - The low nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt;
              shall  be set to the low nibble of the profile-independent check status
              of type E2E_PCheckStatusType.
              If E2E_SMCheck() does not return E2E_E_OK, the return value shall be
              E_SAFETY_SOFT_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06105_SMCheckRetVal</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07105_SMCheckRetVal</srcid><srcstatus/><internalId>292</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00027</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00112.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (buffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), in-place
            E2EXf_Inv_&lt;transformerId&gt; shall copy the first upperHeaderBitsToShift
            bits, in parameter buffer, in direction right by 'distance' of
            BufferProperties.headerLength.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06106_CopyUpperHeader</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00112</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00113.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0),
            out-of-place E2EXf_Inv_&lt;transformerId&gt; shall copy the first
            upperHeaderBitsToShift bits from inputBuffer to buffer, and then copy the
            remaining part of inputBuffer skipping E2E header (i.e. starting with
            offset upperHeaderBitsToShift+BufferProperties.headerLength) to parameter
            buffer starting with the destination offset of
            (upperHeaderBitsToShift).(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07106_CopyUpperHeader</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00113</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00116.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift == 0),
            out-of-place E2EXf_Inv_&lt;transformerId&gt; shall copy inputBuffer starting
            with the offset of BufferProperties.headerLength, to
            buffer.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_08100_CopyUpperHeader</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00116</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00114.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If inputBufferLength == 0, then E2EXf_Inv_&lt;transformerId&gt; shall set
            *bufferLength = 0, otherwise it shall set
            *bufferLength = inputBufferLength - BufferProperties.headerLength/8.
            (RS_E2E_08538)
         </description>
         <comment>
            Incorporated RfC 69897 'Inconsequent usage of bits and bytes for
            BufferProperties.headerLength' and
            RfC 69321 'Correction of calculation of bufferLength'.
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06107_BufLength</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07107_BufLength</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00114</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00167.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server-Communication on the server side, if
            the return value ret equals to E_SAFETY_*_ERR, the value shall be overwritten to
            E_E2E_HARD_SAFETY_ERR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPJLR.SetCounter</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00167</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00037.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            Mandatory Interfaces
            API function          Description
            E2E_PJLRCheck         Checks the Data received using the E2E profile JLR. This includes
                                  CRC calculation, handling of Counter. The function checks only one
                                  single data in one cycle, it does not determine/compute the
                                  accumulated state of the communication link.
            E2E_PJLRCheckInit     Initializes the check state
            E2E_PJLRForward       Protects data which is forwarded by using the E2E profile JLR.
           (draft)                This includes checksum calculation, handling of counter and Data
                                  ID. Detected Errors of received message will be reconstruct on
                                  output data. Tags: atp.Status=draft
            E2E_PJLRMapStatusToSM The function maps the check status of profile JLR to a generic
                                  checkstatus, which can be used by E2E state machine check function.
                                  The E2E profile JLR delivers a more fine-granular status, but this
                                  is not relevant for the E2E state machine.
            E2E_PJLRProtect       Protects the array/buffer to be transmitted using the E2E profile
                                  JLR. This includes checksum calculation, handling of counter.
            E2E_PJLRProtectInit   Initializes the protection state.
            E2E_SMCheck           Checks the communication channel. It determines if the data can be
                                  used for safety-related application, based on history of checks
                                  performed by a corresponding E2E_P0XCheck() function.
            E2E_SMCheckInit       Initializes the state machine.
            (RS_E2E_08538)
         </description>
         <comment>
            Only APIs of activated profiles are mandatory. APIs of deactivated profiles are
            optional. This applies to all profiles.
         </comment>
         <releases>
            <release>AUTOSAR 4.3.0</release>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06004_InvokeProtect</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06102_InvokeCheck</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06103_InvokeMapStatusToSM</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06104_InvokeSMCheck</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07004_InvokeProtect</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07102_InvokeCheck</srcid><srcstatus/><internalId>289</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07103_InvokeMapStatusToSM</srcid><srcstatus/><internalId>290</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07104_InvokeSMCheck</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_13000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_14000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>308</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00037</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_Xfrm_00108.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_TransformerGeneral.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            A transformer which is called with NULL_PTR as input data shall
            not change the output buffer unless the transformer invocation shall trigger an
            autonomous error reaction (see also [SWS_Rte_07420]).(SRS_Xfrm_00005)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.3.0</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06001_IOValidParamCheck</srcid><srcstatus/><internalId>268</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06101_IOValidParamCheck</srcid><srcstatus/><internalId>274</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07001_IOValidParamCheck</srcid><srcstatus/><internalId>282</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07101_IOValidParamCheck</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_Xfrm_00108</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>E2EPJLR.SWS_Xfrm_00032.PJLR</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_TransformerGeneral.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        -----------------------------------------------------------------------------
        Error Name                 | Error Code | Error Type | Description
        -----------------------------------------------------------------------------
        E_OK                       | 0x00       | -          | The communication is safe.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_REP         | 0x01       | Soft       | The data are valid according to
                                                               safety, although data with a repeated
                                                               counter were received.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_SEQ         | 0x02       | Soft       | The data are valid according to
                                                               safety, although a counter jump
                                                               occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_ERR         | 0x03       | Soft       | The data are valid according to
                                                               safety, although the check itself
                                                               failed.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_NND         | 0x05       | Soft       | Communication is valid according to
                                                               safety, but no new data received.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_OK         | 0x20       | Soft       | No data are available since
                                                               initialization of transformer.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_REP        | 0x21       | Soft       | No data are available since
                                                               initialization of transformer because
                                                               a repeated counter was received.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_SEQ        | 0x22       | Soft       | No data are available since
                                                               initialization of transformer and a
                                                               counter jump occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_ERR        | 0x23       | Soft       | No data are available since
                                                               initialization of transformer.
                                                               Therefore the check failed.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_NND        | 0x25       | Soft       | No data are available since
                                                               initialization of transformer.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_OK           | 0x30       | Soft       | Not enough data were received
                                                               to use them.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_REP          | 0x31       | Soft       | Not enough data were received
                                                               to use them but some with a repeated
                                                               counter were received.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_SEQ          | 0x32       | Soft       | Not enough data were received
                                                               to use them, additionally a
                                                               counter jump occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_ERR          | 0x33       | Soft       | Not enough data were received
                                                               to use them, additionally a check
                                                               failed.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_NND          | 0x35       | Soft       | Not enough data were received to use
                                                               them, additionally no new data
                                                               received.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_OK        | 0x40       | Soft       | The data are invalid and cannot
                                                               be used.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_REP       | 0x41       | Soft       | The data are invalid and cannot
                                                               be used because a repeated
                                                               counter was received.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_SEQ       | 0x42       | Soft       | The data are invalid and cannot
                                                               be used due to a counter jump.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_ERR       | 0x43       | Soft       | The data are invalid and cannot
                                                               be used because a check failed.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_NND       | 0x45       | Soft       | Communication is invalid according to
                                                               safety and no new data received
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_OK           | 0x60       | Soft       | Communication is safe, Statemachine
                                                               is not active.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_REP          | 0x61       | Soft       | Data with a repeated counter were
                                                               received. E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_SEQ          | 0x62       | Soft       | A counter jump occurred.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_ERR          | 0x63       | Soft       | The data are invalid and cannot
                                                               be used because a check failed.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_NND          | 0x65       | Soft       | No new data available.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_DEC          | 0x66       | Soft       | Disabled E2E State machine and
                                                               disabled E2E check.
        -----------------------------------------------------------------------------
        E_SAFETY_SOFT_RUNTIMEERROR | 0x77       | Soft       | A runtime error occurred, safety
                                                               properties could not be checked
                                                               (state or status cannot be
                                                               determined) but non-protected output
                                                               data could be produced nonethe
                                                               less.
        -----------------------------------------------------------------------------
        E_E2E_HARD_SAFETY_ERR      | 0x8d       | Hard       | Not further specified E2E error
        -----------------------------------------------------------------------------
        E_SAFETY_HARD_RUNTIMEERROR | 0xFF       | Hard       | A runtime error occurred, safety
                                                               properties could not be checked
                                                               and NO output data could be produced.
        -----------------------------------------------------------------------------
      </description>
      <releases>
         <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
         <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_13000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_14000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>308</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
            <linksto>E2E.SWS_Xfrm_00032</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_Xfrm_00051.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_TransformerGeneral.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If a transformer returns a hard error, it shall leave the output buffer unchanged
            (SRS_Xfrm_00004)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.3.0</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06001_IOValidParamCheck</srcid><srcstatus/><internalId>268</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06101_IOValidParamCheck</srcid><srcstatus/><internalId>274</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07001_IOValidParamCheck</srcid><srcstatus/><internalId>282</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07101_IOValidParamCheck</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_Xfrm_00051</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

      <specobject>
         <id>E2EPJLR.EB.SWS_E2EXf_00133.PJLR</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If the E2E Transformer has not been correctly initialized (which means that
            E2EXf_[&lt;PartitionId&gt;]_PartitionInit() was not successfully
            called before), then all generated E2E
            Transformer APIs shall immediately return E_SAFETY_HARD_RUNTIMEERROR.
            (RS_E2E_08538)
         </description>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06000_NotInitialized</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06100_NotInitialized</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07000_NotInitialized</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07001_IOValidParamCheck</srcid><srcstatus/><internalId>282</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07100_NotInitialized</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.EB.SWS_E2EXf_00133</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

      <specobject>
         <id>E2EPJLR.EB.Transformer.InPlace.NoCopying.PJLR</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If (buffer != NULL) &amp;&amp;
            (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), in-place
            E2EXf_&lt;transformerId&gt; shall keep buffer unchanged.
         </description>
         <comment>
         </comment>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_09000_CopyUpperHeader</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.EB.Transformer.InPlace.NoCopying</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

      <specobject>
         <id>E2EPJLR.EB.InvTransformer.InPlace.NoCopying.PJLR</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If (buffer != NULL) &amp;&amp;
            (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), in-place
            E2EXf_Inv_&lt;transformerId&gt; shall keep buffer unchanged.
         </description>
         <comment>
         </comment>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_09100_CopyUpperHeader</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.EB.InvTransformer.InPlace.NoCopying</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

      <specobject>
         <id>E2EPJLR.EB.SWS_E2EXf_00021.PJLR</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2EXf_[_&lt;PartitionId&gt;]_PartitionInit() function shall initialize
            all state structures managed by E2E transformer, calling the corresponding
            E2E_Init() method on each state variable.
         </description>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06004_InvokeProtect</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06102_InvokeCheck</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06104_InvokeSMCheck</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07004_InvokeProtect</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07102_InvokeCheck</srcid><srcstatus/><internalId>289</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07104_InvokeSMCheck</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.EB.SWS_E2EXf_00021</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

      <specobject>
         <id>E2EPJLR.EB.Transformer.Server.ProtectStatePtrInputCheck.PJLR</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication, the E2EXf_&lt;transformerId&gt; on server-side shall perform the
            following additional precondition check, without continuing further processing:
            - ProtectStatePtr == NULL_PTR
            If the above condition is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <comment>
            Checking ProtectStatePtr for NULL_PTR is necessary as it is dereferenced
            and set by the RequestCounter of csTransactionHandlePtr-&gt;e2eCounter.
         </comment>
         <providescoverage>
           <provcov>
             <linksto>E2E.EB.Transformer.Server.ProtectStatePtrInputCheck</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

      <specobject>
         <id>E2EPJLR.EB.InvTransformer.Client.ProtectStatePtrInputCheck.PJLR</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication, the E2EXf_Inv_&lt;transformerId&gt; on client-side shall perform
            the following additional precondition check, without continuing further processing:
            - ProtectStatePtr == NULL_PTR
            If the above condition is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <comment>
            Checking ProtectStatePtr for NULL_PTR is necessary as it is dereferenced
            to setting the Counter member of CheckStatesPtr-&gt;PXXmCheckState.
         </comment>
         <providescoverage>
           <provcov>
             <linksto>E2E.EB.InvTransformer.Client.ProtectStatePtrInputCheck</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00047.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>3</version>
         <description>
            Imported Types
            Module:Imported Type
            E2E:
            E2E_PJLRCheckStateType
            E2E_PJLRCheckStatusType
            E2E_PJLRConfigType
            E2E_PJLRProtectStateType
            E2E_PCheckStatusType
            E2E_SMCheckStateType
            E2E_SMConfigType
            Std_Types:
            Std_ExtractProtocolHeaderFieldsType
            Std_MessageResultType
            Std_MessageTypeType
            Std_ReturnType
            Std_TransformerForwardCode (draft)
            Std_VersionInfoType
            (RS_E2E_08538)
         </description>
         <comment>
            This requirement is adapted for profile PJLR and is based on E2EP11 of SWS Release 22-11.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_09000_CopyUpperHeader</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPJLR.ProfileTypes</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>E2E.SWS_E2EXf_00047</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00175.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side,
            if the E2E_PXXCheck function returns a value different from E2E_P_OK,
            the status shall be set to E2E_P_ERR.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00175</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00169.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf</source>
         <version>1</version>
         <description>
            If disableEndToEndStateMachine is to TRUE,
            - The high nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt;
              shall be set to 0x6.
            - The low nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt;
              shall be set to the low nibble of the profile-independent check status of type
              E2E_PCheckStatusType.(RS_E2E_08538)
         </description>
         <comment>
         </comment>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
           <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_13000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_14000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>308</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00169</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00173.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and
            Profile is P04, P05, P06, P07, P08, P11, P22 or P44, P04m, P07m, P08m, P44m
            state-&gt;Counter of E2EXf_Inv_&lt;transformerId&gt; shall be set to the
            requestCounter - 1. (RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <comment/>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
           <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPJLR.SetCounter</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00173</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00172.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and Profile is P01 or P02,
            state-&gt;LastValidCounter of E2EXf_Inv_&lt;transformerId&gt; shall be set to the
            requestCounter-1.(RS_E2E_08538)
         </description>
         <rationale>This requirement is not applicable for profile JLR.</rationale>
         <comment/>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00172</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00203.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profile P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_Inv_&lt;transformerId&gt; on the server-side shall set the e2eCounter element
            of the csTransactionHandle to the value of the local variable receivedRequestCounter.
            (RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <comment/>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00203</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00202.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profile P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_Inv_&lt;transformerId&gt; on the server-side shall set the e2eSourceId element
            of the csTransactionHandle to the value of the local variable sourceID.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00202</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00201.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = P04m, P07m, P08m and P44m: the function E2EXf_Inv_&lt;transformerId&gt; on the
            server-side shall invoke E2E_PXXSinkCheck(), passing to that function:
            - config,
            - state,
            - the local variables messageType, messageResult, and the address of the local
              variable sourceID
            - data length:
              inputBufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            - pointer to data:
              . inputBuffer + EndToEndTransformationDescription.upperHeaderBitsToShift
                (out-of-place version) or
              . buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
               (in-place version).
            (RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00201</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00200.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = P04m, P07m, P08m and P44m: the function E2EXf_Inv_&lt;transformerId&gt; on the
            client-side shall invoke E2E_PXXSourceCheck(), passing to that function:
            - config,
            - state,
            - the local variables messageType, messageResult, and the local variable sourceID
            - data length:
              inputBufferLength – EndToEndTransformationDescription.upperHeaderBitsToShift
            - pointer to data:
                . inputBuffer + EndToEndTransformationDescription.upperHeaderBitsToShift
                  (out-of-place version) or
                . buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
                  (in-place version).
            (RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00200</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00199.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_Inv_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00199</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00198.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_Inv_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields() function passing the
            inputBuffer, the inputBufferLength, the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00198</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00197.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_Inv_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields() function
            passing the buffer, the bufferLength, the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00197</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00196.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place
            and the out-of-place E2EXf_Inv_&lt;transformerId&gt; on the client-side shall
            set a local variable sourceID to the sourceID stored in the configuration.
            (RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00196</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00194.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_Inv_&lt;transformerId&gt;
            on the client-side shall call the extractProtocolHeaderFields() function passing the
            inputBuffer, the inputBufferLength, the address of a local variable named messageType,
            and the address of a local variable named messageResult as parameters.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00194</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00193.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_Inv_&lt;transformerId&gt; on
            the client-side shall call the extractProtocolHeaderFields() function passing
            the buffer, the bufferLength, the address of local messageType variable, and
            the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00193</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00192.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_Inv_&lt;transformerId&gt; shall perform the following additional
            precondition checks, without continuing further processing:
            1. extractProtocolHeaderFields == NULL
            2. csTransactionHandle == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00192</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00191.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If DataTransformationStatusForwarding is set to transformerStatusForwarding and
            PXX = P04m, P07m, P08m or P44m: The function E2EXf_&lt;transformerId&gt;()
            shall invoke E2E_PXXForward(), passing to that function:
            - the appropriate Config structure (see [SWS_E2EXf_00125]),
            - the appropriate State structure (see [SWS_E2EXf_00126]),
            - the local variables sourceID, messageType, and messageResult
            - buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
            - bufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            Hereby buffer and bufferLength were updated according to the above requirements
            SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00191</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00168.PJLR</id>
         <status>approved</status> <!-- draft in R22-11 -->
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If DataTransformationStatusForwarding is set to transformerStatusForwarding and
            PXX is P01, P02, P04, P05, P06, P07, P08, P11, P22 or P44 the function
            E2EXf_&lt;transformerId&gt;() shall invoke E2E_PXXForward(), passing to that function
            the appropriate Config and State structures (see [SWS_E2EXf_00125] and [SWS_E2EXf_00126])
            that are associated with &lt;transformerId&gt;, as well as buffer and bufferLength
            (only for P04, P05, P06, P07, P08, P11, P22 and P44) that were updated in requirements
            SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.
            In addition, the E2E status shall be passed on to the E2E_PXXForward() function
            based on the parameter forwardedCode provided by the RTE. This parameter
            is associated with the optional IN parameter forwardedCode from Rte_Write
            (SWS_Rte_01071), Rte_Send (SWS_Rte_01072), Rte_IWrite (SWS_Rte_03744) and
            Rte_IWriteRef (SWS_Rte_05509). The forwardedCode must be mapped to the matching
            E2E status. (RS_E2E_08538))
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
           <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_11000_FWCodeStatusCheck</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_12000_FWCodeStatusCheck</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00168</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00190.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If DataTransformationStatusForwarding is set to noTransformerStatusForwarding
            and PXX = P04m, P07m, P08m or P44m the function E2EXf_&lt;transformerId&gt;()
            shall invoke E2E_PXXProtect(), passing to that function:
            - the appropriate Config structure (see [SWS_E2EXf_00125]),
            - the appropriate State structure (see [SWS_E2EXf_00126]),
            - the local variables sourceID, messageType, and messageResult
            - buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
            - bufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            Hereby buffer and bufferLength were updated according to the requirements
            SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00190</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00166.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If E2E-Transformer is used in a Client-Server Communication and
            Profile is P01, P04, P04m, P05, P06, P07, P07m, P08, P08m, P11, P44 or P44m
            the sequence counter for protecting the response shall be set to requestCounter.
            (RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
           <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPJLR.SetCounter</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00166</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00208.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_MapCodeToStatus shall return the values depending on the value of
            forwardedCode.(RS_E2E_08538)
         </description>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
           <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_11000_FWCodeStatusCheck</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_12000_FWCodeStatusCheck</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00208</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00165.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If E2E-Transformer is used for a response in a Client-Server Communication and
            Profile is P02 or P22 the sequence counter used for protecting the response shall
            be set to requestCounter -1.(RS_E2E_08538)
         </description>
         <rationale>This requirement is not applicable for profile JLR.</rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00165</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00189.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt; on the server-side shall
            set a local variable named requestCounter to the value of the e2eCounter element
            of the csTransactionHandle. (RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00189</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00188.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt;
            on the server-side shall set a local variable sourceID to the value of the e2eSourceId
            element of the csTransactionHandle. (RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00188</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00187.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00187</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00186.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields() function passing the
            inputBuffer, the inputBufferLength, the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00186</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00185.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_&lt;transformerId&gt; on
            the server-side shall call the extractProtocolHeaderFields() function passing the buffer,
            the bufferLength, the address of local messageType variable, and the address of a local
            messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00185</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00184.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_&lt;transformerId&gt; on the client-side shall set a local variable sourceID
            to the sourceID stored in the configuration (see SWS_E2EXf_00126).(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00184</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00183.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00183</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00181.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_&lt;transformerId&gt;
            on the client-side shall call the extractProtocolHeaderFields() function passing
            the buffer, the bufferLength, the address of local messageType variable, and
            the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00181</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00182.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
           For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_&lt;transformerId&gt; on
            the client-side shall call the extractProtocolHeaderFields() function passing
            the inputBuffer, the inputBufferLength, the address of a local variable
            named messageType, and the address of a local variable named messageResult as
            parameters.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00182</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00171.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If E2EXf_&lt;transformerId&gt; is used in a Client-Server Communication on the
            client-side and Profile is P01, P04, P05, P06, P07, P08, P11 or P44, state-&gt;Counter - 1
            shall be stored as requestCounter to be accessed by the E2EXf_Inv_&lt;transformerId&gt;
            for checking the response.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
           <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPJLR.SetCounter</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00171</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00170.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If E2EXf_&lt;transformerId&gt; is used in a Client-Server Communication on the
            client-side and Profile is P02 or P22, state-&gt;Counter shall be stored to as
            requestCounter to be accessed by the E2EXf_Inv_&lt;transformerId&gt; for checking the
            response.(RS_E2E_08538)
         </description>
         <rationale>This requirement is not applicable for profile JLR.</rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00170</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00180.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt; shall perform the following
            additional precondition checks, without continuing further processing:
             1. extractProtocolHeaderFields == NULL
             2. csTransactionHandle == NULL.
            If any of above conditions is TRUE, then the function shall
            return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable as not supported in profile JLR so far.
         </rationale>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00180</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00206.PJLR</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side
            and Profile is P01 or P02, the receivedRequestCounter shall be set to state-&gt;
            LastValidCounter of E2EXf_Inv_&lt;transformerId&gt;.(RS_E2E_08538)
         </description>
         <rationale>
            This requirement is not applicable to E2EPJLR.
         </rationale>
         <comment/>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00206</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

      <specobject>
         <id>E2EPJLR.SWS_E2EXf_00207.PJLR</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side
            and Profile is P04, P05, P06, P07, P08, P11, P22, P44, P04m, P07m,
            P08m or P44m the receivedRequestCounter shall be set to state-&gt;Counter of
            E2EXf_Inv_&lt;transformerId&gt;.(RS_E2E_08538)
         </description>
         <comment/>
         <releases>
           <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
           <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPJLR.SetCounter</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
           <provcov>
             <linksto>E2E.SWS_E2EXf_00207</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

      <specobject>
         <id>E2EPJLR.EB.Transformer.Init.SR</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In S/R communication each transformer can be initialized individually.
            API used is &lt;transformerId&gt;_Init().
         </description>
         <comment>
         </comment>
         <needscoverage>
           <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06004_InvokeProtect</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_06102_InvokeCheck</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07003_BufLength</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_E2EXf_CON_07102_InvokeCheck</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
           <provcov>
             <linksto>E2E.EB.Transformer.Init.SR</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

      <specobject>
         <id>E2EPJLR.EB.Transformer.Init.Client</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication at client end both non-inverse transformer and
            inverse transformer shall be initialized at the time same.
            API used is &lt;non-inversetransformerId&gt;_&lt;inversetransformerId&gt;_Init().
         </description>
         <comment>
            This requirement is not applicable to PJLR
         </comment>
         <providescoverage>
           <provcov>
             <linksto>E2E.EB.Transformer.Init.Client</linksto>
             <dstversion>1</dstversion>
           <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

  </specobjects>
    <specobjects doctype="req">
    <specobject>
      <id>EB_E2EPJLR020115</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00115.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00115'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_04_IncludeFiles</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00011.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00011'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtectInit_InvalidInput</srcid><srcstatus/><internalId>248</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02008_PJLRCheckInit_InvalidInput</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02009_PJLRCheck_InvalidInput</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00037.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00037'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_03_NoConfigParams</srcid><srcstatus/><internalId>264</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

  <!--  GENERIC SWS-CORRECTIONS  -->

    <specobject>
      <id>EB_E2EPJLR020048</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00048
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00048'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          applies,
          E2E library shall be built of the following files: E2E.h (common
          header), E2E.c (implementation of common parts),E2E_PJLR.c
          and E2E_SM.c (for E2E state machine).(RS_E2E_08528)
        </para>
        <para>
          Note:
          E2E.h (common header) is shared by all profiles and exists in a different module.
        </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_05_Files</srcid><srcstatus/><internalId>266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020012</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00012
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00012'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        The internal Supervision mechanisms error detection and reporting
        shall be implemented according to the pre-defined E2E Profiles specified in this
        document.(RS_E2E_08528)
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtectInit_InvalidInput</srcid><srcstatus/><internalId>248</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02008_PJLRCheckInit_InvalidInput</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02009_PJLRCheck_InvalidInput</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020673</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00673
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00673'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        The AUTOSAR E2E-Protocol uses the following error codes:
        Type or error or status                                             Related code
        At least one pointer parameter is a NULL pointer                    E2E_E_INPUTERR_NULL
        At least one input parameter is erroneous, e.g. out of range        E2E_E_INPUTERR_WRONG
        Function completed successfully                                     E2E_E_OK
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteCounter_FS_Repeated</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteCounter_FS_WrongSeq</srcid><srcstatus/><internalId>302</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteDataID_FS_Error</srcid><srcstatus/><internalId>303</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_FS_Nonewdata</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020047</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00047
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00047'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        but only the library functions E2E_PJLRProtect() and E2E_JLRCheck()
        shall use the specified return values,
        and the error flag <code>E2E_E_INTERR</code> is not used
        as return value.
      </description>
      <furtherinfo>
        Justifying rule: WRN.tsc.needscoverage.count violation.
        This req is covered by more than 10 EB tcs.
      </furtherinfo>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtectInit_InvalidInput</srcid><srcstatus/><internalId>248</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02005_PJLRCheckStatus_NoNewData</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02008_PJLRCheckInit_InvalidInput</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02009_PJLRCheck_InvalidInput</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020038</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00038
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00038'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        but the version numbers shall be published
        as stated in [BSW00318] according to the General Requirements on Basic Software Modules
        of ASR R22-11.
        <para>
          That is, the following version numbers shall be defined in the header file
          according to [BSW00318] (General Requirements on Basic Software Modules
          of ASR R22-11):
          <itemizedlist>
            <listitem>E2E_VENDOR_ID</listitem>
            <listitem>E2E_AR_RELEASE_MAJOR_VERSION</listitem>
            <listitem>E2E_AR_RELEASE_MINOR_VERSION</listitem>
            <listitem>E2E_AR_RELEASE_REVISION_VERSION</listitem>
            <listitem>E2E_SW_MAJOR_VERSION</listitem>
            <listitem>E2E_SW_MINOR_VERSION</listitem>
            <listitem>E2E_SW_PATCH_VERSION</listitem>
          </itemizedlist>
        </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_03_PublishedInformation</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>


  <!--  E2EPJLR AUTOSAR REQUIREMENTS  -->

    <specobject>
      <id>EB_E2EPJLR020503</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00503.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00503'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        in Profile JLR, the 4-bit counter ranges from 0 to 15.
        P11 refers to PJLR.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
      <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1110</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>130</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020540</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>2</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00540.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00540'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the E2E Profile variant JLRA is defined as follows
        1. CRC is the 0th byte in the signal group (i.e. starts with bit offset 0)
        2. E2E_PJLRDataIDMode = E2E_PJLR_DATAID_BOTH
        3. SignalIPdu.unusedBitPattern = 0x00.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1400</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>150</internalId></incomingFfbLink><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1410</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>151</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020541</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00541.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00541'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the E2E Profile variant JLRC is defined as follows
        1. CRC is the 0th byte in the signal group (i.e. starts with bit offset 0)
        2. The Data ID nibble is located in the highest 4 bits of 1st byte
           (i.e. starts with bit offset 12)
        3. E2E_PJLRDataIDMode = E2E_PJLR_DATAID_NIBBLE
        4. SignalIPdu.unusedBitPattern = 0x00.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020504</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00504.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00504'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        in E2E Profile JLR, the counter shall use the full numerical range of 0 to 15.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1120</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>131</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020583</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00583.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00583'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        in E2E Profile JLR, two Data ID modes shall be supported:
        1. E2E_PJLR_DATAID_BOTH
        2. E2E_PJLR_DATAID_NIBBLE
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020507</id>
      <status>rejected</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00507.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00507'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        in the E2E profile JLR, the Data IDs shall be globally unique within the network of
        communicating system (made of several ECUs each sending different data).
      </description>
      <comment>
        This requirement is informational only.
        RfC #69062 Uniqueness is only required if different profiles use the same header
        layout AND CRC polynomial (and settings).
        This is the case for P01,P11 and PJLR.
      </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020508</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00508.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00508'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        but in E2E Profile JLR the SCrc_CalculateCRC8() function of the SCrc Library shall be used
        instead of Crc_CalculateCRC8().
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPJLR.SCrc</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1300</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>136</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020505</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00505.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00505'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        In the E2E Profile JLR with DataIDMode set to E2E_PJLR_DATAID_BOTH, the Data ID shall be
        implicitly transmitted, by adding first the Data ID low byte, then the Data ID high byte
        before the user data in the CRC calculation.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1312</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>139</internalId></incomingFfbLink><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1313</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>140</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020506</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00506.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00506'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        in E2E Profile JLR with DataIDMode set to E2E_PJLR_DATAID_NIBBLE, the lower nibble of the
        high byte of the DataID shall be placed in the transmitted data at bit position
        DataIDNibbleOffset, and the CRC calculation shall be done by first calculating over the
        low byte of the Data ID, then a 0-byte, and then the user data.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020509</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00509.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00509'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the function E2E_PJLRProtect() shall have the following overall behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRProtect"/>.
        </para>
       <figure id="fig_E2E_PJLRProtect">
         <title>E2E_PJLRProtect</title>
         <inlinegraphic fileref="images/E2E_PJLRProtect.png" width="90%"/>
       </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020510</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00510.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00510'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Verify inputs of the protect function" in E2E_PJLRProtect()
        shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRProtect_VerifyInputs"/>.
        </para>
        <figure id="fig_E2E_PJLRProtect_VerifyInputs">
          <title>E2E_PJLRProtect_VerifyInputs</title>
          <inlinegraphic fileref="images/E2E_PJLRProtect_VerifyInputs.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020511</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00511.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00511'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Write DataIDNibble" in E2E_PJLRProtect() shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRProtect_WriteDataIDNibble"/>.
        </para>
        <figure id="fig_E2E_PJLRProtect_WriteDataIDNibble">
          <title>E2E_PJLRProtect_WriteDataIDNibble</title>
          <inlinegraphic fileref="images/E2E_PJLRProtect_WriteDataIDNibble.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020512</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00512.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00512'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Write Counter" in E2E_PJLRProtect() shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRProtect_WriteCounter"/>.
        </para>
        <figure id="fig_E2E_PJLRProtect_WriteCounter">
          <title>E2E_PJLRProtect_WriteCounter</title>
          <inlinegraphic fileref="images/E2E_PJLRProtect_WriteCounter.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020513</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00513.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00513'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Compute CRC" in E2E_PJLRProtect() shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRProtect_ComputeCRC"/>.
        </para>
        <figure id="fig_E2E_PJLRProtect_ComputeCRC">
          <title>E2E_PJLRProtect_ComputeCRC</title>
          <inlinegraphic fileref="images/E2E_PJLRProtect_ComputeCRC.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020514</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00514.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00514'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Write CRC" in E2E_PJLRProtect() and E2E_PJLRForward()
        shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRProtect_WriteCRC"/>.
        </para>
        <figure id="fig_E2E_PJLRProtect_WriteCRC">
          <title>E2E_PJLRProtect_WriteCRC</title>
          <inlinegraphic fileref="images/E2E_PJLRProtect_WriteCRC.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020515</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00515.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00515'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        The step ”Increment Counter” in E2E_PJLRProtect() and E2E_PJLRForward()
        shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRProtect_IncrementCounter"/>.
        </para>
        <figure id="fig_E2E_PJLRProtect_IncrementCounter">
          <title>E2E_E2E_PJLRProtect_IncrementCounter</title>
          <inlinegraphic fileref="images/E2E_PJLRProtect_IncrementCounter.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020630</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00630.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00630'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the function E2E_PJLRForward() shall have the following overall behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRForward"/>.
        </para>
        <figure id="fig_E2E_PJLRForward">
          <title>E2E_PJLRForward</title>
          <inlinegraphic fileref="images/E2E_PJLRForward.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteCounter_FS_Repeated</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteCounter_FS_WrongSeq</srcid><srcstatus/><internalId>302</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteDataID_FS_Error</srcid><srcstatus/><internalId>303</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_FS_Nonewdata</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020631</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00631.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00631'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Verify inputs of the protect function" in E2E_PJLRForward()
        shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRForward_VerifyInputs"/>.
        </para>
        <figure id="fig_E2E_PJLRForward_VerifyInputs">
          <title>E2E_PJLRForward_VerifyInputs</title>
          <inlinegraphic fileref="images/E2E_PJLRForward_VerifyInputs.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_FS_Nonewdata</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020632</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00632.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00632'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Write DataIDNibble" in E2E_PJLRForward() shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRForward_WriteDataIDNibble"/>.
        </para>
        <figure id="fig_E2E_PJLRForward_WriteDataIDNibble">
          <title>E2E_PJLRForward_WriteDataIDNibble</title>
          <inlinegraphic fileref="images/E2E_PJLRForward_WriteDataIDNibble.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteDataID_FS_Error</srcid><srcstatus/><internalId>303</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020633</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00633.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00633'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Write Counter" in E2E_PJLRForward() shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRForward_WriteCounter"/>.
        </para>
        <figure id="fig_E2E_PJLRForward_WriteCounter">
          <title>E2E_PJLRForward_WriteCounter</title>
          <inlinegraphic fileref="images/E2E_PJLRForward_WriteCounter.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteCounter_FS_Repeated</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_WriteCounter_FS_WrongSeq</srcid><srcstatus/><internalId>302</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020634</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00634.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00634'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Compute CRC" in E2E_PJLRForward() shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRForward_ComputeCRC"/>.
        </para>
        <figure id="fig_E2E_PJLRForward_ComputeCRC">
          <title>E2E_PJLRForward_ComputeCRC</title>
          <inlinegraphic fileref="images/E2E_PJLRForward_ComputeCRC.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020516</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00516.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00516'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the function E2E_PJLRCheck() shall have the following overall behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRCheck"/>.
        </para>
        <figure id="fig_E2E_PJLRCheck">
         <title>E2E_PJLRCheck</title>
         <inlinegraphic fileref="images/E2E_PJLRCheck.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02005_PJLRCheckStatus_NoNewData</srcid><srcstatus/><internalId>256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020517</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00517.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00517'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Verify inputs of the check function" in E2E_PJLRCheck() shall have the
        following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRCheck_VerifyInputs"/>.
        </para>
        <figure id="fig_E2E_PJLRCheck_VerifyInputs">
          <title>E2E_PJLRCheck_VerifyInputs</title>
          <inlinegraphic fileref="images/E2E_PJLRCheck_VerifyInputs.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02005_PJLRCheckStatus_NoNewData</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02009_PJLRCheck_InvalidInput</srcid><srcstatus/><internalId>260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020582</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00582.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00582'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Read DataIDNibble" in E2E_PJLRCheck shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRCheck_ReadDataIDNibble"/>.
        </para>
        <figure id="fig_E2E_PJLRCheck_ReadDataIDNibble">
          <title>E2E_PJLRCheck_ReadDataIDNibble</title>
          <inlinegraphic fileref="images/E2E_PJLRCheck_ReadDataIDNibble.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020518</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00518.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00518'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Read Counter" in E2E_PJLRCheck() shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRCheck_ReadCounter"/>.
        </para>
        <figure id="fig_E2E_PJLRCheck_ReadCounter">
          <title>E2E_PJLRCheck_ReadCounter</title>
          <inlinegraphic fileref="images/E2E_PJLRCheck_ReadCounter.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020519</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00519.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00519'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Read CRC" in E2E_PJLRCheck shall have the following behavior:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRCheck_ReadCRC"/>.
        </para>
        <figure id="fig_E2E_PJLRCheck_ReadCRC">
          <title>E2E_PJLRCheck_ReadCRC</title>
          <inlinegraphic fileref="images/E2E_PJLRCheck_ReadCRC.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020521</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00521.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00521'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        the step "Do Checks" in E2E_PJLRCheck shall have the following behavior: With the following
        correction: The third decision should also evaluate to TRUE in
        case Config-&gt;DataIDMode == E2E_PJLR_DATAID_BOTH: (DataIDMode == NIBBLE &amp;&amp;
        receivedNibble == DataID&gt;&gt;8) || (DataIDMode != NIBBLE).
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PJLRCheck_DoChecks"/>.
        </para>
        <figure id="fig_E2E_PJLRCheck_DoChecks">
          <title>E2E_PJLRCheck_DoChecks</title>
          <inlinegraphic fileref="images/E2E_PJLRCheck_DoChecks.png" width="90%"/>
        </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02005_PJLRCheckStatus_NoNewData</srcid><srcstatus/><internalId>256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020661</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00661.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00661'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020567</srcid><srcstatus/><internalId>114</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020662</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00662.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00662'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020563</srcid><srcstatus/><internalId>115</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020594</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00594.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00594'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020564</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020663</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>2</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00663.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00663'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020565</srcid><srcstatus/><internalId>113</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020604</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00604.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00604'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020557</srcid><srcstatus/><internalId>125</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020565</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00565.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00565'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Name: E2E_PJLRConfigType
        Type: Structure
        Elements:
        uint16 DataLength         Length of data, in bits. The value shall be a multiple of 8 and
                                  shall be ≤ 240.
        uint16 DataID             A unique identifier, for protection against masquerading. There
                                  are some constraints on the selection of ID values, described in
                                  section "Configuration constraints on Data IDs".
        uint8 MaxDeltaCounter     Maximum allowed gap between two counter values of two
                                  consecutively received valid Data. For example, if the receiver
                                  gets Data with counter 1 and MaxDeltaCounter is 3, then at the
                                  next reception the receiver can accept Counters with
                                  values 2, 3 or 4.
        E2E_PJLRDataIDMode        DataIDMode --
        uint16 CRCOffset          Bit offset of CRC (i.e. since *Data) in MSB first order. In
                                  variants JLRA and JLRC, CRCOffset is 0. The offset shall be a
                                  multiple of 8.
        uint16 CounterOffset      Bit offset of Counter in MSB first order. In variants JLRA and
                                  JLRC, CounterOffset is 8. The offset shall be a multiple of 4.
        uint16 DataIDNibbleOffset Bit offset of the low nibble of the high byte of Data ID. This
                                  parameter is used by E2E Library only if
                                  DataIDMode = E2E_PJLR_DATAID_NIBBLE (otherwise it is ignored by
                                  E2E Library).
                                  For DataIDMode different than E2E_PJLR_DATAID_NIBBLE,
                                  DataIDNibbleOffset shall be initialized to 0 (even if it is
                                  ignored by E2E Library).

        Description: Configuration of transmitted Data (Data Element or I-PDU), for E2E Profile JLR.
                     For each transmitted Data, there is an instance of this typedef.
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02011_PJLRCheck_Structures</srcid><srcstatus/><internalId>262</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020663</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020567</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00567.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00567'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Name: E2E_PJLRProtectStateType
        Type: Structure
        Element:
        uint8 Counter       Counter to be used for protecting the next Data. The initial value is 0,
                            which means that in the first cycle, Counter is 0. Each time
                            E2E_PJLRProtect() is called, it increments the counter up to 0x0F.
        Description: State of the sender for a Data protected with E2E Profile JLR.
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020563</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00563.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00563'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Name: E2E_PJLRCheckStateType
        Type: Structure
        Element:
        E2E_PJLRCheckStatusType    Status Result of the verification of the Data in this cycle,
                                   determined by the Check function.
        uint8 Counter              Counter of the data in previous cycle.
        Description: State of the reception on one single Data protected with E2E Profile JLR.
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02011_PJLRCheck_Structures</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020662</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020564</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00564.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00564'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Name: E2E_PJLRCheckStatusType
        Type: --
        Range:
        E2E_PJLRSTATUS_OK            0x00 OK: the checks of the Data in this cycle were successful
                                          (including counter check, which was incremented by 1).
        E2E_PJLRSTATUS_NONEWDATA     0x01 Error: the Check function has been invoked but no new Data
                                          is not available since the last call, according to
                                          communication medium (e.g. RTE, COM). As a result, no E2E
                                          checks of Data have been consequently executed.
                                          This may be considered similar to E2E_PJLRSTATUS_REPEATED.
        E2E_PJLRSTATUS_ERROR         0x07 Error: error not related to counters occurred
                                         (e.g. wrong crc, wrong length).
        E2E_PJLRSTATUS_REPEATED      0x08 Error: the checks of the Data in this cycle were
                                          successful, with the exception of the repetition.
        E2E_PJLRSTATUS_OKSOMELOST    0x20 OK: the checks of the Data in this cycle were successful
                                          (including counter check, which was incremented within the
                                          allowed configured delta).
        E2E_PJLRSTATUS_WRONGSEQUENCE 0x40 Error: the checks of the Data in this cycle were
                                          successful, with the exception of counter jump, which
                                          changed more than the allowed delta.
        Description: Status of the reception on one single Data in one cycle,
                     protected with E2E Profile JLR.
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02010_PJLRCheck_CheckEnum</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020594</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020575</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00575.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00575'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Service name: E2E_PJLRProtect
        Syntax: Std_ReturnType E2E_PJLRProtect(
                               const E2E_PJLRConfigType* ConfigPtr,
                               E2E_PJLRProtectStateType* StatePtr,
                               uint8* DataPtr,
                               uint16 Length
                               )
        Service ID[hex]:        0x3b
        Sync/Async:             Synchronous
        Reentrancy:             Reentrant
        Parameters (in):        ConfigPtr Pointer to static configuration.
                                Length Length of the data in bytes
        Parameters (inout):     StatePtr Pointer to port/data communication state.
                                DataPtr Pointer to Data to be transmitted.
        Parameters (out):       None
        Return value:           Std_ReturnType E2E_E_INPUTERR_NULL,
                                               E2E_E_OK,
                                               E2E_E_INPUTERR_WRONG,
                                               For definitions for return values, see SWS_E2E_00047.
        Description: Protects the array/buffer to be transmitted using the E2E profile JLR.
                     This includes checksum calculation, handling of counter.
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ComTest_01</srcid><srcstatus/><internalId>245</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020576</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00576.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00576'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Service name: E2E_PJLRProtectInit
        Syntax: Std_ReturnType E2E_PJLRProtectInit(
                               E2E_PJLRProtectStateType* StatePtr
                               )
        Service ID[hex]:        0x3c
        Sync/Async:             Synchronous
        Reentrancy:             Reentrant
        Parameters (in):        None
        Parameters (inout):     None
        Parameters (out):       StatePtr Pointer to port/data communication state.
        Return value:           Std_ReturnType E2E_E_INPUTERR_NULL - null pointer passed,
                                               E2E_E_OK.
        Description: Initializes the protection state.
        Available via: E2E.h
        (RS_E2E_08528, RS_E2E_08527)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ComTest_01</srcid><srcstatus/><internalId>245</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtectInit_Ok</srcid><srcstatus/><internalId>247</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtectInit_InvalidInput</srcid><srcstatus/><internalId>248</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020587</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00587.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00587'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Service name: E2E_PJLRForward
        Syntax: Std_ReturnType E2E_PJLRForward(
                               const E2E_PJLRConfigType* ConfigPtr,
                               uint16 Length,
                               E2E_PCheckStatusType Checkstatus,
                               E2E_PJLRProtectStateType* StatePtr,
                               uint8* DataPtr
                               )
        Service ID[hex]:        0x36
        Sync/Async:             Synchronous
        Reentrancy:             Reentrant
        Parameters (in):        ConfigPtr    Pointer to static configuration.
                                Length       Length of the data in bytes.
                                Checkstatus  E2E Status of the received message
        Parameters (inout):     StatePtr     Pointer to port/data communication state.
                                DataPtr      Pointer to Data to be transmitted.
        Parameters (out):       None
        Return value:           Std_ReturnType E2E_E_INPUTERR_NULL
                                               E2E_E_INPUTERR_WRONG
                                               E2E_E_INTERR
                                               E2E_E_OK
                                               For definitions for return values, see SWS_E2E_00047.
        Description: Protects data which is forwarded by using the E2E profile 11. This includes
                     checksum calculation, handling of counter and Data ID. Detected Errors of
                     received message will be reconstruct on output data.
        Available via: E2E.h
        (RS_E2E_08528, RS_E2E_08527)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020555</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00555.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00555'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        in case State is NULL, E2E_PJLRProtectInit shall return immediately with E2E_E_INPUTERR_NULL.
        Otherwise, it shall intialize the state structure, setting Counter to 0.
        (RS_E2E_08528)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtectInit_Ok</srcid><srcstatus/><internalId>247</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtectInit_InvalidInput</srcid><srcstatus/><internalId>248</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1130</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>132</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020572</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00572.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00572'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Service name: E2E_PJLRCheck
        Syntax: Std_ReturnType E2E_PJLRCheck(
                               const E2E_PJLRConfigType* ConfigPtr,
                               E2E_PJLRCheckStateType* StatePtr,
                               const uint8* DataPtr
                               uint16 Length
                               )
        Service ID[hex]: 0x81
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in):    ConfigPtr Pointer to static configuration.
                            DataPtr Pointer to received data.
        Parameters (inout): StatePtr Pointer to port/data communication state.
        Parameters (out):   None
        Return value:       Std_ReturnType E2E_E_INPUTERR_NULL,
                                           E2E_E_OK,
                                           E2E_E_INPUTERR_WRONG,
                            For definitions for return values, see SWS_E2E_00047.
        Description: Checks the Data received using the E2E profile JLR. This includes
                     CRC calculation, handling of Counter.
        The function checks only one single data in one cycle, it does not determine/compute
        the accumulated state of the communication link.
        Available via: E2E.h
        (RS_E2E_08528, RS_E2E_08527)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ComTest_01</srcid><srcstatus/><internalId>245</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02005_PJLRCheckStatus_NoNewData</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02009_PJLRCheck_InvalidInput</srcid><srcstatus/><internalId>260</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPJLR.ParameterLength</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020573</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00573.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00573'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Service name: E2E_PJLRCheckInit
        Syntax: Std_ReturnType E2E_PJLRCheckInit(
                               E2E_PJLRCheckStateType* StatePtr
                              )
        Service ID[hex]:    0x82
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant
        Parameters (in):    None
        Parameters (inout): None
        Parameters (out):   StatePtr Pointer to port/data communication state.
        Return value:       Std_ReturnType E2E_E_INPUTERR_NULL - null pointer passed
                                           E2E_E_OK.
        Description: Initializes the check state
        Available via: E2E.h
        (RS_E2E_08528, RS_E2E_08527)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ComTest_01</srcid><srcstatus/><internalId>245</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02007_PJLRCheckInit_Ok</srcid><srcstatus/><internalId>258</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02008_PJLRCheckInit_InvalidInput</srcid><srcstatus/><internalId>259</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020556</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00556.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00556'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        in case State is NULL, E2E_PJLRCheckInit shall return immediately with E2E_E_INPUTERR_NULL.
        Otherwise, it shall initialize the state structure, setting:
        1. Counter to 0xF
        2. Status to E2E_PJLRSTATUS_ERROR.
        (RS_E2E_08528)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02007_PJLRCheckInit_Ok</srcid><srcstatus/><internalId>258</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPJLR_ConTest_02008_PJLRCheckInit_InvalidInput</srcid><srcstatus/><internalId>259</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020574</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00574.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00574'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        Service name: E2E_PJLRMapStatusToSM
        Syntax: E2E_PCheckStatusType E2E_PJLRMapStatusToSM(
                   Std_ReturnType CheckReturn,
                   E2E_PJLRCheckStatusType Status
                   )
        Service ID[hex]:    0x3a
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant
        Parameters (in):    CheckReturn Return value of the E2E_PJLRCheck function
                            Status Status determined by E2E_PJLRCheck function
        Parameters (inout): None
        Parameters (out):   None
        Return value:       E2E_PCheckStatusType - Profile-independent status of the reception on
                                                   one single Data in one cycle.
        Description: The function maps the check status of Profile JLR to a generic check status,
                     which can be used by E2E state machine check function. The E2E Profile JLR
                     delivers a more fine-granular status, but this is not relevant for the
                     E2E state machine.
        Available via: E2E.h
        (RS_E2E_08528, RS_E2E_08527)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ComTest_01</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020557</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00557.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00557'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        If CheckReturn = E2E_E_OK, then the function E2E_PJLRMapStatusToSM shall return the values
        depending on the value of Status:
        Status                                              Return value
        E2E_PJLRSTATUS_OK or E2E_PJLRSTATUS_OKSOMELOST      E2E_P_OK
        E2E_PJLRSTATUS_ERROR                                E2E_P_ERROR
        E2E_PJLRSTATUS_REPEATED                             E2E_P_REPEATED
        E2E_PJLRSTATUS_NONEWDATA                            E2E_P_NONEWDATA
        E2E_PJLRSTATUS_WRONGSEQUENCE                        E2E_P_WRONGSEQUENCE
        (RS_E2E_08528, RS_E2E_08548)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02006_PJLRMapStatusToSM</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020604</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020558</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00558.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00558'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        applies,
        P11 refers to PJLR.
        If CheckReturn != E2E_E_OK, then the function E2E_PJLRMapStatusToSM() shall return
        E2E_P_ERROR (regardless of value of Status).
        (RS_E2E_08528, RS_E2E_08548)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02006_PJLRMapStatusToSM</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR020306</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In E2E Profile JLR, with E2E_PJLRDataIDMode configured to
        E2E_PJLR_DATAID_NIBBLE, the high nibble of the high byte shall be 0x0U.
      </description>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_02009_PJLRCheck_InvalidInput</srcid><srcstatus/><internalId>260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

    <specobject>
      <id>EB_E2EPJLR02_CounterOffset</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The alive counter shall be bit aligned and the position can be
        anywhere in the byte, also split over two bytes.
        This requirement is derived from JLR specification STJLR.18.276.
      </description>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <incomingFfbLinks><incomingFfbLink><ffbSrcId>CREQ_JLR_STJLR-18-036v6_1420</ffbSrcId><ffbSrcType>req</ffbSrcType><ffbSrcVersion>1</ffbSrcVersion><internalId>152</internalId></incomingFfbLink></incomingFfbLinks><violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

  </specobjects>
    <specobjects doctype="CDOCS">
    <specobject>
      <id>CDOC_STJLR-18-036v6</id>
      <status>approved</status>
      <source>STJLR-18-036v6.pdf</source>
      <version>V6</version>
      <description>
        The customer requirements are specified in STJLR-18-036v6.pdf, v STJLR.18.036
        Issue: 6, 22 January 2018
      </description>
      <furtherinfo>
        Justifying rule: WRN.req.needscoverage.count violation.
        This req is covered by more than 10 EB tcs.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1110</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1120</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1130</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1140</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1160</srcid><srcstatus/><internalId>134</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1200</srcid><srcstatus/><internalId>135</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1300</srcid><srcstatus/><internalId>136</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1310</srcid><srcstatus/><internalId>137</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1311</srcid><srcstatus/><internalId>138</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1312</srcid><srcstatus/><internalId>139</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1313</srcid><srcstatus/><internalId>140</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1314</srcid><srcstatus/><internalId>141</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1315</srcid><srcstatus/><internalId>142</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1316</srcid><srcstatus/><internalId>143</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1317</srcid><srcstatus/><internalId>144</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1318</srcid><srcstatus/><internalId>145</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1319</srcid><srcstatus/><internalId>146</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_13110</srcid><srcstatus/><internalId>147</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_13111</srcid><srcstatus/><internalId>148</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_13112</srcid><srcstatus/><internalId>149</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1400</srcid><srcstatus/><internalId>150</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1410</srcid><srcstatus/><internalId>151</internalId></linkedfrom><linkedfrom><srcid>CREQ_JLR_STJLR-18-036v6_1420</srcid><srcstatus/><internalId>152</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
  </specobjects>
    <specobjects doctype="req">
    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1110</id>
      <status>approved</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>The counter shall have a size of 4 bits.</description>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR020503</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>81</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1120</id>
      <status>approved</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The counter shall use the full numerical range of 0 to 15. No error marker is permitted.
      </description>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR020504</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>84</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1130</id>
      <status>approved</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>The initial value of the counter shall be zero.</description>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR020555</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>120</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1140</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The counter shall be defined in the network design tool as having a data type which
        identifies that data overwriting is not permitted.
      </description>
      <comment>
        This requirement is not applicable. This is information only.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1160</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The task monitoring counter shall be included in the protected group to which it relates.
      </description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1200</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The counter value shall only be incremented if the source data has been recalculated.
        All suppliers shall provide evidence that no undetected single point failure of the software
        or hardware can result in this requirement not being met.
      </description>
      <comment>
        This requirement is not applicable. Counter shall be incremented by 1 for every subsequent
        send request. So, caller shall call it once source data has been updated.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1300</id>
      <status>approved</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        Safety related signals shall be protected through the network layer according to the 8-bit
        Cyclic Redundancy Check (CRC) method defined in the Society of
        Automotive Engineers (SAE) J1850 recommended practice.
      </description>
      <comment>
        It shall use 0xFFU as initial CRC start value.
      </comment>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR020508</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>87</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1310</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The Data Segment Polynomial (DSP) contents and construction shall be derived from
        the appropriate network configuration file.
      </description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1311</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        A 16 bit DataID for each protected group shall be provided as a constant in
        the network configuration file. (Or ESIS in the case of a LIN slave node.)
      </description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1312</id>
      <status>approved</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The low byte of the DataID shall be processed first in the CRC calculation.
      </description>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR020505</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>88</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1313</id>
      <status>approved</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The high byte of the DataID shall be processed as the second element in the CRC calculation.
      </description>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR020505</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>88</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1314</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The presence of a "group name"_DataID signal shall identify a protected signal group.
      </description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1315</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The group description in the network configuration file shall be inspected to
        identify those signals within the protected group.
      </description>
      <comment>
        This requirement is not applicable. This is an information only.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1316</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        Every signal within a protected group shall be included in the CRC calculation.
      </description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1317</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The DSP (including DataID) shall comprise no more than nine bytes.
      </description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1318</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        All signals not part of the protected group shall be packed into the PDU
        such that they do not intrude into the protected group space.
      </description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1319</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        Any space in the protected group not allocated to signals shall be filled with
        the Unused Bit Pattern of zero.
      </description>
      <comment>
        This requirement is informational only.
        Padding of unused bits to desired template value is configured via module ComXf.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_13110</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>Update bits shall not be included in the DSP.</description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_13111</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The DSP shall be formed in the order and position of ARXML (PDU)
        offsets. DSP offsets shall be adjusted for the fact that the first byte of the
        PDU is the CRC, which shall not be included in the DSP. DSP offsets shall
        also be adjusted for the insertion of the DataID. The signal byte ordering
        shall be applied when a signal larger than 8 bits is included in the DSP.
      </description>
      <comment>
        This requirement is not applicable. This is system configuration requirement.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_13112</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>Any remaining space in the DSP shall be padded with zeros.</description>
      <comment>
        This requirement is informational only.
        Padding of unused bits to desired template value is configured via module ComXf.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1400</id>
      <status>approved</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The PDU (CRC and counter) shall be packed in accordance with AUTOSAR Profile 1A.
      </description>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR020540</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>2</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>82</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1410</id>
      <status>approved</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>The CRC shall be packed in the first byte of the PDU.</description>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR020540</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>2</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>82</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

    <specobject>
      <id>CREQ_JLR_STJLR-18-036v6_1420</id>
      <status>rejected</status>
      <source>JLR</source>
      <sourcefile>STJLR-18-036v6.pdf</sourcefile>
      <version>1</version>
      <description>
        The task monitoring counter shall be packed in the low nibble of the second byte of the PDU.
      </description>
      <comment>
        This requirement is not applicable. This will be covered in EB_E2EPJLR02_CounterOffset.
      </comment>
      <fulfilledby>
        <ffbObj>
          <ffbId>EB_E2EPJLR02_CounterOffset</ffbId>
          <ffbType>req</ffbType>
          <ffbVersion>1</ffbVersion>
        <ffbLinkstatus>linked</ffbLinkstatus><ffbLinkerror/><ffbObjcovstatus>covered</ffbObjcovstatus><internalId>128</internalId></ffbObj>
      <containerCovstatus>covered</containerCovstatus></fulfilledby>
      <providescoverage>
        <provcov>
          <linksto>CDOC_STJLR-18-036v6</linksto>
          <dstversion>V6</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>CDOCS</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>

  </specobjects>
    <specobjects doctype="req">

    <!--
        Top Level requirements motivated by the Product Description
    -->

    <specobject>
      <id>E2EPJLR.top.001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPJLR module shall implement a 4 bit sequence counter without using an error marker,
        explicitly sent in the message header.
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020503</srcid><srcstatus/><internalId>81</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020540</srcid><srcstatus/><internalId>82</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020541</srcid><srcstatus/><internalId>83</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020504</srcid><srcstatus/><internalId>84</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020509</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020512</srcid><srcstatus/><internalId>93</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020515</srcid><srcstatus/><internalId>96</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020630</srcid><srcstatus/><internalId>97</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020633</srcid><srcstatus/><internalId>100</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020516</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020582</srcid><srcstatus/><internalId>104</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020518</srcid><srcstatus/><internalId>105</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020521</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020661</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020662</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020663</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020563</srcid><srcstatus/><internalId>115</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020575</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020576</srcid><srcstatus/><internalId>118</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020587</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020555</srcid><srcstatus/><internalId>120</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020572</srcid><srcstatus/><internalId>121</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020573</srcid><srcstatus/><internalId>122</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020556</srcid><srcstatus/><internalId>123</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR02_CounterOffset</srcid><srcstatus/><internalId>128</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

    <specobject>
      <id>E2EPJLR.top.002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPJLR module shall implement a 16 bit data ID used for CRC calculation.
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020583</srcid><srcstatus/><internalId>85</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020505</srcid><srcstatus/><internalId>88</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020506</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020509</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020511</srcid><srcstatus/><internalId>92</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020513</srcid><srcstatus/><internalId>94</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020630</srcid><srcstatus/><internalId>97</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020632</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020634</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020516</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020582</srcid><srcstatus/><internalId>104</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020521</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020663</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020575</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020576</srcid><srcstatus/><internalId>118</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020587</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020572</srcid><srcstatus/><internalId>121</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020573</srcid><srcstatus/><internalId>122</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>

    <specobject>
      <id>E2EPJLR.top.003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPJLR module shall implement a 8 bit CRC calculation.
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020508</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020509</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020513</srcid><srcstatus/><internalId>94</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020514</srcid><srcstatus/><internalId>95</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020630</srcid><srcstatus/><internalId>97</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020634</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020516</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020519</srcid><srcstatus/><internalId>106</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020521</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020575</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020576</srcid><srcstatus/><internalId>118</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020587</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020572</srcid><srcstatus/><internalId>121</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020573</srcid><srcstatus/><internalId>122</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

    <!--
        Top Level requirements motivated by module specific behavior
    -->

    <specobject>
      <id>E2EPJLR.top.004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPJLR module shall implement error indication and error states
        to indicate malfunction to the SWC.
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020011</srcid><srcstatus/><internalId>74</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020037</srcid><srcstatus/><internalId>75</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020048</srcid><srcstatus/><internalId>76</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020012</srcid><srcstatus/><internalId>77</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020673</srcid><srcstatus/><internalId>78</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020516</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020521</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020594</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020604</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020565</srcid><srcstatus/><internalId>113</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020567</srcid><srcstatus/><internalId>114</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020563</srcid><srcstatus/><internalId>115</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020564</srcid><srcstatus/><internalId>116</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020572</srcid><srcstatus/><internalId>121</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020573</srcid><srcstatus/><internalId>122</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020556</srcid><srcstatus/><internalId>123</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020574</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020557</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020558</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020306</srcid><srcstatus/><internalId>127</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

    <specobject>
      <id>E2EPJLR.top.005</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPJLR module shall support client-server communication via methods.
      </description>
      <comment>This requirement is not applicable.
        Methods for client-server communication are not supported.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

  </specobjects>
    <specobjects doctype="req">

      <specobject>
         <id>E2E.SWS_E2EXf_00102</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In-place E2EXf_&lt;transformerId&gt; shall perform the following
            two precondition checks, without continuing further processing:
             1.  (buffer == NULL)
                 ||
                 (buffer != NULL &amp;&amp; inputBufferLength &lt;
                  EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  bufferLength == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(buffer == NULL &amp;&amp; inputBufferLength != 0)' to '(buffer == NULL)'
            in point 1, see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00102.PJLR</srcid><srcstatus/><internalId>0</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00106</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            Out-of-place E2EXf_&lt;transformerId&gt; shall perform the
            following three precondition checks, without continuing further processing:
             1.  (inputBuffer == NULL)
                 ||
                 (inputBuffer != NULL &amp;&amp; inputBufferLength &lt;
                 EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  bufferLength == NULL
             3.  buffer == NULL
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer == NULL &amp;&amp; inputBufferLength != 0)' to '(inputBuffer == NULL)'
            in point 1, see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00106.PJLR</srcid><srcstatus/><internalId>1</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00108</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0),
            in-place E2EXf_&lt;transformerId&gt; shall copy the amount upper HeaderBitsToShiftbits,
            in parameter buffer, with starting offset of BufferProperties.headerLength,
            in direction left by "distance" of BufferProperties.headerLength.(RS_E2E_08538)
         </description>
         <comment>
            Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
            SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
            Incorporated Bugzilla RfC 75163:
            Rewrite '(buffer != NULL &amp;&amp; EndToEndTransformationDescription.upperHeaderBitsToShift
            &gt; 0)' to '(EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00108.PJLR</srcid><srcstatus/><internalId>2</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00109</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), out-of-place
            E2EXf_&lt;transformerId&gt; shall copy the first upperHeaderBitsToShift bits from
            inputBuffer to buffer, and then copy the remaining part of inputBuffer (i.e. starting with
            offset upperHeaderBitsToShift) to parameter buffer starting with the destination offset
            of (upperHeaderBitsToShift+ BufferProperties.headerLength). (RS_E2E_08538)
         </description>
         <comment>
            Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
            SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)' to
            '(EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00109.PJLR</srcid><srcstatus/><internalId>3</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00115</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), out-of-place
            E2EXf_&lt;transformerId&gt; shall copy inputBuffer to buffer starting with the
            destination offset of BufferProperties.headerLength. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift == 0)' to
            '(EndToEndTransformationDescription.upperHeaderBitsToShift == 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00115.PJLR</srcid><srcstatus/><internalId>4</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00111</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            E2EXf_&lt;transformerId&gt; shall set
            *bufferLength = inputBufferLength + BufferProperties.headerLength/8.
            (RS_E2E_08538)
         </description>
         <comment>
            Incorporated RfC 69897 'Inconsequent usage of bits and bytes for
            BufferProperties.headerLength'.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00111.PJLR</srcid><srcstatus/><internalId>5</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00139</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02, the function E2EXf_&lt;transformerId&gt; shall perform a check of
            the *bufferLength (after the computation of *bufferLength):
            If (*bufferLength != config-&gt;DataLength/8), then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR, i.e. without calling an E2E Library function.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00139.PJLR</srcid><srcstatus/><internalId>6</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00107</id>
         <status>approved</status> <!-- draft in R22-11 -->
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            If DataTransformationStatusForwarding is set to no TransformerStatusForwarding and PXX
            is P01, P02, P04, P05, P06, P07, P08, P11, P22 or P44,
            The function E2EXf_&lt;transformerId&gt;() shall invoke
            E2E_PXXProtect(), passing to that function the appropriate Config and State
            structures (see [SWS_E2EXf_00125] and [SWS_E2EXf_00126]) that are associated
            with &lt;transformerId&gt;, as well as buffer and bufferLength
            (only for P04, P05, P06, P07, P08 ,P11 ,P22 and P44) that were updated in above
            requirements SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.
            (RS_E2E_08538)
         </description>
         <comment>
            ForwardStatus feature added in R22-11.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00107.PJLR</srcid><srcstatus/><internalId>7</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00018</id>
         <status>approved</status> <!-- draft in R22-11 -->
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            In case E2E_PXXProtect() and E2E_PXXForward() returns E2E_E_OK, then E2EXf_&lt;transformerId&gt; shall
            return E_OK, otherwise E2EXf_&lt;transformerId&gt; shall return
            E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <comment>
            ForwardStatus feature added in R22-11.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00018.PJLR</srcid><srcstatus/><internalId>8</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00105</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In-place E2EXf_Inv_&lt;transformerId&gt; shall perform the
            following two precondition checks, without continuing further processing:
             1.  (buffer == NULL &amp;&amp; inputBufferLength != 0)
                 ||
                 (buffer != NULL &amp;&amp; inputBufferLength &lt; BufferProperties.headerLength/8u +
                 EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  bufferLength == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00105.PJLR</srcid><srcstatus/><internalId>9</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00103</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            Out-of-place E2EXf_Inv_&lt;transformerId&gt; shall perform the
            following three precondition checks, without continuing further processing:
             1.  (inputBuffer == NULL &amp;&amp; inputBufferLength != 0)
                 ||
                 (inputBuffer != NULL &amp;&amp; inputBufferLength &lt;
                 BufferProperties.headerLength/8u +
                 EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  If (bufferLength == NULL)
             3.  If (buffer == NULL).
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00103.PJLR</srcid><srcstatus/><internalId>10</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00140</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            For PXX = 01 or 02 (i.e. for profile 1 and 2), the out-of-place
            function E2EXf_Inv_&lt;transformerId&gt; shall
             1.  if(inputBuffer == NULL and inputBufferLength == 0), then
                 -  variable NewDataAvailable of state object of type
                    E2E_PXXCheckStateType (see [SWS_E2EXf_00125]) associated with
                    &lt;transformerId&gt; shall be set to FALSE
             2.  else if (inputBufferLength == config-&gt;DataLength/8), then
                 -  variable NewDataAvailable of state object of type
                    E2E_PXXCheckState Type (see [SWS_E2EXf_00125]) associated with
                    &lt;transformerId&gt; shall be set to TRUE.
             3.  else return E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00140.PJLR</srcid><srcstatus/><internalId>11</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00123</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the out-of-place function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that
            function:
              -  config,
              -  state,
              -  data
            Concerning pointer to data: if(inputBuffer == NULL and inputBufferLength == 0), then
            it shall pass a pointer to a 1-byte variable of E2E transformer, otherwise it shall pass
            inputBuffer.(RS_E2E_08538)
          </description>
          <comment>
            Incorporated RfC 70069
            'Incorrect specification of call of E2E_PXXCheck for profile 01 and 02',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=70069.
            For the case (inputBuffer == NULL and inputBufferLength == 0) it should be sufficient to
            have a valid pointer to data. From the dummy variable where it points to is never read. The
            size of the variable where it points to is considered as an implementation detail and thus
            not important for the fulfillment of this requirement.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00123.PJLR</srcid><srcstatus/><internalId>12</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00141</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the in-place
            function E2EXf_Inv_&lt;transformerId&gt; shall
            1.  If(buffer == NULL and inputBufferLength == 0), then
                - variable NewDataAvailable of state object of type
                   E2E_PXXCheckStateType (see [SWS_E2EXf_00125]) associated with
                   &lt;transformerId&gt; shall be set to FALSE.
            2.  Else if (inputBufferLength == config-&gt;DataLength/8), then
                - variable NewDataAvailable of state object of type E2E_PXXCheckState
                  Type (see [SWS_E2EXf_00125]) associated with &lt;transformerId&gt; shall
                  be set to TRUE.
            3.  Else return E_SAFETY_HARD_RUNTIMEERROR.
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00141.PJLR</srcid><srcstatus/><internalId>13</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00124</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the in-place function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that
            function:
              -  Config,
              -  State,
              -  Data
            Concerning pointer to Data: if(buffer == NULL and inputBufferLength == 0), then it shall
            pass a pointer to a 1-byte variable of E2E transformer, otherwise it shall pass buffer.
            (RS_E2E_08538)
         </description>
         <comment>
            Incorporated RfC 70069
            'Incorrect specification of call of E2E_PXXCheck for profile 01 and 02',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=70069.
            For the case (inputBuffer == NULL and inputBufferLength == 0) it should be sufficient to
            have a valid pointer to data. From the dummy variable where it points to is never read. The
            size of the variable where it points to is considered as an implementation detail and thus
            not important for the fulfillment of this requirement.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00124.PJLR</srcid><srcstatus/><internalId>14</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00142</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If configuration parameter profileBehavior is PRE_R4_2, then
            for PXX = 01 or 02, E2EXf_Inv_&lt;transformerId&gt;() shall set the variable
            MaxDeltaCounter of the state object to the value of variable MaxDeltaCounterInit of
            the corresponding configuration object. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00142.PJLR</srcid><srcstatus/><internalId>15</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00104</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 04, 05, 06, 07, 11, 22: the function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that function:
              -  config,
              -  state,
              -  data length: inputBufferLength
            pointer to data: inputBuffer (out-of-place version) or buffer (in-place
            version). (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00104.PJLR</srcid><srcstatus/><internalId>16</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00029</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_Inv_&lt;transformerId&gt; shall invoke
            E2E_PXXMapStatusToSM(), passing to that function the return value of E2E_PXXCheck
            and the profiles check Status (variable Status of state object of type
            E2E_PXXCheckStateType, see [SWS_E2EXf_00125]), to obtain the profile-
            independent check status. For P1/P2 mapping functions, there is an additional call
            parameter profileBehavior:
            -  if configuration parameter profileBehavior is R4_2, then E2E_PXXMapStatusToSM()
               shall be invoked with the call parameter profileBehavior = 1
            -  if configuration parameter profileBehavior is PRE_R4_2, then
               E2E_PXXMapStatusToSM() shall be invoked with call parameter profileBehavior = 0
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00029.PJLR</srcid><srcstatus/><internalId>17</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00028</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_Inv_&lt;transformerId&gt; shall invoke the
            E2E_SMCheck() function, passing to that function the configuration object of type
            E2E_SMConfigType (see [SWS_E2EXf_00126] and [SWS_E2EXf_00088])and state
            object of type E2E_SMCheckStateType (see [SWS_E2EXf_00125]) that are associated
            with &lt;transformerId&gt;, plus the profile-independent check status that was computed
            by E2E_PXXMapStatusToSM() in SWS_E2EXf_00029.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00028.PJLR</srcid><srcstatus/><internalId>18</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00027</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            If E2E_SMCheck() returns E2E_E_OK and disableEndToEndStateMachine is FALSE, then:
            - the high nibble of the return
              of the function E2EXf_Inv_&lt;transformerId&gt; shall be set to the low nibble
              of the state of the state machine (member SMState of object of type
              E2E_SMStateType that is associated with &lt;transformerId&gt;, see
              [SWS_E2EXf_00125]).
            - The low nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt;
              shall  be set to the low nibble of the profile-independent check status
              of type E2E_PCheckStatusType.
              If E2E_SMCheck() does not return E2E_E_OK, the return value shall be
              E_SAFETY_SOFT_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00027.PJLR</srcid><srcstatus/><internalId>19</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00112</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (buffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), in-place
            E2EXf_Inv_&lt;transformerId&gt; shall copy the first upperHeaderBitsToShift
            bits, in parameter buffer, in direction right by 'distance' of
            BufferProperties.headerLength.(RS_E2E_08538)
         </description>
         <comment>
            Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
            SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00112.PJLR</srcid><srcstatus/><internalId>20</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00113</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0),
            out-of-place E2EXf_Inv_&lt;transformerId&gt; shall copy the first
            upperHeaderBitsToShift bits from inputBuffer to buffer, and then copy the
            remaining part of inputBuffer skipping E2E header (i.e. starting with
            offset upperHeaderBitsToShift+BufferProperties.headerLength) to parameter
            buffer starting with the destination offset of
            (upperHeaderBitsToShift).(RS_E2E_08538)
         </description>
         <comment>
            Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
            SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00113.PJLR</srcid><srcstatus/><internalId>21</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00116</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift == 0),
            out-of-place E2EXf_Inv_&lt;transformerId&gt; shall copy inputBuffer starting
            with the offset of BufferProperties.headerLength, to
            buffer.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00116.PJLR</srcid><srcstatus/><internalId>22</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00169</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If disableEndToEndStateMachine is to TRUE,
            - The high nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt; shall
              be set to 0x6.
            - The low nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt; shall
              be set to the low nibble of the profile-independent check status of type
              E2E_PCheckStatusType. (RS_E2E_08538)
         </description>
         <comment>
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00169.PJLR</srcid><srcstatus/><internalId>37</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00114</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If inputBufferLength == 0, then E2EXf_Inv_&lt;transformerId&gt; shall set
            *bufferLength = 0, otherwise it shall set
            *bufferLength = inputBufferLength - BufferProperties.headerLength/8.
            (RS_E2E_08538)
         </description>
         <comment>
            Incorporated RfC 69897 'Inconsequent usage of bits and bytes for
            BufferProperties.headerLength' and
            RfC 69321 'Correction of calculation of bufferLength'.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00114.PJLR</srcid><srcstatus/><internalId>23</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00167</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server-Communication on the server side, if the return value ret equals
            to E_SAFETY_*_ERR, the value shall be overwritten to E_E2E_HARD_SAFETY_ERR.
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00167.PJLR</srcid><srcstatus/><internalId>24</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00037</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            Mandatory Interfaces
            API function         Description
            E2E_P01Check           Checks the Data received using the E2E profile 1. This includes CRC
                                   calculation, handling of Counter and Data ID.
            E2E_P01CheckInit       Initializes the check state
            E2E_P01Forward (draft) Protects data which is forwarded by using the E2E profile 01.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P01MapStatusToSM   The function maps the check status of Profile 1 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 1 delivers a more fine-granular status, but this is not
                                   relevant for the E2E state machine.
            E2E_P01Protect         Protects the array/buffer to be transmitted using the E2E profile 1.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P01ProtectInit     Initializes the protection state.
            E2E_P02Check           Check the array/buffer using the E2E profile 2. This includes checksum
                                   calculation, handling of sequence counter and Data ID.
            E2E_P02CheckInit       Initializes the check state
            E2E_P02Forward (draft) Protects data which is forwarded by using the E2E profile 02.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P02MapStatusToSM   The function maps the check status of Profile 2 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 2 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P02Protect         Protects the array/buffer to be transmitted using the E2E profile 2.
                                   This includes checksum calculation, handling of sequence counter and
                                   Data ID.
            E2E_P02ProtectInit     Initializes the protection state.
            E2E_P04Check           Checks the Data received using the E2E profile 4. This includes CRC
                                   calculation, handling of Counter and Data ID.
            E2E_P04CheckInit       Initializes the check state
            E2E_P04Forward (draft) Protects data which is forwarded by using the E2E profile 04.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P04MapStatusToSM   The function maps the check status of Profile 4 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 4 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P04Protect         Protects the array/buffer to  be transmitted using the E2E profile 4.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P04ProtectInit     Initializes the protection state.
            E2E_P04mCheckInit      Initializes the check state
            E2E_P04mForward (draft)Protects data which is forwarded by using the E2E profile 04m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P04mMapStatusToSM  The function maps the check status of Profile 4m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 4m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P04mProtect        Protects the array/buffer to  be transmitted using the E2E profile 4.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P04mProtectInit    Initializes the protection state.
            E2E_P04mSinkCheck      Checks the Data received using the E2E profile 4m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
            E2E_P04mSourceCheck    Checks the Data received using the E2E profile 4m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
            E2E_P05Check           Checks the Data received using the E2E profile 5. This includes CRC
                                   calculation, handling of Counter. The function checks only one single
                                   data in one cycle, it does not determine/compute the accumulated state
                                   of the communication link.
            E2E_P05CheckInit       Initializes the check state
            E2E_P05Forward (draft) Protects data which is forwarded by using the E2E profile 05.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P05MapStatusToSM   The function maps the check status of Profile 5 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 5 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P05Protect         Protects the array/buffer to be transmitted using the E2E profile 5. This
                                   includes checksum calculation, handling of counter.
            E2E_P05ProtectInit     Initializes the protection state.
            E2E_P06Check           Checks the Data received using the E2E profile 6. This includes CRC
                                   calculation, handling of Counter. The function checks only one single
                                   data in one cycle, it does not determine/compute the accumulated state
                                   of the communication link.
            E2E_P06CheckInit       Initializes the check state
            E2E_P06Forward (draft) Protects data which is forwarded by using the E2E profile 06.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P06MapStatusToSM   The function maps the check status of Profile 6 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 6 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P06Protect         Protects the array/buffer to be transmitted using the E2E profile 6.
                                   This includes checksum calculation, handling of counter.
            E2E_P06ProtectInit     Initializes the protection state.
            E2E_P07Check           Checks the Data received using the E2E profile 7. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P07CheckInit       Initializes the check state
            E2E_P07Forward (draft) Protects data which is forwarded by using the E2E profile 07.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P07MapStatusToSM   The function maps the check status of Profile 7 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 7 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P07Protect         Protects the array/buffer to be transmitted using the E2E profile 7.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P07ProtectInit     Initializes the protection state.
            E2E_P07mCheckInit      Initializes the check state
            E2E_P07mForward (draft)Protects data which is forwarded by using the E2E profile 07m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P07mMapStatusToSM  The function maps the check status of Profile 7m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 7m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P07mProtect        Protects the array/buffer to  be transmitted using the E2E profile 7m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P07mProtectInit    Initializes the protection state.
            E2E_P07mSinkCheck      Checks the Data received using the E2E profile 7m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P07mSourceCheck    Checks the Data received using the E2E profile 7m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P07Check           Checks the Data received using the E2E profile 7. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P07CheckInit       Initializes the check state
            E2E_P07Forward (draft) Protects data which is forwarded by using the E2E profile 07.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P07MapStatusToSM   The function maps the check status of Profile 7 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 7 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P07Protect         Protects the array/buffer to be transmitted using the E2E profile 7.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P07ProtectInit     Initializes the protection state.
            E2E_P07mCheckInit      Initializes the check state
            E2E_P07mForward (draft)Protects data which is forwarded by using the E2E profile 07m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P07mMapStatusToSM  The function maps the check status of Profile 7m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 7m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P07mProtect        Protects the array/buffer to  be transmitted using the E2E profile 7m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P07mProtectInit    Initializes the protection state.
            E2E_P07mSinkCheck      Checks the Data received using the E2E profile 7m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P07mSourceCheck    Checks the Data received using the E2E profile 7m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P08Check           Checks the Data received using the E2E profile 8. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P08CheckInit       Initializes the check state
            E2E_P08Forward (draft) Protects data which is forwarded by using the E2E profile 08.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P08MapStatusToSM   The function maps the check status of Profile 8 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 8 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P08mCheckInit      Initializes the check state
            E2E_P08mForward (draft)Protects data which is forwarded by using the E2E profile 08m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P08mMapStatusToSM  The function maps the check status of Profile 8m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 8m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P08mProtect        Protects the array/buffer to  be transmitted using the E2E profile 8m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P08mProtectInit    Initializes the protection state.
            E2E_P08mSinkCheck      Checks the Data received using the E2E profile 8m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P08mSourceCheck    Checks the Data received using the E2E profile 8m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P08Check           Checks the Data received using the E2E profile 8. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P08CheckInit       Initializes the check state
            E2E_P08Forward (draft) Protects data which is forwarded by using the E2E profile 08.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P08MapStatusToSM   The function maps the check status of Profile 8 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 8 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P08Protect         Protects the array/buffer to be transmitted using the E2E profile 8.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P08ProtectInit     Initializes the protection state.
            E2E_P08mCheckInit      Initializes the check state
            E2E_P08mForward (draft)Protects data which is forwarded by using the E2E profile 08m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P08mMapStatusToSM  The function maps the check status of Profile 8m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 8m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P08mProtect        Protects the array/buffer to  be transmitted using the E2E profile 8m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P08mProtectInit    Initializes the protection state.
            E2E_P08mSinkCheck      Checks the Data received using the E2E profile 8m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P08mSourceCheck    Checks the Data received using the E2E profile 8m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P08Protect         Protects the array/buffer to be transmitted using the E2E profile 8.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P08ProtectInit     Initializes the protection state.
            E2E_P11Check           Checks the Data received using the E2E profile 11. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P11CheckInit       Initializes the check state
            E2E_P11Forward (draft) Protects data which is forwarded by using the E2E profile 11.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P11MapStatusToSM   The function maps the check status of Profile 11 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 11 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P11Protect         Protects the array/buffer to be transmitted using the E2E profile 11.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P11ProtectInit     Initializes the protection state.
            E2E_P22Check           Checks the Data received using the E2E profile 22. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P22CheckInit       Initializes the check state
            E2E_P22Forward (draft) Protects data which is forwarded by using the E2E profile 22.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P22MapStatusToSM   The function maps the check status of Profile 22 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 22 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P22Protect         Protects the array/buffer to be transmitted using the E2E profile 22.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P22ProtectInit     Initializes the protection state.
            E2E_P44Check           Checks the Data received using the E2E profile 44. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P44CheckInit       Initializes the check state
            E2E_P44Forward (draft) Protects data which is forwarded by using the E2E profile 44.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P44MapStatusToSM   The function maps the check status of Profile 44 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 44 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P44mCheckInit      Initializes the check state
            E2E_P44mForward (draft)Protects data which is forwarded by using the E2E profile 44m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P44mMapStatusToSM  The function maps the check status of Profile 44m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 44m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P44mProtect        Protects the array/buffer to  be transmitted using the E2E profile 44m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P44mProtectInit    Initializes the protection state.
            E2E_P44mSinkCheck      Checks the Data received using the E2E profile 44m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P44mSourceCheck    Checks the Data received using the E2E profile 44m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P44Check           Checks the Data received using the E2E profile 44. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P44CheckInit       Initializes the check state
            E2E_P44Forward (draft) Protects data which is forwarded by using the E2E profile 44.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P44MapStatusToSM   The function maps the check status of Profile 44 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 44 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P44Protect         Protects the array/buffer to be transmitted using the E2E profile 44.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P44ProtectInit     Initializes the protection state.
            E2E_P44mCheckInit      Initializes the check state
            E2E_P44mForward (draft)Protects data which is forwarded by using the E2E profile 44m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P44mMapStatusToSM  The function maps the check status of Profile 44m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 44m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P44mProtect        Protects the array/buffer to  be transmitted using the E2E profile 44m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P44mProtectInit    Initializes the protection state.
            E2E_P44mSinkCheck      Checks the Data received using the E2E profile 44m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P44mSourceCheck    Checks the Data received using the E2E profile 44m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P44Protect         Protects the array/buffer to be transmitted using the E2E profile 44.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P44ProtectInit     Initializes the protection state.
            E2E_SMCheck            Checks the communication channel. It determines if the data can
                                   be used for safety-related application, based on history of
                                   checks performed by a corresponding E2E_P0XCheck() function.
            E2E_SMCheckInit        Initializes the state machine.
            (RS_E2E_08538)
         </description>
         <comment>
            ForwardStatus feature added in R22-11.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00037.PJLR</srcid><srcstatus/><internalId>25</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

      <specobject>
         <id>E2E.SWS_Xfrm_00108</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_TransformerGeneral.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsTo
            Shift &gt; 0), in-place E2EXf_&lt;transformerId&gt; shall copy the amount upper HeaderBits
            ToShiftbits, in parameter buffer, with starting offset of BufferProperties.headerLength,
            in direction left by "distance" of BufferProperties.headerLength.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_Xfrm_00108.PJLR</srcid><srcstatus/><internalId>26</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>
      
      <specobject>
         <id>E2E.SWS_Xfrm_00032</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_TransformerGeneral.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            A safety transformer shall return one of the errors shown in Table below
        -----------------------------------------------------------------------------
        Error Name                 | Error Code | Error Type | Description
        -----------------------------------------------------------------------------
        E_OK                       | 0x00       | -          | The communication is safe.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_REP         | 0x01       | Soft       | The data are valid according to
                                                               safety, although data with a re-
                                                               peated counter were received.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_SEQ         | 0x02       | Soft       | The data are valid according to
                                                               safety, although a counter jump
                                                               occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_ERR         | 0x03       | Soft       | The data are valid according to
                                                               safety, although the check itself
                                                               failed.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_NND         | 0x05       | Soft       | Communication is valid according to
                                                               safety, but no new data received.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_OK         | 0x20       | Soft       | No data are available since ini-
                                                               tialization of transformer.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_REP        | 0x21       | Soft       | No data are available since
                                                               initialization of transformer be-
                                                               cause a repeated counter was
                                                               received.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_SEQ        | 0x22       | Soft       | No data are available since ini-
                                                               tialization of transformer and a
                                                               counter jump occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_ERR        | 0x23       | Soft       | No data are available since ini-
                                                               tialization of transformer. There-
                                                               fore the check failed.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_NND        | 0x25       | Soft       | No data are available since
                                                               initialization of transformer.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_OK           | 0x30       | Soft       | Not enough data were received
                                                               to use them.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_REP          | 0x31       | Soft       | Not enough data were received
                                                               to use them but some with a re-
                                                               peated counter were received.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_SEQ          | 0x32       | Soft       | Not enough data were received
                                                               to use them, additionally a
                                                               counter jump occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_ERR          | 0x33       | Soft       | Not enough data were received
                                                               to use them, additionally a check
                                                               failed.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_NND          | 0x35       | Soft       | Not enough data were received to use
                                                               them, additionally no new data
                                                               received.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_OK        | 0x40       | Soft       | The data are invalid and cannot
                                                               be used.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_REP       | 0x41       | Soft       | The data are invalid and can-
                                                               not be used because a repeated
                                                               counter was received.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_SEQ       | 0x42       | Soft       | The data are invalid and cannot
                                                               be used due to a counter jump.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_ERR       | 0x43       | Soft       | The data are invalid and cannot
                                                               be used because a check failed.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_NND       | 0x45       | Soft       | Communication is invalid according to
                                                               safety and no new data received
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_OK           | 0x60       | Soft       | Communication is safe, Statemachine
                                                               is not active.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_REP          | 0x61       | Soft       | Data with a repeated counter were
                                                               received. E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_SEQ          | 0x62       | Soft       | A counter jump occurred.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_ERR          | 0x63       | Soft       | The data are invalid and cannot
                                                               be used because a check failed.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_NND          | 0x65       | Soft       | No new data available.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_DEC          | 0x66       | Soft       | Disabled E2E State machine and
                                                               disabled E2E check.
        -----------------------------------------------------------------------------
        E_SAFETY_SOFT_RUNTIMEERROR | 0x77       | Soft       | A runtime error occurred, safety
                                                               properties could not be checked
                                                               (state or status cannot be deter-
                                                               mined) but non-protected output
                                                               data could be produced nonethe-
                                                               less.
        -----------------------------------------------------------------------------
        E_E2E_HARD_SAFETY_ERR      | 0x8d       | Hard       | Not further specified E2E error
        -----------------------------------------------------------------------------
        E_SAFETY_HARD_RUNTIMEERROR | 0xFF       | Hard       | A runtime error occurred, safety
                                                               properties could not be checked
                                                               and NO output data could be pro-
                                                               duced.
        -----------------------------------------------------------------------------
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_Xfrm_00032.PJLR</srcid><srcstatus/><internalId>27</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

      <specobject>
         <id>E2E.SWS_Xfrm_00051</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_TransformerGeneral.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If a transformer returns a hard error, it shall leave the output buffer unchanged
            (SRS_Xfrm_00004)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_Xfrm_00051.PJLR</srcid><srcstatus/><internalId>28</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00047</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>2</version>
         <description>
            Imported Types
            Module:Imported Type
            E2E:
            E2E_P01CheckStateType
            E2E_P01CheckStatusType
            E2E_P01ConfigType
            E2E_P01DataIDMode
            E2E_P01ProtectStateType
            E2E_P02CheckStateType
            E2E_P02CheckStatusType
            E2E_P02ConfigType
            E2E_P02ProtectStateType
            E2E_P04CheckStateType
            E2E_P04CheckStatusType
            E2E_P04ConfigType
            E2E_P04ProtectStateType
            E2E_P04mCheckStateType
            E2E_P04mCheckStatusType
            E2E_P04mConfigType
            E2E_P04mProtectStateType
            E2E_P05CheckStateType
            E2E_P05CheckStatusType
            E2E_P05ConfigType
            E2E_P05ProtectStateType
            E2E_P06CheckStateType
            E2E_P06CheckStatusType
            E2E_P06ConfigType
            E2E_P06ProtectStateType
            E2E_P07CheckStatusType
            E2E_P07CheckStateType
            E2E_P07ConfigType
            E2E_P07ProtectStateType
            E2E_P07mCheckStateType
            E2E_P07mCheckStatusType
            E2E_P07mConfigType
            E2E_P07mProtectStateType
            E2E_P08CheckStateType
            E2E_P08CheckStatusType
            E2E_P08ConfigType
            E2E_P08ProtectStateType
            E2E_P08mCheckStateType
            E2E_P08mCheckStatusType
            E2E_P08mConfigType
            E2E_P08mProtectStateType
            E2E_P11CheckStatusType
            E2E_P11CheckStateType
            E2E_P11ConfigType
            E2E_P11DataIDMode
            E2E_P11ProtectStateType
            E2E_P22CheckStateType
            E2E_P22CheckStatusType
            E2E_P22ConfigType
            E2E_P22ProtectStateType
            E2E_P44CheckStateType
            E2E_P44CheckStatusType
            E2E_P44ConfigType
            E2E_P44ProtectStateType
            E2E_P44mCheckStateType
            E2E_P44mCheckStatusType
            E2E_P44mConfigType
            E2E_P44mProtectStateType
            E2E_PCheckStatusType
            E2E_SMCheckStateType
            E2E_SMConfigType
            E2E_SMStateType
            Std_Types:
            Std_ExtractProtocolHeaderFieldsType
            Std_MessageResultType
            Std_MessageTypeType
            Std_ReturnType
            Std_TransformerForwardCode (draft)
            Std_VersionInfoType
         </description>
         <comment>
            This requirement was adapted for profile E2EP07 and E2EP11 with SWS Release 4.3.0.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00047.PJLR</srcid><srcstatus/><internalId>35</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00175</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side, if the
            E2E_PXXCheck function returns a value different from E2E_P_OK, the status shall be
            set to E2E_P_ERR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00175.PJLR</srcid><srcstatus/><internalId>36</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00173</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and
            Profile is P04, P05, P06, P07, P08, P11, P22 or P44, P04m, P07m, P08m, P44m
            state-&gt;Counter of E2EXf_Inv_&lt;transformerId&gt; shall be set to the requestCounter - 1.
            (RS_E2E_08538)
         </description>
         <comment/>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00173.PJLR</srcid><srcstatus/><internalId>38</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00172</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and Profile is P01 or P02,
            state-&gt;LastValidCounter of E2EXf_Inv_&lt;transformerId&gt; shall be set to the
            requestCounter-1.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00172.PJLR</srcid><srcstatus/><internalId>39</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00203</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profile P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_Inv_&lt;transformerId&gt; on the server-side shall set the e2eCounter element
            of the csTransactionHandle to the value of the local variable receivedRequestCounter.
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00203.PJLR</srcid><srcstatus/><internalId>40</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00202</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profile P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_Inv_&lt;transformerId&gt; on the server-side shall set the e2eSourceId element
            of the csTransactionHandle to the value of the local variable sourceID.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00202.PJLR</srcid><srcstatus/><internalId>41</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00201</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For PXX = P04m, P07m, P08m and P44m: the function E2EXf_Inv_&lt;transformerId&gt; on the
            server-side shall invoke E2E_PXXSinkCheck(), passing to that function:
            - config,
            - state,
            - the local variables messageType, messageResult, and the address of the local variable
            sourceID
            - data length:
              inputBufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            - pointer to data:
              . inputBuffer + EndToEndTransformationDescription.upperHeaderBitsToShift
              (out-of-place version) or
              . buffer + EndToEndTransformationDescription.upperHeaderBitsToShift (in-place version).
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00201.PJLR</srcid><srcstatus/><internalId>42</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00200</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For PXX = P04m, P07m, P08m and P44m: the function E2EXf_Inv_&lt;transformerId&gt; on
            the client-side shall invoke E2E_PXXSourceCheck(), passing to that function:
            - config,
            - state,
            - the local variables messageType, messageResult, and the local variable sourceID
            - data length:
              inputBufferLength – EndToEndTransformationDescription.upperHeaderBitsToShift
            - pointer to data:
                . inputBuffer + EndToEndTransformationDescription.upperHeaderBitsToShift
                  (out-of-place version) or
                . buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
                  (in-place version).
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00200.PJLR</srcid><srcstatus/><internalId>43</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00199</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_Inv_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00199.PJLR</srcid><srcstatus/><internalId>44</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00198</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_Inv_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields()
            function passing the inputBuffer, the inputBufferLength,
            the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00198.PJLR</srcid><srcstatus/><internalId>45</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00197</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_Inv_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields() function
            passing the buffer, the bufferLength, the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00197.PJLR</srcid><srcstatus/><internalId>46</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00196</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place
            and the out-of-place E2EXf_Inv_&lt;transformerId&gt; on the client-side shall
            set a local variable sourceID to the sourceID stored in the configuration
            (see SWS_E2EXf_00126).(RS_E2E_08538).
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00196.PJLR</srcid><srcstatus/><internalId>47</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00194</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_Inv_&lt;transformerId&gt;
            on the client-side shall call the extractProtocolHeaderFields() function passing the
            inputBuffer, the inputBufferLength, the address of a local variable named messageType,
            and the address of a local variable named messageResult as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00194.PJLR</srcid><srcstatus/><internalId>48</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00193</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_Inv_&lt;transformerId&gt; on
            the client-side shall call the extractProtocolHeaderFields() function passing
            the buffer, the bufferLength, the address of local messageType variable, and
            the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00193.PJLR</srcid><srcstatus/><internalId>49</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00192</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_Inv_&lt;transformerId&gt; shall perform the following additional
            precondition checks, without continuing further processing:
            1. extractProtocolHeaderFields == NULL
            2. csTransactionHandle == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00192.PJLR</srcid><srcstatus/><internalId>50</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00191</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If DataTransformationStatusForwarding is set to transformerStatusForwarding and
            PXX = P04m, P07m, P08m or P44m: The function E2EXf_&lt;transformerId&gt;()
            shall invoke E2E_PXXForward(), passing to that function:
             - the appropriate Config structure (see [SWS_E2EXf_00125]),
             - the appropriate State structure (see [SWS_E2EXf_00126]),
             - the local variables sourceID, messageType, and messageResult
             - buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
             - bufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            Hereby buffer and bufferLength were updated according to the above requirements
            SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00191.PJLR</srcid><srcstatus/><internalId>51</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>

      <specobject>
        <id>E2E.SWS_E2EXf_00168</id>
        <status>approved</status> <!-- draft in R22-11 -->
        <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
        <version>1</version>
        <description>
          If DataTransformationStatusForwarding is set to transformerStatusForwarding and
          PXX is P01, P02, P04, P05, P06, P07, P08, P11, P22 or P44 the function
          E2EXf_&lt;transformerId&gt;() shall invoke E2E_PXXForward(), passing to that function
          the appropriate Config and State structures (see [SWS_E2EXf_00125] and [SWS_E2EXf_00126])
          that are associated with &lt;transformerId&gt;, as well as buffer and bufferLength
          (only for P04, P05, P06, P07, P08, P11, P22 and P44) that were updated in requirements
          SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.
          In addition the parameter ForwardStatus shall be passed to the E2E_PXXForward() function,
          which is provided by the RTE. This parameter is associated with the optional IN parameter
          ForwardStatus from Rte_Write (SWS_Rte_01071), Rte_Send (SWS_Rte_01072),
          Rte_IWrite (SWS_Rte_03744) and Rte_IWriteRef (SWS_Rte_05509)(RS_E2E_08538)
        </description>
        <releases>
          <release>AUTOSAR CP R22-11</release>
        </releases>
        <needscoverage>
          <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00168.PJLR</srcid><srcstatus/><internalId>52</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00190</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If DataTransformationStatusForwarding is set to noTransformerStatusForwarding
            and PXX = P04m, P07m, P08m or P44m the function E2EXf_&lt;transformerId&gt;()
            shall invoke E2E_PXXProtect(), passing to that function:
             - the appropriate Config structure (see [SWS_E2EXf_00125]),
             - the appropriate State structure (see [SWS_E2EXf_00126]),
             - the local variables sourceID, messageType, and messageResult
             - buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
             - bufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            Hereby buffer and bufferLength were updated according to the requirements
            SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00190.PJLR</srcid><srcstatus/><internalId>53</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00166</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If E2E-Transformer is used in a Client-Server Communication and
            Profile is P01, P04, P04m, P05, P06, P07, P07m, P08, P08m, P11, P44 or P44m
            the sequence counter for protecting the response shall be set to requestCounter.
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00166.PJLR</srcid><srcstatus/><internalId>54</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00208</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_MapCodeToStatus shall return the values depending on the value of
            forwardedCode.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00208.PJLR</srcid><srcstatus/><internalId>55</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00165</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If E2E-Transformer is used for a response in a Client-Server Communication and
            Profile is P02 or P22 the sequence counter used for protecting the response shall
            be set to requestCounter -1. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00165.PJLR</srcid><srcstatus/><internalId>56</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00189</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt; on the server-side shall
            set a local variable named requestCounter to the value of the e2eCounter element
            of the csTransactionHandle. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00189.PJLR</srcid><srcstatus/><internalId>57</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00188</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt;
            on the server-side shall set a local variable sourceID to the value of the e2eSourceId
            element of the csTransactionHandle. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00188.PJLR</srcid><srcstatus/><internalId>58</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00187</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00187.PJLR</srcid><srcstatus/><internalId>59</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00186</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields() function passing the
            inputBuffer, the inputBufferLength, the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00186.PJLR</srcid><srcstatus/><internalId>60</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>

      <specobject>
        <id>E2E.SWS_E2EXf_00185</id>
        <status>approved</status>
        <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
        <version>1</version>
        <description>
           For profiles P04m, P07m, P08m and P44m the in-place E2EXf_&lt;transformerId&gt; on
           the server-side shall call the extractProtocolHeaderFields() function passing the buffer,
           the bufferLength, the address of local messageType variable, and the address of a local
           messageResult variable as parameters.
        </description>
        <releases>
           <release>AUTOSAR CP R22-11</release>
        </releases>
        <needscoverage>
           <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00185.PJLR</srcid><srcstatus/><internalId>61</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00184</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_&lt;transformerId&gt; on the client-side shall set a local variable sourceID
            to the sourceID stored in the configuration (see SWS_E2EXf_00126).
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00184.PJLR</srcid><srcstatus/><internalId>62</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00183</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00183.PJLR</srcid><srcstatus/><internalId>63</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00181</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_&lt;transformerId&gt;
            on the client-side shall call the extractProtocolHeaderFields() function passing
            the buffer, the bufferLength, the address of local messageType variable, and
            the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00181.PJLR</srcid><srcstatus/><internalId>64</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00182</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_&lt;transformerId&gt; on
            the client-side shall call the extractProtocolHeaderFields() function passing
            the inputBuffer, the inputBufferLength, the address of a local variable
            named messageType, and the address of a local variable named messageResult as
            parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00182.PJLR</srcid><srcstatus/><internalId>65</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00171</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If E2EXf_&lt;transformerId&gt; is used in a Client-Server Communication on the client-side
            and Profile is P01, P04, P05, P06, P07, P08, P11 or P44, P04m, P07m, P08m, P44m
            state-&gt;Counter - 1 shall be stored as requestCounter to be accessed by the
            E2EXf_Inv_&lt;transformerId&gt; for checking the response. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00171.PJLR</srcid><srcstatus/><internalId>66</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00170</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If E2EXf_&lt;transformerId&gt; is used in a Client-Server Communication on the client-side
            and Profile is P02 or P22, state-&gt;Counter shall be stored to as requestCounter to be
            accessed by the E2EXf_Inv_&lt;transformerId&gt; for checking the response.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00170.PJLR</srcid><srcstatus/><internalId>67</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00180</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt; shall perform the following
            additional precondition checks, without continuing further processing:
             1. extractProtocolHeaderFields == NULL
             2. csTransactionHandle == NULL.
            If any of above conditions is TRUE, then the function shall
            return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00180.PJLR</srcid><srcstatus/><internalId>68</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00206</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and Profile is P01 or P02,
            the receivedRequestCounter shall be set to state-&gt;LastValidCounter of
            E2EXf_Inv_&lt;transformerId&gt;.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00206.PJLR</srcid><srcstatus/><internalId>69</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00207</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and Profile is P04, P05, P06,
            P07, P08, P11, P22, P44, P04m, P07m, P08m or P44m the receivedRequestCounter shall be
            set to state-&gt;Counter of E2EXf_Inv_&lt;transformerId&gt;.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.SWS_E2EXf_00207.PJLR</srcid><srcstatus/><internalId>70</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>

     <!--
         EB requirements valid for E2E profiles
     -->

      <specobject>
         <id>E2E.EB.SWS_E2EXf_00133</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If the E2E Transformer has not been correctly initialized (which means that
            E2EXf_[_&lt;PartitionId&gt;]_PartitionInit() was not successfully
            called before), then all generated E2E
            Transformer APIs shall immediately return E_SAFETY_HARD_RUNTIMEERROR.
         </description>
         <comment>
            This requirement replaces E2EXf.ASR421.SWS_E2EXf_00133.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.EB.SWS_E2EXf_00133.PJLR</srcid><srcstatus/><internalId>29</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.InPlace.NoCopying</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If (buffer != NULL) &amp;&amp;
            (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), in-place
            E2EXf_&lt;transformerId&gt; shall keep buffer unchanged.
         </description>
         <comment>
            This requirement is based on requirement E2EXf.ASR421.SWS_E2EXf_00115
            but applied to in-place buffering for sake of completeness.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.EB.Transformer.InPlace.NoCopying.PJLR</srcid><srcstatus/><internalId>30</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>

      <specobject>
         <id>E2E.EB.SWS_E2EXf_00021</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2EXf_[_&lt;PartitionId&gt;]_PartitionInit() function shall initialize
            all state structures managed by E2E transformer, calling the corresponding
            E2E_Init() method on each state variable.
         </description>
         <comment>
            This requirement replaces E2EXf.ASR421.SWS_E2EXf_00021
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.EB.SWS_E2EXf_00021.PJLR</srcid><srcstatus/><internalId>32</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>

      <specobject>
         <id>E2E.EB.InvTransformer.InPlace.NoCopying</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If (buffer != NULL) &amp;&amp;
            (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), in-place
            E2EXf_Inv_&lt;transformerId&gt; shall keep buffer unchanged.
         </description>
         <comment>
            This requirement is based on requirement E2EXf.SWS_E2EXf_00116
            but applied to in-place buffering for sake of completeness.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.EB.InvTransformer.InPlace.NoCopying.PJLR</srcid><srcstatus/><internalId>31</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.Server.ProtectStatePtrInputCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication, the E2EXf_&lt;transformerId&gt; on server-side shall perform the
            following additional precondition check, without continuing further processing:
            - ProtectStatePtr == NULL_PTR
            If the above condition is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.
         </description>
         <comment>
            Checking ProtectStatePtr for NULL_PTR is necessary as it is dereferenced
            and set by the RequestCounter of csTransactionHandlePtr-&gt;e2eCounter.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.EB.Transformer.Server.ProtectStatePtrInputCheck.PJLR</srcid><srcstatus/><internalId>33</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>

      <specobject>
         <id>E2E.EB.InvTransformer.Client.ProtectStatePtrInputCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication, the E2EXf_Inv_&lt;transformerId&gt; on client-side shall perform the
            following additional precondition check, without continuing further processing:
            - ProtectStatePtr == NULL_PTR
            If the above condition is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.
         </description>
         <comment>
            Checking ProtectStatePtr for NULL_PTR is necessary as it is dereferenced
            to set the Counter member of CheckStatesPtr-&gt;PXXmCheckState.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.EB.InvTransformer.Client.ProtectStatePtrInputCheck.PJLR</srcid><srcstatus/><internalId>34</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.Init</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In S/R communication each transformer can be initialized individually.
            While in C/S communication, at client end both non-inverse transformer and
            inverse transformer shall be initialized at the time same.
         </description>
         <comment>
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2E.EB.Transformer.Init.SR</srcid><srcstatus/><internalId>230</internalId></linkedfrom><linkedfrom><srcid>E2E.EB.Transformer.Init.Client</srcid><srcstatus/><internalId>231</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.Init.SR</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In S/R communication each transformer can be initialized individually.
            API used is &lt;transformerId&gt;_Init().
         </description>
         <comment>
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.EB.Transformer.Init.SR</srcid><srcstatus/><internalId>71</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
          <provcov>
            <linksto>E2E.EB.Transformer.Init</linksto>
            <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.Init.Client</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication at client end both non-inverse transformer and
            inverse transformer shall be initialized at the time same.
            API used is &lt;non-inversetransformerId&gt;_&lt;inversetransformerId&gt;_Init().
         </description>
         <comment>
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.EB.Transformer.Init.Client</srcid><srcstatus/><internalId>72</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
        <providescoverage>
          <provcov>
            <linksto>E2E.EB.Transformer.Init</linksto>
            <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>

   </specobjects>
    <specobjects doctype="req">

    <!--
        Top Level requirements motivated by the Product Description
    -->

      <specobject>
         <id>E2E.top.001</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall implement a sequence counter mechanism
            to allow the protection and validation of communication data.
         </description>
         <comment>
            The modules E2EPxx contain the implementation of the sequence counter mechanism.
            The E2E module provides this generic requirement to have inter-module
            tracing unmodified with the removal or creation of new profiles.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.top.001</srcid><srcstatus/><internalId>153</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>

      <specobject>
         <id>E2E.top.002</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall implement a data ID mechanism
            to allow the protection and validation of communication data.
         </description>
         <comment>
            The modules E2EPxx contain the implementation of the data ID mechanism.
            The E2E module provides this generic requirement to have inter-module
            tracing unmodified with the removal or creation of new profiles.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.top.002</srcid><srcstatus/><internalId>154</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>

      <specobject>
         <id>E2E.top.003</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall implement a Cyclic Redundancy Check mechanism
            to allow the protection and validation of communication data.
         </description>
         <comment>
            The modules E2EPxx contain the implementation of the Cyclic Redundancy
            Check mechanism.
            The E2E module provides this generic requirement to have inter-module
            tracing unmodified with the removal or creation of new profiles.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.top.003</srcid><srcstatus/><internalId>155</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>

      <!--
        Top Level requirements motivated by module specific behavior
    -->

      <specobject>
         <id>E2E.top.004</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall modularly structure static implementation files and data types.
         </description>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020115</srcid><srcstatus/><internalId>73</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>

      <specobject>
         <id>E2E.top.005</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall check input parameter for validity.
         </description>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020047</srcid><srcstatus/><internalId>79</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020509</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020510</srcid><srcstatus/><internalId>91</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020630</srcid><srcstatus/><internalId>97</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020631</srcid><srcstatus/><internalId>98</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020516</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020517</srcid><srcstatus/><internalId>103</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020555</srcid><srcstatus/><internalId>120</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPJLR020556</srcid><srcstatus/><internalId>123</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>

      <specobject>
         <id>E2E.top.006</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall provide a mechanism to read the version number.
      </description>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPJLR020038</srcid><srcstatus/><internalId>80</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>

      <specobject>
         <id>E2E.top.011</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall support client-server communication via methods for PXXm profiles.
         </description>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPJLR.top.005</srcid><srcstatus/><internalId>157</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>

   </specobjects>
    <specobjects doctype="req">

    <specobject>
      <id>E2EPJLR.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPJLR_VerifyCodeStub</srcid><srcstatus/><internalId>244</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.E2EPJLR.SCrc</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>dev.E2EPJLR.SetCounter</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00166.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00171.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00173.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00207.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00167.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>dev.E2EPJLR.ProfileTypes</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00047.PJLR</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>dev.E2EPJLR.ParameterLength</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>112</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/build/reqm/common_req/E2EPJLR_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(E2EPJLR.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_ComTest_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Compile/IN/E2EPJLR_ComTest_01/source/application/E2EPJLR_ComTest_01.c</sourcefile>
      <sourceline>29</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The End-to-End Communication Protection Library Module shall be translated.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 

    01: Call E2E_PJLRProtect().
    02: VP(EB_E2EPJLR020575):
        E2E_PJLRProtect() shall be translated.
    03: Call E2E_PJLRCheck().
    04: VP(EB_E2EPJLR020572):
        E2E_PJLRCheck() shall be translated.
    05: Call E2E_PJLRProtectInit().
    06: VP(EB_E2EPJLR020576):
        E2E_PJLRProtectInit() shall be translated.
    07: Call E2E_PJLRCheckInit().
    08: VP(EB_E2EPJLR020573):
        E2E_PJLRCheckInit() shall be translated.
    09: Call E2E_PJLRMapStatusToSM().
    10: VP(EB_E2EPJLR020574):
        E2E_PJLRMapStatusToSM() shall be translated.



Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020575</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020576</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020573</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020574</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_ConTest_01_PJLRProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_01_PJLRProtect/source/application/E2EPJLR_ConTest_01_PJLRProtect.c</sourcefile>
      <sourceline>665</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 

  &lt;para&gt;
  The aspects stated below are done on valid input data only.

  1) (EB_E2EPJLR020575,EB_E2EPJLR020509)
    Test that E2E_PJLRProtect()
    a) writes the Counter in the Data at the Counter position specified
       in the State data,
    b) writes DataID Nibble in Data (if E2E_PJLR_DATAID_NIBBLE is used) at the Nibble
       position specified in the configuration data,
    c) computes the CRC over DataID (depending on DataID mode - see
       test aspects 5), 6), and 7)) and Data,
    d) writes the CRC in the Data at the CRC position provided in the configuration data, and
    e) increments the Counter in the State data.

  2) (EB_E2EPJLR020504)
     Test that E2E_PJLRProtect() increments the passed State Counter
     value by 1 up to 15, and then restarts with 0 again.

  3) (EB_E2EPJLR020508)
     Test that E2E_PJLRProtect() calls the SCrc_CalculateCRC8() function

  4) (EB_E2EPJLR020513)
     Test that E2E_PJLRProtect() uses CRC-8-SAE J1850 with 0xFFU as start value for the calculation of
     the CRC (That is,  SCrc_CalculateCRC8() is called with StartValue8=0x0U).

  5) (EB_E2EPJLR020505)
     Test that for DataId inclusion Mode E2E_PJLR_DATAID_BOTH,
     first low byte and then high byte of the DataID are included in the CRC calculation
     step regarding the DataID.

  6) (EB_E2EPJLR020506)
     Test that for DataID inclusion Mode E2E_PJLR_DATAID_NIBBLE,
     the low Nibble of the high byte of the DataID is written to the
     Data(covered by CRC calculation when computing CRC over Data). The high nibble of the
     high byte is left out. The low byte of the DataID is then included in the CRC calculation.
     The high byte is treated as 0.
  &lt;/para&gt;

  &lt;para&gt;
  Test strategies applied:
     Equivalence Class Partitioning:
       Test execution is done with a permutation of following parameters
          - E2E_PJLRProtectStateType.Counter
          - E2E_PJLRConfigType.CounterOffset
          - E2E_PJLRConfigType.CRCOffset
          - E2E_PJLRConfigType.DataIDNibbleOffset
          - E2E_PJLRConfigType.DataIDMode
          - E2E_PJLRConfigType.DataLength
          - E2E_PJLRConfigType.DataID
        Note: The following parameters are not used at sender side and therefore not relevant:
           - MaxDeltaCounter

     Pair wise tests: Tests are executed with a  combination of following parameters / values
          - DataIDMode
          - CRCOffset
          - CounterOffset
          - DataIDNibbleOffset (only relevant for E2E_PJLR_DATAID_NIBBLE)

     Boundary Value Analysis in combination
     with test-case E2EPJLR_ConTest_01_PJLRProtect_InvalidInput (outside bound):
        DataIdMode: [E2E_PJLR_DATAID_BOTH, E2E_PJLR_DATAID_NIBBLE]
        DataLength: MIN=2, MAX=30
        Counter: MIN=0, MAX=15; (First Byte, Last Byte, in between Data)
        DataId: MIN=0, MAX=0xFFFF (E2E_PJLR_DATAID_BOTH)
                       MAX=0x0FFF (E2E_PJLR_DATAID_NIBBLE)
        DataIDNibbleOffset: MIN=12, MAX=DataLength+4 (low nibble and high nibble)
        CounterOffset: MIN=0, MAX=DataLength+4
        CRCOffset: MIN=0, MAX=DataLength
  &lt;/para&gt;


Test Object: None.
Test Precondition: None.
Test Execution: 

 010: Prepare CRC stub (SCrc_CalculateCRC8) to return the number of overall Stub calls.

For each stated TestDataBlock (InputTstCfg), execute the following steps:
 020: call the E2E_Protect function with following parameters:
      - Parameter Config points to following test-data
          Config.DataIDMode       = InputTstCfg.DataIDMode
          Config.DataID           = InputTstCfg.DataID
          Config.DataIDNibbleOffset = InputTstCfg.DataIDNibbleOffset
          Config.CRCOffset        = InputTstCfg.CRCOffset
          Config.CounterOffset    = InputTstCfg.CounterOffset
          Config.DataLength       = InputTstCfg.DataLength
          Config.TstData          = InputTstCfg.TstData
       - Parameter State points to following input data
          State.Counter           = InputTstCfg.Counter
       - Parameter Data points to valid input data
 030: VP (EB_E2EPJLR020575):
     E2E_Protect function returns E2E_E_OK
 040: VP (EB_E2EPJLR020504,EB_E2EPJLR020575,EB_E2EPJLR020509)
     State.Counter is updated as follows:
         If InputTstCfg.Counter==MAX(15) =&gt; State.Counter=0
         If InputTstCfg.Counter &lt; MAX(15) =&gt; State.Counter=InputTstCfg.Counter+1
 050: VP (EB_E2EPJLR020575,EB_E2EPJLR020509)
     TestData at position Config.CounterOffset (4 bits) equals InputTstCfg.Counter
 060: VP (EB_E2EPJLR020575,EB_E2EPJLR020509)
     If Config.DataIDMode=E2E_PJLR_DATAID_NIBBLE =&gt;
       TestData at position Config.DataIDNibbleOffset (4 bits) equals
       the low Nibble of the high byte of Config.DataID
 070: VP (EB_E2EPJLR020575,EB_E2EPJLR020509)
     TestData at position Config.CRCOffset (8 bits) equals
     the number of overall calls to the SCrc_CalculateCRC8 CRC stub
 080: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020509)
      Number of SCrc_CalculateCRC8 CRC stub calls equals n where:

         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_BOTH
            and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3
         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_BOTH
           and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4
         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE
           and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3
         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4
 090: VP (EB_E2EPJLR020509,EB_E2EPJLR020511,EB_E2EPJLR020512,EB_E2EPJLR020513,EB_E2EPJLR020514,)
        No other data except CRC / Counter and DataId Nibble is modified in TestData
 100: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020509)
      1st call to SCrc_CalculateCRC8 CRC stub in this test iteration:
        - SCrc_DataPtr points to a value that equals the low byte of InputTstCfg.DataID
        - SCrc_Length equals 1
        - SCrc_StartValue8 equals 0x0U
        - SCrc_IsFirstCall equals FALSE
 110: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on DataIdMode):
        If InputTstCfg.DataIDMode==E2E_PJLR_DATAID_BOTH:
         - SCrc_DataPtr points to a value that equals the high byte of InputTstCfg.DataID
         - SCrc_Length equals 1
         - SCrc_StartValue8 equals the SCrc return value from the previous stub call
         - SCrc_IsFirstCall equals FALSE
       If InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE:
         - SCrc_DataPtr points to a value 0
         - SCrc_Length equals 1
         - SCrc_StartValue8 equals the SCrc return value from the previous stub call
         - SCrc_IsFirstCall equals FALSE
 120: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020506,EB_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
       if InputTstCfg.CRCOffset is first byte in TestData
          - SCrc_DataPtr points to 2nd byte of the data passed to E2E_Protect
          - SCrc_Length equals Config.DataLength-1
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE
       if InputTstCfg.CRCOffset is not first byte in TestData
          - SCrc_DataPtr points to 1st byte of the data passed to E2E_Protect
          - SCrc_Length equals Config.CRCOffset / 8 (excludes CRC value)
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE
 130: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020506,EB_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
       if InputTstCfg.CRCOffset is not first byte and not last byte
          - SCrc_DataPtr points to 1st byte after CRC byte in the TestData
          - SCrc_Length equals Config.DataLength-(Config.CRCOffset/8) (Data after CRC byte)
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE


Test Input: 

Note: MAX ... maximum possible counter value =  15

TestDataBlock 1 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_BOTH
  - CRC at first Byte
  - Counter at second Byte
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 1 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different size and values)

TestDataBlock 2 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_BOTH
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             16
InputTstCfg.CounterOffset:         28
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 0, 1, 2, 0, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different size and values)

TestDataBlock 3 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_BOTH
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         52
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 6 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different values)


TestDataBlock 4 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC at first Byte
  - Counter at second Byte
  - DataID Nibble at bit position 12 (High Nibble)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    12
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 1 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different size and values)

TestDataBlock 5 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  - DataID Nibble at bit position 32  (Low Nibble)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    32
InputTstCfg.CRCOffset:             16
InputTstCfg.CounterOffset:         28
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                      { 5 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different size and values)

TestDataBlock 6 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  - DataID Nibble at bit position 8 (Low Nibble)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    8
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         52
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 6 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different values)

TestDataBlock 7 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC at first Byte
  - Counter at second Byte
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    12
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 5, 0, 5, 5, 5 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different size and values)

TestDataBlock 8 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  - DataIDNibble in first byte in low nibble
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             8
InputTstCfg.CounterOffset:         12
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 8, MAX, 2, 0, MAX }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different size and values)

TestDataBlock 9 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  -- DataIDNibble in the third byte as low nibble
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    16
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         44
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 0, 1, 2, 0, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different values)


Test Output: 
  return value for all tests shall be E2E_E_OK
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020575</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020509</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020504</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020513</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020511</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020512</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020514</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020515</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_01_PJLRProtectInit_Ok</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_01_PJLRProtect/source/application/E2EPJLR_ConTest_01_PJLRProtect.c</sourcefile>
      <sourceline>1234</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

    Test that E2E_PJLRProtectInit() initializes the state structure, setting Counter to 0.

  &lt;/para&gt;
  
Test Object: E2E_PJLRProtectInit()
Test Precondition: None.
Test Execution: 

    01: Call E2E_PJLRProtectInit() with valid parameter.
    02: VP(EB_E2EPJLR020576,EB_E2EPJLR020555):
        E2E_PJLRProtectInit() returns E2E_E_OK.
        PJLRCheckState.Counter is initialized with 0.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to E2E_E_OK status for E2E_PJLRProtectInit() function)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020576</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020555</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_01_PJLRProtectInit_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_01_PJLRProtect/source/application/E2EPJLR_ConTest_01_PJLRProtect.c</sourcefile>
      <sourceline>1291</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

      Test that if E2E_PJLRProtectInit() is called with StatePtr equal to NULL
      then E2E_PJLRProtectInit() returns immediately with E2E_E_INPUTERR_NULL.

  &lt;/para&gt;
  
Test Object: E2E_PJLRProtectInit()
Test Precondition: None.
Test Execution: 

    01: Call E2E_PJLRProtectInit() with NULL parameter.
    02: VP(EB_E2EPJLR020576,EB_E2EPJLR020555,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRProtectInit() returns E2E_E_INPUTERR_NULL.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to E2E_E_INPUTERR_NULL status for E2E_PJLRProtectInit() function)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020576</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020555</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_01_PJLRProtect_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_01_PJLRProtect/source/application/E2EPJLR_ConTest_01_PJLRProtect.c</sourcefile>
      <sourceline>1352</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

    1) Check that the E2E-library function E2E_PJLRProtect()
       returns the error codes E2E_E_INPUTERR_NULL if:
    - NULL_PTR is passed for configuration data / state data / data to be protected

    2) Check that the E2E-library function E2E_PJLRProtect()
       returns the error codes E2E_E_INPUTERR_WRONG if:
    - invalid counter values in state data (maximum value exceeded)
    - invalid data length (not a multiple of 8, maximum value exceeded, value smaller than 16)
    - invalid crc offsets (greater than data length)
    - invalid counter offset (greater than data length + 4)
    - invalid DataIDNibbleOffset in case of DataID mode not equal to E2E_PJLR_DATAID_NIBBLE (!=0)

    See also in the SWS section 7.2.1 Error classification
    (End-to-End Communication Protection Library V1.0.0 R4.3 Rev 0).

&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 
    The input/output parameter(s) shall hold the following
    value(s) for calling E2E_PJLRProtect():
    01: set configuration to NULL
    02: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_NULL
    03: set sender state to NULL
    04: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_NULL
    05: set data to NULL
    06: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_NULL
    07: set all input parameters (configuration, sender state
        and data) to NULL
    08: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020510,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_NULL
    09: set all input parameters in RAM (sender state and data)
        to NULL
    10: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_NULL
    11: exceed maximum allowed State.Counter
    12: VP (EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG
    13: call with a data length which is not a multiple of 8
    14: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020510,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG
    15: call with a data length exceeding the maximum number of
        specified bits
    16: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG
    17: call with data id mode E2E_PJLR_DATAID_NIBBLE and a too high DataIdNibbleOffset)
        (i.e. Config-&gt;DataIDNibbleOffset + 4U) &gt; Config-&gt;DataLength)
    18: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG
    19: call with a crc offset greater than the configured data length
    20: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047,EB_E2EPJLR020567)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG
    21: call with a counter offset greater than the configured data length
    22: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047,EB_E2EPJLR020565)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG
    23: call with data id mode E2E_PJLR_DATAID_BOTH and DataIDNibbleOffset != 0
    24 VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG
    25: call with data id mode E2E_PJLR_DATAID_NIBBLE and DataID &gt;
        12bit value (0x1000U)
    26 VP (EB_E2EPJLR020506)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG
    27: call with data id mode E2E_PJLR_DATAID_NIBBLE and DataID &gt;
        12bit value (0xFFFFU)
    28 VP (EB_E2EPJLR020506)
        E2E_PJLRProtect() returns E2E_E_INPUTERR_WRONG


Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020575</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020567</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020565</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020510</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_01_PJLRProtect_AliveCntr</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_01_PJLRProtect/source/application/E2EPJLR_ConTest_01_PJLRProtect.c</sourcefile>
      <sourceline>1578</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 

  &lt;para&gt;
  The aspects stated below are done on valid input data only.

  1) (EB_E2EPJLR020575,EB_E2EPJLR020509,EB_E2EPJLR02_CounterOffset)
    Test that E2E_PJLRProtect()
    a) writes the Counter in the Data at the Counter position specified
       in the State data, The counter shall be bit aligned and the position can be 
       anywhere in the byte, also split over two bytes
    b) writes DataID Nibble in Data (if E2E_PJLR_DATAID_NIBBLE is used) at the Nibble
       position specified in the configuration data,
    c) computes the CRC over DataID (depending on DataID mode - see
       test aspects 5), 6), and 7)) and Data,
    d) writes the CRC in the Data at the CRC position provided in the configuration data, and
    e) increments the Counter in the State data.

  2) (EB_E2EPJLR020504)
     Test that E2E_PJLRProtect() increments the passed State Counter
     value by 1 up to 15, and then restarts with 0 again.

  3) (EB_E2EPJLR020508)
     Test that E2E_PJLRProtect() calls the SCrc_CalculateCRC8() function

  4) (EB_E2EPJLR020513)
     Test that E2E_PJLRProtect() uses CRC-8-SAE J1850 with 0xFFU as start value for the calculation of
     the CRC (That is,  SCrc_CalculateCRC8() is called with StartValue8=0x0U).

  5) (EB_E2EPJLR020506)
     Test that for DataID inclusion Mode E2E_PJLR_DATAID_NIBBLE,
     the low Nibble of the high byte of the DataID is written to the
     Data(covered by CRC calculation when computing CRC over Data). The high nibble of the
     high byte is left out. The low byte of the DataID is then included in the CRC calculation.
     The high byte is treated as 0.
  &lt;/para&gt;

  &lt;para&gt;
  Test strategies applied:
     Equivalence Class Partitioning:
       Test execution is done with a permutation of following parameters
          - E2E_PJLRProtectStateType.Counter
          - E2E_PJLRConfigType.CounterOffset
          - E2E_PJLRConfigType.CRCOffset
          - E2E_PJLRConfigType.DataIDNibbleOffset
          - E2E_PJLRConfigType.DataIDMode
          - E2E_PJLRConfigType.DataLength
          - E2E_PJLRConfigType.DataID
        Note: The following parameters are not used at sender side and therefore not relevant:
           - MaxDeltaCounter

     Pair wise tests: Tests are executed with a  combination of following parameters / values
          - DataIDMode
          - CRCOffset
          - CounterOffset
          - DataIDNibbleOffset (only relevant for E2E_PJLR_DATAID_NIBBLE)

     Boundary Value Analysis in combination
     with test-case E2EPJLR_ConTest_01_PJLRProtect_InvalidInput (outside bound):
        DataIdMode: [E2E_PJLR_DATAID_NIBBLE]
        DataLength: MIN=2, MAX=30
        Counter: MIN=0, MAX=15; (First Byte, Last Byte, in between Data)
        DataId: MIN=0, MAX=0x0FFF (E2E_PJLR_DATAID_NIBBLE)
        DataIDNibbleOffset: MIN=12, MAX=DataLength+4 (low nibble and high nibble)
        CounterOffset: MIN=0, MAX=DataLength+4
        CRCOffset: MIN=0, MAX=DataLength
  &lt;/para&gt;


Test Object: None.
Test Precondition: None.
Test Execution: 

 010: Prepare CRC stub (SCrc_CalculateCRC8) to return the number of overall Stub calls.

 For each stated TestDataBlock (InputTstCfg), execute the following steps:
 020: call the E2E_Protect function with following parameters:
      - Parameter Config points to following test-data
          Config.DataIDMode       = InputTstCfg.DataIDMode
          Config.DataID           = InputTstCfg.DataID
          Config.DataIDNibbleOffset = InputTstCfg.DataIDNibbleOffset
          Config.CRCOffset        = InputTstCfg.CRCOffset
          Config.CounterOffset    = InputTstCfg.CounterOffset
          Config.DataLength       = InputTstCfg.DataLength
          Config.TstData          = InputTstCfg.TstData
       - Parameter State points to following input data
          State.Counter           = InputTstCfg.Counter
       - Parameter Data points to valid input data
 030: VP (EB_E2EPJLR020575):
     E2E_Protect function returns E2E_E_OK
 040: VP (EB_E2EPJLR020504,EB_E2EPJLR020575,EB_E2EPJLR020509)
     State.Counter is updated as follows:
         If InputTstCfg.Counter==MAX(15) =&gt; State.Counter=0
         If InputTstCfg.Counter &lt; MAX(15) =&gt; State.Counter=InputTstCfg.Counter+1
 050: VP (EB_E2EPJLR020575,EB_E2EPJLR020509,EB_E2EPJLR02_CounterOffset)
     Counter shall be bit aligned and the position can be anywhere in the byte, 
         also split over two bytes
     TestData at position Config.CounterOffset (4 bits) equals InputTstCfg.Counter
 060: VP (EB_E2EPJLR020575,EB_E2EPJLR020509)
     If Config.DataIDMode=E2E_PJLR_DATAID_NIBBLE =&gt;
       TestData at position Config.DataIDNibbleOffset (4 bits) equals
       the low Nibble of the high byte of Config.DataID
 070: VP (EB_E2EPJLR020575,EB_E2EPJLR020509)
     TestData at position Config.CRCOffset (8 bits) equals
     the number of overall calls to the SCrc_CalculateCRC8 CRC stub
 080: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020509)
      Number of SCrc_CalculateCRC8 CRC stub calls equals n where:

         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE
           and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3
         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4
 090: VP (EB_E2EPJLR020509,EB_E2EPJLR020511,EB_E2EPJLR020512,EB_E2EPJLR020513,EB_E2EPJLR020514,)
        No other data except CRC / Counter and DataId Nibble is modified in TestData
 100: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020509)
      1st call to SCrc_CalculateCRC8 CRC stub in this test iteration:
        - SCrc_DataPtr points to a value that equals the low byte of InputTstCfg.DataID
        - SCrc_Length equals 1
        - SCrc_StartValue8 equals 0x0U
        - SCrc_IsFirstCall equals FALSE
 110: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on DataIdMode):
       If InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE:
         - SCrc_DataPtr points to a value 0
         - SCrc_Length equals 1
         - SCrc_StartValue8 equals the SCrc return value from the previous stub call
         - SCrc_IsFirstCall equals FALSE
 120: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020506,EB_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
       if InputTstCfg.CRCOffset is first byte in TestData
          - SCrc_DataPtr points to 2nd byte of the data passed to E2E_Protect
          - SCrc_Length equals Config.DataLength-1
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE
       if InputTstCfg.CRCOffset is not first byte in TestData
          - SCrc_DataPtr points to 1st byte of the data passed to E2E_Protect
          - SCrc_Length equals Config.CRCOffset / 8 (excludes CRC value)
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE
 130: VP (EB_E2EPJLR020575,EB_E2EPJLR020508,EB_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020506,EB_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
       if InputTstCfg.CRCOffset is not first byte and not last byte
          - SCrc_DataPtr points to 1st byte after CRC byte in the TestData
          - SCrc_Length equals Config.DataLength-(Config.CRCOffset/8) (Data after CRC byte)
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE


Test Input: 

Note: MAX ... maximum possible counter value =  15

TestDataBlock 1 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  - DataID Nibble at bit position 16 (Low Nibble)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    16
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         { 41, 42, 43 }
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 11, 7, 12 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different values)

TestDataBlock 2 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the second byte of the Data
  - Counter at in the third byte of the Data
  -- DataIDNibble in the fifth byte as low nibble
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    40
InputTstCfg.CRCOffset:             16
InputTstCfg.CounterOffset:         { 29, 30, 31 }
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Protect
                                   { 8, 9, 10 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Protect (different values)


Test Output: 
  return value for all tests shall be E2E_E_OK
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020575</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020509</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020504</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020513</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020511</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020512</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020514</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR02_CounterOffset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_ConTest_02000_PJLRCheckStatus_Ok</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>875</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;

      1. Test that E2E_PJLRSTATUS_OK is set if the difference between
         received counter and state counter is 1 and the CRC value from header
         is equal to calculated CRC value.
      2. Test correct CRC callouts for different PJLR Counter and DataIDNibble offsets
         (beginning, end, in the mid of the received data).
      3. Test that the library correctly considers a wrap around of
         the counter value in case the ReceivedCounter &lt; State-&gt;Counter.

      Note: Here, only good case is tested where

      - "received" CRC equals the expected value
      - Calculated DeltaCounter is valid

  &lt;/para&gt;
  
Test Object: E2E_PJLRCheckStatus()
Test Precondition: 
  
Test Execution: 

    Execute the following steps several times with InputDataXX from input:

    01: Call E2E_PJLRCheck() with
        - the E2E_PJLRConfig stated in InputDataXX
        - the E2E_PJLRCheckState stated in InputDataXX
        - the data VDxx stated in InputDataXX

    VPs checked in EBTEST_GenericTest():

    02: VP(EB_E2EPJLR020047,EB_E2EPJLR020572):
        The return value of E2E_PJLRCheck()
        shall be equal to the value specified in OutputDataXX.
    03: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
        State-&gt;Status shall be equal to the value specified in OutputDataXX.
    04: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
        State-&gt;Counter shall be equal to the value specified in OutputDataXX.

    VPs checked in SCrc_CalculateCRC8() stub:

    05: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
        SCrc_CalculateCRC8() shall be called 4 times for each E2E_PJLRCheck() iteration
        if configured Offset is greater than 0:
        first call:
          length in bytes shall be 1
          low byte of configured Data ID is used in the calculation
          the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
          SCrc_IsFirstCall is FALSE
        second call:
          length in bytes shall be 1
          high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE
        third call:
          length in bytes shall be CRCOffset
          data bytes used in the calculation the ones located before the CRC byte
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE
        fourth call:
          length in bytes shall be Length - CRCOffset - 1
          data bytes used in the calculation the ones located after the CRC byte
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE
    06: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
          SCrc_CalculateCRC8() shall be called 3 times for each E2E_PJLRCheck() iteration
          if configured CRCOffset is 0:
        first call:
          length in bytes shall be 1
          low byte of configured Data ID is used in the calculation
          the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
          SCrc_IsFirstCall is FALSE
        second call:
          length in bytes shall be 1
          high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE
        third call:
          length in bytes shall be Length - CRCOffset - 1
          data bytes used in the calculation the ones located after the CRC byte
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE

    Test aspects of individual InputDataXX/OutputDataXX:
    (always tested in modes E2E_PJLR_DATAID_BOTH and E2E_PJLR_DATAID_NIBBLE)

    Data00/1..Data02/2: VP(EB_E2EPJLR020518,EB_E2EPJLR020521,EB_E2EPJLR020540):
                    Difference between received counter and state counter is 1.
    Data00/1..Data02/2: VP(EB_E2EPJLR020519,EB_E2EPJLR020516,EB_E2EPJLR020521,EB_E2EPJLR020540):
                    CRC value from header is equal to calculated CRC value.
    Data00/1, Data00/2: VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
                    SCrc_CalculateCRC8() is called three times.
    Data01/1..Data02/2: VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
                    SCrc_CalculateCRC8() is called four times.

    Used Test Strategies:
    - Pair wise tests
    (Different values among different E2E_PJLRCheckState parameters)
    - Boundary Value Analysis
    (Either usage of all possible values or min / intermediate /max value for individual parameters)
    Note: A wrap around of the counter is possible w.r.t. to lastReceivedCounter value.
    - Equivalence Class Partitioning
    (Testing only transitions to Rx status E2E_PJLRSTATUS_OK)

  
Test Input: 

    InputDataXX:

   Order of Input Data is always as follows:
      {
                     +-PJLRConfig-+
        { DataLength(in bits) , DataID , MaxDeltaCounter, DataIDMode , CRCOffset(in bits), CounterOffset(in bits), DataIDNibbleOffset (in bits) },
                     +-PJLRCheckState-+
        { PJLRCheckStatus, Counter } ,
        CRCOffset(in bytes), NoNewDataReceived, Counter value in E2E header , CRC Return Value , DataIDNibble
      }

    00/1: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)

    00/2: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value in header data
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)

    01/1: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 1)

    01/2: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 1)

    02/1: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - counter value in PJLRCheckState smaller than counter in header data (DeltaCounter == 1)

    02/2: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - counter value in PJLRCheckState smaller than counter in header data (DeltaCounter == 1)

  
Test Output: 

    OutputDataXX:

                 +-PJLRCheckState-+
              +-PJLRCheckStatus  +-Counter +-retVal +-invokedCrcCount
    00/1:  {{E2E_PJLRSTATUS_OK, 0x0U},  E2E_E_OK,    3U},
                 +-PJLRCheckState-+
              +-PJLRCheckStatus  +-Counter +-retVal +-invokedCrcCount
    00/2:  {{E2E_PJLRSTATUS_OK, 0x0U},  E2E_E_OK,    3U},
                 +-PJLRCheckState-+
              +-PJLRCheckStatus  +-Counter +-retVal +-invokedCrcCount
    01/1:  {{E2E_PJLRSTATUS_OK, 0x8U},  E2E_E_OK,    4U},
                 +-PJLRCheckState-+
              +-PJLRCheckStatus  +-Counter +-retVal +-invokedCrcCount
    01/2:  {{E2E_PJLRSTATUS_OK, 0x8U},  E2E_E_OK,    4U},
                 +-PJLRCheckState-+
              +-PJLRCheckStatus  +-Counter +-retVal +-invokedCrcCount
    02/1:  {{E2E_PJLRSTATUS_OK, 0xFU},  E2E_E_OK,    3U},
                     +-PJLRCheckState-+
              +-PJLRCheckStatus  +-Counter +-retVal +-invokedCrcCount
    02/2:  {{E2E_PJLRSTATUS_OK, 0xFU},  E2E_E_OK,    3U}

  </description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020516</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020517</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020582</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020518</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020519</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020540</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020541</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02001_PJLRCheckStatus_OkSomeLost</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>1163</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;

        1. Test that E2E_PJLRSTATUS_OKSOMELOST is set if the difference
           between received counter and state counter is greater than 1
           and smaller than configured MaxDeltaCounter.
        2. Test correct CRC callouts for different PJLR offsets
           (beginning, end, in the mid of the received data).
        3. Test that the library correctly considers a wrap around of
           the counter value in case the ReceivedCounter &lt; State-&gt;Counter.

    &lt;/para&gt;
    
Test Object: E2E_PJLRCheckStatus()
Test Precondition: 
    
Test Execution: 

      Execute the following steps several times with InputDataXX from input:

      01: Call E2E_PJLRCheck() with
          - the E2E_PJLRConfig stated in InputDataXX
          - the E2E_PJLRCheckState stated in InputDataXX
          - the data VDxx stated in InputDataXX

      VPs checked in EBTEST_GenericTest():

      02: VP(EB_E2EPJLR020047,EB_E2EPJLR020572):
          The return value of E2E_PJLRCheck()
          shall be equal to the value specified in OutputDataXX.
      03: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
          State-&gt;Status shall be equal to the value specified in OutputDataXX.
      04: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
          State-&gt;Counter shall be equal to the value specified in OutputDataXX.

      VPs checked in SCrc_CalculateCRC8() stub:

      05: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
          SCrc_CalculateCRC8() shall be called 4 times for each E2E_PJLRCheck() iteration
          if configured Offset is greater than 0:
          first call:
            length in bytes shall be 1
            low byte of configured Data ID is used in the calculation
            the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
            SCrc_IsFirstCall is FALSE
          second call:
            length in bytes shall be 1
            high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE
          third call:
            length in bytes shall be CRCOffset
            data bytes used in the calculation the ones located before the CRC byte
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE
          fourth call:
            length in bytes shall be Length - CRCOffset - 1
            data bytes used in the calculation the ones located after the CRC byte
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE
      06: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
          SCrc_CalculateCRC8() shall be called 3 times for each E2E_PJLRCheck() iteration
          if configured CRCOffset is 0:
          first call:
            length in bytes shall be 1
            low byte of configured Data ID is used in the calculation
            the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
            SCrc_IsFirstCall is FALSE
          second call:
            length in bytes shall be 1
            high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE
          third call:
            length in bytes shall be Length - CRCOffset - 1
            data bytes used in the calculation the ones located after the CRC byte
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE

      Test aspects of individual InputDataXX/OutputDataXX:

      Data00/1..Data02/2: VP(EB_E2EPJLR020518,EB_E2EPJLR020521,EB_E2EPJLR020540):
              Difference between received counter and state counter is greater than 1 and
              smaller than or equal to configured MaxDeltaCounter.
      Data00/1, Data00/2: VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
              SCrc_CalculateCRC8() is called three times.
      Data01/1.. Data02/02: VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
              SCrc_CalculateCRC8() is called four times.

      Used Test Strategies:
      - Pair wise tests
      (Different values among different E2E_PJLRCheckState parameters)
      - Boundary Value Analysis
      (Either usage of all possible values or min / intermediate /max value for individual parameters)
      Note: A wrap around of the counter is possible w.r.t. to lastReceivedCounter value.
      - Equivalence Class Partitioning
      (Testing only transitions to Rx status E2E_PJLRSTATUS_OKSOMELOST)

    
Test Input: 

      InputDataXX:

      Order of Input Data is always as follows:
      {
                     +-PJLRConfig-+
        { DataLength(in bits) , DataID , MaxDeltaCounter, DataIDMode , CRCOffset(in bits), CounterOffset(in bits), DataIDNibbleOffset (in bits) },
                     +-PJLRCheckState-+
        { PJLRCheckStatus, Counter } ,
        CRCOffset(in bytes), NoNewDataReceived, Counter value in E2E header , CRC Return Value , DataIDNibble
      }

    00/1: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - counter value in header data is 1
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - MaxDeltaCounter is 2
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    00/2: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - counter value in header data is 1
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - MaxDeltaCounter is 2
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    01/1: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 7)
        - MaxDeltaCounter is 7
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    01/2: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 7)
        - MaxDeltaCounter is 7
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    02/1: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - minimum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - MaxDeltaCounter is 0xF
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    02/2: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - minimum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - MaxDeltaCounter is 0xF
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    
Test Output: 

      OutputDataXX:

                   +-PJLRCheckState-+
                +-PJLRCheckStatus         +-Counter +-retVal +-invokedCrcCount
      00/1:  {{E2E_PJLRSTATUS_OKSOMELOST, 0x1U},   E2E_E_OK,  3U},
                   +-PJLRCheckState-+
                +-PJLRCheckStatus         +-Counter +-retVal +-invokedCrcCount
      00/2:  {{E2E_PJLRSTATUS_OKSOMELOST, 0x1U},   E2E_E_OK,  3U},
                   +-PJLRCheckState-+
                +-PJLRCheckStatus         +-Counter +-retVal +-invokedCrcCount
      01/1:  {{E2E_PJLRSTATUS_OKSOMELOST, 0xAU},   E2E_E_OK,  4U},
                   +-PJLRCheckState-+
                +-PJLRCheckStatus         +-Counter +-retVal +-invokedCrcCount
      01/2:  {{E2E_PJLRSTATUS_OKSOMELOST, 0xAU},   E2E_E_OK,  4U},
                   +-PJLRCheckState-+
                +-PJLRCheckStatus         +-Counter +-retVal +-invokedCrcCount
      02/1:  {{E2E_PJLRSTATUS_OKSOMELOST, 0xFU},   E2E_E_OK,  3U},
                   +-PJLRCheckState-+
                +-PJLRCheckStatus         +-Counter +-retVal +-invokedCrcCount
      02/2:  {{E2E_PJLRSTATUS_OKSOMELOST, 0xFU},   E2E_E_OK,  3U}

    </description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020516</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020517</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020582</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020518</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020540</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020541</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02002_PJLRCheckStatus_WrongSequence</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>1460</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;

      1. Test that E2E_PJLRSTATUS_WRONGSEQUENCE is set if the difference
         between the read Counter value from the passed data and the Counter
         in the state structure is greater than MaxDeltaCounter.
      2. Test correct CRC callouts for different PJLR header offsets
         (beginning, end, in the mid of the received data).
      3. Test that the library correctly considers a wrap around of
         the counter value in case the ReceivedCounter &lt; State-&gt;Counter.

  &lt;/para&gt;
  
Test Object: E2E_PJLRCheckStatus()
Test Precondition: 
  
Test Execution: 

    Execute the following steps several times with InputDataXX from input:

    01: Call E2E_PJLRCheck() with
        - the E2E_PJLRConfig stated in InputDataXX
        - the E2E_PJLRCheckState stated in InputDataXX
        - the data VDxx stated in InputDataXX

    VPs checked in EBTEST_GenericTest():

    02: VP(EB_E2EPJLR020047,EB_E2EPJLR020572):
        The return value of E2E_PJLRCheck()
        shall be equal to the value specified in OutputDataXX.
    03: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
        State-&gt;Status shall be equal to the value specified in OutputDataXX.
    04: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
        State-&gt;Counter shall be equal to the value specified in OutputDataXX.

    VPs checked in SCrc_CalculateCRC8() stub:

    05: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
        SCrc_CalculateCRC8() shall be called 4 times for each E2E_PJLRCheck() iteration
        if configured Offset is greater than 0:
        first call:
          length in bytes shall be 1
          low byte of configured Data ID is used in the calculation
          the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
          SCrc_IsFirstCall is FALSE
        second call:
          length in bytes shall be 1
          high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE
        third call:
          length in bytes shall be CRCOffset
          data bytes used in the calculation the ones located before the CRC byte
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE
        fourth call:
          length in bytes shall be Length - CRCOffset - 1
          data bytes used in the calculation the ones located after the CRC byte
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE
    06: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
          SCrc_CalculateCRC8() shall be called 3 times for each E2E_PJLRCheck() iteration
          if configured CRCOffset is 0:
        first call:
          length in bytes shall be 1
          low byte of configured Data ID is used in the calculation
          the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
          SCrc_IsFirstCall is FALSE
        second call:
          length in bytes shall be 1
          high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE
        third call:
          length in bytes shall be Length - CRCOffset - 1
          data bytes used in the calculation the ones located after the CRC byte
          the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
          SCrc_IsFirstCall is FALSE

    Test aspects of individual InputDataXX/OutputDataXX:

    Data00/1..Data02/2: VP(EB_E2EPJLR020518,EB_E2EPJLR020521,EB_E2EPJLR020540):
            Difference between received counter and state counter is greater than
            configured MaxDeltaCounter.
    Data00/1, Data00/2 : VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
            SCrc_CalculateCRC8() is called three times.
    Data01/1, Data01/2, Data02/01, Data02/02: VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
            SCrc_CalculateCRC8() is called four times.

    Used Test Strategies:
    - Pair wise tests
    (Different values among different E2E_PJLRCheckState parameters)
    - Boundary Value Analysis
    (Either usage of all possible values or min / intermediate /max value for individual parameters)
    Note: A wrap around of the counter is possible w.r.t. to lastReceivedCounter value.
    - Equivalence Class Partitioning
    (Testing only transitions to Rx status E2E_PJLRSTATUS_WRONGSEQUENCE)

  
Test Input: 

    InputDataXX:

    Order of Input Data is always as follows:
    {
                  +-PJLRConfig-+
     { DataLength(in bits) , DataID , MaxDeltaCounter, DataIDMode , CRCOffset(in bits), CounterOffset(in bits), DataIDNibbleOffset (in bits) },
                  +-PJLRCheckState-+
     { PJLRCheckStatus, Counter } ,
      CRCOffset(in bytes), NoNewDataReceived, Counter value in E2E header , CRC Return Value , DataIDNibble
    }

    00/1: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - MaxDeltaCounter is 0
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    00/2: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - MaxDeltaCounter is 0
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    01/1: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 8)
        - MaxDeltaCounter is 7
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    01/2: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 8)
        - MaxDeltaCounter is 7
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    02/1: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - minimum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - MaxDeltaCounter is 0xE
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    02/2: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - minimum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - MaxDeltaCounter is 0xE
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

  
Test Output: 

    OutputDataXX:

                 +-JLRCheckState-+
              +-JLRCheckStatus            +-Counter +-retVal            +-invokedCrcCount
    00/1:  {{E2E_PJLRSTATUS_WRONGSEQUENCE, 0x0U},   E2E_P_WRONGSEQUENCE,  3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus            +-Counter +-retVal            +-invokedCrcCount
    00/2:  {{E2E_PJLRSTATUS_WRONGSEQUENCE, 0x0U},   E2E_P_WRONGSEQUENCE,  3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus            +-Counter +-retVal            +-invokedCrcCount
    01/1:  {{E2E_PJLRSTATUS_WRONGSEQUENCE, 0xCU},   E2E_P_WRONGSEQUENCE,  4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus            +-Counter +-retVal            +-invokedCrcCount
    01/2:  {{E2E_PJLRSTATUS_WRONGSEQUENCE, 0xCU},   E2E_P_WRONGSEQUENCE,  4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus            +-Counter +-retVal            +-invokedCrcCount
    02/1:  {{E2E_PJLRSTATUS_WRONGSEQUENCE, 0xFU},   E2E_P_WRONGSEQUENCE,  3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus            +-Counter +-retVal            +-invokedCrcCount
    02/2:  {{E2E_PJLRSTATUS_WRONGSEQUENCE, 0xFU},   E2E_P_WRONGSEQUENCE,  3U}

  </description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020516</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020517</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020582</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020518</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020540</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020541</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02003_PJLRCheckStatus_Repeated</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>1752</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;

        1. Test that E2E_JLRSTATUS_REPEATED is set if the read Counter value
           from the passed data is equal to the Counter in the state structure.
        2. Test correct CRC callouts for different JLR header offsets
           (beginning, end, in the mid of the received data).
        3. Test that the library correctly considers a wrap around of
           the counter value in case the ReceivedCounter &lt; State-&gt;Counter.

    &lt;/para&gt;
    
Test Object: E2E_PJLRCheckStatus()
Test Precondition: 
    
Test Execution: 

      Execute the following steps several times with InputDataXX from input:

      01: Call E2E_PJLRCheck() with
          - the E2E_PJLRConfig stated in InputDataXX
          - the E2E_PJLRCheckState stated in InputDataXX
          - the data VDxx stated in InputDataXX

      VPs checked in EBTEST_GenericTest():

      02: VP(EB_E2EPJLR020047,EB_E2EPJLR020572):
          The return value of E2E_PJLRCheck()
          shall be equal to the value specified in OutputDataXX.
      03: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
          State-&gt;Status shall be equal to the value specified in OutputDataXX.
      04: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
          State-&gt;Counter shall be equal to the value specified in OutputDataXX.

      VPs checked in SCrc_CalculateCRC8() stub:

      05: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
          SCrc_CalculateCRC8() shall be called 4 times for each E2E_PJLRCheck() iteration
          if configured Offset is greater than 0:
          first call:
            length in bytes shall be 1
            low byte of configured Data ID is used in the calculation
            the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
            SCrc_IsFirstCall is FALSE
          second call:
            length in bytes shall be 1
            high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE
          third call:
            length in bytes shall be CRCOffset
            data bytes used in the calculation the ones located before the CRC byte
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE
          fourth call:
            length in bytes shall be Length - CRCOffset - 1
            data bytes used in the calculation the ones located after the CRC byte
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE
      06: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
            SCrc_CalculateCRC8() shall be called 3 times for each E2E_PJLRCheck() iteration
            if configured CRCOffset is 0:
          first call:
            length in bytes shall be 1
            low byte of configured Data ID is used in the calculation
            the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
            SCrc_IsFirstCall is FALSE
          second call:
            length in bytes shall be 1
            high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE
          third call:
            length in bytes shall be Length - CRCOffset - 1
            data bytes used in the calculation the ones located after the CRC byte
            the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
            SCrc_IsFirstCall is FALSE

      Test aspects of individual InputDataXX/OutputDataXX:

      Data00/1..Data02/2: VP(EB_E2EPJLR020518,EB_E2EPJLR020521,EB_E2EPJLR020540):
              Difference between received counter and state counter is 0.
      Data00/1, Data00/2 : VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
              SCrc_CalculateCRC8() is called three times.
      Data01/1, Data01/2, Data02/01, Data02/02: VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
              SCrc_CalculateCRC8() is called four times.

      Used Test Strategies:
      - Pair wise tests
      (Different values among different E2E_PJLRCheckState parameters)
      - Boundary Value Analysis
      (Either usage of all possible values or min / intermediate /max value for individual parameters)
      Note: A wrap around of the counter is possible w.r.t. to lastReceivedCounter value.
      - Equivalence Class Partitioning
      (Testing only transitions to Rx status E2E_PJLRSTATUS_REPEATED)

    
Test Input: 

      InputDataXX:

      Order of Input Data is always as follows:
     {
                  +-PJLRConfig-+
       { DataLength(in bits) , DataID , MaxDeltaCounter, DataIDMode , CRCOffset(in bits), CounterOffset(in bits), DataIDNibbleOffset (in bits) },
                  +-PJLRCheckState-+
       { PJLRCheckStatus, Counter } ,
       CRCOffset(in bytes), NoNewDataReceived, Counter value in E2E header , CRC Return Value , DataIDNibble
     }

    00/1: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
          - minimum data length
          - minimum counter value in header data
          - minimum counter value in PJLRCheckState
          - MaxDeltaCounter is 1
          - DataIDMode is E2E_PJLR_DATAID_BOTH

    00/2: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - MaxDeltaCounter is 0
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    01/1: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 0)
        - MaxDeltaCounter is 7
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    01/2: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 0)
        - MaxDeltaCounter is 7
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    02/1: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - maximum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - MaxDeltaCounter is 0xF
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    02/2: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - maximum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - MaxDeltaCounter is 0xF
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

  
Test Output: 

    OutputDataXX:

                 +-JLRCheckState-+
              +-JLRCheckStatus      +-Counter +-retVal     +-invokedCrcCount
    00/1:  {{E2E_PJLRSTATUS_REPEATED, 0x00U}, E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus      +-Counter +-retVal     +-invokedCrcCount
    00/2:  {{E2E_PJLRSTATUS_REPEATED, 0x00U}, E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus      +-Counter +-retVal     +-invokedCrcCount
    01/1:  {{E2E_PJLRSTATUS_REPEATED, 0x7U},   E2E_E_OK,   4U},
              +-JLRCheckStatus      +-Counter +-retVal     +-invokedCrcCount
    01/2:  {{E2E_PJLRSTATUS_REPEATED, 0x7U},   E2E_E_OK,   4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus      +-Counter +-retVal     +-invokedCrcCount
    02/1:  {{E2E_PJLRSTATUS_REPEATED, 0xFU}, E2E_E_OK,     3U}
                 +-JLRCheckState-+
              +-JLRCheckStatus      +-Counter +-retVal     +-invokedCrcCount
    02/2:  {{E2E_PJLRSTATUS_REPEATED, 0xFU}, E2E_E_OK,     3U}

  </description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020516</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020517</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020582</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020518</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020540</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020541</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02004_PJLRCheckStatus_Error</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>2041</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;

        1. Test that E2E_PJLRSTATUS_ERROR is set if the read CRC value
           from the passed data differs from the calculated CRC value.
        2. Test correct CRC callouts for different JLR header offsets
           (beginning, end, in the mid of the received data).
        3. Test that E2E_PJLRSTATUS_ERROR is set if DataIDMode is E2E_PJLR_DATAID_NIBBLE
           and ReceivedNibble does not match low nibble of high byte of DataID.

    &lt;/para&gt;
    
Test Object: E2E_PJLRCheckStatus()
Test Precondition: 
    
Test Execution: 

      Execute the following steps several times with InputDataXX from input:

      01: Call E2E_PJLRCheck() with
          - the E2E_PJLRConfig stated in InputDataXX
          - the E2E_PJLRCheckState stated in InputDataXX
          - the data VDxx stated in InputDataXX

      VPs checked in EBTEST_GenericTest():

        02: VP(EB_E2EPJLR020047,EB_E2EPJLR020572):
            The return value of E2E_PJLRCheck()
            shall be equal to the value specified in OutputDataXX.
        03: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
            State-&gt;Status shall be equal to the value specified in OutputDataXX.
        04: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
            State-&gt;Counter shall be equal to the value specified in OutputDataXX.

      VPs checked in SCrc_CalculateCRC8() stub:

        05: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
            SCrc_CalculateCRC8() shall be called 4 times for each E2E_PJLRCheck() iteration
            if configured Offset is greater than 0:
            first call:
              length in bytes shall be 1
              low byte of configured Data ID is used in the calculation
              the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
              SCrc_IsFirstCall is FALSE
            second call:
              length in bytes shall be 1
              high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
              the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
              SCrc_IsFirstCall is FALSE
            third call:
              length in bytes shall be CRCOffset
              data bytes used in the calculation the ones located before the CRC byte
              the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
              SCrc_IsFirstCall is FALSE
            fourth call:
              length in bytes shall be Length - CRCOffset - 1
              data bytes used in the calculation the ones located after the CRC byte
              the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
              SCrc_IsFirstCall is FALSE
        06: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
              SCrc_CalculateCRC8() shall be called 3 times for each E2E_PJLRCheck() iteration
              if configured CRCOffset is 0:
            first call:
              length in bytes shall be 1
              low byte of configured Data ID is used in the calculation
              the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
              SCrc_IsFirstCall is FALSE
            second call:
              length in bytes shall be 1
              high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
              the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
              SCrc_IsFirstCall is FALSE
            third call:
              length in bytes shall be Length - CRCOffset - 1
              data bytes used in the calculation the ones located after the CRC byte
              the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
              SCrc_IsFirstCall is FALSE

      Test aspects of individual InputDataXX/OutputDataXX:

      Data00/1..Data03/6: VP(EB_E2EPJLR020519,ASR_E2EJLR020406,EB_E2EPJLR020521,EB_E2EPJLR020540):
                          CRC value from header is different than calculated CRC value.
      Data00..Data01/2: VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
                        SCrc_CalculateCRC8() is called three times.
      Data02/1..Data03/6: VP(EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
                          SCrc_CalculateCRC8() is called four times.

      Used Test Strategies:
      - Pair wise tests
      (Different values among different E2E_PJLRCheckState parameters)
      - Boundary Value Analysis
      (Either usage of all possible values or min / intermediate /max value for individual parameters)
      Note: A wrap around of the counter is possible w.r.t. to lastReceivedCounter value.
      - Equivalence Class Partitioning
      (Testing only transitions to Rx status E2E_PJLRSTATUS_ERROR due to wrong CRC)

    
Test Input: 

    InputDataXX:

    Order of Input Data is always as follows:
     {
                  +-PJLRConfig-+
       { DataLength(in bits) , DataID , MaxDeltaCounter, DataIDMode , CRCOffset(in bits), CounterOffset(in bits), DataIDNibbleOffset (in bits) },
                  +-PJLRCheckState-+
       { PJLRCheckStatus, Counter } ,
       CRCOffset(in bytes), NoNewDataReceived, Counter value in E2E header , CRC Return Value , DataIDNibble
     }

    00/1: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_1OF3)
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    00/2: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_2OF3)
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    01/1: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_1OF3)
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    01/2: - PJLR header (CRC, DataIDNibble and Counter) at beginning of test data
        - minimum data length
        - minimum counter value
        - maximum counter value in PJLRCheckState (wrap around of the counter considered)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_2OF3)
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    02/1: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 1)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_1OF4)
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    02/2: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 1)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_2OF4)
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    02/3: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 1)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_3OF4)
        - DataIDMode is E2E_PJLR_DATAID_BOTH

    02/4: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 1)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_1OF4)
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    02/5: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 1)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_2OF4)
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    02/6: - PJLR header (CRC, DataIDNibble and Counter) in middle of test data
        - mid data length
        - mid counter value in header data
        - mid counter value in PJLRCheckState (DeltaCounter == 1)
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_3OF4)
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE

    03/1: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - maximum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - DataIDMode is E2E_PJLR_DATAID_BOTH
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_1OF3)

    03/2: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - maximum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - DataIDMode is E2E_PJLR_DATAID_BOTH
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_2OF3)

    03/3: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - maximum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_1OF3)

    03/4: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - maximum data length
        - maximum counter value in header data
        - maximum counter value in PJLRCheckState (DeltaCounter == 0xF)
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE
        - wrong CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8_2OF3)

    04/0: - PJLR header (CRC, DataIDNibble and Counter) at end of test data
        - minimum data length
        - minimum counter value in header data
        - minimum counter value in PJLRCheckState (DeltaCounter == 0x0)
        - DataIDMode is E2E_PJLR_DATAID_NIBBLE
        - correct CRC in E2E header (EBTEST_RETVAL_CALCULATECRC8)
  
Test Output: 

    OutputDataXX:

                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    00/1:  {{E2E_PJLRSTATUS_ERROR, 0xFU},  E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    00/2:  {{E2E_PJLRSTATUS_ERROR, 0xFU},  E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    01/1:  {{E2E_PJLRSTATUS_ERROR, 0xFU},  E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    01/2:  {{E2E_PJLRSTATUS_ERROR, 0xFU},  E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    02/1:  {{E2E_PJLRSTATUS_ERROR, 0x7U},  E2E_E_OK,   4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    02/2:  {{E2E_PJLRSTATUS_ERROR, 0x7U},  E2E_E_OK,   4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    02/3:  {{E2E_PJLRSTATUS_ERROR, 0x7U},  E2E_E_OK,   4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    02/4:  {{E2E_PJLRSTATUS_ERROR, 0x7U},  E2E_E_OK,   4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    02/5:  {{E2E_PJLRSTATUS_ERROR, 0x7U},  E2E_E_OK,   4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    02/6:  {{E2E_PJLRSTATUS_ERROR, 0x7U},  E2E_E_OK,   4U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    03/1:  {{E2E_PJLRSTATUS_ERROR, 0xEU},  E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    03/2:  {{E2E_PJLRSTATUS_ERROR, 0xEU},  E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    03/3:  {{E2E_PJLRSTATUS_ERROR,  0xEU},  E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    03/4:  {{E2E_PJLRSTATUS_ERROR,  0xEU},  E2E_E_OK,   3U},
                 +-JLRCheckState-+
              +-JLRCheckStatus     +-Counter +-retVal +-invokedCrcCount
    04/0:  {{E2E_PJLRSTATUS_ERROR,  0xFU},  E2E_E_OK,   3U},

  </description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020516</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020503</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020517</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020519</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020540</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020541</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02005_PJLRCheckStatus_NoNewData</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>2500</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
      &lt;para&gt;

          Test that E2E_PJLRSTATUS_NONEWDATA is set if the passed
          DataPtr is NULL and Length is 0.

      &lt;/para&gt;
      
Test Object: E2E_PJLRCheckStatus()
Test Precondition: 
      
Test Execution: 

        Execute the following steps several times with InputDataXX from input:

        01: Call E2E_PJLRCheck() with
            - the E2E_PJLRConfig stated in InputDataXX
            - the E2E_PJLRCheckState stated in InputDataXX
            - the data VDxx stated in InputDataXX
            - Length equal to 0

        VPs checked in EBTEST_GenericTest():

        02: VP(EB_E2EPJLR020047,EB_E2EPJLR020572):
            The return value of E2E_PJLRCheck()
            shall be equal to the value specified in OutputDataXX.
        03: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
            State-&gt;Status shall be equal to the value specified in OutputDataXX.
        04: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020582,EB_E2EPJLR020519,EB_E2EPJLR020521):
            State-&gt;Counter shall be equal to the value specified in OutputDataXX.

        VPs checked in SCrc_CalculateCRC8() stub:

          05: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020518,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
              SCrc_CalculateCRC8() shall be called 4 times for each E2E_PJLRCheck() iteration
              if configured Offset is greater than 0:
              first call:
                length in bytes shall be 1
                low byte of configured Data ID is used in the calculation
                the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
                SCrc_IsFirstCall is FALSE
              second call:
                length in bytes shall be 1
                high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
                the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
                SCrc_IsFirstCall is FALSE
              third call:
                length in bytes shall be CRCOffset
                data bytes used in the calculation the ones located before the CRC byte
                the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
                SCrc_IsFirstCall is FALSE
              fourth call:
                length in bytes shall be Length - CRCOffset - 1
                data bytes used in the calculation the ones located after the CRC byte
                the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
                SCrc_IsFirstCall is FALSE
          06: VP(EB_E2EPJLR020516,EB_E2EPJLR020517,EB_E2EPJLR020508,EB_E2EPJLR020540,EB_E2EPJLR020541):
                SCrc_CalculateCRC8() shall be called 3 times for each E2E_PJLRCheck() iteration
                if configured CRCOffset is 0:
              first call:
                length in bytes shall be 1
                low byte of configured Data ID is used in the calculation
                the start value shall be 0x0U (which is internally calculated
                         to 0xFFU within real SCrc module
                SCrc_IsFirstCall is FALSE
              second call:
                length in bytes shall be 1
                high byte of configured Data ID is used in the calculation, DataIDMode is set to E2E_PJLR_DATAID_BOTH
                the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
                SCrc_IsFirstCall is FALSE
              third call:
                length in bytes shall be Length - CRCOffset - 1
                data bytes used in the calculation the ones located after the CRC byte
                the start value shall be the value returned by the previous call of SCrc_CalculateCRC8()
                SCrc_IsFirstCall is FALSE

        Test aspects of individual InputDataXX/OutputDataXX:

        Data00: VP(EB_E2EPJLR020521,EB_E2EPJLR020540):
                DataPtr is NULL.

        Used Test Strategies:
        - Pair wise tests
        (Different values among different E2E_PJLRCheckState parameters)
        - Boundary Value Analysis
        (Either usage of all possible values or min / intermediate /max value for individual parameters)
        Note: A wrap around of the counter is possible w.r.t. to lastReceivedCounter value.
        - Equivalence Class Partitioning
        (Testing only transitions to Rx status E2E_PJLRSTATUS_NONEWDATA)

      
Test Input: 

        InputDataXX:

        Order of Input Data is always as follows:
        {
                  +-PJLRConfig-+
          { DataLength(in bits) , DataID , MaxDeltaCounter, DataIDMode , CRCOffset(in bits), CounterOffset(in bits), DataIDNibbleOffset (in bits) },
                  +-PJLRCheckState-+
          { PJLRCheckStatus, Counter } ,
          CRCOffset(in bytes), NoNewDataReceived, Counter value in E2E header , CRC Return Value , DataIDNibble
        }


        00: - pointer to data array is set to NULL in EBTEST_GenericTest()

      
Test Output: 

        OutputDataXX:

                     +-JLRCheckState-+
                  +-JLRCheckStatus         +-Counter +-retVal    +-invokedCrcCount
        00:  {{E2E_PJLRSTATUS_NONEWDATA, 0xFU},      E2E_E_OK,   0U},

      </description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020516</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020517</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02006_PJLRMapStatusToSM</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>2672</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

     1) Test that if CheckReturn=E2E_E_OK then E2E_PJLRMapStatusToSM provides the following
        return value depending on the passed Status value:
        Status==E2E_PJLRSTATUS_OK =&gt; E2E_P_OK
        Status==E2E_PJLRSTATUS_OKSOMELOST =&gt; E2E_P_OK
        Status==E2E_PJLRSTATUS_ERROR =&gt; E2E_P_ERROR
        Status==E2E_PJLRSTATUS_REPEATED =&gt; E2E_P_REPEATED
        Status==E2E_PJLRSTATUS_NONEWDATA =&gt; E2E_P_NONEWDATA
        Status==E2E_PJLRSTATUS_WRONGSEQUENCE=&gt; E2E_P_WRONGSEQUENCE

     2) Test that if CheckReturn != E2E_E_OK then the function E2E_PJLRMapStatusToSM()
        returns E2E_P_ERROR.

     3) Test that if Status is undefined then the function E2E_PJLRMapStatusToSM()
        returns E2E_P_ERROR.

  &lt;/para&gt;
  
Test Object: E2E_PJLRMapStatusToSM()
Test Precondition: 
  
Test Execution: 

    01: Set first parameter to E2E_E_OK and second parameter to E2E_PJLRSTATUS_OK
        and call E2E_PJLRMapStatusToSM().
    02: VP(EB_E2EPJLR020557):
        E2E_PJLRMapStatusToSM() shall return E2E_P_OK.
    03: Set first parameter to E2E_E_OK and second parameter to E2E_PJLRSTATUS_OKSOMELOST
        and call E2E_PJLRMapStatusToSM().
    04: VP(EB_E2EPJLR020557):
        E2E_PJLRMapStatusToSM() shall return E2E_P_OK.
    05: Set first parameter to E2E_E_OK and second parameter to E2E_PJLRSTATUS_ERROR
        and call E2E_PJLRMapStatusToSM().
    06: VP(EB_E2EPJLR020557):
        E2E_PJLRMapStatusToSM() shall return E2E_P_ERROR.
    07: Set first parameter to E2E_E_OK and second parameter to E2E_PJLRSTATUS_REPEATED
        and call E2E_PJLRMapStatusToSM().
    08: VP(EB_E2EPJLR020557):
        E2E_PJLRMapStatusToSM() shall return E2E_P_REPEATED.
    09: Set first parameter to E2E_E_OK and second parameter to E2E_PJLRSTATUS_NONEWDATA
        and call E2E_PJLRMapStatusToSM().
    10: VP(EB_E2EPJLR020557):
        E2E_PJLRMapStatusToSM() shall return E2E_P_NONEWDATA.
    11: Set first parameter to E2E_E_OK and second parameter to E2E_PJLRSTATUS_WRONGSEQUENCE
        and call E2E_PJLRMapStatusToSM().
    12: VP(EB_E2EPJLR020557):
        E2E_PJLRMapStatusToSM() shall return E2E_P_WRONGSEQUENCE.
    13: Set first parameter to E2E_E_INPUTERR_NULL and second parameter to E2E_PJLRSTATUS_OK
        and call E2E_PJLRMapStatusToSM().
    14: VP(EB_E2EPJLR020558):
        E2E_PJLRMapStatusToSM() shall return E2E_P_ERROR.
    15: Set first parameter to E2E_E_INPUTERR_WRONG and second parameter to E2E_PJLRSTATUS_OK
        and call E2E_PJLRMapStatusToSM().
    16: VP(EB_E2EPJLR020558):
        E2E_PJLRMapStatusToSM() shall return E2E_P_ERROR.
    17: Set first parameter to E2E_E_INTERR and second parameter to E2E_PJLRSTATUS_OK
        and call E2E_PJLRMapStatusToSM().
    18: VP(EB_E2EPJLR020558):
        E2E_PJLRMapStatusToSM() shall return E2E_P_ERROR.
    19: Set first parameter to E2E_E_INVALID and second parameter to E2E_PJLRSTATUS_OK
        and call E2E_PJLRMapStatusToSM().
    20: VP(EB_E2EPJLR020558):
        E2E_PJLRMapStatusToSM() shall return E2E_P_ERROR.
    21: Set first parameter to E2E_E_WRONGSTATE and second parameter to E2E_PJLRSTATUS_OK
        and call E2E_PJLRMapStatusToSM().
    22: VP(EB_E2EPJLR020558):
        E2E_PJLRMapStatusToSM() shall return E2E_P_ERROR.
    23: Set first parameter to E2E_E_OK and second parameter to 5U, which is not defined,
        and call E2E_PJLRMapStatusToSM().
    24: VP(EB_E2EPJLR020558):
        E2E_PJLRMapStatusToSM() shall return E2E_P_ERROR.

    Used Test Strategies:
    - Pair wise tests
    (Different values among different E2E_PJLRMapStatusToSM() parameters)

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020557</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020558</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02007_PJLRCheckInit_Ok</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>2870</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

     Tests that in case State is valid, E2E_PJLRCheckInit() initializes the state structure,
     setting with Counter to 0xFU and Status to E2E_PJLRSTATUS_ERROR.

  &lt;/para&gt;
  
Test Object: E2E_PJLRCheckInit()
Test Precondition: None.
Test Execution: 

    01: Call E2E_PJLRCheckInit() with valid parameter.
    02: VP(EB_E2EPJLR020573, EB_E2EPJLR020556):
        E2E_PJLRCheckInit() returns E2E_E_OK.
        PJLRCheckState.Counter is initialized with 0xFU.
        PJLRCheckState.Status is initialized with E2E_PJLRSTATUS_ERROR.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to status E2E_E_OK for E2EJLRCheckInit() function)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020573</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020556</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02008_PJLRCheckInit_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>2930</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

    Tests that in case State is NULL, E2E_PJLRCheckInit() returns immediately
    with E2E_E_INPUTERR_NULL (no state data is modified).

&lt;/para&gt;

Test Object: E2E_PJLRCheckInit
Test Precondition: None.
Test Execution: 

  01: Call E2E_PJLRCheckInit() with NULL parameter.
  02: VP(EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047,EB_E2EPJLR020573,EB_E2EPJLR020556):
      E2E_PJLRCheckInit() returns E2E_E_INPUTERR_NULL.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to status E2E_E_INPUTERR_NULL for E2EPJLRCheckInit() function)


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020573</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020556</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02009_PJLRCheck_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>2991</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

    1) Test that the E2E-library function E2E_PJLRCheck()
       returns the error code E2E_E_INPUTERR_NULL if:
       - NULL_PTR is passed for configuration data
       - NULL_PTR is passed for state data
       - Length is != 0 and data pointer is NULL
    2) Test that the E2E-library function E2E_PJLRCheck()
       returns the error code E2E_E_INPUTERR_WRONG if:
    - CRCOffset in bits in the E2E_PJLRConfig is not a multiple of 8
    - CRCOffset in bits in the E2E_PJLRConfig is greater than DataLength
    - Config-&gt;DataIDMode is set neither to E2E_PJLR_DATAID_BOTH nor to
      E2E_PJLR_DATAID_NIBBLE
    - CounterOffset in bits in the E2E_PJLRConfig is not a multiple of 4
    - DataIDNibbleOffset in bits in the E2E_PJLRConfig is not a multiple of 4 and
      DataIDMode is set to E2E_PJLR_DATAID_NIBBLE
    - DataLength in the E2E_PJLRConfig is not a multiple of 8
    - CounterOffset in bits + 4 in the E2E_PJLRConfig is greater than DataLength
    - DataIDNibbleOffset in bits + 4 in the E2E_PJLRConfig is greater than DataLength
    - Length is 0 and data pointer is different than NULL
    - Length is smaller than (DataLength / 8)
    - Length is greater than (DataLength / 8)
    - Config-&gt;DataIDMode is E2E_PJLR_DATAID_NIBBLE and high nibble of high byte in
      DataID does not equal zero

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 

    01: Set first parameter to NULL (E2E_PJLRConfig) and call E2E_PJLRCheck().
    02: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_NULL.
    03: Set second parameter to NULL (E2E_PJLRCheckState) and call E2E_PJLRCheck().
    04: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_NULL.
    05: Set first and second parameter to NULL (E2E_PJLRConfig and E2E_PJLRCheckState)
        and call E2E_PJLRCheck().
    06: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_NULL.
    07: CRCOffset in the E2E_PJLRConfig is not a multiple of 8. Call E2E_PJLRCheck().
    08: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_WRONG.
    09: CRCOffset in the E2E_PJLRConfig is greater than DataLength. Call E2E_PJLRCheck().
    10: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_WRONG.
    11: DataLength in the E2E_PJLRConfig is not a multiple of 8. Call E2E_PJLRCheck().
    12: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_WRONG.
    13: DataIDNibbleOffset in the E2E_PJLRConfig is not a multiple of 4 and
        DataIDMode is set to E2E_PJLR_DATAID_NIBBLE. Call E2E_PJLRCheck().
    14: VP(ASR_E2EJLR020?,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_NULL.
    15: Length is smaller than (E2E_PJLRConfig.DataLength / 8U).
        Call E2E_PJLRCheck().
    16: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_WRONG.
    17: Length is greater than (E2E_PJLRConfig.DataLength / 8U).
        Call E2E_PJLRCheck().
    18: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_WRONG.
    19: Set fourth parameter to 0 (Length), set third parameter (Data) to a value different
        than NULL and call E2E_PJLRCheck().
    20: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_WRONG.
    21: Set third parameter to NULL (Data) and fourth parameter (Length) to a non-zero
        valid value and call E2E_PJLRCheck().
    22: VP(EB_E2EPJLR020572,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_NULL.
    23: Set DataIDMode neither to E2E_PJLR_DATAID_BOTH nor to E2E_PJLR_DATAID_NIBBLE, set to
        invalid enum value 2 and call E2E_PJLRCheck().
    24: VP(EB_E2EPJLR020505,EB_E2EPJLR020506,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_NULL.
    25: CounterOffset in the E2E_PJLRConfig is not smaller than (DataLength - 4U). Call E2E_PJLRCheck().
    26: VP(EB_E2EPJLR020505,EB_E2EPJLR020506,EB_E2EPJLR020517,EB_E2EPJLR020012,EB_E2EPJLR020011,EB_E2EPJLR020047):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_NULL.
    27: DataIDMode is set to E2E_PJLR_DATAID_NIBBLE and high nibble of high byte of DataID is not zero.
        Call E2E_PJLRCheck().
    28: VP(EB_E2EPJLR020306):
        E2E_PJLRCheck() returns E2E_E_INPUTERR_WRONG.

    Used Test Strategies:
    - Pair wise tests
    (Different values among different E2E_PJLRCheckState parameters)
    - Boundary Value Analysis
    (Either usage of all possible values or min / intermediate /max value for individual parameters)
    - Equivalence Class Partitioning
    (Testing only transitions to statuses different than E2E_E_OK for E2E_PJLRCheck() function)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020572</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020517</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020306</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02010_PJLRCheck_CheckEnum</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>3286</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;&lt;programlisting&gt;
   This test shall check enumerations related to E2E_PJLRCheck():
   - E2E_PJLRSTATUS_NONEWDATA
   - E2E_PJLRSTATUS_OK
   - E2E_PJLRSTATUS_REPEATED
   - E2E_PJLRSTATUS_ERROR
   - E2E_PJLRSTATUS_OKSOMELOST
   - E2E_PJLRSTATUS_WRONGSEQUENCE
&lt;/programlisting&gt;&lt;/para&gt;

Test Object: E2E_PJLRCheckStatusType
Test Precondition: None.
Test Execution: 

  00: VP(EB_E2EPJLR020564):
      Enumeration constants are not defined as macros.
  01: VP(EB_E2EPJLR020564):
      Enumeration constant E2E_PJLRSTATUS_NONEWDATA holds the specified value.
  02: VP(EB_E2EPJLR020564):
      Enumeration constant E2E_PJLRSTATUS_ERROR holds the specified value.
  03: VP(EB_E2EPJLR020564):
      Enumeration constant E2E_PJLRSTATUS_REPEATED holds the specified value.
  04: VP(EB_E2EPJLR020564):
      Enumeration constant E2E_PJLRSTATUS_OK holds the specified value.
  05: VP(EB_E2EPJLR020564):
      Enumeration constant E2E_PJLRSTATUS_OKSOMELOST holds the specified value.
  06: VP(EB_E2EPJLR020564):
      Enumeration constant E2E_PJLRSTATUS_WRONGSEQUENCE holds the specified value.


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020564</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_02011_PJLRCheck_Structures</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_02_PJLRCheck/source/application/E2EPJLR_ConTest_02_PJLRCheck.c</sourcefile>
      <sourceline>3380</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
     This test shall check the correct member order in structures
     E2E_PJLRCheckStateType and E2E_PJLRConfigType.
  &lt;/para&gt;
  
Test Object: E2E_PJLRConfigType,E2E_PJLRCheckStateType
Test Precondition: None.
Test Execution: 

    01: Create a typedef E2E_PJLRCheckStateCompareType
        that has the expected order of the members
        w.r.t E2E_PJLRCheckStateType.
    02: Create a typedef E2E_PJLRConfigCompareType
        that has the expected order of the members
        w.r.t E2E_PJLRConfigType.
    03: Define two local variables of type
        E2E_PJLRCheckStateType and E2E_PJLRCheckStateCompareType,
        respectively, each having the same values in the ordered
        initializer list.
    04: Define two local variables of type
        E2E_PJLRConfigType and E2E_PJLRConfigCompareType,
        respectively, each having the same values in the ordered
        initializer list.
    05: VP(EB_E2EPJLR020565)
        Each member of the the two local variables of Step 03
        are equal.
    06: VP(EB_E2EPJLR020563)
        Each member of the the two local variables of Step 04
        are equal.

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020565</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020563</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_ConTest_03_PublishedInformation</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_03_General/source/application/E2EPJLR_ConTest_03_General.c</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check the correct definition of the common published information
    provided in the module header file.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 

 01: VP(EB_E2EPJLR020038):
     E2EPJLR_VENDOR_ID is defined with the value provided by the tooling environment
 02: VP(EB_E2EPJLR020038):
     E2EPJLR_AR_RELEASE_MAJOR_VERSION is defined with the value specified in config.mk
 03: VP(EB_E2EPJLR020038):
     E2EPJLR_AR_RELEASE_MINOR_VERSION is defined with the value specified in config.mk
 04: VP(EB_E2EPJLR020038):
     E2EPJLR_AR_RELEASE_REVISION_VERSION is defined with the value specified in config.mk
 05: VP(EB_E2EPJLR020038):
     E2EPJLR_SW_MAJOR_VERSION is defined with the value specified in config.mk
 06: VP(EB_E2EPJLR020038):
     E2EPJLR_SW_MINOR_VERSION is defined with the value specified in config.mk
 07: VP(EB_E2EPJLR020038):
     E2EPJLR_SW_PATCH_VERSION is defined with the value specified in config.mk


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_03_NoConfigParams</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_03_General/source/application/E2EPJLR_ConTest_03_General.c</sourcefile>
      <sourceline>126</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check that the profile does not
    have any configuration options.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 

 TS5 build process steps:
 01: Provide a reference file E2EPJLR_Config.txt
     that contains the first line of the configuration
     container of the module configuration
 02: grep all variables of the installed
     profile configuration and for the name of
     the configuration container
 02a: remove all allowed variables from the result of step 02,
     i.e parameters of CommonPublishedInformation and PublishedInformation
 03: Compare the result of Step 2a with
     E2EPJLR_Config.txt
     and store the difference into
     E2EPJLR_Config.txt.diff.
 04: VP(EB_E2EPJLR020037):
     Step 03 reveals no difference
     (i.e. E2EPJLR_Config.txt.diff is empty)
 05: Include comparison differences of Step 04
     (i.e. E2EPJLR_Config.txt.diff)
     within this file.
 06: Compile this file
 07: VP(EB_E2EPJLR020037):
     This file compiles without errors.
 08: Execute this test case
 09: VP(EB_E2EPJLR020037):
     TS5ATL_RESULT_SUCCESS is returned Step 08

   Note:
    If one of the Verification points is violated, then the
    build process is aborted and an error is reported.


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_ConTest_04_IncludeFiles</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_04_Includes/source/application/E2EPJLR_ConTest_04_Includes.c</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   1) Test that E2E_PJLR.h exclusively includes E2E.h and no other files
   (EB_E2EPJLR020115).
   2) Test that E2E_PJLR.c exclusively includes E2E_PJLR.h, MemMap.h,
   and SCrc_CRC8.h and no other files (EB_E2EPJLR020115).
 
Test Object: None.
Test Precondition: 
 
Test Execution: 

 TS5 build process steps:
  1) Provide a reference file includesOf_E2E_PJLR.h.txt
     that contains the includes:
     E2E.h, MemMap.h
  2) Provide a reference file includesOf_E2E_PJLR.c.txt
     that contains the includes:
     E2E_PJLR.h, SCrc_CRC8.h, MemMap.h.
  3) Extract all includes of E2E_PJLR.h
  4) Extract all includes of E2E_PJLR.c
  5) Compare all includes of Step 3 with the
     reference file includesOf_E2E_PJLR.h.txt
     and store difference
     in file includesOf_E2E_PJLR.h.txt.diff.
  6) Compare all includes of Step 4 with the
     reference file includesOf_E2E_PJLR.c.txt
     and store difference
     in file includesOf_E2E_PJLR.h.txt.diff.
  7) Include comparison differences of Step 5 and Step 6
     (i.e. includesOf_E2E_PJLR.h.txt.diff and
     includesOf_E2E_PJLR.c.txt.diff) within this file.
  8) Compile this file
  9) VP(EB_E2EPJLR020115):
     Execute this test case which always returns TS5ATL_RESULT_SUCCESS.
     Note:
        If the extracted includes of Step 5 / Step 6 and
        the reference file are not identical, then
        the compile signals an error due to the
        inclusion of the diff results which contains
        not compilable text (backup in case the build process
        incorrectly does not abort).

 
Test Input: 
 
Test Output: 
 &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_ConTest_05_Files</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_05_Files/source/application/E2EPJLR_ConTest_05_Files.c</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test shall check that the profile JLR specific part
   of the E2E library is built of the following files: E2E_PJLR.h and E2E_PJLR.c
 
Test Object: None.
Test Precondition: 
 
Test Execution: 

 TS5 build process steps:
  1) Provide a reference file E2EPJLR_HeaderFiles.txt
     that contains: E2E_PJLR.h
  2) Provide a reference file E2EPJLR_SourceFiles.txt
     that contains: E2E_PJLR.c
  3) Search for all header files existing in the
     installed Tresos plugin of E2EPJLR
  4) Search for all source files existing in the
     installed Tresos plugin of E2EPJLR
  5) Compare the found files of Step 3 with the
     files listed in E2EPJLR_HeaderFiles.txt
     and store the difference into
     E2EPJLR_HeaderFiles.txt.diff.
  6) VP(EB_E2EPJLR020048):
     Step 5 reveals no difference
     (i.e. E2EPJLR_HeaderFiles.txt.diff is empty)
  7) Compare the found files of Step 4 with the
     files listed in E2EPJLR_SourceFiles.txt
     and store the difference into
     E2EPJLR_SourceFiles.txt.diff.
  8) VP(EB_E2EPJLR020048):
     Step 7 reveals no difference
     (i.e. E2EPJLR_SourceFiles.txt.diff is empty)
  9) Include comparison differences of Step 5 and Step 7
     (i.e. E2EPJLR_HeaderFiles.txt.diff and
     E2EPJLR_SourceFiles.txt.diff) within this file.
  10) Compile this file
  11) VP(EB_E2EPJLR020048):
      This file compiles without errors.
  12) Execute this test case
  13) VP(EB_E2EPJLR020048):
     TS5ATL_RESULT_SUCCESS is returned in 12

   Note:
    If one of the Verification points is violated, then the
    build process is aborted and an error is reported.

 
Test Input: 
 
Test Output: 
 &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06000_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf.c</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that the transformer function returns E_SAFETY_HARD_RUNTIMEERROR when the
  module is not initialized.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  00: Call E2EXf_PartitionDeInit to ensure a non initialized state of the module.
  01: Call the transformer function with valid parameters.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00133.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06001_IOValidParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf.c</sourcefile>
      <sourceline>151</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if the input and output parameters are not valid then the in-place
  function 'E2EXf_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR for profile JLR.
  This test verifies that the output buffer does not change when the transformer is called with
  a NULL_PTR as input data.
  This test verifies that the output buffer does not change when the transformer returns a
  hard error.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  00: Initialize module

  Case 1 part 1
  01: Set buffer to NULL and inputBufferLength different from 0 and call
      transformer function.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

  Case 1 part 2a
  03: Set buffer different from NULL and inputBufferLength equal to 0 (smaller than
      upperHeaderBitsToShift/8, here the lowest erroneous value), and call
      transformer function.
  04: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 1 part 2b
  05: Set buffer different from NULL and inputBufferLength equal to upperHeaderBitsToShift/8-1U
      (smaller than upperHeaderBitsToShift/8, here the highest erroneous value), and call
      transformer function.
  06: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 2
  07: Set bufferLength to NULL and call transformer function.
  08: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00102.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00108.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00051.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06002_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf.c</sourcefile>
      <sourceline>279</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the upper header is copied to the front of
  existing parameter buffer by the in-place function 'E2EXf_transformerId' of profile JLR
  when headerLength is smaller upperHeaderBitsToShift (greater 0).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 24 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Call transformer 'E2EXf_transformerId' with Buffer different from NULL and
      upperHeaderBitsToShift greater 0.
  02: VP: 'E2EXf_transformerId' copied the amount upperHeaderBitsToShift bits,
      in parameter buffer, with starting offset of headerLength, in direction
      left by 'distance' of headerLength.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00108.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>2</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06003_BufLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf.c</sourcefile>
      <sourceline>363</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place transformer 'E2EXf_transformerId' of profile JLR sets the
  BufferLength equal to InputBufferLength plus HeaderLength in bytes.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Call transformer function with valid parameters.
  02: VP: BufferLength holds the sum of InputBufferLength and HeaderLength in bytes.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00111.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06004_InvokeProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf.c</sourcefile>
      <sourceline>419</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place transformer 'E2EXf_transformerId' of profile JLR
  invokes 'E2E_PJLRProtect()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_PJLRProtectInit.

  This test verifies that the mandatory interfaces for a protect transformer are called:
      API function         Description
      E2E_PJLRProtect       Protects the array/buffer to  be transmitted using the E2E profile JLR.
      This includes checksum calculation, handling of counter and Data ID.
      E2E_PJLRProtectInit   Initializes the protection state.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Initialize Buffer with values different to 0U.
  02: Reinitialize module and
      - structure of StatePtr is initialized by E2E_PJLRProtectInit (Counter set to 0U).
  03: Call transformer function with valid parameters.
  04: VP: E2E_PJLRProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.
  05: Set Crc to a defined value.
  06: Call transformer function with valid parameters.
  07: VP: E2E_PJLRProtect() was called, because counter was increased to 1U and set correctly in E2E
          header.
          This verifies indirectly that E2E_PJLRProtect() passes the correct pointer to state by
          StatePtr.
  08: VP: Crc in E2E header is set to value previously set in test.
          This verifies indirectly that E2E_PJLRProtect() passes the correct pointer to data by
          DataPtr.
  09: Reinitialize module with respective transformer and
      - structure of StatePtr is initialized by E2E_PJLRProtectInit (Counter set to 0U).
  10: Call transformer function with valid parameters.
  11: VP: E2E_PJLRProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00107.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00021.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06005_RetValProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf.c</sourcefile>
      <sourceline>556</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if E2E_PJLRProtect() returns E2E_E_OK then the
  in-place transformer 'E2EXf_transformerId' for profile JLR returns E_OK,
  otherwise it returns E_SAFETY_HARD_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Reinitialize module.
  02: Call transformer function with valid parameters.
  03: VP: The call was successful and 'E2EXf_transformerId' returns E_OK

  04: Make E2E_PJLRProtect() return E2E_E_INPUTERR_NULL by calling internal API that is wrapped
      by transformer API with StatePtr set to NULL_PTR. Note: StatePtr is only checked in
      E2E_PJLRProtect function.
  05: VP: The call was successful and 'E2EXf_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00018.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06100_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>187</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that the transformer function returns E_SAFETY_HARD_RUNTIMEERROR when the
  module is not initialized.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  00: Call E2EXf_PartitionDeInit to ensure a non initialized state of the module.
  01: Call the transformer function with valid parameters.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00133.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06101_IOValidParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>242</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if the input and output parameters are not valid then the in-place
  function 'E2EXf_Inv_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR for profile JLR.
  This test verifies that the output buffer does not change when the transformer is called with
  a NULL_PTR as input data.
  This test verifies that the output buffer does not change when the transformer returns a
  hard error.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  00: Initialize module

  Case 1 part 1
  01: Set buffer to NULL and inputBufferLength different from 0 and call
      inverted transformer function.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

  Case 1 part 2a
  03: Set buffer different from NULL and inputBufferLength equal to 0U (smaller than
      headerLength/8U + upperHeaderBitsToShift/8U, here the lowest
      erroneous value), and call inverted transformer function.
  04: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 1 part 2b
  05: Set buffer different from NULL and inputBufferLength equal to
      ((headerLength/8U + upperHeaderBitsToShift/8U) - 1U)
      (smaller than headerLength/8U + upperHeaderBitsToShift/8U,
      here the highest erroneous value), and call inverted transformer function.
  06: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 2
  07: Set bufferLength to NULL and call inverted transformer function.
  08: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00105.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00108.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00051.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06102_InvokeCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>369</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR invokes 'E2E_PJLRCheck()' with proper parameters.

  This test verifies that state structures are initialized correctly by E2E_PJLRCheckInit.

  This test verifies that E2E_PJLRCheck uses correct configuration provided by the initialization.

  This test verifies that the mandatory interfaces for a check transformer are called:
      API function         Description
      E2E_PJLRCheck         Checks the Data received using the E2E profile JLR. This includes CRC
                           calculation, handling of Counter and Data ID.
      E2E_PJLRCheckInit     Initializes the check state
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Set Buffer to defined values.
  02: Deinitialize module.
  03: VP: Transformer is deinitialized.
  04: Initialize module.
  05: - Set E2E header to correct values (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  06: VP: E2E_PJLRCheck() returns E2E_P_OK (indirectly checked, RetVal is provided to E2ESM stub).
          Verifies that state structures are initialized correctly.

  07: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  08: VP: E2E_PJLRCheck() returns E2E_P_OK.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.

  09: - Set E2E header to values simulating repeated message (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  10: VP: E2E_PJLRCheck() returns E2E_P_REPEATED.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.

  11: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  12: VP: E2E_PJLRCheck() returns E2E_P_OK.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.
          Verifies that correct state structure is used.

  13: - Set E2E header to correct values (Counter = 3U) except Crc is set to an incorrect value.
      - Call inverted transformer function with valid parameters.
  14: VP: E2E_PJLRCheck() returns E2E_P_ERROR.
          Verifies that E2E_PJLRCheck() uses correct configuration because incorrect Crc was
          detected.
  15: Initialize module with respective transformer.
  16: - Set E2E header to correct values (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  17: VP: E2E_PJLRCheck() returns E2E_P_OK (indirectly checked, RetVal is provided to E2ESM stub).
          Verifies that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00104.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00021.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06103_InvokeMapStatusToSM</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>572</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR with configuration parameter profileBehavior set to R4_2 invokes
  'E2E_PJLRMapStatusToSM()' with proper parameters.

  This test verifies that the mandatory interfaces for a check transformer are called:
      E2E_PJLRMapStatusToSM The function maps the check status of profile JLR to a generic check
                           status, which can be used by E2E state machine check function. The E2E
                           profile JLR delivers a more fine-granular status, but this is not relevant
                           for the E2E state machine.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Reinitialize module
  02: - Set E2E header to correct values (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  03: VP: Inverted transformer function returns E_OK.
          Ensures that states are correct.
  04: - Set E2E header to values simulating repeated message (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  05: VP: E2E_PJLRMapStatusToSM() is called. Verified by checking the return value of
          E2E_PJLRMapStatusToSM() which is passed to E2ESM stub. It is expected to be E2E_P_REPEATED.
          Verifies that E2E_PJLRMapStatusToSM() passes the Status provided by initialization.
  06: - Set E2E header to values provoking E2E_PJLRSTATUS_WRONGSEQUENCE, i.e. set Counter to a value
        larger than ConfigPtr-&gt;MaxDeltaCounter.
      - Call inverted transformer function with valid parameters.
  07: VP: E2E_PJLRCheck() returns E2E_PJLRSTATUS_WRONGSEQUENCE.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00029.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06104_InvokeSMCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>675</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR invokes 'E2E_SMCheck()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_SMCheckInit.

  This test verifies that the mandatory interfaces for a check transformer are called:
      E2E_SMCheck          Checks the communication channel. It determines if the data can be used
                           for safety-related application, based on history of checks performed by
                           a corresponding E2E_P0XCheck() function.
      E2E_SMCheckInit      Initializes the state machine.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Reinitialize module
  02: VP: Init functions are called.
  03: Set E2E header to correct values
  04: Call inverted transformer function with valid parameters.
  05: VP: E2E_SMCheck() is called.
  06: VP: E2E_SMCheck() passes the correct ProfileStatus
      (the returned value of E2E_PJLRMapStatusToSM).
  07: VP: E2E_SMCheck() points through ConfigPtr to the static SM configuration
      (provided by initialization module via E2E_SMCheckInit).
  08: VP: E2E_SMCheck() passes the correct pointer to state by StatePtr and state structures
      are initialized correctly (verified within callout).

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00028.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00021.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06105_SMCheckRetVal</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>784</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR returns E2E_E_OK after a 'E2E_SMCheck()' call, then:
  - the high nibble of the return will be set to the low nibble of the state
    of the state machine (member SMState of object of type E2E_SMStateType that
    is associated with 'transformerId');
  - the low nibble of the return will be set to the low nibble of the profile-independent
    check status of type E2E_PCheckStatusType;
  otherwise the return of the 'E2E_SMCheck()' call is E_SAFETY_SOFT_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Initialize SMState of StatePtr and return a value equal to E2E_E_OK by E2E_SMCheck.
  02: Call inverted transformer function with valid parameters.
  03: VP: The high nibble of the returned value of E2EXf_Inv_'transformerId' function is
      set to the low nibble of the state of the state machine.
  04: VP: The low nibble of the returned value of E2EXf_Inv_'transformerId' function is
      set to the low nibble of the profile-independent check status of type E2E_PCheckStatusType.

  05: Return a value different to E2E_E_OK by E2E_SMCheck.
  06: VP: E2E_SMCheck() returns E_SAFETY_SOFT_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00027.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06106_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the upper header is copied to the front of existing parameter
  buffer by the in-place function 'E2EXf_Inv_transformerId' of profile JLR when
  when headerLength is smaller upperHeaderBitsToShift (greater 0).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Reinitialize module.
  02: Set E2E header to correct values.
  03: Call inverted transformer function with inputBuffer different from NULL and
      upperHeaderBitsToShift greater 0.
  04: VP: 'E2EXf_Inv_transformerId' copied the amount upperHeaderBitsToShift bits,
      in parameter buffer, with starting offset of headerLength, in direction right by
      'distance' of headerLength.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00112.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_06107_BufLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf/source/application/E2EPJLR_ConTest_06_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>956</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR sets the BufferLength equal to InputBufferLength minus HeaderLength in bytes.
  Additionally it is verified that BufferLength is set to zero in the case that no new data
  is available (InputBufferLength == 0 and Buffer == NULL).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
    - headerLength: 16 bits
    - upperHeaderBitsToShift: 64 bits
  E2EXf_Inv_PJLR_InP_SomeIpXf_Rx1:
    - dataLength: 176 bits
  E2EXf_Inv_PJLR_InP_SomeIpXf_Rx2:
    - dataLength: 80 bits

Test Execution: 
  01: Reinitialize module

  Case 1 (InputBufferLength equals minimum buffer size given by the sum of upperHeader size and
  the upperHeaderBitsToShift size)
  02: Set InputBufferLength value to the sum of headerLength and upperHeaderBitsToShift.
      Set E2E header to correct values.
  03: Call inverted transformer function with valid parameters.
      (E2EXf_Inv_PJLR_InP_SomeIpXf_Rx2 because length is compared with InputBufferLength in
       E2E_PJLRCheck function, see precondition)
  04: VP: BufferLength holds the correct value given by the subtraction of
      E2E transformer HeaderLength in bytes from InputBufferLength.

  Case 2 (InputBufferLength equals maximum buffer size given by the size of Buffer)
  05: Set InputBufferLength to the size of Buffer.
      Set E2E header to correct values.
  06: Call inverted transformer function with valid parameters.
  07: VP: BufferLength holds the correct value given by the subtraction of HeaderLength in bytes
      from InputBufferLength.

  Case 3 (No new data available: InputBufferLength equals zero and Buffer equals NULL)
  08: Set InputBufferLength to 0.
      Set E2E header to correct values.
  09: Call inverted transformer function with Buffer set to NULL.
  10: VP: BufferLength is 0.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00114.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07000_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf.c</sourcefile>
      <sourceline>94</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that the transformer function returns E_SAFETY_HARD_RUNTIMEERROR when the
  module is not initialized.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  00: Call E2EXf_PartitionDeInit to ensure a non initialized state of the module.
  01: Call the transformer function with valid parameters.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00133.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07001_IOValidParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf.c</sourcefile>
      <sourceline>153</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if the input and output parameters are not valid then the out-of-place
  function 'E2EXf_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR for profile JLR.
  This test verifies that the output buffer does not change when the transformer is called with
  a NULL_PTR as input data.
  This test verifies that the output buffer does not change when the transformer returns a
  hard error.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  00: Initialize module

  Case 1 part 1
  01: Set inputBuffer to NULL and inputBufferLength different from 0 and call
      transformer function.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 1 part 2a
  03: Set inputBuffer different from NULL and inputBufferLength equal to 0 (smaller than
      upperHeaderBitsToShift/8, here the lowest erroneous value), and call
      transformer function.
  04: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 1 part 2b
  05: Set inputBuffer different from NULL and inputBufferLength equal to upperHeaderBitsToShift/8-1U
      (smaller than upperHeaderBitsToShift/8, here the highest erroneous value), and call
      transformer function.
  06: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 2
  07: Set bufferLength to NULL and call transformer function.
  08: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 3
  09: Set buffer equal to NULL and call transformer function.
  10: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00106.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00133.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00108.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00051.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07002_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf.c</sourcefile>
      <sourceline>310</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that for valid parameters (inputBuffer is not NULL and headerLength is smaller
  upperHeaderBitsToShift (greater 0), out-of-place transformer 'E2EXf_transformerId' for profile JLR
  does the following:
  - the upper header is copied to the beginning of the output buffer
  - the payload is copied to the output buffer starting with the destination offset of
    upperHeaderBitsToShift plus headerLength.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 24 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Call transformer 'E2EXf_transformerId' with inputBuffer different from NULL and
      upperHeaderBitsToShift greater 0.
  02: VP: The function copies the first upperHeaderBitsToShift bits from
      inputBuffer to buffer, and then copies the remaining part of inputBuffer
      (i.e. starting with offset upperHeaderBitsToShift) to parameter buffer starting with
      the destination offset of upperHeaderBitsToShift plus headerLength.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00109.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07003_BufLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf.c</sourcefile>
      <sourceline>396</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place transformer 'E2EXf_transformerId' of profile JLR sets the
  BufferLength equal to InputBufferLength plus HeaderLength in bytes.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Call transformer function with valid parameters.
  02: VP: BufferLength holds the sum of InputBufferLength and HeaderLength in bytes.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00111.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07004_InvokeProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf.c</sourcefile>
      <sourceline>457</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place transformer 'E2EXf_transformerId' of profile JLR
  invokes 'E2E_PJLRProtect()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_PJLRProtectInit.

  This test verifies implicitly that the mandatory interfaces for a protect transformer are called:
      API function         Description
      E2E_PJLRProtect       Protects the array/buffer to  be transmitted using the E2E profile JLR.
                           This includes checksum calculation, handling of counter and Data ID.
      E2E_PJLRProtectInit   Initializes the protection state.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Initialize Buffer with values different to 0U.
  02: Reinitialize module and
      - structure of StatePtr is initialized by E2E_PJLRProtectInit (Counter set to 0U).
  03: Call transformer function with valid parameters.
  04: VP: E2E_PJLRProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.
  05: Set Crc to a defined value.
  06: Call transformer function with valid parameters.
  07: VP: E2E_PJLRProtect() was called, because counter was increased to 1U and set correctly in E2E
          header.
          This verifies indirectly that E2E_PJLRProtect() passes the correct pointer to state by
          StatePtr.
  08: VP: Crc in E2E header is set to value previously set in test.
          This verifies indirectly that E2E_PJLRProtect() passes the correct pointer to data by
          DataPtr.
  09: Reinitialize module with respective transformer and
      - structure of StatePtr is initialized by E2E_PJLRProtectInit (Counter set to 0U).
  10: Call transformer function with valid parameters.
  11: VP: E2E_PJLRProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00107.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00021.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07005_RetValProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf.c</sourcefile>
      <sourceline>604</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if E2E_PJLRProtect() returns E2E_E_OK then
  out-of-place transformer 'E2EXf_transformerId' for profile JLR returns E_OK,
  otherwise it returns E_SAFETY_HARD_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Reinitialize module.
  02: Call transformer function with valid parameters.
  03: VP: The call was successful and 'E2EXf_transformerId' returns E_OK

  04: Make E2E_PJLRProtect() return E2E_E_INPUTERR_NULL by calling internal API that is wrapped
      by transformer API with StatePtr set to NULL_PTR. Note: StatePtr is only checked in
      E2E_PJLRProtect function.
  05: VP: The call was successful and 'E2EXf_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00018.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07100_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>187</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that the transformer function returns E_SAFETY_HARD_RUNTIMEERROR when the
  module is not initialized.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  00: Call E2EXf_PartitionDeInit to ensure a non initialized state of the module.
  01: Call the transformer function with valid parameters.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00133.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07101_IOValidParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>247</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if the input and output parameters are not valid then the out-of-place
  function 'E2EXf_Inv_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR for profile JLR.
  This test verifies that the output buffer does not change when the transformer is called with
  a NULL_PTR as input data.
  This test verifies that the output buffer does not change when the transformer returns a
  hard error.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  00: Initialize module

  Case 1 part 1
  01: Set inputBuffer to NULL and inputBufferLength different from 0 and call
      inverted transformer function.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 1 part 2a
  03: Set inputBuffer different from NULL and inputBufferLength equal to 0U (smaller than
      headerLength/8U + upperHeaderBitsToShift/8U, here the lowest
      erroneous value), and call inverted transformer function.
  04: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 1 part 2b
  05: Set inputBuffer different from NULL and inputBufferLength equal to
      ((headerLength/8U + upperHeaderBitsToShift/8U) - 1U)
      (smaller than headerLength/8U + upperHeaderBitsToShift/8U,
      here the highest erroneous value), and call inverted transformer function.
  06: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 2
  07: Set bufferLength to NULL and call inverted transformer function.
  08: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 3
  09: Set buffer equal to NULL and call inverted transformer function.
  10: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00103.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00108.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00051.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07102_InvokeCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>400</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR invokes 'E2E_PJLRCheck()' with proper parameters.

  This test verifies that state structures are initialized correctly by E2E_PJLRCheckInit.

  This test verifies that E2E_PJLRCheck uses correct configuration provided by the initialization.

  This test verifies that the mandatory interfaces for a check transformer are called:
      API function         Description
      E2E_PJLRCheck         Checks the Data received using the E2E profile JLR. This includes CRC
                           calculation, handling of Counter and Data ID.
      E2E_PJLRCheckInit     Initializes the check state
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Deinitialize module.
  02: VP: Transformer is deinitialized.
  03: Initialize module.
  04: - Set E2E header to correct values (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  05: VP: E2E_PJLRCheck() returns E2E_P_OK (indirectly checked, RetVal is provided to E2ESM stub).
          Verifies that state structures are initialized correctly.

  06: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  07: VP: E2E_PJLRCheck() returns E2E_P_OK.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.

  08: - Set E2E header to values simulating repeated message (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  09: VP: E2E_PJLRCheck() returns E2E_P_REPEATED.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.

  10: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  11: VP: E2E_PJLRCheck() returns E2E_P_OK.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.
          Verifies that correct state structure is used.

  12: - Set E2E header to correct values (Counter = 3U) except Crc is set to an incorrect value.
      - Call inverted transformer function with valid parameters.
  13: VP: E2E_PJLRCheck() returns E2E_P_ERROR.
          Verifies that E2E_PJLRCheck() uses correct configuration because incorrect Crc was
          detected.
  14: Initialize module with respective transformer.
  15: - Set E2E header to correct values (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  16: VP: E2E_PJLRCheck() returns E2E_P_OK (indirectly checked, RetVal is provided to E2ESM stub).
          Verifies that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00104.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00021.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07103_InvokeMapStatusToSM</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>604</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR with configuration parameter profileBehavior set to R4_2 invokes
  'E2E_PJLRMapStatusToSM()' with proper parameters.

  This test verifies that the mandatory interfaces for a check transformer are called:
      E2E_PJLRMapStatusToSM The function maps the check status of profile JLR to a generic check
                           status, which can be used by E2E state machine check function. The E2E
                           profile JLR delivers a more fine-granular status, but this is not relevant
                           for the E2E state machine.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Reinitialize module
  02: - Set E2E header to correct values (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  03: VP: Inverted transformer function returns E_OK.
          Ensures that states are correct.
  04: - Set E2E header to values simulating repeated message (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  05: VP: E2E_PJLRMapStatusToSM() is called. Verified by checking the return value of
          E2E_PJLRMapStatusToSM() which is passed to E2ESM stub. It is expected to be E2E_P_REPEATED.
          Verifies that E2E_PJLRMapStatusToSM() passes the Status provided by initialization.
  06: - Set E2E header to values provoking E2E_PJLRSTATUS_WRONGSEQUENCE, i.e. set Counter to a value
        larger than ConfigPtr-&gt;MaxDeltaCounter.
      - Call inverted transformer function with valid parameters.
  07: VP: E2E_PJLRCheck() returns E2E_PJLRSTATUS_WRONGSEQUENCE.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00029.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07104_InvokeSMCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>714</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR invokes 'E2E_SMCheck()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_SMCheckInit.

  This test verifies that the mandatory interfaces for a check transformer are called:
      E2E_SMCheck          Checks the communication channel. It determines if the data can be used
                           for safety-related application, based on history of checks performed by
                           a corresponding E2E_P0XCheck() function.
      E2E_SMCheckInit      Initializes the state machine.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Reinitialize module
  02: VP: Init functions are called.
  03: Set E2E header to correct values
  04: Call inverted transformer function with valid parameters.
  05: VP: E2E_SMCheck() is called.
  06: VP: E2E_SMCheck() passes the correct ProfileStatus
      (the returned value of E2E_PJLRMapStatusToSM).
  07: VP: E2E_SMCheck() points through ConfigPtr to the static SM configuration
      (provided by initialization module via E2E_SMCheckInit).
  08: VP: E2E_SMCheck() passes the correct pointer to state by StatePtr and state structures
      are initialized correctly (verified within callout).

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00028.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.EB.SWS_E2EXf_00021.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07105_SMCheckRetVal</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>828</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR returns E2E_E_OK after a 'E2E_SMCheck()' call, then:
  - the high nibble of the return will be set to the low nibble of the state
    of the state machine (member SMState of object of type E2E_SMStateType that
    is associated with 'transformerId');
  - the low nibble of the return will be set to the low nibble of the profile-independent
    check status of type E2E_PCheckStatusType;
  otherwise the return of the 'E2E_SMCheck()' call is E_SAFETY_SOFT_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Initialize SMState of StatePtr and return a value equal to E2E_E_OK by E2E_SMCheck.
  02: Call inverted transformer function with valid parameters.
  03: VP: The high nibble of the returned value of E2EXf_Inv_'transformerId' function is
      set to the low nibble of the state of the state machine.
  04: VP: The low nibble of the returned value of E2EXf_Inv_'transformerId' function is
      set to the low nibble of the profile-independent check status of type E2E_PCheckStatusType.

  05: Return a value different to E2E_E_OK by E2E_SMCheck.
  06: VP: E2E_SMCheck() returns E_SAFETY_SOFT_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00027.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07106_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>920</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that for valid parameters (inputBuffer is not NULL and headerLength is smaller
  upperHeaderBitsToShift (greater 0), out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  for profile JLR does the following:
  - the upper header is copied to the beginning of the output buffer
  - the payload is copied to the output buffer starting with the destination offset of
  (upperHeaderBitsToShift + headerLength).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Reinitialize module.
  02: Set E2E header to correct values.
  03: Call inverted transformer function with inputBuffer different from NULL and
      upperHeaderBitsToShift greater 0.
  04: VP: 'E2EXf_Inv_transformerId' copied the amount upperHeaderBitsToShift bits,
      in parameter buffer, with starting offset of headerLength, in direction right by
      'distance' of headerLength.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00113.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_07107_BufLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf/source/application/E2EPJLR_ConTest_07_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>1010</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR sets the BufferLength equal to InputBufferLength minus HeaderLength in bytes.
  Additionally it is verified that BufferLength is set to zero in the case that no new data
  is available (InputBufferLength == 0 and InputBuffer == NULL).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
    - headerLength: 16 bits
    - upperHeaderBitsToShift: 64 bits
  E2EXf_Inv_PJLR_InP_SomeIpXf_Rx1:
    - dataLength: 176 bits
  E2EXf_Inv_PJLR_InP_SomeIpXf_Rx2:
    - dataLength: 80 bits

Test Execution: 
  01: Reinitialize module

  Case 1 (InputBufferLength equals minimum buffer size given by the sum of upperHeader size and
  the upperHeaderBitsToShift size)
  02: Set InputBufferLength value to the sum of headerLength and upperHeaderBitsToShift.
      Set E2E header to correct values.
  03: Call inverted transformer function with valid parameters.
      (E2EXf_Inv_PJLR_InP_SomeIpXf_Rx2 because length is compared with InputBufferLength in
       E2E_PJLRCheck function, see precondition)
  04: VP: BufferLength holds the correct value given by the subtraction of
      E2E transformer HeaderLength in bytes from InputBufferLength.

  Case 2 (InputBufferLength equals maximum buffer size given by the size of Buffer)
  05: Set InputBufferLength to the size of Buffer.
      Set E2E header to correct values.
  06: Call inverted transformer function with valid parameters.
  07: VP: BufferLength holds the correct value given by the subtraction of HeaderLength in bytes
      from InputBufferLength.

  Case 3 (No new data available: InputBufferLength equals zero and Buffer equals NULL)
  08: Set InputBufferLength to 0.
      Set E2E header to correct values.
  09: Call inverted transformer function with Buffer set to NULL.
  10: VP: BufferLength is 0.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00114.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_08000_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPJLR_ConTest_08_E2EXf_OoP_ComXf.c</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if (inputBuffer is not NULL and upperHeaderBitsToShift is equal to 0),
  out-of-place transformer 'E2EXf_transformerId' of profile JLR copies inputBuffer to buffer
  starting with the destination offset of headerLength.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  ----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  ----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize E2EXf module
  01: Set inputBuffer different from NULL and upperHeaderBitsToShift equal to 0 and call
      out-of-place transformer function.
  02: VP: The function copies the inputBuffer to buffer starting with the destination offset of
      headerLength.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00115.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_08100_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPJLR_ConTest_08_E2EXf_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if (inputBuffer is not NULL and upperHeaderBitsToShift is equal to 0),
  out-of-place inverted transformer 'E2EXf_Inv_transformerId' of profile JLR copies inputBuffer to
  buffer starting with the destination offset of headerLength.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  ----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  ----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Reinitialize module.
  02: Set E2E header to correct values.
  03: Call inverted transformer function with inputBuffer different from NULL.
  04: VP: The function copies the inputBuffer to buffer starting with the destination offset of
      headerLength.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00116.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_09000_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_09_E2EXf_InP_ComXf/source/application/E2EPJLR_ConTest_09_E2EXf_InP_ComXf.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if (inputBuffer is not NULL and upperHeaderBitsToShift is equal to 0),
  in-place transformer 'E2EXf_transformerId' of profile JLR keeps buffer unchanged.

  This test also verifies the imported types of PJLR
    - E2E_PJLRCheckStateType
    - E2E_PJLRCheckStatusType
    - E2E_PJLRConfigType
    - E2E_PJLRProtectStateType
    - E2E_PCheckStatusType
    - E2E_SMCheckStateType
    - E2E_SMConfigType

    Std_Types:
    - Std_ReturnType
    - Std_VersionInfoType
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  ----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  ----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize E2EXf module
  01: Set Buffer different from NULL and upperHeaderBitsToShift equal to 0 and call
      transformer function.
  02: VP: After E2E header the function keeps buffer unchanged.
  03: VP:(E2EPJLR.SWS_E2EXf_00047.PJLR) Instances of the imported types are defined for:
             E2E_PJLRCheckStateType      E2E_PJLRCheckState
             E2E_PJLRCheckStatusType     E2E_PJLRCheckStatus
             E2E_PJLRConfigType          E2E_PJLRConfig
             E2E_PJLRProtectStateType    E2E_PJLRProtectState
             E2E_PCheckStatusType        E2E_PCheckStatus
             E2E_SMCheckStateType        E2E_SMCheckState
             E2E_SMConfigType            E2E_SMConfig
             Std_ReturnType              Std_Return
             Std_VersionInfoType         Std_VersionInfo
  04: VP: Successful compilation of E2E transformer using configuration specified above.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.EB.Transformer.InPlace.NoCopying.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00047.PJLR</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_09100_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_09_E2EXf_InP_ComXf/source/application/E2EPJLR_ConTest_09_E2EXf_InP_ComXf_Inv.c</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if (inputBuffer is not NULL and upperHeaderBitsToShift is equal to 0),
  in-place inverted transformer 'E2EXf_Inv_transformerId' of profile JLR keeps buffer unchanged.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  ----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  ----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Reinitialize module.
  02: Set E2E header to correct values.
  03: Call inverted transformer function with inputBuffer different from NULL.
  04: VP: The function keeps the buffer unchanged.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.EB.InvTransformer.InPlace.NoCopying.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_ConTest_10_PJLRForward</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_10_PJLRForward/source/application/E2EPJLR_ConTest_10_PJLRForward.c</sourcefile>
      <sourceline>632</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 

  &lt;para&gt;
  The aspects stated below are done on valid input data only.

  1) (EB_E2EPJLR020587,EB_E2EPJLR020630)
    Test that E2E_PJLRForward()
    a) writes the Counter in the Data at the Counter position specified
       in the State data,
    b) writes DataID Nibble in Data (if E2E_PJLR_DATAID_NIBBLE is used) at the Nibble
       position specified in the configuration data,
    c) computes the CRC over DataID (depending on DataID mode - see
       test aspects 5), 6), and 7)) and Data,
    d) writes the CRC in the Data at the CRC position provided in the configuration data, and
    e) increments the Counter in the State data.

  2) (EB_E2EPJLR020504)
     Test that E2E_PJLRForward() increments the passed State Counter
     value by 1 up to 15, and then restarts with 0 again.

  3) (EB_E2EPJLR020508)
     Test that E2E_PJLRForward() calls the SCrc_CalculateCRC8() function

  4) (EB_E2EPJLR020634)
     Test that E2E_PJLRForward() uses CRC-8-SAE J1850 with 0xFFU as start value for the calculation of
     the CRC (That is,  SCrc_CalculateCRC8() is called with StartValue8=0xFFU).

  5) (EB_E2EPJLR020505)(EB_E2EPJLR020583)
     Test that for DataId inclusion Mode E2E_PJLR_DATAID_BOTH,
     first low byte and then high byte of the DataID are included in the CRC calculation
     step regarding the DataID.

  6) (EB_E2EPJLR020506)(EB_E2EPJLR020583)
     Test that for DataID inclusion Mode E2E_PJLR_DATAID_NIBBLE,
     the low Nibble of the high byte of the DataID is written to the
     Data(covered by CRC calculation when computing CRC over Data). The high nibble of the
     high byte is left out. The low byte of the DataID is then included in the CRC calculation.
     The high byte is treated as 0.
  &lt;/para&gt;

  &lt;para&gt;
  Test strategies applied:
     Equivalence Class Partitioning:
       Test execution is done with a permutation of following parameters
          - E2E_PJLRProtectStateType.Counter
          - E2E_PJLRConfigType.CounterOffset
          - E2E_PJLRConfigType.CRCOffset
          - E2E_PJLRConfigType.DataIDNibbleOffset
          - E2E_PJLRConfigType.DataIDMode
          - E2E_PJLRConfigType.DataLength
          - E2E_PJLRConfigType.DataID
        Note: The following parameters are not used at sender side and therefore not relevant:
           - MaxDeltaCounter

     Pair wise tests: Tests are executed with a  combination of following parameters / values
          - DataIDMode
          - CRCOffset
          - CounterOffset
          - DataIDNibbleOffset (only relevant for E2E_PJLR_DATAID_NIBBLE)

     Boundary Value Analysis in combination
     with test-case E2EPJLR_ConTest_10_PJLRForward_InvalidInput (outside bound):
        DataIdMode: [E2E_PJLR_DATAID_BOTH, E2E_PJLR_DATAID_NIBBLE]
        DataLength: MIN=2, MAX=30
        Counter: MIN=0, MAX=15; (First Byte, Last Byte, in between Data)
        DataId: MIN=0, MAX=0xFFFF (E2E_PJLR_DATAID_BOTH)
                       MAX=0x0FFF (E2E_PJLR_DATAID_NIBBLE)
        DataIDNibbleOffset: MIN=12, MAX=DataLength+4 (low nibble and high nibble)
        CounterOffset: MIN=0, MAX=DataLength+4
        CRCOffset: MIN=0, MAX=DataLength
  &lt;/para&gt;


Test Object: None.
Test Precondition: None.
Test Execution: 

 010: Prepare CRC stub (SCrc_CalculateCRC8) to return the number of overall Stub calls.

For each stated TestDataBlock (InputTstCfg), execute the following steps:
 020: call the E2E_Forward function with following parameters:
      - Parameter Config points to following test-data
          Config.DataIDMode       = InputTstCfg.DataIDMode
          Config.DataID           = InputTstCfg.DataID
          Config.DataIDNibbleOffset = InputTstCfg.DataIDNibbleOffset
          Config.CRCOffset        = InputTstCfg.CRCOffset
          Config.CounterOffset    = InputTstCfg.CounterOffset
          Config.DataLength       = InputTstCfg.DataLength
          Config.TstData          = InputTstCfg.TstData
       - Parameter State points to following input data
          State.Counter           = InputTstCfg.Counter
       - Parameter Data points to valid input data
 030: VP (ASR_E2EPJLR020575):
     E2E_Forward function returns E2E_E_OK
 040: VP (EB_E2EPJLR020504,ASR_E2EPJLR020575,ASR_E2EPJLR020509)
     State.Counter is updated as follows:
         If InputTstCfg.Counter==MAX(15) =&gt; State.Counter=0
         If InputTstCfg.Counter &lt; MAX(15) =&gt; State.Counter=InputTstCfg.Counter+1
 050: VP (ASR_E2EPJLR020575,ASR_E2EPJLR020509)
     TestData at position Config.CounterOffset (4 bits) equals InputTstCfg.Counter
 060: VP (ASR_E2EPJLR020575,ASR_E2EPJLR020509)
     If Config.DataIDMode=E2E_PJLR_DATAID_NIBBLE =&gt;
       TestData at position Config.DataIDNibbleOffset (4 bits) equals
       the low Nibble of the high byte of Config.DataID
 070: VP (ASR_E2EPJLR020575,ASR_E2EPJLR020509)
     TestData at position Config.CRCOffset (8 bits) equals
     the number of overall calls to the SCrc_CalculateCRC8 CRC stub
 080: VP (ASR_E2EPJLR020575,EB_E2EPJLR020508,ASR_E2EPJLR020513,EB_E2EPJLR020505
          ASR_E2EPJLR020509)
      Number of SCrc_CalculateCRC8 CRC stub calls equals n where:

         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_BOTH
            and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3
         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_BOTH
           and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4
         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE
           and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3
         IF InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4
 090: VP (ASR_E2EPJLR020509,ASR_E2EPJLR020511,ASR_E2EPJLR020512,ASR_E2EPJLR020513,EB_E2EPJLR020514,)
        No other data except CRC / Counter and DataId Nibble is modified in TestData
 100: VP (ASR_E2EPJLR020575,EB_E2EPJLR020508,ASR_E2EPJLR020513,EB_E2EPJLR020505
          ASR_E2EPJLR020509)
      1st call to SCrc_CalculateCRC8 CRC stub in this test iteration:
        - SCrc_DataPtr points to a value that equals the low byte of InputTstCfg.DataID
        - SCrc_Length equals 1
        - SCrc_StartValue8 equals 0x0U
        - SCrc_IsFirstCall equals FALSE
 110: VP (ASR_E2EPJLR020575,EB_E2EPJLR020508,ASR_E2EPJLR020513,EB_E2EPJLR020505
          ASR_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on DataIdMode):
        If InputTstCfg.DataIDMode==E2E_PJLR_DATAID_BOTH:
         - SCrc_DataPtr points to a value that equals the high byte of InputTstCfg.DataID
         - SCrc_Length equals 1
         - SCrc_StartValue8 equals the SCrc return value from the previous stub call
         - SCrc_IsFirstCall equals FALSE
       If InputTstCfg.DataIDMode==E2E_PJLR_DATAID_NIBBLE:
         - SCrc_DataPtr points to a value 0
         - SCrc_Length equals 1
         - SCrc_StartValue8 equals the SCrc return value from the previous stub call
         - SCrc_IsFirstCall equals FALSE
 120: VP (ASR_E2EPJLR020575,EB_E2EPJLR020508,ASR_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020506,ASR_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
       if InputTstCfg.CRCOffset is first byte in TestData
          - SCrc_DataPtr points to 2nd byte of the data passed to E2E_Forward
          - SCrc_Length equals Config.DataLength-1
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE
       if InputTstCfg.CRCOffset is not first byte in TestData
          - SCrc_DataPtr points to 1st byte of the data passed to E2E_Forward
          - SCrc_Length equals Config.CRCOffset / 8 (excludes CRC value)
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE
 130: VP (ASR_E2EPJLR020575,EB_E2EPJLR020508,ASR_E2EPJLR020513,EB_E2EPJLR020505
          EB_E2EPJLR020506,ASR_E2EPJLR020509)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
       if InputTstCfg.CRCOffset is not first byte and not last byte
          - SCrc_DataPtr points to 1st byte after CRC byte in the TestData
          - SCrc_Length equals Config.DataLength-(Config.CRCOffset/8) (Data after CRC byte)
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls)
          - SCrc_IsFirstCall equals FALSE


Test Input: 

Note: MAX ... maximum possible counter value =  15

TestDataBlock 1 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_BOTH
  - CRC at first Byte
  - Counter at second Byte
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                   { 1 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different size and values)

TestDataBlock 2 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_BOTH
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             16
InputTstCfg.CounterOffset:         28
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                   { 0, 1, 2, 0, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different size and values)

TestDataBlock 3 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_BOTH
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         52
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                   { 6 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different values)


TestDataBlock 4 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC at first Byte
  - Counter at second Byte
  - DataID Nibble at bit position 12 (High Nibble)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    12
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                   { 1 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different size and values)

TestDataBlock 5 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  - DataID Nibble at bit position 32  (Low Nibble)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    32
InputTstCfg.CRCOffset:             16
InputTstCfg.CounterOffset:         28
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                      { 5 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different size and values)

TestDataBlock 6 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  - DataID Nibble at bit position 8 (Low Nibble)
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    8
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         52
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                   { 6 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different values)

TestDataBlock 7 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC at first Byte
  - Counter at second Byte
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    12
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                   { 5, 0, 5, 5, 5 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different size and values)

TestDataBlock 8 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  - DataIDNibble in first byte in low nibble
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             8
InputTstCfg.CounterOffset:         12
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                   { 8, MAX, 2, 0, MAX }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different size and values)

TestDataBlock 9 test aspects:
=============================
  - DataIDMode E2E_PJLR_DATAID_NIBBLE
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  -- DataIDNibble in the third byte as low nibble
InputTstCfg.DataIDMode:            E2E_PJLR_DATAID_NIBBLE
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
InputTstCfg.DataIDNibbleOffset:    16
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         44
InputTstCfg.Counter:               State Counter provided as input for E2EPJLR_Forward
                                   { 0, 1, 2, 0, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPJLR_Forward (different values)


Test Output: 
  return value for all tests shall be E2E_E_OK
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020673</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020587</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020630</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020504</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020508</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020634</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020583</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        
        <provcov>
          <linksto>EB_E2EPJLR020632</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020633</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020514</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020515</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_10_PJLRForward_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_10_PJLRForward/source/application/E2EPJLR_ConTest_10_PJLRForward.c</sourcefile>
      <sourceline>1146</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

    1) Check that the E2E-library function E2E_PJLRForward()
       returns the error codes E2E_E_INPUTERR_NULL if:
    - NULL_PTR is passed for configuration data / state data / data to be forwarded

    2) Check that the E2E-library function E2E_PJLRForward()
       returns the error codes E2E_E_INPUTERR_WRONG if:
    - invalid counter values in state data (maximum value exceeded)
    - invalid data length (not a multiple of 8, maximum value exceeded, value smaller than 16)
    - invalid crc offsets (greater than data length)
    - invalid counter offset (greater than data length + 4)
    - invalid DataIDNibbleOffset in case of DataID mode not equal to E2E_PJLR_DATAID_NIBBLE (!=0)

    See also in the SWS section 7.2.1 Error classification
    (End-to-End Communication Protection Library R22-11).

&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 
    The input/output parameter(s) shall hold the following
    value(s) for calling E2E_PJLRForward():
    01: set configuration to NULL
    02: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_NULL
    03: set sender state to NULL
    04: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_NULL
    05: set data to NULL
    06: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_NULL
    07: set all input parameters (configuration, sender state
        and data) to NULL
    08: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020631,ASR_E2EPJLR020575,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_NULL
    09: set all input parameters in RAM (sender state and data)
        to NULL
    10: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_NULL
    11: exceed maximum allowed State.Counter
    12: VP (EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG
    13: call with a data length which is not a multiple of 8
    14: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020631,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG
    15: call with a data length exceeding the maximum number of
        specified bits
    16: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG
    17: call with data id mode E2E_PJLR_DATAID_NIBBLE and a too high DataIdNibbleOffset)
        (i.e. Config-&gt;DataIDNibbleOffset + 4U) &gt; Config-&gt;DataLength)
    18: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG
    19: call with a crc offset greater than the configured data length
    20: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047,EB_E2EPJLR020567)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG
    21: call with a counter offset greater than the configured data length
    22: VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047,EB_E2EPJLR020565)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG
    23: call with data id mode E2E_PJLR_DATAID_BOTH and DataIDNibbleOffset != 0
    24 VP (EB_E2EPJLR020505,EB_E2EPJLR020011,EB_E2EPJLR020012,EB_E2EPJLR020587,EB_E2EPJLR020047)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG
    25: call with data id mode E2E_PJLR_DATAID_NIBBLE and DataID &gt;
        12bit value (0x1000U)
    26 VP (EB_E2EPJLR020506)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG
    27: call with data id mode E2E_PJLR_DATAID_NIBBLE and DataID &gt;
        12bit value (0xFFFFU)
    28 VP (EB_E2EPJLR020506)
        E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG


Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020673</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020587</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020567</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020565</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020506</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020583</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020505</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020631</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_10_PJLRForward_WriteCounter_FS_Repeated</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_10_PJLRForward/source/application/E2EPJLR_ConTest_10_PJLRForward.c</sourcefile>
      <sourceline>1373</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that correct Counter is written in the E2E Header in Big Endian format
    tested by iterating among all counter values, wrap around of the counter is considered.

    counter = StatePtr-&gt;Counter - 1U
  &lt;/para&gt;
  
Test Object: E2E_PJLRForward()
Test Precondition: 
  
Test Execution: 

    Iterate the following steps several times:

    00: Loop through:
        - different positions of PJLR header (CRCOffset, CounterOffset and DataIDNibbleOffset)
        - different Length values (encoded in header)
        - all possible values of state Counter (0U to 14U)

    01: Call E2E_PJLRForward().
    02: VP:E2E_PJLRForward() returns E2E_E_OK.
    03: VP:The State-&gt;Counter in E2E header
        which starts at Offset = E2E_PJLRConfig-&gt;Offset / 8.
    04: VP: Expected output data equals to output data returns E2E_E_OK.

    Used Test Strategies:
    - Pair wise tests:
        Different values among the configuration parameters "Offset", "DataLength" and state
        parameter "Counter".
    - Boundary Value Analysis
        Usage of minimum, intermediate and maximum values of state parameter "Counter".
    - Equivalence Class Partitioning
        Testing only transitions to E2E_E_OK status for E2E_PJLRForward() function.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020673</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020630</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020633</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_10_PJLRForward_WriteCounter_FS_WrongSeq</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_10_PJLRForward/source/application/E2EPJLR_ConTest_10_PJLRForward.c</sourcefile>
      <sourceline>1591</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that correct Counter is written in the E2E Header in Big Endian format
    tested by iterating among all counter values, wrap around of the counter is considered.

    counter = StatePtr-&gt;Counter + ConfigPtr-&gt;MaxDeltaCounter
  &lt;/para&gt;
  
Test Object: E2E_PJLRForward()
Test Precondition: 
  
Test Execution: 

    Iterate the following steps several times:

    00: Loop through:
        - different positions of PJLR header (CRCOffset, CounterOffset and DataIDNibbleOffset)
        - different Length values (encoded in header)
        - all possible values of state Counter (0U to 14U)

    01: Call E2E_PJLRForward().
    02: VP:E2E_PJLRForward() returns E2E_E_OK.
    03: VP:The State-&gt;Counter in E2E header
    04: VP: Expected output data equals to output data returns E2E_E_OK.

    Used Test Strategies:
    - Pair wise tests:
        Different values among the configuration parameters "Offset", "DataLength" and state
        parameter "Counter".
    - Boundary Value Analysis
        Usage of minimum, intermediate and maximum values of state parameter "Counter".
    - Equivalence Class Partitioning
        Testing only transitions to E2E_E_OK status for E2E_PJLRForward() function.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020673</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020630</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020633</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_10_PJLRForward_WriteDataID_FS_Error</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_10_PJLRForward/source/application/E2EPJLR_ConTest_10_PJLRForward.c</sourcefile>
      <sourceline>1800</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that correct DataID incremented by 1 is written
    in the E2E Header in Big Endian format if check status is error.
  &lt;/para&gt;
  
Test Object: E2E_PJLRForward()
Test Precondition: 
  
Test Execution: 

    Iterate the following steps several times:

    00: Loop through:
        - different positions of PJLR header (CRCOffset, CounterOffset and DataIDNibbleOffset)
        - different Length values (encoded in header)
        - all possible values of state Counter (0U to 14U)

    01: Call E2E_PJLRForward().
    02: VP:E2E_PJLRForward() returns E2E_E_OK.
    03: VP:The State-&gt;Counter in E2E header
    04: VP: Expected output data equals to output data returns E2E_E_OK.

    Used Test Strategies:
    - Pair wise tests:
        Different values among the configuration parameters "Offset", "DataLength" and state
        parameter "Counter".
    - Boundary Value Analysis
        Usage of minimum, intermediate and maximum values of state parameter "Counter".
    - Equivalence Class Partitioning
        Testing only transitions to E2E_E_OK status for E2E_PJLRForward() function.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020673</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020630</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020632</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    <specobject>
      <id>TS_E2EPJLR_ConTest_10_PJLRForward_FS_Nonewdata</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_10_PJLRForward/source/application/E2EPJLR_ConTest_10_PJLRForward.c</sourcefile>
      <sourceline>2008</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if forward status is E2E_P_NONEWDATA then
    forward status shall return E2E_E_INPUTERR_WRONG.
  &lt;/para&gt;
  
Test Object: E2E_PJLRForward()
Test Precondition: 
  
Test Execution: 

    01: Call E2E_PJLRForward().
    02: VP:E2E_PJLRForward() returns E2E_E_INPUTERR_WRONG.

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPJLR020673</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020630</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPJLR020631</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_11000_FWCodeStatusCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_11_E2EXf_InP_SomeIpXf_FWCode/source/application/E2EPJLR_ConTest_11_E2EXf_InP_SomeIpXf.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place transformer 'E2EXf_transformerId' of profile JLR
  invokes 'E2E_PJLRForward()' with with different error codes.

  This test also verfies that state structures are initialized correctly by E2E_PJLRProtectInit.

  This test verifies that the mandatory interfaces for a protect transformer are called:
      API function         Description
      E2E_PJLRForward      Protects data which is forwarded by using the E2E profile JLR. This
                           includes checksum calculation, handling of counter and Data ID.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Initialize Buffer with values different to 0U.
  02: Reinitialize module and
      - structure of StatePtr is initialized by E2E_PJLRProtectInit (Counter set to 0U).
  03: Call transformer function with valid parameters.
  04: VP: E2E_PJLRForward() was called, because transformer function is called with forwardedCode as
          E_OK (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_OK), counter was set correctly to
          0U in E2E header. The Counter will be incremented which will be used in the next
          invocation of E2E_PJLRForward.
  05: Call transformer function with valid parameters.
  06: VP: E2E_PJLRForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_REP (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_REPEATED), counter
          was decremented and set correctly to 0U in E2E header. The Counter will be incremented
          which will be used in the next invocation of E2E_PJLRForward..
  07: Call transformer function with valid parameters.
  08: VP: E2E_PJLRForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_SEQ (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_WRONGSEQUENCE),
          counter was set to (Counter + MaxDeltaCounterInit)U in E2E header. The Counter will be
          incremented which will be used in the next invocation of E2E_PJLRForward.
  09: Call transformer function with valid parameters.
  10: VP: E2E_PJLRForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_CRC (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_ERROR),
          counter was incremented and set in E2E header. DataId will be incremented by 1U and set
          in E2E header.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00107.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00168.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00208.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_12000_FWCodeStatusCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_12_E2EXf_OoP_SomeIpXf_FWCode/source/application/E2EPJLR_ConTest_12_E2EXf_OoP_SomeIpXf.c</sourcefile>
      <sourceline>55</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place transformer 'E2EXf_transformerId' of profile JLR
  invokes 'E2E_PJLRForward()' with with different error codes.

  This test also verfies that state structures are initialized correctly by E2E_PJLRProtectInit.

  This test verifies implicitly that the mandatory interfaces for a protect transformer are called:
      API function         Description
      E2E_PJLRForward      Protects data which is forwarded by using the E2E profile JLR. This
                           includes checksum calculation, handling of counter and Data ID.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Initialize Buffer with values different to 0U.
  02: Reinitialize module and
      - structure of StatePtr is initialized by E2E_PJLRProtectInit (Counter set to 0U).
  03: Call transformer function with valid parameters.
  04: VP: E2E_PJLRForward() was called, because transformer function is called with forwardedCode as
          E_OK (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_OK), counter was set correctly to
          0U in E2E header. The Counter will be incremented which will be used in the next
          invocation of E2E_PJLRForward.
  05: Call transformer function with valid parameters.
  06: VP: E2E_PJLRForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_REP (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_REPEATED), counter
          was decremented and set correctly to 0U in E2E header. The Counter will be incremented
          which will be used in the next invocation of E2E_PJLRForward.
  07: Call transformer function with valid parameters.
  08: VP: E2E_PJLRForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_SEQ (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_WRONGSEQUENCE),
          counter was set to (Counter + MaxDeltaCounterInit)U in E2E header. The Counter will be
          incremented which will be used in the next invocation of E2E_PJLRForward.
  09: Call transformer function with valid parameters.
  10: VP: E2E_PJLRForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_CRC (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_ERROR),
          counter was incremented and set in E2E header. DataId will be incremented by 1U and set
          in E2E header.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00107.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00168.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00208.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_13000_InvokeCheck_DisableE2ESM_TRUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_13_E2EXf_InP_SomeIpXf_DisableE2ESM/source/application/E2EPJLR_ConTest_13_E2EXf_InP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>55</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId' of profile JLR
  invokes 'E2E_PJLRCheck()' with disableEndToEndStateMachine TRUE.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  00: Set Buffer to defined values.

  01: Deinitialize and Initialize module.

  02: - Set E2E header to correct values (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  03: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_OK.
          Verifies that state structures are initialized correctly.

  04: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  05: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.

  06: - Set E2E header to values simulating repeated message (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  07: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_REP.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.

  08: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  09: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.
          Verifies that correct state structure is used.

  10: - Set E2E header to correct values (Counter = 3U) except Crc is set to an incorrect value.
      - Call inverted transformer function with valid parameters.
  11: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_ERR.
          Verifies that E2E_PJLRCheck() uses correct configuration because incorrect Crc was
          detected.

  12: - Set E2E header to correct values (Counter = 3U).
      - Call inverted transformer function with valid parameters.
  13: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_OK.
          Verifies that state structures are initialized correctly.

  14: - Set E2E header to values pand set Counter to a value larger than ConfigPtr-&gt;MaxDeltaCounter.
      - Call inverted transformer function with valid parameters.
  15: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_SEQ.

  16: - Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function with Buffer == NULL and
        InputBufferLength == 0.
  17: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_NND.
          Verifies that E2E_PJLRCheck() passes the correct pointer to data by DataPtr.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00169.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00032.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPJLR_E2EXf_CON_14000_InvokeCheck_DisableE2ESM_TRUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPJLR)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPJLR/test/ts5/Conformance/IN/E2EPJLR_ConTest_14_E2EXf_OoP_SomeIpXf_DisableE2ESM/source/application/E2EPJLR_ConTest_14_E2EXf_OoP_SomeIpXf_Inv.c</sourcefile>
      <sourceline>55</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile JLR invokes 'E2E_PJLRCheck()' with disableEndToEndStateMachine TRUE.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 16 bits
  - upperHeaderBitsToShift: 64 bits

Test Execution: 
  01: Deinitialize and Initialize module.

  02: - Set E2E header to correct values (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  03: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_OK.
          Verifies that state structures are initialized correctly.

  04: - Set E2E header to values simulating repeated message (Counter = 0U).
      - Call inverted transformer function with valid parameters.
  05: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_REP.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.

  06: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  07: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PJLRCheck() is called because Counter was checked.
          Verifies that correct state structure is used.

  08: - Set E2E header to correct values (Counter = 2U) except Crc is set to an incorrect value.
      - Call inverted transformer function with valid parameters.
  09: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_ERR.
          Verifies that E2E_PJLRCheck() uses correct configuration because incorrect Crc was
          detected.

  10: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  11: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_OK.
          Verifies that state structures are initialized correctly.

  12: - Set E2E header to correct values, set Counter to a value larger than
        ConfigPtr-&gt;MaxDeltaCounter.
  13: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_SEQ.

  14: - Set E2E header to correct values (Counter = 3U).
      - Call inverted transformer function with InputBuffer == NULL.
  15: VP: E2E_PJLRCheck() returns E_SAFETY_NOSM_NND.
          Verifies that E2E_PJLRCheck() passes the correct pointer to data by DataPtr.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00169.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_E2EXf_00037.PJLR</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPJLR.SWS_Xfrm_00032.PJLR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
