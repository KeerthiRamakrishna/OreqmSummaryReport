<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_IpduM_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_4_0_3.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_4_2_1.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_4_3_1.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_R20-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_RefinedRequirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_test_manConfTests.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_PbcfgM_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_PduLengthType_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 21:09:21 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_IpduM_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_4_0_3.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_4_2_1.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_4_3_1.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_R20-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_requirements_IpduM_RefinedRequirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_Native/asc_IpduM_test_manConfTests.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_PbcfgM_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_PduLengthType_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="lim">

    <specobject>
      <id>lim.IpduM.EB_INTREQ_IpduM_0001</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- class: minor, long term -->
      <!-- class-reason:
           * this is the designed functionality of the module -->
      Ensuring that the configured data retrieval mechanisms (the configuration parameters <code>IpduMContainerTxTriggerMode</code> and <code>IpduMContainedTxPduCollectionSemantics</code>)
      are compatible with the associated modules is the responsibility of the integrator.
      </description>
      <rationale>
      For example by choosing <code>IPDUM_COLLECT_LAST_IS_BEST</code> as <code>IpduMContainedTxPduCollectionSemantics</code> it is expected that
      the module initiating the transmission exposes the interface <code>&lt;module&gt;_TriggerTransmit()</code>.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

    <specobject>
      <id>lim.IpduM.EB_INTREQ_IpduM_0002</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- class: minor, long term -->
      <!-- class-reason:
         * was behaving differently before implementation of ASCIPDUM-1045 -->
      An <code>IpduMContainerTxPdu</code> container with <code>IpduMContainerQueueSize</code> not configured will have no queue buffer.
      The effect is that <code>IpduM_Transmit()</code> will return <code>E_NOT_OK</code> for a contained IPDU within a container for which <code>IpduM_TxConfirmation()</code> is awaited from an ongoing transmission.
      </description>
      <rationale>
        Previously, an <code>IpduMContainerTxPdu</code> container with <code>IpduMContainerQueueSize</code> not configured would have had the same behavior as if <code>IpduMContainerQueueSize</code> was configured to 1.
        The change is meant to bring a clear distinction between the above two configurations and
        brings the expectation of the user from the IpduM configuration into actual sequence of events.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

    <specobject>
      <id>lim.IpduM.EB_INTREQ_IpduM_0003</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- class: minor, long term -->
      <!-- class-reason:
         * Data consistency assurrance -->
      API <code>IpduM_Transmit()</code> is not reentrant for contained IPDUs belonging to the same <code>IpduMContainerTxPdu</code> container.
      </description>
      <rationale>
        The measure is necessary to assure the order and consistency of contained IPDUs and their data within an instance of a TX container.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

    <specobject>
      <id>lim.IpduM.EB_INTREQ_IpduM_0004</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <!-- class: minor, long term -->
      <!-- class-reason:
         * Data consistency assurrance -->
      Through means of appropriate task scheduling and priority handling it shall be ensured during integration that the APIs
      <code>IpduM_MainFunctionTx</code> and <code>IpduM_Transmit()</code> do no interrupt one another.
      </description>
      <rationale>
        The measure is necessary to assure the order and consistency of contained IPDUs and their data within an instance of a TX container.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">


    <specobject>
      <id>IPDUM.EB.IPDUM501</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Add following configuration item
        Name: IpduMZeroCopy
        Parent container: IpduMGeneral
        Type: BOOLEAN
        Multiplicity: 1
        Default value: true
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: If IpduMZeroCopy is enabled the IpduM behaves as specified in the Specification of the
        I-PDU Multiplexer, V2.1.0, R4.0 Rev 2. If IpduMZeroCopy is disabled the parameter IpduMSegmentPosition
        specifies the segment position in the multiplexed and demultiplexed PDU.
      </description>
      <comment>
        See also IPDUM.EB.IPDUM504.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_25</srcid><srcstatus/><internalId>556</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM504</id>
      <!-- 2011-11-10
        It is still under discussion if this requirement is still needed. The customer which is requesting this feature probably
        will not use it. Removing this Requirement would seriously improve the performance and ease the maintenance.
        Remember that several requirements must be deleted too when this requirement falls.

        See also:
        IPDUM.EB.IPDUM501
        IPDUM.EB.IPDUM506
      -->
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If IpduMZeroCopy is enabled the single PDU (segments) will be not copied to designated
        IpduMSegmentPosition of the multiplexed PDU sent to the lower layer. Only the pointer to the data is handed over.
        The behavior of the IpduM is in this case as specified in the Specification of the I-PDU Multiplexer, V2.1.0, R4.0 Rev 2
      </description>
      <comment>
        This parameter was introduced to be backward compatible to AUTOSAR 3.2.
        See also IPDUM505.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_02098_ZeroCopy</srcid><srcstatus/><internalId>697</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM505</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If IpduMZeroCopy is disabled the PDU (segments) will be copied to the IpduMSegmentPosition
        position of the multiplexed PDU sent to the lower layer.
      </description>
      <comment>
        This parameter was introduced to be back ward compatible to AUTOSAR 3.2.
        See also IPDUM504.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_11002_Tx_ZC_Off</srcid><srcstatus/><internalId>976</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM506</id>
      <!-- Referenced by a test -->
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If IpduMZeroCopy is disabled the incoming PDU will be demultiplexed and the demultiplexed PDU
        (segments) must be copied to the IpduMSegmentPosition of the PDU sent to the upper layer.
      </description>
      <comment>
        See also IPDUM504.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_11003_Rx_ZC_Off</srcid><srcstatus/><internalId>977</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM507</id>
      <!--
        IPDUM.EB.IPDUM507 can be fully handled by IPDUM170 with SWS Rev. 3.

        The test shall be implemented with
        https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-370
      -->
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Requirement IpduM.ASR40.SWS_IpduM_00170 applies, but the version numbers shall be published
        as stated in [BSW00318] according to the General Requirements on Basic Software Modules
        of ASR V3.1.0 R4.0 Rev 2.

        That is, the following version numbers shall be defined in the header file
        according to [BSW00318] (General Requirements on Basic Software Modules
        of ASR V3.1.0 R4.0 Rev 2):
          * PDUR_VENDOR_ID
          * PDUR_MODULE_ID
          * PDUR_AR_RELEASE_MAJOR_VERSION
          * PDUR_AR_RELEASE_MINOR_VERSION
          * PDUR_AR_RELEASE_REVISION_VERSION
          * PDUR_SW_MAJOR_VERSION
          * PDUR_SW_MINOR_VERSION
          * PDUR_SW_PATCH_VERSION
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_04003_PublishedInformation</srcid><srcstatus/><internalId>704</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.ZeroPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>3</version>
      <description>
        An I-PDU with configured PduLength of 0 shall be considered invalid.
      </description>
      <comment>
        No meaningful processing can be performed.
        Refined due to ASCIPDUM-999.
      </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.ZeroPduLength.Configured</srcid><srcstatus/><internalId>10</internalId></linkedfrom><linkedfrom><srcid>IPDUM.EB.ZeroPduLength.Transmission</srcid><srcstatus/><internalId>11</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.ZeroPduLength.Configured</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
      An I-PDU with configured PduLength of 0 shall be considered invalid.
      The MCG shall issue an error stating that it is invalid.
    </description>
      <comment>
      No meaningful processing can be performed.
      Covered by TS_IPDUM_GEN_00013_ZeroPduLength.
    </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_00008_ZeroPduLength</srcid><srcstatus/><internalId>967</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.ZeroPduLength</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.ZeroPduLength.Transmission</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        During transmission Contained PDUs with an SduLength of 0 shall be ignored
        silently.
        IpduM_Transmit() returns E_OK.
      </description>
      <comment>
        No meaningful processing can be performed.
        Covered by TS_IPDUM_CON_07085_Tx_Length_0, TS_IPDUM_CON_14010_CntrTx_Static_Length_0.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07085_Tx_Length_0</srcid><srcstatus/><internalId>769</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14010_CntrTx_Static_Length_0</srcid><srcstatus/><internalId>890</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.ZeroPduLength</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM550_Conf</id>
      <!-- use byte wise copy routines shall be tested with ASCIPDUM-491 -->
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Add following configuration item
        Name: IpduMByteCopy {IPDUM_BYTE_COPY}
        Parent container: IpduMGeneral
        Type: BOOLEAN
        Multiplicity: 1
        Default value: false
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Use byte-wise copy routines.
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios.
      </furtherinfo>
      <comment>
        IpduMByteCopy can only be enabled if source and destination segments are byte aligned,
        see IPDUM551.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_73</srcid><srcstatus/><internalId>557</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_00000</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_01000</srcid><srcstatus/><internalId>647</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00020</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00021</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00024</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00025_InitDefaultValues</srcid><srcstatus/><internalId>666</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00026_InitDefaultValuesTTNotOK</srcid><srcstatus/><internalId>667</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00030_PduInit</srcid><srcstatus/><internalId>668</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00040_JitUpdateOnTransmit</srcid><srcstatus/><internalId>669</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00050_JitUpdateOnTriggerTransmit</srcid><srcstatus/><internalId>670</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00060_JitUpdateNotOkOnTransmit</srcid><srcstatus/><internalId>671</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00070_JitUpdateNotOkOnTriggerTransmit</srcid><srcstatus/><internalId>672</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM551</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        IpduMByteCopy can only be enabled if source and destination segments are byte aligned.
        Otherwise an error shall be issued and no code must be generated.
      </description>
      <comment>
        IpduMSegmentPosition shall be configured byte aligned.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_00003_ByteCopy_Segment</srcid><srcstatus/><internalId>962</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM554_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Add following configuration item
        Name: IpduMTxSelectorValue
        Parent container: IpduMTxDynamicPart
        Type: INTEGER
        Multiplicity: 1
        Default value: -
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: If IpduMTxAutomaticSelector is enabled IpduMTxSelectorValue holds the selector
        value for the outgoing PDU.
      </description>
      <comment>
        For enabled configuration parameter IpduMTxAutomaticSelector the issue is covered by IPDUM555.
        For disabled configuration parameter IpduMTxAutomaticSelector the issue is covered by IPDUM556.
        With respect to TPS_ECUC_06051 (AUTOSAR_TPS_ECUConfiguration, ASR 4.1.3) the
        implemented configuration class is set to PostBuild.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_794</srcid><srcstatus/><internalId>580</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM555</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduM supports the possibility to configure the selector value for TX PDUs within the
        IpduM. The selector value is stored in IpduMTxSelectorValue. The feature is enabled with
        IpduMTxAutomaticSelector.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_00000</srcid><srcstatus/><internalId>969</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM556</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduMTxAutomaticSelector is disabled the parameter IpduMTxSelectorValue must not be
        editable.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_823</srcid><srcstatus/><internalId>581</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM557</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Add following configuration item
        Name: IpduMDataMemSize
        Parent container: IpduMGeneral
        Type: INTEGER
        Multiplicity: 1
        Default value: false
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Size of internal IpduM data in units of bytes (static memory allocation) - Memory
        required by post-build configuration shall not be greater than this constant.
      </description>
      <comment>
        The functional part of this requirement is covered by IPDUM.EB.IPDUM562 and it is tested by
        - TS_IPDUM_GEN_50001_DataMem
        With respect to TPS_ECUC_06051 (AUTOSAR_TPS_ECUConfiguration, ASR 4.1.3) the
        implemented configuration class is set to Link.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_167</srcid><srcstatus/><internalId>560</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00165</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM558</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        An error shall be reported if IpduMTxAutomaticSelector is disabled and the selector field
        is not fully contained within one segment of the dynamic part.
      </description>
      <comment>
        If the IpduMTxAutomaticSelector is disabled then the behaviour of IpduM regarding
        the containment of the selector field is as specified in IPDUM004 of
        AUTOSAR_SWS_IPDUMultiplexer.pdf (V2.2.0).
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_01000_SelUpperBoundViolation</srcid><srcstatus/><internalId>918</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_01010_SelFullyContainment</srcid><srcstatus/><internalId>919</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_01020_SelLowerBoundViolation</srcid><srcstatus/><internalId>920</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM559</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduMTxAutomaticSelector is enabled then the selector field should not be enclosed
        by any segment of the dynamic and static part otherwise a warning shall be reported.
      </description>
      <comment>
        This ensures that no data comming from the upper layer module is unintended overwritten
        in case the selector field is managed by the IpduM module.
        Considering IPDUM.EB.IPDUM558 the selector field should not be part of any segment of
        the static part regardless the value of IpduMTxAutomaticSelector.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_02000_AutoSelLowerBoundViolation</srcid><srcstatus/><internalId>921</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_02010_AutoSelFullyContainment</srcid><srcstatus/><internalId>922</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_02015_AutoSelFullyStaticContainment</srcid><srcstatus/><internalId>923</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_02020_AutoSelUpperBoundViolation</srcid><srcstatus/><internalId>924</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_02030_AutoSelStaticBoundViolation</srcid><srcstatus/><internalId>925</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM560</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The IpduM shall support only LITTLE_ENDIAN for IpduMByteOrder.
      </description>
      <comment>
        This requirement is contrary to:
        * IpduM.ECUC_IpduM_00162
        * IpduM.ECUC_IpduM_00162_1
        * IpduM.SWS_IpduM_00173
        The related deviation has the tag [ASCIPDUM-198].
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_01002_LittleEndianOnly</srcid><srcstatus/><internalId>972</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM561</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case IpduMTxConfirmationTimeout was omitted or configured to 0, the IpduM
        module does not block any new transmission requests.
      </description>
      <comment>
        The source of this requirement is the sentence after requirement IPDUM020.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_04004_TxConfTime_Zero</srcid><srcstatus/><internalId>705</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM565</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case IpduMTxConfirmationTimeout was omitted or configured to 0, the IpduM
        module only confirms the last transmission request. All other Tx confirmations are
        discarded silently.
      </description>
      <comment>
        This requirement is in relation to IPDUM.EB.IPDUM561.
        This requirement follows the spirit of IPDUM024.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_04004_TxConfTime_Zero</srcid><srcstatus/><internalId>705</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM563</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduM shall use the EB defense programing macros.
      </description>
      <comment>
        It can only be tested that a IpduM internal header supplies these macros.
        See:
        http://wiki.elektrobit.com/index.php/Project:EB_tresos/Architecture/Defensive_Programming#Implementing_Defensive_Programming_in_a_Module
        Version: 16:45, 15 May 2012
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_06002_CheckDefensiveProgramming</srcid><srcstatus/><internalId>974</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM564</id>
      <!--
        Since the short names of containers with multiplicity one are available the naming of the
        macros is outdated and probably more confusing than necessary. If there are any plans to
        improve this, the short names of the regarding container should be used.
      -->
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduM shall generate symbolic name value macros of the adjacent module PduR. These macros
        are only active if enabled by defining the pre-processor statement
        IPDUM_PROVIDE_ADJACENT_MODULE_VENDOR_SYMBOLIC_NAMES.

        Macros for Rx Pathways
        - The macro for the parameter IpduMOutgoingDynamicPduRef (PduRSrcPduRef) shall be generated as
          following: IPDUM_RX_OUTGOING_ID_[IpduMRxPathway Name]_[IpduMRxDynamicPart Name]

        - The macro for the parameter IpduMOutgoingStaticPduRef (PduRSrcPduRef) shall be generated as
          following: IPDUM_RX_OUTGOING_ID_[IpduMRxPathway Name]

        Macros for Tx Pathways
        - The macro for the parameter IpduMOutgoingPduRef (PduRSrcPduRef) shall be generated as
          following: IPDUM_TX_OUTGOING_ID_[IpduMTxPathway Name]

        - The macro for the parameter IpduMTxStaticPduRef (PduRDestPduRef) shall be generated as
          following: IPDUM_TX_CONFIRM_ID_[IpduMTxPathway Name]

        - The macro for the parameter IpduMTxDynamicPduRef (PduRDestPduRef) shall be generated as
          following: IPDUM_TX_CONFIRM_ID_[IpduMTxPathway Name]_[IpduMTxDynamicPart Name]
      </description>
      <comment>
        These macros are introduced for test purpose and not part of the public IpduM APIs.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_11001_AdjacentModuleVendorSymbolicNames</srcid><srcstatus/><internalId>975</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

  <!-- Feature related requirements -->

    <specobject>
      <id>IPDUM.EB.BSWMDGeneration_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      The module's generator shall generate a basic software
      module description (BSWMD) based on the module's
      configuration containing information on the exclusive areas
      required by the module's implementation.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_03000_ConfigType</srcid><srcstatus/><internalId>650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.BSWMDGeneration_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      The module's generator shall generate a basic software
      module description (BSWMD) based on the module's
      configuration containing information on the scheduled
      MainFunctions together with the scheduling period.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_03000_ConfigType</srcid><srcstatus/><internalId>650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.BSWMDGeneration_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      The module's BSWMD shall be generated using a generator
      mode named "generate_swcd".
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_03000_ConfigType</srcid><srcstatus/><internalId>650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM042.InvalidSelectorValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When a multiplexed I-PDU is received from the PduR with an invalid selector value,
        PduR_IpduMRxIndication is not called for the dynamic part.
        </description>
      <comment>
        See IpduM.ASR40.SWS_IpduM_00042 for the corresponding valid selector value.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01012</srcid><srcstatus/><internalId>686</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_03100</srcid><srcstatus/><internalId>700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMInitializationBySignalValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>3</version>
      <description>
      The container IpduMGeneral shall hold the configuration item
      Name: IpduMInitializationBySignalValue {IPDUM_INITIALIZATION_BY_SIGNAL_VALUE}
      Type: BOOLEAN
      Multiplicity: 1
      Default value: true
      Configuration class: Pre-compile time
      Scope/Dependency: scope local
      Description: Enables initialization of the static and dynamic parts
      in retrieving signal values from the upper layer module by IpduM_Init.
      This comprises especially the usage of mandatory parameter IpduMInitialDynamicPart.
      If IpduMInitializationBySignalValue is disabled the static and dynamic parts are only
      initialized by the unused area pattern configured.
    </description>
    <comment>
      If IpduMInitializationBySignalValue is enabled the IpduM is compliant to AUTOSAR
      Specification of the I-PDU Multiplexer, V2.1.0, R4.0 Rev 3.
    </comment>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMInitializationBySignalValue.Success</srcid><srcstatus/><internalId>30</internalId></linkedfrom><linkedfrom><srcid>IPDUM.EB.IpduMInitializationBySignalValue.Failure</srcid><srcstatus/><internalId>31</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMInitializationBySignalValue.Success</id>
      <!--
        Test cases:
        - check setting of macro to STD_ON and STD_OFF
        - check initialization with disabled parameter
      -->
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The container IpduMGeneral shall hold the configuration item
        Name: IpduMInitializationBySignalValue {IPDUM_INITIALIZATION_BY_SIGNAL_VALUE}
        Type: BOOLEAN
        Multiplicity: 1
        Default value: true
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Enables initialization of the static and dynamic parts
        in retrieving signal values from the upper layer module by IpduM_Init.
        This comprises especially the usage of mandatory parameter IpduMInitialDynamicPart.
        If IpduMInitializationBySignalValue is disabled the static and dynamic parts are only
        initialized by the unused area pattern configured.
      </description>
      <comment>
        If IpduMInitializationBySignalValue is enabled the IpduM is compliant to AUTOSAR
        Specification of the I-PDU Multiplexer, V2.1.0, R4.0 Rev 3.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1532</srcid><srcstatus/><internalId>499</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_03000_ConfigType</srcid><srcstatus/><internalId>650</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01009_NoSignalValuesForInit</srcid><srcstatus/><internalId>683</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_00006_InitialDynamicPart</srcid><srcstatus/><internalId>965</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMInitializationBySignalValue</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMInitializationBySignalValue.Failure</id>
      <!--
        Test cases:
        - check setting of macro to STD_ON
        - check initialization with TriggerTransmit returning E_NOT_OK
      -->
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The container IpduMGeneral shall hold the configuration item
        Name: IpduMInitializationBySignalValue {IPDUM_INITIALIZATION_BY_SIGNAL_VALUE}
        Type: BOOLEAN
        Multiplicity: 1
        Default value: true
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Enables initialization of the static and dynamic parts
        in retrieving signal values from the upper layer module by IpduM_Init.
        This comprises especially the usage of mandatory parameter IpduMInitialDynamicPart.
        If PduR_IpduMTriggerTransmit() returns E_NOT_OK, the static and dynamic parts are only
        initialized by the unused area pattern configured.
      </description>
      <comment>
        If IpduMInitializationBySignalValue is enabled the IpduM is compliant to AUTOSAR
        Specification of the I-PDU Multiplexer, V2.1.0, R4.0 Rev 3.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_706</srcid><srcstatus/><internalId>493</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00026_InitDefaultValuesTTNotOK</srcid><srcstatus/><internalId>667</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMInitializationBySignalValue</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMEnableJitUpdate</id>
      <!--
        Test case:
        - check setting of macro to STD_ON and STD_OFF
      -->
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The container IpduMGeneral shall hold the configuration item
        Name: IpduMEnableJitUpdate {IPDUM_ENABLE_JIT_UPDATE}
        Type: BOOLEAN
        Multiplicity: 1
        Default value: true
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Enables just-in-time updates of the static and dynamic parts in general.
        This comprises especially the usage of mandatory parameter IpduMInitialDynamicPart.
      </description>
      <comment>
        If IpduMEnableJitUpdate is enabled the IpduM is compliant to AUTOSAR
        Specification of the I-PDU Multiplexer, V2.1.0, R4.0 Rev 3.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_230</srcid><srcstatus/><internalId>561</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_03000_ConfigType</srcid><srcstatus/><internalId>650</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00040_JitUpdateOnTransmit</srcid><srcstatus/><internalId>669</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_00006_InitialDynamicPart</srcid><srcstatus/><internalId>965</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00223</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>318</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.LegacySymbolicNameValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If macro IPDUM_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined then
        the macros for legacy symbolic name values must not be generated for the parameters that have SymbolicNameValue set to true.
      </description>
      <comment>
        see http://wiki.elektrobit.com/index.php/Project:EB_tresos/Architecture/Config#Symbolic_Names
        and https://issue.ebgroup.elektrobit.com/browse/ASCPROJECT-332
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_NonLegSymbolicNames</srcid><srcstatus/><internalId>649</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerPduHandlingEnable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The container IpduMGeneral shall hold the configuration item
        Name: IpduMContainerPduHandlingEnable {IPDUM_CONTAINER_PDU_HANDLING_ENABLE}
        Type: EcucBooleanParamDef
        Multiplicity: 1
        Default value: true
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Enables or disables the Multiple-PDU-to-Container handling.
                    True: Multiple-PDU-to-Container handling is enabled.
                    False: Multiple-PDU-to-Container handling is disabled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_447</srcid><srcstatus/><internalId>571</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_ContainerPduHandling</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_HandleIdObtained</srcid><srcstatus/><internalId>662</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduM_MainFunctionRx_Processing</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V4.2.1</source>
      <version>1</version>
      <description>
        The function IpduM_MainFunctionRx shall perform the processing of the reception activities
        that are not directly handled within the calls from PduR.
      </description>
      <comment>
        See Bugzilla RfC 71983 and RfC 61297.
        It was removed because duplicates the description from IpduM.SWS_IpduM_91001 which was
        IpduM.ASR42.SWS_IpduM_00101.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2_ASR1911</srcid><srcstatus/><internalId>863</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2</srcid><srcstatus/><internalId>864</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduM_MainFunctionTx_Processing</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V4.2.1</source>
      <version>1</version>
      <description>
        The function IpduM_MainFunctionTx shall perform the processing of the transmission activities
        that are not directly handled within the calls from PduR. This includes at least the
        TxConfirmation time observation.
      </description>
      <comment>
        See Bugzilla RfC 71983 and RfC 61297.
        It was removed because duplicates the description from IpduM.SWS_IpduM_91002 which was
        IpduM.ASR42.SWS_IpduM_00103.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_09001_MainFuncTx_TxConfTimeout</srcid><srcstatus/><internalId>865</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_09002_MainFuncTx_SendTimeout</srcid><srcstatus/><internalId>866</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_09003_MainFuncTx_SendTimeout2</srcid><srcstatus/><internalId>867</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMDequeueInTxConf</id>
      <status>approved</status>
      <source>EB</source>
      <version>4</version>
      <description>
        The container IpduMGeneral shall hold the configuration item
        Name: IpduMDequeueInTxConf {IPDUM_DEQUEUE_IN_TX_CONF}
        Type: EcucBooleanParamDef
        Multiplicity: 1
        Default value: false
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Enables or disables dequeuing (transmission) in addition
                    in the context of an IpduM_TxConfirmation() call of
                    ContainerTxPdus with IpduMContainerTxTriggerMode set to IPDUM_DIRECT.
                    Containers which have it set to IPDUM_TRIGGERTRANSMIT are always dequeued.
                    True: Transmission occurs also in IpduM_TxConfirmation().
                    False: Transmission occurs only in IpduM_MainFunctionTx().
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_650</srcid><srcstatus/><internalId>576</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07006_TxConfAwait</srcid><srcstatus/><internalId>776</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07007_TxConfAwait_2</srcid><srcstatus/><internalId>777</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07009_TxConfAwait_4</srcid><srcstatus/><internalId>779</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07026_TriggerTransmit</srcid><srcstatus/><internalId>791</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07054_TriggerTransmit_E_NOT_OK</srcid><srcstatus/><internalId>792</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07035_TxConfirm_Queue_NextInstance</srcid><srcstatus/><internalId>826</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07037_Dequeue_Main_Func_with_Tx_Confirm</srcid><srcstatus/><internalId>830</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07038_Dequeue_Tx_Confirm_Q</srcid><srcstatus/><internalId>856</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07065_BusOffRecovery</srcid><srcstatus/><internalId>857</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07038_Dequeue_Tx_Confirm_LB</srcid><srcstatus/><internalId>858</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07055_Dequeue_Tx_Confirm_LB_E_NOT_OK</srcid><srcstatus/><internalId>859</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07056_Tx_Confirm_LB_NoCntrQueueing</srcid><srcstatus/><internalId>860</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07074_Dequeue_Tx_Confirm_LB_TT</srcid><srcstatus/><internalId>861</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMSendAfterConf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When the IpduMContainerTxPdu has IpduMContainerTxConfirmationTimeout greater than IpduMContainerTxSendTimeout
        or greater than the maximum IpduMContainedTxPduSendTimeout of its referenced IpduMContainerTxPdus, then,
        after the expiration of the IpduMContainerTxConfirmationTimeout, the IpduMContainerTxPdu shall
        be triggered.
      </description>
      <comment>
        Rationale: even though the send timeout has expired in the meantime, the container PDU can not be sent since there is a
        confirmation expected. In this way, after the elapse of confirmation timeout or if confirmation has been received,
        the container PDU will be triggered.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07048_TxSendTimeout_ConfTimeout</srcid><srcstatus/><internalId>785</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMSendAfterDequeue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When the IpduMContainerTxSendTimeout or IpduMContainedTxPduSendTimeout expires for an IpduMContainerTxPdu in
        the same Main Function cycle as when dequeuing would happen, dequeuing is prioritized and the timeout for the
        IpduMContainerTxPdu is extended by 1 Main Function cycle.
      </description>
      <comment>
        Rationale: even though the send timeout has expired meanwhile, the container PDU can not be sent since there is a
        queued instance awaiting transmission.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07044_TriggerTransmit_Queue_5_LB</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07053_TriggerTransmit_Queue_5_LB_E_NOT_OK</srcid><srcstatus/><internalId>821</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07049_TxSendTimeoutDelayedByDequeue</srcid><srcstatus/><internalId>829</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07065_BusOffRecovery</srcid><srcstatus/><internalId>857</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMMaxContainerRxLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        A buffer is allocated on the stack for the assembly of the payload of Container PDUs during reception.
        The default value is 64.
        For PostBuild configVariant it might be desirable to provide a value greater than the length of the largest
        referenced EcuC PDU.
      </description>
      <comment>
        Rationale: Because it's allocated on the stack, PB configurations possibly might have larger PDUs configured
        than the ones provided during initial compilation of the code, which need to fit as well.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_623</srcid><srcstatus/><internalId>575</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainedCollectQueuedTx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The container IpduMGeneral shall hold the configuration item
        Name: IpduMContainedCollectQueuedTx {IPDUM_CNTND_COLLECT_QUEUED_TX}
        Type: EcucBooleanParamDef
        Multiplicity: 1
        Default value: false
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Enables or disables the handling of PDUs during
                    transmission with IpduMContainedTxPduCollectionSemantics
                    IPDUM_COLLECT_QUEUED.
                    True: IpduMContainedTxPduCollectionSemantics set to
                          IPDUM_COLLECT_QUEUED is supported.
                    False: Only IpduMContainedTxPduCollectionSemantics
                            IPDUM_COLLECT_LAST_IS_BEST is supported.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_578</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerQueuingRx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The container IpduMGeneral shall hold the configuration item
        Name: IpduMContainerQueuingRx {IPDUM_CONTAINER_QUEUING_RX}
        Type: EcucBooleanParamDef
        Multiplicity: 1
        Default value: false
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Enables or disables the queuing of Multiple-PDU-to-Container
                    PDUs during reception.
                    (Parameter IpduMContainerQueueSize enabled and set.)
                    True: Queuing during reception is supported.
                    False: Queuing during reception is not supported.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_533</srcid><srcstatus/><internalId>573</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerTT_SingleInstance</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT and IpduMContainerQueueSize
        is disabled and adding a new contained PDU would exceed the PduLength of container PDU, the IpduM shall return
        E_NOT_OK and shall not allow new contained PDUs to be added to current container PDU instance.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07007_TxConfAwait_2</srcid><srcstatus/><internalId>777</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07071_SizeAnnounceOnlyOnce_LB_NoQueuing</srcid><srcstatus/><internalId>802</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07072_SizeAnnounceOnlyOnce_LB_NoQueuing2</srcid><srcstatus/><internalId>803</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07073_SizeAnnounceOnlyOnce_LB_NoQueuing3</srcid><srcstatus/><internalId>804</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07069_SizeAnnounceOnlyOnce_Queued</srcid><srcstatus/><internalId>839</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07070_SizeAnnounceOnlyOnce_Queued2</srcid><srcstatus/><internalId>840</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerTT_SingleInstanceRetry</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT and IpduMContainerQueueSize
        is disabled, when container PDU is triggered according to IPDUM.EB.IpduMContainerTT_Triggers and previous
        call to PduR_IpduMTransmit() returned E_NOT_OK, IpduM shall call it again.
        At the latest, PduR_IpduMTransmit() shall be called, if none of the previous calls succedeed, when container PDU
        size is reached/exceeded or during next IpduM_MainFunctionTx(), after send timeout expires.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07080_SizeAnnounceOnlyOnce_E_NOT_OK_LB_NoQueuing</srcid><srcstatus/><internalId>807</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07079_SizeAnnounceOnlyOnce_E_NOT_OK_Queued_NoQueuing</srcid><srcstatus/><internalId>843</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerTT_MultipleInstance</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT and IpduMContainerQueueSize
        is enabled and adding a new contained PDU would exceed the PduLength of container PDU, the IpduM shall queue the
        current instance and add the new contained PDU to a new container PDU instance.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07067_SizeAnnounceMFTx_LB</srcid><srcstatus/><internalId>800</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07068_SizeAnnounceOnlyOnce_LB</srcid><srcstatus/><internalId>801</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07063_SizeAnnounceOnlyOnce</srcid><srcstatus/><internalId>833</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07064_SizeAnnounceMFTx</srcid><srcstatus/><internalId>837</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07066_SizeAnnounceOnlyOnce2</srcid><srcstatus/><internalId>838</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerTT_MultipleInstanceRetry</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT and IpduMContainerQueueSize
        is enabled and container PDU instance is added to queue, if E_NOT_OK is received when calling PduR_IpduMTransmit(),
        the call to PduR_IpduMTransmit() shall be retried during next IpduM_MainFunctionTx().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07076_SizeAnnounceRetry_E_NOT_OK_LB</srcid><srcstatus/><internalId>805</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07078_SizeAnnounceRetry_E_NOT_OK_LB2</srcid><srcstatus/><internalId>806</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07090_NoErroneousDoubleTx</srcid><srcstatus/><internalId>812</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07075_SizeAnnounceRetry_E_NOT_OK_Queued</srcid><srcstatus/><internalId>841</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07077_SizeAnnounceRetry_E_NOT_OK_Queued2</srcid><srcstatus/><internalId>842</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerTT_Triggers</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT and
        any of IpduMContainerTxFirstContainedPduTrigger (enabled) or IpduMContainerTxSizeThreshold (reached)
        or IpduMContainedTxPduTrigger (set to IPDUM_TRIGGER_ALWAYS) triggers are fulfilled, the IpduM
        shall call PduR_IpduMTransmit(). In this case the IpduM shall allow adding new contained PDUs to the
        current instance of container PDU.
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios.
      </furtherinfo>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07067_SizeAnnounceMFTx_LB</srcid><srcstatus/><internalId>800</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07068_SizeAnnounceOnlyOnce_LB</srcid><srcstatus/><internalId>801</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07071_SizeAnnounceOnlyOnce_LB_NoQueuing</srcid><srcstatus/><internalId>802</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07072_SizeAnnounceOnlyOnce_LB_NoQueuing2</srcid><srcstatus/><internalId>803</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07073_SizeAnnounceOnlyOnce_LB_NoQueuing3</srcid><srcstatus/><internalId>804</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07063_SizeAnnounceOnlyOnce</srcid><srcstatus/><internalId>833</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07064_SizeAnnounceMFTx</srcid><srcstatus/><internalId>837</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07066_SizeAnnounceOnlyOnce2</srcid><srcstatus/><internalId>838</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07069_SizeAnnounceOnlyOnce_Queued</srcid><srcstatus/><internalId>839</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07070_SizeAnnounceOnlyOnce_Queued2</srcid><srcstatus/><internalId>840</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10007_MainFuncFlexAlloc_SizeAnnounce</srcid><srcstatus/><internalId>875</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerTT</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT,
        and any trigger condition is fulfilled, the IpduM shall call PduR_IpduMTransmit() only once
        for each container PDU instance.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07068_SizeAnnounceOnlyOnce_LB</srcid><srcstatus/><internalId>801</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07063_SizeAnnounceOnlyOnce</srcid><srcstatus/><internalId>833</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerTT_ConfirmMFTx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT and confirmation
        timeout has not expired and any trigger condition is fulfilled, the IpduM shall call PduR_IpduMTransmit()
        during IpduM_TxConfirmation() or during IpduM_MainFunctionTx() after confirmation timeout has expired.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07068_SizeAnnounceOnlyOnce_LB</srcid><srcstatus/><internalId>801</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07063_SizeAnnounceOnlyOnce</srcid><srcstatus/><internalId>833</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07092_SizeAnnounceOnlyOnce_TrgAlways</srcid><srcstatus/><internalId>834</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMContainerTT_Queue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT and IpduMContainerQueueSize
        enabled and queue is not empty, IpduM shall call PduR_IpduMTransmit() during IpduM_MainFunctionTx().
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07067_SizeAnnounceMFTx_LB</srcid><srcstatus/><internalId>800</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07064_SizeAnnounceMFTx</srcid><srcstatus/><internalId>837</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07066_SizeAnnounceOnlyOnce2</srcid><srcstatus/><internalId>838</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMCntdTxPduSendTimeout_TxTimeBase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case IpduMContainedTxPduSendTimeout is not divisible by IpduMTxTimeBase a generator error shall be reported.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_504</srcid><srcstatus/><internalId>588</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03005_IpduM_CntdTxPduSendTimeout_TxTimeBase</srcid><srcstatus/><internalId>930</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMCntrTxSendTimeout_TxTimeBase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case IpduMContainerTxSendTimeout is not divisible by IpduMTxTimeBase a generator error shall be reported.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_971</srcid><srcstatus/><internalId>595</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03006_IpduM_CntrTxSendTimeout_TxTimeBase</srcid><srcstatus/><internalId>931</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMCntrTxConfirmationTimeout_TxTimeBase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case IpduMContainerTxConfirmationTimeout is not divisible by IpduMTxTimeBase a generator error shall be reported.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_911</srcid><srcstatus/><internalId>594</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03007_IpduM_CntrTxConfirmationTimeout_TxTimeBase</srcid><srcstatus/><internalId>932</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMDedicatedIpduProcessingSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMDedicatedIpduProcessingSupport
        Description En-/disables the assignment of Container PDUs to selected MainFunctions for processing.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value FALSE
        Post-Build Variant Value FALSE
        Value Configuration Class
          Pre-compile time X
          All Variants
          Link time --
          Post-build time --
        Scope / Dependency scope: local
      </description>
      <comment>
        The MainFunctions are configured via the IpduMRxProcessing / IpduMTxProcessing containers.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_261</srcid><srcstatus/><internalId>562</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMRxProcessing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMRxProcessing Description Container used for the definition / configuration of an RX MainFunction.
        Multiplicity [0 .. INF[
        Type EcucParamConfContainerDef
        Default value --
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_293</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_Rx_Only</srcid><srcstatus/><internalId>656</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_TxPathWay_Only</srcid><srcstatus/><internalId>657</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_CntrTx_Only</srcid><srcstatus/><internalId>658</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00211</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMRxProcessing.IpduMRxPduRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMRxPduRef
        Description Reference to an IpduMContainerRxPdu
        Multiplicity 1 .. INF[
        Type EcucReferenceDef
        Default value --
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_344</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03009_IpduM_RxFlexAlloc_SingleMF</srcid><srcstatus/><internalId>934</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00212</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMRxProcessing.IpduMTimeBase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMTimeBase
        Description Reference timebase for the associated IpduMContainerRxPdu
        Multiplicity 1 .. 1
        Type EcucFloatParamDef
        Range 0 .. 3600
        Default value --
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_309</srcid><srcstatus/><internalId>564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMTxProcessing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMTxProcessing Description Container used for the definition / configuration of a TX MainFunction.
        Multiplicity [0 .. INF[
        Type EcucParamConfContainerDef
        Default value --
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_370</srcid><srcstatus/><internalId>567</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc</srcid><srcstatus/><internalId>655</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_Rx_Only</srcid><srcstatus/><internalId>656</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_TxPathWay_Only</srcid><srcstatus/><internalId>657</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_CntrTx_Only</srcid><srcstatus/><internalId>658</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMTxProcessing.IpduMTxPduRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMTxPduRef
        Description Reference to either an IpduMContainerTxPdu or IpduMTxPathway
        Multiplicity 1 .. INF[
        Type EcucReferenceDef
        Default value --
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_421</srcid><srcstatus/><internalId>570</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03008_IpduM_TxFlexAlloc_SingleMF</srcid><srcstatus/><internalId>933</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMTxProcessing.IpduMTimeBase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMTimeBase
        Description Reference timebase for the associated IpduMContainerTxPdu or IpduMTxPathway
        Multiplicity 1 .. 1
        Type EcucFloatParamDef
        Range 0 .. 3600
        Default value --
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_386</srcid><srcstatus/><internalId>568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00218</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>362</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMRxProcessing.IpduMPartitionRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMPartitionRef
        Description Reference to EcucPartition
        Multiplicity 1 .. 1
        Type EcucReferenceDef
        Default value --
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_326</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_BSWMD_PartitionRef</srcid><srcstatus/><internalId>659</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_BSWMD_DiffCheck</srcid><srcstatus/><internalId>660</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>359</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMTxProcessing.IpduMPartitionRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMPartitionRef
        Description Reference to EcucPartition
        Multiplicity 1 .. 1
        Type EcucReferenceDef
        Default value --
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_403</srcid><srcstatus/><internalId>569</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_BSWMD_PartitionRef</srcid><srcstatus/><internalId>659</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_BSWMD_DiffCheck</srcid><srcstatus/><internalId>660</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMMetaDataSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMMetaDataSupport
        Description Enables the use of MetaData support.
        Multiplicity 1 .. 1
        Type EcucBooleanParamDef
        Default value false
        Post-Build Variant Value FALSE
        Value Configuration Class
          Pre-compile time X
          Link time -
          Post-build time -
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_2042</srcid><srcstatus/><internalId>601</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Immediate</srcid><srcstatus/><internalId>907</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Deffered</srcid><srcstatus/><internalId>908</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Static</srcid><srcstatus/><internalId>909</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Negative</srcid><srcstatus/><internalId>910</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_60001_NoMetaData</srcid><srcstatus/><internalId>959</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_00009_NoMetaData</srcid><srcstatus/><internalId>968</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMMetaDataTxPrioritySupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMMetaDataTxPrioritySupport
        Description Enables support for using the highest priority of
          ContainedPdus for ContainerPdu transmission (according to the
          SAE J1939-22 standard (MAR2021; Ch. 6.3.1.1))
        Multiplicity 1 .. 1
        Type EcucBooleanParamDef
        Default value false
        Post-Build Variant Value FALSE
        Value Configuration Class
          Pre-compile time X
          Link time -
          Post-build time -
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_748</srcid><srcstatus/><internalId>579</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_19000_PrioCQ</srcid><srcstatus/><internalId>914</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_19001_PrioLB</srcid><srcstatus/><internalId>915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>IpduM.EB.RelocatablePBCfg</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In order to support post-build-time configuration data handled by relative offsets to
        the configuration start address, the container IpduMGeneral must be extended by the
        configuration parameter IpduMRelocatablePbcfgEnable.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_683</srcid><srcstatus/><internalId>577</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_PBcfgM_Off</srcid><srcstatus/><internalId>643</internalId></linkedfrom><linkedfrom><srcid>IpduM_Test_PBcfgM_On</srcid><srcstatus/><internalId>644</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_17002_LoadPbCfg</srcid><srcstatus/><internalId>879</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMCntrRx.MaxPduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Rx PDU length shall be less or equal than IpduMMaxContainerRxLength.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_809</srcid><srcstatus/><internalId>593</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03012_IpduM_CntrRx_MaxPduLength</srcid><srcstatus/><internalId>936</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMCntrRx.NoRefAcceptAll</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Contained Rx PDU shall not reference container Rx PDUs which have
        IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_276</srcid><srcstatus/><internalId>584</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03013_IpduM_CntrRx_NoRefAcceptAll</srcid><srcstatus/><internalId>937</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IpduMStaticContainerPduHandling</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMStaticContainerPduHandling
        Description En-/disables the use of static multiple-PDU-to-Container handling.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value FALSE
        Post-Build Variant Value FALSE
        Value Configuration Class
          Pre-compile time X
          All Variants
          Link time --
          Post-build time --
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_489</srcid><srcstatus/><internalId>572</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04000_IpduMStaticContainerPduHandling</srcid><srcstatus/><internalId>940</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

    <specobject>
      <id>IpduM.EB.HeaderTypeNone.CntdOverlapping</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For contained PDUs which reference container PDU with header size set to
        IPDUM_HEADERTYPE_NONE, it shall be ensured that contained PDUs belonging
        to the same container PDU do not overlap with another contained PDU or
        with a byte which contains an update bit.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_checks.m_198</srcid><srcstatus/><internalId>603</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_checks.m_275</srcid><srcstatus/><internalId>607</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04001_IpduMRx_CntdOverlapping_Cntd</srcid><srcstatus/><internalId>941</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_04002_IpduMRx_CntdOverlapping_UpdateByte</srcid><srcstatus/><internalId>942</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_04003_IpduMTx_CntdOverlapping_Cntd</srcid><srcstatus/><internalId>943</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_04004_IpduMTx_CntdOverlapping_UpdateByte</srcid><srcstatus/><internalId>944</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

    <specobject>
      <id>IpduM.EB.HeaderTypeNone.CntdSizeExceed</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For contained PDUs which reference container PDU with header size set to
        IPDUM_HEADERTYPE_NONE, it shall be ensured that none of the contained PDUs
        exceed the container PDU configured PduLength.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_checks.m_199</srcid><srcstatus/><internalId>604</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_checks.m_276</srcid><srcstatus/><internalId>608</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04005_IpduMRx_CntdSizeExceed</srcid><srcstatus/><internalId>945</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_04006_IpduMTx_CntdSizeExceed</srcid><srcstatus/><internalId>946</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

    <specobject>
      <id>IpduM.EB.HeaderTypeNone.CntdUpdateBitSizeExceed</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For contained PDUs which reference container PDU with header size set to
        IPDUM_HEADERTYPE_NONE, in case IpduMPduUpdateBitPosition is enabled, it
        shall be ensured that it does not exceed container PDU length.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_checks.m_200</srcid><srcstatus/><internalId>605</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_checks.m_277</srcid><srcstatus/><internalId>609</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04007_IpduMRx_CntdUpdateBitSizeExceed</srcid><srcstatus/><internalId>947</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_04008_IpduMTx_CntdUpdateBitSizeExceed</srcid><srcstatus/><internalId>948</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

    <specobject>
      <id>IpduM.EB.SWS_IpduM_00243</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When sending a Static Container PDU, the IpduM shall reduce the size of
        the Container PDU by omitting not updated data behind the last updated
        PDU and the last update bit.

        Caveat: By reducing the size of a Container PDU and applying a padding
        by the underlying bus, it is possible that on receiver side a contained
        PDU with the padding pattern of the bus is received. If this is not
        acceptable, it should be considered using update-bits for the contained
        PDUs or the system designer has to cope with this by other means.
      </description>
      <comment>
        Rationale:

        To optimize the used bandwidth, the IPduM shall be able to trim/shorten
        the IPDUs in case not every part of the multiplexed PDU has been updated.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07084_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>854</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07086_StaticTTLBOK</srcid><srcstatus/><internalId>855</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14012_CntrTx_TT_Partial_Update_Bit</srcid><srcstatus/><internalId>895</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14008_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>896</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14013_CntrTx_Unused_Area_PartialReception2</srcid><srcstatus/><internalId>897</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrRx.DeferredMF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When IpduM_MainFunctionRx is called, all the deferred instances of the
        associated Container Rx PDUs shall be processed.
        In this way, the IpduM ensures data consistency and that Rx indication
        data provision to the upper layer is done immediately.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05016_Deferred_Queue</srcid><srcstatus/><internalId>755</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05017_Deferred_Queue_Multiple_PDUs_ASR1911</srcid><srcstatus/><internalId>756</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05017_Deferred_Queue_Multiple_PDUs</srcid><srcstatus/><internalId>757</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05018_Deferred_MF_RxIndication_ASR1911</srcid><srcstatus/><internalId>758</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05018_Deferred_MF_RxIndication</srcid><srcstatus/><internalId>759</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05018_Deferred_MF_RxIndication_Overflow</srcid><srcstatus/><internalId>760</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing_ASR1911</srcid><srcstatus/><internalId>876</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing</srcid><srcstatus/><internalId>877</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrRx.AllowOnlyDeferred</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        References from IpduMRxProcessing container may refer only IpduMContainerRxPdu containers with IpduMContainerPduProcessing configured as IPDUM_PROCESSING_DEFERRED.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03014_IpduM_CntrRx_RxProc_DeferredOnly</srcid><srcstatus/><internalId>938</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrRx.QueuingNumInstances</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        With IpduMContainerQueueSize specified the number of instances of the ContainerRxPdu
        shall be 1 + IpduMContainerQueueSize.
      </description>
      <comment>
        The explicative text in the TX section specifies that up to IpduMContainerQueueSize
        instances can be stored in addition to the current one.
        For RX there are no details provided.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_Macros.m_126</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05016_Deferred_Queue</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrRx.DequeueOrder</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        While processing the deferred containers in IpduM_MainFunctionRx the temporal order
        in which they were received shall be maintained during normal operation.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.EB.CntrRx.DequeueOrder.NoOverFlow</srcid><srcstatus/><internalId>77</internalId></linkedfrom><linkedfrom><srcid>IpduM.EB.CntrRx.DequeueOrder.OverFlowNotRead</srcid><srcstatus/><internalId>78</internalId></linkedfrom><linkedfrom><srcid>IpduM.EB.CntrRx.DequeueOrder.OverFlowWhileReading</srcid><srcstatus/><internalId>79</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrRx.DequeueOrder.NoOverFlow</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        While processing the deferred containers in IpduM_MainFunctionRx and
        no queue overflow occured, the temporal order in which they were received shall be maintained.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2302</srcid><srcstatus/><internalId>510</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05016_Deferred_Queue</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrRx.DequeueOrder.OverFlowNotRead</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        While processing the deferred containers in IpduM_MainFunctionRx and
        a queue overflow occured before the processing took place,
        the temporal order in which they were received shall be maintained.
      </description>
      <comment>
        Case: IpduM_RxIndications() overflow the queue after which
        IpduM_MainFunctionRx() is called.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2321</srcid><srcstatus/><internalId>512</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05016_Deferred_Queue</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrRx.DequeueOrder.OverFlowWhileReading</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        While processing the deferred containers in IpduM_MainFunctionRx and
        during it a queue overflow occurs, temporal order is not maintained,
        the newest instances is dequeued before the older ones in ascending order.
      </description>
      <comment>
        Case: IpduM_RxIndications() overflow the queue while IpduM_MainFunctionRx()
        is processing them.
        Rationale: The overflow of the queue is not considered to be normal operation,
        handling this specific case would unnecessarily increase complexity.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2312</srcid><srcstatus/><internalId>511</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05018_Deferred_MF_RxIndication_Overflow</srcid><srcstatus/><internalId>760</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrTx.DequeueOrder</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        While processing queued TX containers the temporal order
        in which they were received shall be maintained.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.EB.CntrTx.DequeueOrder.NoOverFlow</srcid><srcstatus/><internalId>81</internalId></linkedfrom><linkedfrom><srcid>IpduM.EB.CntrTx.DequeueOrder.OverFlow</srcid><srcstatus/><internalId>82</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrTx.DequeueOrder.NoOverFlow</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        While processing queued TX containers no queue overflow occured,
        the temporal order in which they were received shall be maintained.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3869</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07047_TxSendTimeout_SizeTrigger</srcid><srcstatus/><internalId>828</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CntrTx.DequeueOrder.OverFlow</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        While processing queued TX containers a queue overflow occurs,
        the temporal order in which they were received shall be maintained.
      </description>
      <comment>
        Rationale: With the type change of the error IPDUM_E_QUEUEOVFL from Development
        to Runtime it is reasonable to expect continued operation.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3289</srcid><srcstatus/><internalId>536</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3870</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3893</srcid><srcstatus/><internalId>552</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07032_TriggerTransmit_Queue_2</srcid><srcstatus/><internalId>816</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07037_Dequeue_Main_Func_with_Tx_Confirm</srcid><srcstatus/><internalId>830</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07098_DeQOrder1_NoConf_Queued_TT</srcid><srcstatus/><internalId>847</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07099_DeQOrder2_NoConf_Queued_TT</srcid><srcstatus/><internalId>848</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07100_DeQOrder3_NoConf_Queued_TT</srcid><srcstatus/><internalId>849</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07101_DeQOrder4_NoConf_Queued_TT</srcid><srcstatus/><internalId>850</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

    <specobject>
      <id>IpduM.EB.RxContainerId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduMContainerRxHandleId of deferred Container PDUs has to follow those of the IpduMRxPathways and
        precede the ones of Container PDUs with IpduMContainerPduProcessing set as IPDUM_PROCESSING_IMMEDIATE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03016_IpduM_ID_of_Deferred</srcid><srcstatus/><internalId>939</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

    <specobject>
      <id>IpduM.EB.Container.Payload.Rx.Validation.SduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the provided SduLength during a call to IpduM_RxIndication() is greater than the one configured
        for a container which has IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED,
        the error IPDUM_E_CONTAINER shall be reported.
        The container shall not be processed.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05024_Payload_Validation_SduLength</srcid><srcstatus/><internalId>725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

    <specobject>
      <id>IpduM.EB.Container.Payload.Rx.Validation.DLC.Length</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a DLC value provided for a Container during reception would overflow the underlying type,
        the error IPDUM_E_HEADER shall be reported.
        The Container shall be ignored.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05025_Payload_Validation_DLC</srcid><srcstatus/><internalId>767</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>IpduM.EB.RxPathWay.SduLength.Min.Selector</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If during the reception of a Multiplexed I-PDU the SduLength is less than the byte position
        where the selector field is defined, the error IPDUM_E_PARAM shall be reported to Det.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_03101</srcid><srcstatus/><internalId>701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

    <specobject>
      <id>IpduM.EB.RxPathWay.SduLength.Min.StaticPart</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If during the reception of a Multiplexed I-PDU the SduLength is less than the byte position where the last (with the greatest IpduMSegmentPosition) IpduMStaticPart/IpduMSegment would terminate, the static part is silently ignored.
      </description>
      <comment>
        The SWS very sparsely mentions that (Chapter 7.2.5 Reception, SWS 4.2.2) : "The IpduM module separately routes the static and dynamic parts of the multiplexed I-PDU to their destinations." and "As all multiplexed I-PDUs contain a dynamic part this part always has to be routed. There are no requirements to handle or notify wrongly configured parts. Hence, if the received I-PDU contains segments not configured for reception on this ECU, they will be ignored silently". As such it makes sense to treat the static and dynamic parts separately and if one can be extracted in it's entirety it shall be done as such without regard for the other (in this case the StaticPart).
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1704</srcid><srcstatus/><internalId>500</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1739</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00081_MinSduLength_Copy</srcid><srcstatus/><internalId>674</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02099_MinSduLength_ZeroCopy</srcid><srcstatus/><internalId>698</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

    <specobject>
      <id>IpduM.EB.RxPathWay.SduLength.Min.DynamicPart</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If during the reception of a Multiplexed I-PDU the SduLength is less than the byte position where the last (with the greatest IpduMSegmentPosition) IpduMDynamicPart/IpduMSegment would terminate, the dynamic part is silently ignored.
      </description>
      <comment>
        The SWS very sparsely mentions that (Chapter 7.2.5 Reception, SWS 4.2.2) : "The IpduM module separately routes the static and dynamic parts of the multiplexed I-PDU to their destinations." and "As all multiplexed I-PDUs contain a dynamic part this part always has to be routed. There are no requirements to handle or notify wrongly configured parts. Hence, if the received I-PDU contains segments not configured for reception on this ECU, they will be ignored silently". As such it makes sense to treat the static and dynamic parts separately and if one can be extracted in it's entirety it shall be done as such without regard for the other (in this case the DynamicPart).
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1722</srcid><srcstatus/><internalId>501</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1762</srcid><srcstatus/><internalId>503</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00081_MinSduLength_Copy</srcid><srcstatus/><internalId>674</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02099_MinSduLength_ZeroCopy</srcid><srcstatus/><internalId>698</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

    <specobject>
      <id>IpduM.EB.IpduMTxRequestMaxSduLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Name: IpduMTxRequestMaxSduLength
        Parent container: IpduMGeneral
        Type: EcucIntegerParamDef
        Multiplicity: 0..1
        Default value: 32 (M4_IpduMTxRequestMaxSduLength)
        Scope/Dependency: scope ECU
        Description: The value of the parameter is used to allocate an array of that size for TxRequests.
      </description>
      <comment>
        Buffer of this size is allocated on the stack.
        Referencing PB parameters from PC context is prohibited. Size needs to be known and fixed.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_109</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_1612</srcid><srcstatus/><internalId>598</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_00007_IpduMTxRequestMaxSduLength</srcid><srcstatus/><internalId>966</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.RxContainerAcceptAllNoRefOnly_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name
        IpduMRxContainerAcceptAllNoRefOnly

        Description
        Switches the behavior of IPDUM_ACCEPT_ALL.
        False: All IpduMContainedRxPdus are accepted regardless of IpduMContainedRxInContainerPduRef,
               according to SWS_IpduM_00206 (IpduM.SWS_IpduM_00206).
        True:  IpduMContainedRxPdus which do not have IpduMContainedRxInContainerPduRef configured
               are accepted, according to SWS_IpduM_00206 (IpduM.SWS_IpduM_00206).

        Multiplicity 1

        Type EcucBooleanParamDef

        Default value -
        ConfigurationClass
        Pre-compile time X All Variants
        Link time -
        Post-build time -

        Scope / Dependency scope: local
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBSelectable.FileName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If postBuildVariant is a non-empty string, the module's post-build-time
        configuration file names shall be changed in the following way:
        IpduM_PBcfg.* to IpduM_&lt;postBuildVariant&gt;_PBcfg.* and
        IpduM_Lcfg.h to IpduM_&lt;postBuildVariant&gt;_Lcfg.h.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_16000_Variant0</srcid><srcstatus/><internalId>905</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_16001_Variant1</srcid><srcstatus/><internalId>906</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBSelectable.TypeName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If postBuildVariant is a non-empty string, the module's post-build-time
        configuration type/variable names shall be changed in the following way:
        IpduM_[Const]ConfigLayoutType to IpduM_&lt;postBuildVariant&gt;_[Const]ConfigLayoutType
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_16000_Variant0</srcid><srcstatus/><internalId>905</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_16001_Variant1</srcid><srcstatus/><internalId>906</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBSelectable.Master</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If postBuildVariant is a non-empty string, the module shall generate a post-build-time
        configuration file IpduM_PBcfg.h/c which includes all the variant specific post-build-time
        configurations (IpduM_&lt;postBuildVariant&gt;[_*]_PBcfg.h/c).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_16000_Variant0</srcid><srcstatus/><internalId>905</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_16001_Variant1</srcid><srcstatus/><internalId>906</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

    <specobject>
      <id>IpduM.EB.TriggerTransmit.MinSduLength.Pw</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduM_TriggerTransmit() is called for an IpduMTxPathway having
        IpduMTxTriggerMode configured as NONE, with an SduLength less than
        the configured PduLength, E_NOT_OK shall be returned and
        the PduInfoPtr remains unchanged.
        IPDUM_E_PARAM is reported to Det.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01002</srcid><srcstatus/><internalId>676</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

    <specobject>
      <id>IpduM.EB.TriggerTransmit.MinSduLength.Cntr</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduM_TriggerTransmit() is called for an IpduMContainerTxPdu having
        IpduMContainerTxTriggerMode configured as IPDUM_TRIGGERTRANSMIT,
        with an SduLength less than the configured PduLength,
        E_NOT_OK shall be returned and the PduInfoPtr remains unchanged.
        Transmission is reattempted in the next TX MainFunction.
        IPDUM_E_PARAM is reported to Det.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07093_TriggerTransmit_E_NOT_OK_CQ_Retry</srcid><srcstatus/><internalId>835</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07094_TriggerTransmit_E_NOT_OK_LB_Retry</srcid><srcstatus/><internalId>836</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

    <specobject>
      <id>IpduM.EB.MetaData.StoreTxMetaData</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduM_TriggerTransmit() is called, the MetaData shall be obtained from the EcuC and
        the calculated MetaData shall be stored with the Contained PDU. The calculated metadata
        will be:
        ResultMetaData = (ContainedMetaData AND IpduMTxMetaDataMask) OR (IpduMTxMetaDataValue AND (~IpduMTxMetaDataMask)).
        ResultMetaData shall be set to the container PDU and sent to the lower layer.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1802_Tx_MetaData_Mainfunction</srcid><srcstatus/><internalId>912</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1803_Tx_MetaData_NoMetadata</srcid><srcstatus/><internalId>913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

    <specobject>
      <id>IpduM.EB.MetaData.ContainerTxMetaData.FirstRequest</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If first request for container is requested, the container shall use the calculated MetaData
        as its MetaData.
        The calculated metadata of the TX container instance will be :
        ResultMetaData = (ContainedMetaData AND IpduMTxMetaDataMask) OR (IpduMTxMetaDataValue AND (~IpduMTxMetaDataMask)).
        Where ContainedMetaData is the metadata that receive from the upper layer via TxContained PDU.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1802_Tx_MetaData_Mainfunction</srcid><srcstatus/><internalId>912</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1803_Tx_MetaData_NoMetadata</srcid><srcstatus/><internalId>913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

    <specobject>
      <id>IpduM.EB.MetaData.ContainerTxMetaData.Request</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduM_Transmit() is called, the MetaData from the container shall be compared with
        the Result_MetaData of the new request. If the stored MetaData and Result_MetaData are
        the same, then a new request will be stored for the current container, else the container
        shall be triggered and a new instance created.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1802_Tx_MetaData_Mainfunction</srcid><srcstatus/><internalId>912</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1803_Tx_MetaData_NoMetadata</srcid><srcstatus/><internalId>913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.MetaData.IpduMTxMetaDataMask</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMTxMetaDataMask
        Description Mask value to obtain TxMetaData. The default value for the IpduMTxMetaDataMask is all ones.
                    This is an optional parameter.
                     The calculated metadata of the TX container instance will be :
                     ResultMetaData = (ContainedMetaData AND IpduMTxMetaDataMask) OR (IpduMTxMetaDataValue AND (~IpduMTxMetaDataMask)).
                      Where ContainedMetaData is the metadata that receive from the upper layer via TxContained PDU In case configured otherwise will be zero.
                     ResultMetaData will be set to the container PDU and will be sent to the lower layer.
                     It is changeable at run time and changeable per instance.
        Range 0 .. 4294967295
        Type EcucIntegerParamDef
        Multiplicity 0..1
        Post-Build Variant Value FALSE
        Value Configuration Class
          Pre-compile time X
          Link time -
          Post-build time -
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_529</srcid><srcstatus/><internalId>589</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1802_Tx_MetaData_Mainfunction</srcid><srcstatus/><internalId>912</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1803_Tx_MetaData_NoMetadata</srcid><srcstatus/><internalId>913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.MetaData.IpduMTxMetaDataValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMTxMetaDataValue
        Description Value of TxMetaData. The default value for the IpduMTxMetaDataValue is all zeros.
                    This is an optional parameter.
                     The calculated metadata of the TX container instance will be :
                     ResultMetaData = (ContainedMetaData AND IpduMTxMetaDataMask) OR (IpduMTxMetaDataValue AND (~IpduMTxMetaDataMask)).
                      Where ContainedMetaData is the metadata that receive from the upper layer via TxContained PDU In case configured otherwise will be zero.
                     ResultMetaData will be set to the container PDU and will be sent to the lower layer.
                     It is changeable at run time and changeable per instance.
        Range 0 .. 4294967295
        Type EcucIntegerParamDef
        Multiplicity 0..1
        Post-Build Variant Value FALSE
        Value Configuration Class
          Pre-compile time X
          Link time -
          Post-build time -
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_571</srcid><srcstatus/><internalId>590</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1802_Tx_MetaData_Mainfunction</srcid><srcstatus/><internalId>912</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1803_Tx_MetaData_NoMetadata</srcid><srcstatus/><internalId>913</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

    <specobject>
      <id>IpduM.EB.MetaData.Rx.GetMetadata</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        IpduM shall retrieve the metadata of a received container
        via API EcuC_CopyMetaDataTypeFromPdu() and shall store it localy.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2073</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2191</srcid><srcstatus/><internalId>508</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Immediate</srcid><srcstatus/><internalId>907</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Deffered</srcid><srcstatus/><internalId>908</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Static</srcid><srcstatus/><internalId>909</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Negative</srcid><srcstatus/><internalId>910</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00227</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00229</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

    <specobject>
      <id>IpduM.EB.MetaData.Rx.SetMetadata</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        IpduM shall set the metadata of a contained Pdu via API EcuC_CopyMetaDataTypeToPdu()
        using the value previously retrieved for the respective received container.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2133</srcid><srcstatus/><internalId>507</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2237</srcid><srcstatus/><internalId>509</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Immediate</srcid><srcstatus/><internalId>907</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Deffered</srcid><srcstatus/><internalId>908</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Static</srcid><srcstatus/><internalId>909</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Negative</srcid><srcstatus/><internalId>910</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00227</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00229</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>327</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

    <specobject>
      <id>IpduM.EB.MetaData.Tx.Priority.Establish</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        IpduM shall establish the priority of a ContainedPdu according to the
        SAE J1939-22 standard (MAR2021; Ch. 6.3.1.1): bits 26-28 of the 4-byte
        MetaData, the lower value representing the highest priority.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_4092</srcid><srcstatus/><internalId>554</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1802_Tx_MetaData_Mainfunction</srcid><srcstatus/><internalId>912</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_19000_PrioCQ</srcid><srcstatus/><internalId>914</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_19001_PrioLB</srcid><srcstatus/><internalId>915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

    <specobject>
      <id>IpduM.EB.MetaData.Tx.Priority.Transmit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        IpduM shall use the highest priority of the ContainedPdus of which the
        ContainerPdu is composed of (SAE J1939-22 MAR2021; Ch. 6.5.1).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_4126</srcid><srcstatus/><internalId>555</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_1802_Tx_MetaData_Mainfunction</srcid><srcstatus/><internalId>912</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_19000_PrioCQ</srcid><srcstatus/><internalId>914</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_19001_PrioLB</srcid><srcstatus/><internalId>915</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_19002_NoPrioCntdCQ</srcid><srcstatus/><internalId>916</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_19003_NoPrioCntdLB</srcid><srcstatus/><internalId>917</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

    <specobject>
      <id>IpduM.EB.MetaData.Tx.Priority.Transmit.NoContainedPrio</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case IpduMMetaDataTxPrioritySupport is enabled and a Container has MetaData
        configured (type CAN_ID_32) but none of it's ContainedPdus do, the priority
        shall be set to lowest (7).
      </description>
      <comment>
        For such a configuration a WARNING is emitted.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_870</srcid><srcstatus/><internalId>494</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2741</srcid><srcstatus/><internalId>521</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_19002_NoPrioCntdCQ</srcid><srcstatus/><internalId>916</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_19003_NoPrioCntdLB</srcid><srcstatus/><internalId>917</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CanFdPadding.IpduMCanFdPaddingSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: IpduMCanFdPaddingSupport
        Parent container: IpduMGeneral
        Type: BOOLEAN
        Multiplicity: 1
        Default value: false
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: Enables the CanFd padding service according to the SAE J1939-22 standard.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_2076</srcid><srcstatus/><internalId>602</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>
    <specobject>
      <id>IpduM.EB.CanFdPadding.IpduMCanFdPaddingService</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: IpduMCanFdPaddingService
        Parent container: IpduMContainerTxPdu
        Type: BOOLEAN
        Multiplicity: 0..1
        Default value: false
        Post-Build Variant Value TRUE
        Value Configuration Class
          Pre-compile time X
          Link time X
          Post-build time X
        Scope/Dependency: scope local
        Description: Enables padding of a container up to a valid CAN FD Data Length Code.
        When enabled, if the length of the transmitted container instance does not match possible CAN FD DLC values,
        IpduM shall use the next higher valid CAN FD DLC for transmission.
        Valid DLC values are: 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 32, 48, and 64 bytes.
        Padding shall be performed as follows: If 1 to 3 bytes of padding is required, then the padding shall be 1 to 3 bytes of 00h.
        If 4 to 15 bytes of padding is required, then the padding format shall be 3 bytes of 00h
        followed by 1 to 12 bytes of AAh.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_1037</srcid><srcstatus/><internalId>596</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_60000_Tx_CanFd_Padding_MetaData</srcid><srcstatus/><internalId>958</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>IpduM.EB.CanFdPadding.Restrictions</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduMCanFdPaddingService shall work only on Direct Tx containers with headers that have IpduMUnusedAreasDefault set to OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_1070</srcid><srcstatus/><internalId>597</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_60000_Tx_CanFd_Padding_MetaData</srcid><srcstatus/><internalId>958</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>
    <specobject>
      <id>IpduM.EB.CanFdPadding.Behavior</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduMCanFdPaddingService is enabled, IpduM shall perform padding
        for a Tx container up to the next higher valid CanFd DLC as follows:
        If 1 to 3 bytes of padding is required, then the padding shall be 1 to 3 bytes of 00h.
        If 4 to 15 bytes of padding is required, then the padding format shall be 3 bytes of 00h
        followed by 1 to 12 bytes of AAh.
      </description>
      <comment>
        Valid DLC values are: 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 32, 48, and 64 bytes.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3962</srcid><srcstatus/><internalId>553</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_1801_Tx_MetaData</srcid><srcstatus/><internalId>911</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>IpduM.ASR40.ECUC_IpduM_00053</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        Name: IpduMSegment
        Container Type: Sub-Container
        Parent Containers: IpduMRxDynamicPart, IpduMRxStaticPart, IpduMTxDynamicPart, IpduMTxStaticPart,
        Description: This contains the location and the length of a segment. A segment must fit inside 
        the I-PDU. The segment in the source I-PDU that is located at the IpduMSegmentPosition is 
        copied to the same position in the destination I-PDU.
        Lower Multiplicity: 1
        infinite
      </description>
      <comment>
        The description part "A segment must fit inside the I-PDU." can be tested.
        The length of the total segments (dynamic+static) shall be less than or equal to
        the total PDU length.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_00004_SegmentOverlap</srcid><srcstatus/><internalId>963</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.ECUC_IpduM_00124</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        Name: IpduMTxConfirmationTimeout
        Parameter Type: FloatValue
        Parent Containers: IpduMTxRequest,
        Description: This timeout (in seconds) defines the timeout period for monitoring the reception 
        of the TxConfirmation.
        Introduction: It is not used when an I-PDU is requested using the trigger transmit API.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
        Max-Value: 3600 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        See also IpduM.ASR40.SWS_IpduM_00019.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01007</srcid><srcstatus/><internalId>681</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02094</srcid><srcstatus/><internalId>693</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04008_Timeout_OneTick</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04009_Timeout_MaximumTicks</srcid><srcstatus/><internalId>710</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10009_MainFuncFlexAlloc_TxPathWay_ContainerTx</srcid><srcstatus/><internalId>878</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_00005_ConfTime</srcid><srcstatus/><internalId>964</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.ECUC_IpduM_00131</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>3</version>
      <description>
        Name: IpduMConfigurationTimeBase
        Parameter Type: FloatValue
        Parent Containers: IpduMGeneral,
        Description: The cycle time with which IpduM_MainFunction should  be invoked (in seconds)
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
        Max-Value: 3600 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        See RfC 71983 - [IpduM] Introduce separate main functions for reception and transmission.
        See ASCIPDUM-772 - Flexible allocation of PDUs to MainFunctions.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.UnsupportedIpduMConfigurationTimeBase</srcid><srcstatus/><internalId>452</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00004</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        A multiplexed I-PDU consists of a static part and a dynamic part, where the static part 
        consists of zero or more signals or signal groups. The dynamic part consists of the selector 
        field and one or more signals or signal groups; see Figure 2.
      </description>
      <comment>
        This requirement is informational only.
        Overview of module functionality, coverage achieved via further requirements.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00005</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The position of the static and the dynamic part of the multiplexer shall be arbitrary and has 
        to be configurable per I-PDU; see Figure 2, for configuration see Chapter 10.2.2.
      </description>
      <comment>
        This requirement is informational only.
        Overview of module functionality, coverage achieved via further requirements.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00006</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        It shall be possible that the static and the dynamic part consist of more than one element. 
        These elements of the static or dynamic parts are called segments.
      </description>
      <comment>
        This requirement is informational only.
        Overview of module functionality, coverage achieved via further requirements.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00007</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        There shall be only one selector field within one multiplexed I-PDU.
      </description>
      <comment>
        This requirement is not applicable.
        This restriction is also defined in the AUTOSAR schema file.
        Set this to rejected since there are more detailed requirements in the chapter 10.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00009</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The selector field of one I-PDU shall have a configurable size between one and eight contiguous 
        bits.
      </description>
      <comment>
        This requirement is not applicable.
        This requirement claims the existence of the parameter as the requirement IPDUM160_Conf does.
        Therefore this requirement is rejected since it duplicates IPDUM160_Conf.
        The functional aspect this requirement is handled in IPDUM042.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00010</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The position of the selector field within the I-PDU shall be defined by configuration.
      </description>
      <comment>
        This requirement is not applicable.
        This requirement claims the existence of the parameter as the requirement IPDUM161_Conf does.
        Therefore this requirement is rejected since it duplicates IPDUM161_Conf.
        Info: The functional aspect this requirement is handled in IPDUM042.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The configuration of the IpduM shall contain a dedicated timeout for each IpduM I-PDU within 
        the IpduM module in the configuration parameter IpduMTxConfirmationTimeout.
      </description>
      <comment>
        This requirement claims the existence of the parameter as the requirement IPDUM124_Conf does.
        Therefore this requirement is refined to IPDUM124_Conf.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ASR40.ECUC_IpduM_00124</srcid><srcstatus/><internalId>111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        In case the IpduMTxConfirmationTimeout was configured to a value greater than 0, as long as the 
        corresponding timeout timer has not elapsed, and no transmission confirmation for that 
        multiplexed I-PDU was received, the function IpduM_Transmit shall not allow a new transmission 
        request from the upper layer with a COM I-PDU that belongs to the same IpduM I-PDUs.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01005</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01013</srcid><srcstatus/><internalId>687</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02095</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04008_Timeout_OneTick</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04009_Timeout_MaximumTicks</srcid><srcstatus/><internalId>710</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10009_MainFuncFlexAlloc_TxPathWay_ContainerTx</srcid><srcstatus/><internalId>878</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        If the Tx-Confirmation is not received within the configured timeout IpduMTxConfirmationTimeout 
        the IpduM shall allow new transmission requests for this specific I-PDU after timeout is 
        elapsed.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01008</srcid><srcstatus/><internalId>682</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01013</srcid><srcstatus/><internalId>687</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01014</srcid><srcstatus/><internalId>688</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02097</srcid><srcstatus/><internalId>696</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The IpduM shall discard unexpected Tx-Confirmations silently. This may happen if a previously 
        requested transmit request has been timed out, but is confirmed now.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01008</srcid><srcstatus/><internalId>682</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02096</srcid><srcstatus/><internalId>695</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to FALSE, the IpduM module shall not report any 
        development errors.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_00000</srcid><srcstatus/><internalId>646</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00038</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The function IpduM_GetVersionInfo shall return the version information of this module. The 
        version information includes: Module ID Vendor ID Vendor specific version numbers (BSW00407)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_XX022_GetVersionInfo</srcid><srcstatus/><internalId>997</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The function IpduM_GetVersionInfo shall be pre compile time configurable On/Off by the 
        configuration parameter: IpduMVersionInfoApi.
      </description>
      <comment>
        Macro IPDUM_VERSION_INFO_API is provided for that reason.
        See also IPDUM134_Conf.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_00000</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_01000</srcid><srcstatus/><internalId>647</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_XX022_GetVersionInfo</srcid><srcstatus/><internalId>997</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        Service name: IpduM_Transmit Syntax: Std_ReturnType IpduM_Transmit( PduIdType PdumTxPduId,
         const PduInfoType* PduInfoPtr) Service ID[hex]: 0x03 Sync/Async: Synchronous Reentrancy: Non 
        Reentrant for the same PDU-ID. Reentrant for different PDU-ID. Parameters (in): PdumTxPduId ID 
        of I-PDU to be transmitted.Range: 0..(maximum number of I-PDU IDs which are multiplexed) - 1 
        PduInfoPtr A pointer to a structure with I-PDU related data that shall be transmitted: data 
        length and pointer to I-SDU buffer Parameters (inout): None Parameters (out): None Return value:
        Std_ReturnType E_OK: Transmit request is acceptedE_NOT_OK: Transmit request is not accepted 
        Description: Service is called by the PDU-Router to request a transmission.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01004</srcid><srcstatus/><internalId>678</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01011</srcid><srcstatus/><internalId>685</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02094</srcid><srcstatus/><internalId>693</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_06001_ServiceId</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00044</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        Service name: IpduM_TxConfirmation Syntax: void IpduM_TxConfirmation( PduIdType TxPduId) 
        Service ID[hex]: 0x40 Sync/Async: Synchronous Reentrancy: Reentrant for different PduIds. Non 
        reentrant for the same PduId. Parameters (in): TxPduId ID of the I-PDU that has been 
        transmitted. Parameters (inout): None Parameters (out): None Return value: None Description: 
        The lower layer communication module confirms the transmission of an I-PDU.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00024</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01005</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_06001_ServiceId</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00073</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The code of the IpduM module, as long as it is written in C, shall conform to the HIS subset of 
        the MISRA C Standard.
      </description>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        http://svn.ebgroup.elektrobit.com/svn/autosar/asc_Project/trunk/doc/project/templates/Module_RFI_Checklist_template.xltx, rev 1357 Checks='MISRA'
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00074</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The code of the IpduM module shall avoid direct use of compiler and platform specific keywords.
      </description>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        http://svn.ebgroup.elektrobit.com/svn/autosar/asc_Project/trunk/doc/project/templates/Module_RFI_Checklist_template.xltx, rev 1357 Checks='CMDB Test run result WINDOWS', 'CMDB Test run result lead platform'
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00075</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The code of the IpduM module shall indicate all global data with read-only purposes by 
        explicitly assigning the const keyword.
      </description>
      <comment>
        - Add source code tracing to all global variables
        - Global variables which are not const should have a comment which indicates that they are supposed to be changed.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/IpduM_Int.h.m4_1006</srcid><srcstatus/><internalId>478</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate/src/IpduM_Lcfg.c.m4_26</srcid><srcstatus/><internalId>479</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate/src/IpduM_Lcfg.c.m4_71</srcid><srcstatus/><internalId>480</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_621</srcid><srcstatus/><internalId>490</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_633</srcid><srcstatus/><internalId>491</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_var/xgen/IpduM.xgen_18</srcid><srcstatus/><internalId>612</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00076</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The IpduM module can use macros instead of functions where source code is used and runtime is 
        critical.
      </description>
      <comment>
        This requirement is not applicable.

      The EB IpduM implementation does not provide such macros since they are not mandatory.
      Furthermore this is not a restriction to the implementation of the IpduM since the word can
      is used.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00078</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The source code of the IpduM module shall not be processor and compiler dependent.
      </description>
      <comment>
        The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):
        http://svn.ebgroup.elektrobit.com/svn/autosar/asc_Project/trunk/doc/project/templates/Module_RFI_Checklist_template.xltx, rev 1357 Checks='CMDB Test run result WINDOWS', 'CMDB Test run result lead platform'
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00085</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        If source code for caller and callee of the function IpduM_GetVersionInfo are available, the 
        module IpduM should realize this function as a macro, defined in the module's header file.
      </description>
      <comment>
        The control if implemented as macro or function is realized by IPDUM039.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_XX022_GetVersionInfo</srcid><srcstatus/><internalId>997</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00095</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The module IpduM shall provide a file IpduM_Lcfg.c containing the link-time configurable 
        parameters.
      </description>
      <comment>
        Link time configuration is not supported.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.PostBuild</srcid><srcstatus/><internalId>449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00096</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>2</version>
      <description>
        The module IpduM shall provide a file IpduM_PBcfg.c containing the post-build time configurable 
        parameters.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/IpduM.xgen_17</srcid><srcstatus/><internalId>611</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_PBConfig</srcid><srcstatus/><internalId>654</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_16_NoPbCfg</srcid><srcstatus/><internalId>661</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00101</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>2</version>
      <description>
        The function IpduM_MainFunction shall perform the processing of the IpduM activities that are 
        not directly initiated by the calls from PDU-R. This includes at least the TxConfirmation time 
        observation.
      </description>
      <comment>
        See RfC 71983 - [IpduM] Introduce separate main functions for reception and transmission.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.UnsupportedIpduM_MainFunction</srcid><srcstatus/><internalId>453</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00103</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>2</version>
      <description>
        Service name: IpduM_MainFunction Syntax: void IpduM_MainFunction( void) Service ID[hex]: 
        0x10 Timing: FIXED_CYCLIC_WITH_PRECONDITION Description: Performs the processes of the 
        activities that are not directly initiated by the calls from PDU-R.
      </description>
      <comment>
        See RfC 71983 - [IpduM] Introduce separate main functions for reception and transmission.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.UnsupportedIpduM_MainFunction</srcid><srcstatus/><internalId>453</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00106</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        Development error values are of type uint8.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_01000</srcid><srcstatus/><internalId>647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00144</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        Each variable that shall be accessible by AUTOSAR Debugging, shall be defined as global 
        variable.
      </description>
      <comment>
        EB Debug and Trace will be supported instead.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.AutosarDebugging</srcid><srcstatus/><internalId>447</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00145</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        All type definitions of variables, which shall be debugged, shall be accessible by the header 
        file IpduM.h.
      </description>
      <comment>
        EB Debug and Trace will be supported instead.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.AutosarDebugging</srcid><srcstatus/><internalId>447</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00146</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The declaration of variables in the header file shall be such, that it is possible to calculate 
        the size of the variables by C-"sizeof"
      </description>
      <comment>
        EB Debug and Trace will be supported instead.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.AutosarDebugging</srcid><srcstatus/><internalId>447</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00147</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        Variables available for debugging shall be described in the respective Basic Software Module 
        Description.
      </description>
      <comment>
        EB Debug and Trace will be supported instead.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.AutosarDebugging</srcid><srcstatus/><internalId>447</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00148</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The file IpduM.c shall include IpduM.h, IpduM_Cbk.h, PduR_IpduM.h, and optionally IpduM_Cfg.h, 
        Det.h and Com.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00148_1</srcid><srcstatus/><internalId>366</internalId></linkedfrom><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00148_2</srcid><srcstatus/><internalId>367</internalId></linkedfrom><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00148_3</srcid><srcstatus/><internalId>368</internalId></linkedfrom><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00148_4</srcid><srcstatus/><internalId>369</internalId></linkedfrom><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00148_5</srcid><srcstatus/><internalId>370</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00149</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The file IpduM_Lcfg.c shall include IpduM.h.
      </description>
      <comment>
        This requirement is not applicable: EB convention for file structure is used.
        Implementation is distributed over several implementation files.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.FileInclusion</srcid><srcstatus/><internalId>450</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00150</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The file IpduM_PBcfg.c shall include IpduM.h.
      </description>
      <comment>
        This requirement is not applicable: EB convention for file structure is used.
        Implementation is distributed over several implementation files.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.FileInclusion</srcid><srcstatus/><internalId>450</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00151</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        File IpduM.h shall include MemMap.h, SchM_IpduM.h and ComStack_Types.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00151_1</srcid><srcstatus/><internalId>371</internalId></linkedfrom><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00151_2</srcid><srcstatus/><internalId>374</internalId></linkedfrom><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00151_3</srcid><srcstatus/><internalId>375</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00155</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        BSW02802)
        Restricting the selector field to be within one byte helps avoiding endianness related
        problems regarding the selector field.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_00001_Rx_SelectorBoundary</srcid><srcstatus/><internalId>960</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_00002_Tx_SelectorBoundary</srcid><srcstatus/><internalId>961</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00165</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        The IpduM module shall perform Inter Module Checks to avoid integration of incompatible files. 
        The imported include files shall be checked by preprocessing directives. The following version 
        numbers shall be verified: &lt;MODULENAME&gt;_AR_RELEASE_MAJOR_VERSION &lt;MODULENAME&gt;
        _AR_RELEASE_MINOR_VERSION &lt;MODULENAME&gt; is the module's short name of the other (external) 
        module, which provides header files included by the IpduM module. If the values are not 
        identical to the expected values, an error shall be reported.
      </description>
      <comment>
        This requirement is not applicable.
        Conflicts with EB coding guideline BSWM_CHK_401 (...inter-module version-checks SHALL NOT be done...).
        See:
        http://wiki.elektrobit.com/index.php/Project:EB_tresos/Engineering_AutoCore/Software_Construction/Coding_Guidelines
        See also https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-403
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.ConsChck</srcid><srcstatus/><internalId>448</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00170</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_0_3.xml</source>
      <version>1</version>
      <description>
        BSW00402 in the General Requirements on Basic Software Modules [3] shall be
        published within the header file of this module and need to be provided in the BSW
        Module Description. The according module abbreviation can be found in the List of
        Basic Software Modules [1]
        Additional module-specific published parameters are listed below if applicable.
      </description>
      <comment>
        The requirement IpduM.ASR40.SWS_IpduM_00170 is replaced by IPDUM.EB.IPDUM507.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.ConsChck</srcid><srcstatus/><internalId>448</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>
    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00166</id>
      <status>approved</status>
      <version>1</version>
      <description>
        description=The endianness of signals of the de-multiplexed I-PDUs configured in COM
        must match the endianness of the corresponding multiplexed I-PDU in IpduM
        as configured per IpduMByteOrder (IPDUM162_Conf)
      </description>
      <comment>
        Info: This is only relevant for the selector.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.LittleEndiannessOnly</srcid><srcstatus/><internalId>444</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>IpduM.ASR42.ECUC_IpduM_00172</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_2_1.xml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedPduHeaderId
        Parameter Type: Integer
        Parent Containers: IpduMContainedRxPdu, IpduMContainedTxPdu,
        Description: Header Id which is part of the ContainerPdu when this ContainedPdu is inside.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 1 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>
    <specobject>
      <id>IpduM.ASR42.ECUC_IpduM_00190</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_2_1.xml</source>
      <version>2</version>
      <description>
        Name: IpduMContainerTxConfirmationTimeout
        Parameter Type: FloatValue
        Parent Containers: IpduMContainerTxPdu,
        Description: This timeout (in seconds) defines the timeout period for monitoring the reception 
        of the TxConfirmation. It is not used when an I-PDU is requested using the trigger transmit API.
        Introduction: If this Parameter is omitted, the default value shall be used.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.ASR42.SWS_IpduM_00189.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ASR42.ECUC_IpduM_00190.AlwaysConsidered</srcid><srcstatus/><internalId>415</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>
    <specobject>
      <id>IpduM.ASR42.SWS_IpduM_00189</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_2_1.xml</source>
      <version>1</version>
      <description>
        In case the IpduMContainerTxConfirmationTimeout is configured to a value greater than 0, as 
        long as the corresponding transmission confirmation timeout timer has not elapsed, and no 
        transmission confirmation for that Container PDU was received, the IpduM shall wait for the 
        TxConfirmation before invoking PduR_IpduMTransmit for the next instance of that Container PDU.
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07008_TxConfAwait_3</srcid><srcstatus/><internalId>778</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07043_TriggerTransmit_E_NOT_OK_3</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07028_Transmit_E_NOT_OK</srcid><srcstatus/><internalId>798</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07090_NoErroneousDoubleTx</srcid><srcstatus/><internalId>812</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07091_NoErroneousDoubleTx2</srcid><srcstatus/><internalId>813</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07044_TriggerTransmit_Queue_5_LB</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07053_TriggerTransmit_Queue_5_LB_E_NOT_OK</srcid><srcstatus/><internalId>821</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07035_TxConfirm_Queue_NextInstance</srcid><srcstatus/><internalId>826</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07050_TT_Queued_NoCntrQueuing</srcid><srcstatus/><internalId>831</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>
    <specobject>
      <id>IpduM.ASR42.SWS_IpduM_00197</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_2_1.xml</source>
      <version>1</version>
      <description>
        A TxConfirmation for a contained I-PDU shall only be configurable if for the corresponding 
        Container PDU has a IpduMContainerTxConfirmationTimeout is configured.? (SRS_IpduM_02820)
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Requirement is covered and verified by VSMD checker.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03001_IpduMContainedTxPduConfirmation</srcid><srcstatus/><internalId>927</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>
    <specobject>
      <id>IpduM.ASR42.SWS_IpduM_00198</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_2_1.xml</source>
      <version>1</version>
      <description>
        The IpduM shall discard unexpected Tx-Confirmations silently.
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07024_TxConfirmationTimeout</srcid><srcstatus/><internalId>789</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07041_ContainerSeparation</srcid><srcstatus/><internalId>823</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07034_TxConfirm_Queue_SameContainedPdu</srcid><srcstatus/><internalId>825</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07066_SizeAnnounceOnlyOnce2</srcid><srcstatus/><internalId>838</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_09001_MainFuncTx_TxConfTimeout</srcid><srcstatus/><internalId>865</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>
    <specobject>
      <id>IpduM.ASR42.SWS_IpduM_00218</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_2_1.xml</source>
      <version>1</version>
      <description>
        If the IpduMContainerTxSendTimeout is omitted all IpduMContainedTxPdu have to provide a 
        IpduMContainedTxPduSendTimeout.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Requirement is covered and verified by VSMD checker.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03000_IpduMContainedTxPduSendTimeout</srcid><srcstatus/><internalId>926</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>IpduM.ASR43.ECUC_IpduM_00200</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_3_1.xml</source>
      <version>1</version>
      <description>
        Name: IpduMRxTimeBase
        Parameter Type: FloatValue
        Parent Containers: IpduMGeneral,
        Description: The period between successive calls to IpduM_MainFunctionRx in seconds. This 
        parameter may be used by the IpduM generator to transform the values of the reception related 
        timing configuration parameters of the IpduM module to internal implementation specific counter 
        or tick values. The IpduM module's internal timing handling is implementation specific.
        Introduction: The IpduM module (generator) may rely on the fact that IpduM_MainFunctionRx is 
        scheduled according to the value configured here.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: Inf (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <comment>
        The value of IpduMRxTimeBase is not directly used within the IpduM but the
        module's internal time out counter depends on it.
        Incorporated Bugzilla RfC 71983 'Introduce separate main functions for reception and transmission',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=71983 .
      </comment>
      <releases>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_04008_Timeout_OneTick</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04009_Timeout_MaximumTicks</srcid><srcstatus/><internalId>710</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10009_MainFuncFlexAlloc_TxPathWay_ContainerTx</srcid><srcstatus/><internalId>878</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_1942</srcid><srcstatus/><internalId>599</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>
    <specobject>
      <id>IpduM.ASR43.ECUC_IpduM_00201</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ IpduM_4_3_1.xml</source>
      <version>1</version>
      <description>
        Name: IpduMTxTimeBase
        Parameter Type: FloatValue
        Parent Containers: IpduMGeneral,
        Description: The period between successive calls to IpduM_MainFunctionTx in seconds. This 
        parameter may be used by the IpduM generator to transform the values of the reception related 
        timing configuration parameters of the IpduM module to internal implementation specific counter 
        or tick values. The IpduM module's internal timing handling is implementation specific.
        Introduction: The IpduM module (generator) may rely on the fact that IpduM_MainFunctionTx is 
        scheduled according to the value configured here.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: Inf (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <comment>
        The value of IpduMTxTimeBase is not directly used within the IpduM but the
        module's internal confirmation time out counter depends on it.
        ConfirmationTimeout = IpduMTxConfirmationTimeout / IpduMTxTimeBase
        Incorporated Bugzilla RfC 71983 'Introduce separate main functions for reception and transmission',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=71983 .
      </comment>
      <releases>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_04008_Timeout_OneTick</srcid><srcstatus/><internalId>709</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04009_Timeout_MaximumTicks</srcid><srcstatus/><internalId>710</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10009_MainFuncFlexAlloc_TxPathWay_ContainerTx</srcid><srcstatus/><internalId>878</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_1972</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>IpduM.ECUC_IpduM_00047</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxIndication
        Container Type: Sub-Container
        Parent Containers: IpduMRxPathway,
        Sub-Containers: IpduMRxDynamicPart IpduMRxDynamicSegment IpduMRxStaticPart IpduMRxStaticSegment
        IpduMSelectorField
        Description: Contains the configuration for incoming RxIndication calls.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00048</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxDynamicPart
        Container Type: Sub-Container
        Parent Containers: IpduMRxIndication,
        Description: This container contains the configuration for the dynamic part of incoming
        RxIndication calls. When an incoming received I-PDU's selector field matches the
        IpduMRxSelectorValue, the new outgoing I-PDU for the dynamic part is constructed as defined by
        the segments (defined in the IpduMDynamicSegment container) and sent out with the I-PDU ID
        referenced by IpduMOutgoingDynamicPduRef.
        Introduction: In case no dynamic part shall be extracted from this received I-PDU this
        container does not exist. This use-case can occur in case a MultiplexedIPdu is received by an
        ECU which is only interested in the static part of the MultiplexedIPdu.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00049</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxStaticPart
        Container Type: Sub-Container
        Parent Containers: IpduMRxIndication,
        Description: This container contains the configuration for the static part of incoming
        RxIndication calls. On reception, the new outgoing I-PDU for the static part is constructed as
        defined by the segments (defined in the IpduMStaticSegment container) and sent out with the I-
        PDU ID referenced by IpduMOutgoingStaticPduRef.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00052</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxRequest
        Container Type: Sub-Container
        Parent Containers: IpduMTxPathway,
        Sub-Containers: IpduMSelectorField IpduMTxDynamicPart IpduMTxDynamicSegment IpduMTxStaticPart
        IpduMTxStaticSegment
        Description: This container is used to specify the configuration for Transmit requests.
        Introduction: There will be one instance of this container for each I-PDU that can be requested
        for transmission (the outgoing I-PDUs) by the IpduM.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxDynamicPart
        Container Type: Sub-Container
        Parent Containers: IpduMTxRequest,
        Description: Configuration parameters for an instance of a TxRequest call into the IpduM. When
        a Tx Request with the IpduMTxDynamicHandleId is received by the IpduM, all segments (defined in
        the IpduMDynamicSegment container) are copied from the incoming I-PDU into the outgoing I-PDU
        buffer and then the send mode honored. This container is used by the dynamic part of a
        TxRequest configuration. Therefore, for each outgoing I-PDU there will be one instance of this
        container for the dynamic part.
        Lower Multiplicity: 1
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00059</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMConfig
        Container Type: Container
        Sub-Containers: IpduMContainedRxPdu IpduMContainedTxPdu IpduMContainerRxPdu IpduMContainerTxPdu
        IpduMMainFunctionRx IpduMMainFunctionTx IpduMRxPathway IpduMTxPathway
        Description: This container contains the sub containers of the IpduM module.
        Introduction: * The IpduMTxPathway subcontainer includes information about sent I-PDUs. * The
        IpduMRxPathway includes information about received I-PDUs. * The IpduMContainerTxPdu and
        IpduMContainedTxPdu include information about the sending of ContainerPdus. * The
        IpduMContainerRxPdu and IpduMContainedRxPdu include information about the reception of
        ContainerPdus.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00070</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxPathway
        Container Type: Sub-Container
        Parent Containers: IpduMConfig,
        Sub-Containers: IpduMTxRequest
        Description: Contains the configuration parameters transmitted I-PDUs by the IpduM module.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00071</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxPathway
        Container Type: Sub-Container
        Parent Containers: IpduMConfig,
        Sub-Containers: IpduMRxIndication
        Description: Contains the configuration parameters received I-PDUs by the IpduM module.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00082</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxStaticPart
        Container Type: Sub-Container
        Parent Containers: IpduMTxRequest,
        Description: Configuration parameters for an instance of a Tx_Request call into the IpduM. When
        a Tx Request with the IpduMTxStaticHandleId is received by the IpduM, all segments (defined in
        the IpduMStaticSegment container) are copied from the incoming I-PDU into the outgoing I-PDU
        buffer and then the send mode honored. This container is used for the static part of a
        TxRequest configuration. Therefore, for each outgoing I-PDU there will be one instance of this
        container for the static part if it exists.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00108</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxIndicationPduRef
        Parameter Type: Reference
        Parent Containers: IpduMRxIndication,
        Description: Reference to the received Pdu representation in the ECU Configuration Description
        exchange file.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00109</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxHandleId
        Parameter Type: Integer
        Parent Containers: IpduMRxIndication,
        Description: This is the I-PDU ID of the incoming I-PDU. If an incoming RxIndication's I-PDU ID
        matches this value then it is unpacked according to the specification in this container.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_02000_SymbolicNames</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04002_SymbolicNameValues40</srcid><srcstatus/><internalId>703</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00112</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMOutgoingDynamicPduRef
        Parameter Type: Reference
        Parent Containers: IpduMRxDynamicPart,
        Description: When the new I-PDU is sent out it is sent with this I-PDU ID. Reference to the
        sent PDU representation in the ECU Configuration Description exchange file.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00113</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxSelectorValue
        Parameter Type: Integer
        Parent Containers: IpduMRxDynamicPart,
        Description: This is the selector value that this container refers to.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduMRxSelectorValue.UpperMultiplicity</srcid><srcstatus/><internalId>474</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ECUC_IpduM_00113.1</srcid><srcstatus/><internalId>364</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00114</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMSegmentLength
        Parameter Type: Integer
        Parent Containers: IpduMRxDynamicSegment, IpduMRxStaticSegment, IpduMTxDynamicSegment,
        IpduMTxStaticSegment,
        Description: Length of the segment in bits.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 2032 (Type:
        Min-Value: 1 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00115</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMOutgoingStaticPduRef
        Parameter Type: Reference
        Parent Containers: IpduMRxStaticPart,
        Description: When the new I-PDU is sent out it is sent with this I-PDU ID. Reference to the
        sent Pdu representation in the ECU Configuration Description exchange file.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00120</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMOutgoingPduRef
        Parameter Type: Reference
        Parent Containers: IpduMTxRequest,
        Description: Reference to the PDU defining the outgoing I-PDU.
        Introduction: When the outgoing I-PDU is sent this is the I-PDU ID to give it. It is the IpduM
        I-PDU ID of the assembled I-PDU.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00121</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMIPduUnusedAreasDefault
        Parameter Type: Integer
        Parent Containers: IpduMTxRequest,
        Description: IpduM module fills not used areas of an I-PDU with this bit-pattern
        Introduction: If this attribute is omitted the IpduM module does not fill the I-PDU.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The description part is fully covered by IPDUM067.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00125</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxTriggerMode
        Parameter Type: Enumeration
        Parent Containers: IpduMTxRequest,
        Description: Selects whether to send the multiplexed I-PDU immediately or at some later date.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: DYNAMIC_PART_TRIGGER, AUTOSAR_ECUC
        Enumeration Literal: NONE, AUTOSAR_ECUC
        Enumeration Literal: STATIC_OR_DYNAMIC_PART_TRIGGER, AUTOSAR_ECUC
        Enumeration Literal: STATIC_PART_TRIGGER, AUTOSAR_ECUC
      </description>
      <comment>
        This requirement is in relation to IpduM.ASR40.SWS_IpduM_00021.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00021</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01005</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01006</srcid><srcstatus/><internalId>680</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01008</srcid><srcstatus/><internalId>682</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01010</srcid><srcstatus/><internalId>684</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00126</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxDynamicPduRef
        Parameter Type: Reference
        Parent Containers: IpduMTxDynamicPart,
        Description: Reference to the Pdu representation in the ECU Configuration Description exchange
        file to be transmitted.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00127</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxDynamicHandleId
        Parameter Type: Integer
        Parent Containers: IpduMTxDynamicPart,
        Description: This defines an incoming handle id. When the handle of an incoming Tx Request
        matches this id, the configured dynamic segments are copied and the IpduMTxTriggerMode is
        honored.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ECUC_IpduM_00127.Postbuild</srcid><srcstatus/><internalId>418</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00128</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxStaticPduRef
        Parameter Type: Reference
        Parent Containers: IpduMTxStaticPart,
        Description: Reference to the Pdu representation in the ECU Configuration Description exchange
        file to be transmitted.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00129</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxStaticHandleId
        Parameter Type: Integer
        Parent Containers: IpduMTxStaticPart,
        Description: This defines an incoming handle id. When the handle of an incoming Tx Request
        matches this id, the configured static segments are copied and the IpduMTxTriggerMode is
        honored.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ECUC_IpduM_00129.Postbuild</srcid><srcstatus/><internalId>419</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00130</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMGeneral
        Container Type: Container
        Description: Contains the general configuration parameters of IpduM.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00132</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMDevErrorDetect
        Parameter Type: Boolean
        Parent Containers: IpduMGeneral,
        Description: Switches the development error detection and notification on or off.
        Introduction: * true: detection and notification is enabled. * false: detection and
        notification is disabled.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        See also IpduM.ASR40.SWS_IpduM_00027, IpduM.SWS_IpduM_00028, IpduM.SWS_IpduM_00153.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00133</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMStaticPartExists
        Parameter Type: Boolean
        Parent Containers: IpduMGeneral,
        Description: This is to allow optimizations in the case the IpduM will never be used with a
        static part.
        Introduction: Note that this is a pre-compile option. If this is set to False then it will not
        be possible to add static parts after compilation. True: A static part may exist. False: A
        static part will never exist.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_00000</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_01000</srcid><srcstatus/><internalId>647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00134</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMVersionInfoApi
        Parameter Type: Boolean
        Parent Containers: IpduMGeneral,
        Description: Active/Deactivate the version information API.
        Introduction: true: version information activated false: version information deactivated
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Requirement is checked by VSMD checker.
        It is fully covered by IPDUM039.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00141</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMPublishedInformation
        Container Type: Container
        Description: Additional published parameters not covered by
        Introduction: CommonPublishedInformation container. Note that these parameters do not have any
        configuration class setting, since they are published information.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00142</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxDirectComInvocation
        Parameter Type: Boolean
        Parent Containers: IpduMPublishedInformation,
        Description: If set to TRUE the COM invocation optimization as defined in
        Introduction: IPDUM140 is implemented.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PUBLISHED-INFORMATION, VARIANT-LINK-TIME
        Value-Configuration Class: PUBLISHED-INFORMATION, VARIANT-POST-BUILD
        Value-Configuration Class: PUBLISHED-INFORMATION, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        The parameter it self is set to not editable. See also deviation [ASCIPDUM-203].
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.IpduMRxDirectComInvocation</srcid><srcstatus/><internalId>445</internalId></linkedfrom><linkedfrom><srcid>dev.PartlyImplementedFunctionalities</srcid><srcstatus/><internalId>469</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00157</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMInitialDynamicPart
        Parameter Type: Reference
        Parent Containers: IpduMTxRequest,
        Description: Reference to the dynamic part that shall be used to initialize this multiplexed TX-
        I-PDU.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IpduM/IpduMConfig/IpduMTxPathway/IpduMTxRequest/
        IpduMTxDynamicPart
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (checked by VSMD checker).
        The functional part is completely covered by IPDUM068.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00158</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxConfirmationPduId
        Parameter Type: Integer
        Parent Containers: IpduMTxRequest,
        Description: Handle Id used by the PduR for confirmation (IpduM_TxConfirmation)&lt;b&gt; &lt;/b&gt;and for
        TriggerTransmit (IpduM_TriggerTransmit)
        Introduction: The existence of this parameter is essential for the PduR generation tool to
        actually find a symbolicNameValue for the OutgoingPdu.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        The multiplicity of this parameter has to be considered as one. The description already
        mentions that this parameter is essential for the configuration code generation.
        Please see also the deviation entry which references this requirement.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.TxConfirmationPduId</srcid><srcstatus/><internalId>451</internalId></linkedfrom><linkedfrom><srcid>dev.PartlyImplementedFunctionalities</srcid><srcstatus/><internalId>469</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ECUC_IpduM_00158.Postbuild</srcid><srcstatus/><internalId>420</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00159</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMSegmentPosition
        Parameter Type: Integer
        Parent Containers: IpduMRxDynamicSegment, IpduMRxStaticSegment, IpduMTxDynamicSegment,
        IpduMTxStaticSegment,
        Description: Segments bit position in the multiplexed Pdu.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 2031 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00160</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMSelectorFieldLength
        Parameter Type: Integer
        Parent Containers: IpduMSelectorField,
        Description: Length of the selector field in bits.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 16 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ECUC_IpduM_00160.1</srcid><srcstatus/><internalId>421</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduMSelectorFieldLength.Range</srcid><srcstatus/><internalId>475</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00161</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMSelectorFieldPosition
        Parameter Type: Integer
        Parent Containers: IpduMSelectorField,
        Description: Selector field bit position in the multiplexed Pdu.
        Introduction: Range: 0..63 for CAN/ LIN I-PDUs, 0..511 for CAN FD I-PDUs, 0..2031 for FlexRay I-
        PDUs.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 2031 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00020</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00021</srcid><srcstatus/><internalId>664</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00162</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMByteOrder
        Parameter Type: Enumeration
        Parent Containers: IpduMRxIndication, IpduMTxRequest,
        Description: This parameter defines the ByteOrder for all segments (static and dynamic part)
        and for the selectorField within the MultiplexedPdu.
        Introduction: The absolute position of a segment in the MultiplexedIPdu is determined by the
        definition of the ByteOrder parameter: If BIG_ENDIAN is specified, the SegmentPosition
        indicates the bit position of the most significant bit in an IPDU. If LITTLE_ENDIAN is
        specified, the SegmentPosition indicates the bit position of the least significant bit in an
        IPDU.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: BIG_ENDIAN, AUTOSAR_ECUC
        Enumeration Literal: LITTLE_ENDIAN, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.

        Covered by VSMD checker.

        There is a deviation regarding to the parameter range of the endianess. The requirement is
        only realized for LITTLE_ENDIAN. The endianess is handled with IPDUM.EB.IPDUM560. The
        deviation regarding the endianess has the tag [ASCIPDUM-198].

        See also similar requirement: IpduM.ECUC_IpduM_00162_1
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.LittleEndiannessOnly</srcid><srcstatus/><internalId>444</internalId></linkedfrom><linkedfrom><srcid>dev.PartlyImplementedFunctionalities</srcid><srcstatus/><internalId>469</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00163</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxDynamicConfirmation
        Parameter Type: Boolean
        Parent Containers: IpduMTxDynamicPart,
        Description: A transmit request can be confirmed by the lower layer. If this parameter is set
        to true a confirmation of the I-PDU in COM representing the dynamic part is generated.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        Covered by VSMD checker.
        Requirement is applied to test cases with disabled parameter, IPDUM022 if enabled.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00024</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04001_DisabledConfirmation</srcid><srcstatus/><internalId>702</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04005_DisabledConfirmation</srcid><srcstatus/><internalId>706</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04007_DisabledConfirmation</srcid><srcstatus/><internalId>708</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00164</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxStaticConfirmation
        Parameter Type: Boolean
        Parent Containers: IpduMTxStaticPart,
        Description: A transmit request can be confirmed by the lower layer. If this parameter is set
        to true a confirmation of the I-PDU in COM representing the static part is generated.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        Covered by VSMD checker.
        Requirement is applied to test cases with disabled parameter, IPDUM022 if enabled.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00024</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04001_DisabledConfirmation</srcid><srcstatus/><internalId>702</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04005_DisabledConfirmation</srcid><srcstatus/><internalId>706</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00167</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMJitUpdate
        Parameter Type: Boolean
        Parent Containers: IpduMTxDynamicPart, IpduMTxStaticPart,
        Description: If configured to true fetch the data of this part Just-In-Time via the
        triggerTransmit API of the PduR.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification (covered by
        VSMD checker). The functionality described is completely covered by requirements IPDUM168
        and IPDUM169.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The number of values used of the selector field, i.e. values used to distinguish between
        different I-PDU layouts, does not have to be the whole range of possible values.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01003</srcid><srcstatus/><internalId>677</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01004</srcid><srcstatus/><internalId>678</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02093</srcid><srcstatus/><internalId>692</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02094</srcid><srcstatus/><internalId>693</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For a multiplexed I-PDU IpduM shall merge the corresponding two COM I-PDUs representing the
        associated static part and the last received dynamic part into one single IpduM I-PDU with a
        new unique I-PDU ID. IpduM shall send out this new IpduM I-PDU to the PDU Router module, see
        also Figure 1.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00021</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01004</srcid><srcstatus/><internalId>678</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01016</srcid><srcstatus/><internalId>690</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02094</srcid><srcstatus/><internalId>693</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_01001_BC_TX</srcid><srcstatus/><internalId>971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function IpduM_Transmit shall assemble the multiplexed I-PDU, using the related static and
        dynamic part, and transmit it according to the trigger conditions/ modes as defined in
        SWS_IpduM_00021 and ECUC_IpduM_00125.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00021</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01004</srcid><srcstatus/><internalId>678</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01016</srcid><srcstatus/><internalId>690</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_01001_BC_TX</srcid><srcstatus/><internalId>971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00021</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The IpduM module shall be configurable to send a transmission request for the new multiplexed I-
        PDU to the PDU Router because of the following trigger conditions/ modes:
        receiving a static part
        receiving a dynamic part
        receiving a static or a dynamic part
        does not trigger transmission because of receiving anything of this I-PDU (IpduMTxTriggerMode
        None) in case of TriggerTransmit
        For configuration, see ECUC_IpduM_00052.
      </description>
      <comment>
        This requirement is not applicable.
        'see IPDUM052_CONF' is most probably a typo and IPDUM125_Conf is meant instead of.
        This requirement claims the existence of the parameter as the requirement IPDUM125_Conf does.
        Therefore this requirement is rejected since it duplicates IPDUM125_Conf.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the IpduM receives a TxConfirmation for a specific IpduM I-PDU, it shall translate this
        confirmation into the corresponding confirmations for the COM I-PDUs, which were contained in
        the last sent out multiplexed IpduM I-PDU.
      </description>
      <comment>
        The requirement is applied to Tx pathways where the confirmation of the considered
        COM I-PDU is enabled. For disabled confirmations the requirements IPDUM163_Conf and
        IPDUM164_Conf are applied.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00021</srcid><srcstatus/><internalId>664</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01005</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01007</srcid><srcstatus/><internalId>681</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02095</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04004_TxConfTime_Zero</srcid><srcstatus/><internalId>705</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04005_DisabledConfirmation</srcid><srcstatus/><internalId>706</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04006_DisabledConfirmation</srcid><srcstatus/><internalId>707</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04007_DisabledConfirmation</srcid><srcstatus/><internalId>708</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_01001_BC_TX</srcid><srcstatus/><internalId>971</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE, all IpduM APIs shall check their input parameters
        and report detected errors to DET via Det_ReportError. IPDUM_E_PARAM shall be reported for
        normal parameters and IPDUM_E_PARAM_POINTER for pointer parameters.
      </description>
      <furtherinfo>
        Justifying rule: WRN.swurs.needscoverage.count
        IpduMDevErrorDetect has a high impact in the module, therefore more refinements are necessary.
      </furtherinfo>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00028_1</srcid><srcstatus/><internalId>382</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_2</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_3</srcid><srcstatus/><internalId>384</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_4</srcid><srcstatus/><internalId>385</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_5</srcid><srcstatus/><internalId>386</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_6</srcid><srcstatus/><internalId>387</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_7</srcid><srcstatus/><internalId>388</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_8</srcid><srcstatus/><internalId>389</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_9</srcid><srcstatus/><internalId>390</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_10</srcid><srcstatus/><internalId>391</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_11</srcid><srcstatus/><internalId>392</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00032</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | IpduM_Init
        Syntax
        void IpduM_Init (const IpduM_ConfigType* config)
        Service ID [hex] | 0x00
        Sync/Async | Synchronous
        Reentrancy | Non Reentrant
        Parameters (in) | config | Implementation specific structure with configuration parameters.
        Parameters (inout) | None
        Parameters (out) | None
        Return value | None
        Description | Initializes the I-PDU Multiplexer. In configurations, in which IpduM is assigned
        to more than one partition (i.e. IpduM_MainFunctions are mapped to partitions), IpduM may
        provide one init function per partition.
        Available via | IpduM.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_00000</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_01000</srcid><srcstatus/><internalId>647</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_06001_ServiceId</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function IpduM_Init shall initialize all module-related global variables.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00025_InitDefaultValues</srcid><srcstatus/><internalId>666</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00026_InitDefaultValuesTTNotOK</srcid><srcstatus/><internalId>667</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00030_PduInit</srcid><srcstatus/><internalId>668</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | IpduM_GetVersionInfo
        Syntax
        void IpduM_GetVersionInfo (Std_VersionInfoType* versioninfo)
        Service ID [hex] | 0x01
        Sync/Async | Synchronous
        Reentrancy | Reentrant
        Parameters (in) | None
        Parameters (inout) | None
        Parameters (out) | versioninfo | Pointer to where to store the version information of this
        module.
        Return value | None
        Description | Service returns the version information of this module.
        Available via | IpduM.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_06001_ServiceId</srcid><srcstatus/><internalId>973</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_XX022_GetVersionInfo</srcid><srcstatus/><internalId>997</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | IpduM_RxIndication
        Syntax
        void IpduM_RxIndication (PduIdType RxPduId, const PduInfoType* PduInfoPtr)
        Service ID [hex] | 0x42
        Sync/Async | Synchronous
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | RxPduId | ID of the received PDU.
        PduInfoPtr | Contains the length (SduLength) of the received PDU, a pointer to a buffer (
        SduDataPtr) containing the PDU, and the MetaData related to this PDU.
        Parameters (inout) | None
        Parameters (out) | None
        Return value | None
        Description | Indication of a received PDU from a lower layer communication interface module.
        Available via | IpduM.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_00000</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_01000</srcid><srcstatus/><internalId>647</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01012</srcid><srcstatus/><internalId>686</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_06001_ServiceId</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If there is a static part configured in a multiplexed SDU received from the PDU Router, the
        function IpduM_RxIndication transforms the incoming I-PDU ID into the correct I-PDU ID for the
        static part's destination and then forwards the SDU via the PDU Router, see
        PduR_IpduMRxIndication in the PDU Router SWS.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00020</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01003</srcid><srcstatus/><internalId>677</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02093</srcid><srcstatus/><internalId>692</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_01000_BC_RX</srcid><srcstatus/><internalId>970</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00042</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When a multiplexed I-PDU is received from the PDU Router the function IpduM_RxIndication uses
        the incoming I-PDU ID and the selector field to find out the correct I-PDU ID for the dynamic
        part's destination and then forwards the I-PDU via the PDU Router, see PduR_IpduMRxIndication
        in the PDU Router SWS.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00020</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01003</srcid><srcstatus/><internalId>677</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01017</srcid><srcstatus/><internalId>691</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02093</srcid><srcstatus/><internalId>692</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_03099</srcid><srcstatus/><internalId>699</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_01000_BC_RX</srcid><srcstatus/><internalId>970</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>2</version>
      <description>
        Service Name | IpduM_Transmit
        Syntax
        Std_ReturnType IpduM_Transmit (PduIdType TxPduId, const PduInfoType* PduInfoPtr)
        Service ID [hex] | 0x49
        Sync/Async | Synchronous
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | TxPduId | Identifier of the PDU to be transmitted
        PduInfoPtr | Length of and pointer to the PDU data and pointer to MetaData.
        Parameters (inout) | None
        Parameters (out) | None
        Return value | Std_ReturnType | E_OK: Transmit request has been accepted.E_NOT_OK: Transmit
        request has not been accepted.
        Description | Requests transmission of a PDU.
        Available via | IpduM.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Transmit.ServiceId</srcid><srcstatus/><internalId>461</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00044</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | IpduM_TxConfirmation
        Syntax
        void IpduM_TxConfirmation (PduIdType TxPduId, Std_ReturnType result)
        Service ID [hex] | 0x40
        Sync/Async | Synchronous
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | TxPduId | ID of the PDU that has been transmitted.
        result | E_OK: The PDU was transmitted. E_NOT_OK: Transmission of the PDU failed.
        Parameters (inout) | None
        Parameters (out) | None
        Return value | None
        Description | The lower layer communication interface module confirms the transmission of a PDU,
        or the failure to transmit a PDU.
        Available via | IpduM.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Container.ReliableTxConfirmation</srcid><srcstatus/><internalId>459</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00060</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | IpduM_TriggerTransmit
        Syntax
        Std_ReturnType IpduM_TriggerTransmit (PduIdType TxPduId, PduInfoType* PduInfoPtr)
        Service ID [hex] | 0x41
        Sync/Async | Synchronous
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | TxPduId | ID of the SDU that is requested to be transmitted.
        Parameters (inout) | PduInfoPtr | Contains a pointer to a buffer (SduDataPtr) to where the SDU
        data shall be copied, and the available buffer size in SduLengh. On return, the service will
        indicate the length of the copied SDU data in SduLength.
        Parameters (out) | None
        Return value | Std_ReturnType | E_OK: SDU has been copied and SduLength indicates the number of
        copied bytes.E_NOT_OK: No SDU data has been copied. PduInfoPtr must not be used since it may
        contain a NULL pointer or point to invalid data.
        Description | Within this API, the upper layer module (called module) shall check whether the
        available data fits into the buffer size reported by PduInfoPtr-&gt;SduLength. If it fits, it
        shall copy its data into the buffer provided by PduInfoPtr-&gt;SduDataPtr and update the length of
        the actual copied data in PduInfoPtr-&gt;SduLength. If not, it returns E_NOT_OK without changing
        PduInfoPtr.
        Available via | IpduM.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_00000</srcid><srcstatus/><internalId>646</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_COM_01000</srcid><srcstatus/><internalId>647</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_06001_ServiceId</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00067</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The IpduM shall initialize its internal transmit buffers with the configured pattern
        IpduMIPduUnusedAreasDefault.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00025_InitDefaultValues</srcid><srcstatus/><internalId>666</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00026_InitDefaultValuesTTNotOK</srcid><srcstatus/><internalId>667</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00030_PduInit</srcid><srcstatus/><internalId>668</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00068</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The initial signal values of the initial dynamic part shall be set according to initial values
        of the referenced COM I-PDU (IpduMInitialDynamicPart -&gt; IpduMTxDynamicPart -&gt;
        IpduMTxDynamicPduRef)
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed but we already have it implemented accordingly.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00030_PduInit</srcid><srcstatus/><internalId>668</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00084</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The behavior of the IpduM is unspecified until a correct call to IpduM_Init is made.
      </description>
      <comment>
        This requirement is informational only.
        Rejected since this requirement has to be considered by the user of the IpduM.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00086</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function IpduM_RxIndication shall be callable in interrupt context, e.g. from receive
        interrupt.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_Manual_InterruptCallable</srcid><srcstatus/><internalId>424</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00087</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function IpduM_TxConfirmation shall be callable in interrupt context, e.g. from a transmit
        interrupt.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_Manual_InterruptCallable</srcid><srcstatus/><internalId>424</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00088</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function IpduM_TxConfirmation shall translate the confirmation received from the PDU Router
        into confirmations for the I-PDUs which where contained in the sent multiplexed I-PDU or
        Container PDU.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01005</srcid><srcstatus/><internalId>679</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00089</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The function IpduM_TriggerTransmit shall be callable in interrupt context.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_Manual_InterruptCallable</srcid><srcstatus/><internalId>424</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00090</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Within the function IpduM_TriggerTransmit, the IpduM shall copy the contents of its I-PDU
        transmit buffer to the PDU buffer given by PduInfoPtr-&gt;SduDataPtr and update PduInfoPtr-&gt;
        SduLength with length of the copied data accordingly.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01004</srcid><srcstatus/><internalId>678</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01010</srcid><srcstatus/><internalId>684</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01015</srcid><srcstatus/><internalId>689</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_15003_TxTT</srcid><srcstatus/><internalId>987</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00091</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The IpduM shall take care about the data consistency during providing the data.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01015</srcid><srcstatus/><internalId>689</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00097</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The IpduM shall be implemented so that no other modules depend on it and that it is be possible
        to build a system without the IpduM module if it is not needed.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00098</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The IpduM module shall not set the selector field.
      </description>
      <comment>
        There is an EB requirement which makes this feature configurable.
        See: IPDUM.EB.IPDUM553_Conf
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IPDUM553_Conf</srcid><srcstatus/><internalId>380</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00102</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Module | Header File | Imported Type
        ComStack_Types | ComStack_Types.h | PduIdType
        ComStack_Types.h | PduInfoType
        ComStack_Types.h | PduLengthType
        Std | Std_Types.h | Std_ReturnType
        Std_Types.h | Std_VersionInfoType
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_ImportedTypes</srcid><srcstatus/><internalId>652</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00104</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        API Function | Header File | Description
        Det_ReportRuntimeError | Det.h | Service to report runtime errors. If a callout has been
        configured then this callout shall be called.
      </description>
      <comment>
        There are further mandatory interfaces.
        See IpduM.SWS_IpduM_00105.2, IpduM.SWS_IpduM_00105.3 and IpduM.SWS_IpduM_00105.4.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Interfaces</srcid><srcstatus/><internalId>446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00105</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        API Function | Header File | Description
        Det_ReportError | Det.h | Service to report development errors.
        PduR_IpduMRxIndication | PduR_IpduM.h | Indication of a received PDU from a lower layer
        communication interface module.
        PduR_IpduMTransmit | PduR_IpduM.h | Requests transmission of a PDU.
        PduR_IpduMTriggerTransmit | PduR_IpduM.h | Within this API, the upper layer module (called
        module) shall check whether the available data fits into the buffer size reported by PduInfoPtr-
        SduLength. If it fits, it shall copy its data into the buffer provided by PduInfoPtr-&gt;
        SduDataPtr and update the length of the actual copied data in PduInfoPtr-&gt;SduLength. If not, it
        returns E_NOT_OK without changing PduInfoPtr.
        PduR_IpduMTxConfirmation | PduR_IpduM.h | The lower layer communication interface module
        confirms the transmission of a PDU, or the failure to transmit a PDU.
      </description>
      <comment>
        Set to REFINE since this requirement can only be partly covered
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00105.1</srcid><srcstatus/><internalId>393</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00105.2</srcid><srcstatus/><internalId>394</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00105.3</srcid><srcstatus/><internalId>395</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00105.4</srcid><srcstatus/><internalId>396</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00107</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The IpduM shall not directly access the AUTOSAR OS.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_03000_ConfigType</srcid><srcstatus/><internalId>650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00140</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        It shall be allowed to optimize the Rx- and Tx-Confirmation path from the IpduM module via the
        PDU Router module to the COM layer to call the COM API directly from the IpduM module without
        including the PDU Router. This shall be indicated by setting the published parameter
        IpduMRxDirectComInvocation to TRUE, see ECUC_IpduM_00142.
      </description>
      <comment>
        This is an optimization which is not implemented yet.
        See also deviation [ASCIPDUM-203].
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.IpduMRxDirectComInvocation</srcid><srcstatus/><internalId>445</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00143</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The initial signal values of the static part shall be set according to the intial values of the
        referenced COM I-PDU (IpduMTxStaticPart -&gt; IpduMTxStaticPduRef)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00030_PduInit</srcid><srcstatus/><internalId>668</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00152</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        As long as no transmission confirmation for the IpduM I-PDU is received (regardless of the
        result), the function IpduM_Transmit shall return E_NOT_OK for any new transmission request
        from the upper layer with a COM I-PDU belonging to the same IpduM I-PDU.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01005</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_01013</srcid><srcstatus/><internalId>687</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_02095</srcid><srcstatus/><internalId>694</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00159</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name | IpduM_ConfigType
        Kind | Structure
        Description | This is the type of the data structure containing the initialization data for the
        I-PDU multiplexer.
        Available via | IpduM.h
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_03000_ConfigType</srcid><srcstatus/><internalId>650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00168</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case the transmission of a multiplexed I-PDU is triggered by the update of one part and
        IpduMJitUpdate is configured to true for the second part, the IpduM module shall update the
        second part via PduR_IpduMTriggerTransmit before the multiplexed I-PDU is sent out via
        PduR_IpduMTransmit.
      </description>
      <comment>
        Some clarifications on which of the dynamic part has be updated are stated within Bugzilla
        RfC 65613.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00040_JitUpdateOnTransmit</srcid><srcstatus/><internalId>669</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00080_JitUpdateOnInitialDynamicPart</srcid><srcstatus/><internalId>673</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00169</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case the contents of a multiplexed I-PDU is requested via IpduM_TriggerTransmit, the IpduM
        module shall update all parts which have IpduMJitUpdate configured to true before returning the
        contents of the multiplexed I-PDU.
      </description>
      <comment>
        Some clarifications on which of the dynamic parts has to be updated are stated within
        Bugzilla RfC 65613.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00050_JitUpdateOnTriggerTransmit</srcid><srcstatus/><internalId>670</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00999</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        These requirements are not applicable to this specification.
        (BSW171, BSW00375, BSW00437, BSW168, BSW00423, BSW00427, BSW00431,
        BSW00432, BSW00433, BSW00434, BSW00336, BSW00339, BSW00422, BSW00417,
        BSW00386, BSW162, BSW005, BSW164, BSW00325, BSW00326, BSW00314, BSW00377)
      </description>
      <comment>
        This requirement is informational only.
        Rejected since this has to be considered in a different instance of requirement coverage.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMSelectorField
        Container Type: Sub-Container
        Parent Containers: IpduMRxIndication, IpduMTxRequest,
        Description: This contains the location and the length of the selector field.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00165</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMaxTxPathwayCnt
        Parameter Type: Integer
        Parent Containers: IpduMConfig,
        Description: Maximum number of transmitted IPdus. This parameter is needed only in case of post-
        build loadable implementation using static memory allocation.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <rationale>
        Handled differently by IPDUM.EB.IPDUM557
      </rationale>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduMMaxTxPathwayCnt</srcid><srcstatus/><internalId>470</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IPDUM557</srcid><srcstatus/><internalId>17</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00166</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMaxTxBufferSize
        Parameter Type: Integer
        Parent Containers: IpduMConfig,
        Description: Maximum total size of all Tx buffers. This parameter is needed only in case
        of post-build loadable implementation using static memory allocation.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: LINK, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: LINK, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <rationale>
        Handled differently by IPDUM.EB.IPDUM557
      </rationale>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduMMaxTxBufferSize</srcid><srcstatus/><internalId>471</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IPDUM557</srcid><srcstatus/><internalId>17</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00168</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxDynamicSegment
        Container Type: Sub-Container
        Parent Containers: IpduMTxRequest,
        Description: The dynamic part of the multiplexed outgoing I-Pdu (referenced by
        IpduMOutgoingPduRef) can be separated into several segments.
        Introduction: For each segment one IpduMTxDynamicSegment container shall be created that
        contains the location and the length of the segment. Please note that each configured segment
        will be copied out of the source I-Pdu that is referenced in the IpduMTxDynamicPart container
        and will be copied to the same location in the multiplexed outgoing I-Pdu. The segment layout
        for all dynamic Parts is always identical.
        Lower Multiplicity: 1
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00169</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxStaticSegment
        Container Type: Sub-Container
        Parent Containers: IpduMRxIndication,
        Description: The static part of the multiplexed incoming I-Pdu (referenced by
        IpduMRxIndicationPduRef) can be separated into several segments.
        Introduction: For each segment one IpduMRxStaticSegment container shall be created that
        contains the location and the length of the segment. Please note that each configured segment
        will be copied into the destination I-Pdu that is referenced in the IpduMRxStaticPart container
        and will be copied from the same location in the multiplexed incoming I-Pdu.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00170</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxDynamicSegment
        Container Type: Sub-Container
        Parent Containers: IpduMRxIndication,
        Description: The dynamic part of the multiplexed incoming I-Pdu (referenced by
        IpduMRxIndicationPduRef) can be separated into several segments.
        Introduction: For each segment one IpduMRxDynamicSegment container shall be created that
        contains the location and the length of the segment. Please note that each configured segment
        will be copied into the destination I-Pdu that is referenced in the IpduMRxDynamicPart
        container and will be copied from the same location in the multiplexed incoming I-Pdu. The
        segment layout for all dynamic Parts is always identical.
        Lower Multiplicity: 0
        Upper Multiplicity: Infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ECUC_IpduM_00170.1</srcid><srcstatus/><internalId>422</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduMRxDynamicSegment.LowerMultiplicity</srcid><srcstatus/><internalId>476</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00171</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxStaticSegment
        Container Type: Sub-Container
        Parent Containers: IpduMTxRequest,
        Description: The static part of the multiplexed outgoing I-Pdu (referenced by
        IpduMOutgoingPduRef) can be separated into several segments.
        Introduction: For each segment one IpduMTxStaticSegment container shall be created that
        contains the location and the length of the segment. Please note that each segment in the
        source I-Pdu that is referenced in the IpduMTxStaticPart container will be copied to the same
        location in the multiplexed outgoing I-Pdu.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00171</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case the transmission of a multiplexed I-PDU is triggered by the update of one part and
        IpduMJitUpdate is configured to true for the second part, the multiplexed I-PDU shall not be
        send if the JIT-update request via PduR_IpduMTriggerTransmit returns E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00171.NoTransmission</srcid><srcstatus/><internalId>397</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00171.RetVal</srcid><srcstatus/><internalId>398</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00172</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case the contents of a multiplexed I-PDU is requested via IpduM_TriggerTransmit and
        IpduMJitUpdate is configured to true for any multiplexed part, IpduM_TriggerTransmit shall
        return E_NOT_OK if any of the JIT-update requests via PduR_IpduMTriggerTransmit return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_987</srcid><srcstatus/><internalId>495</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1000</srcid><srcstatus/><internalId>496</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00070_JitUpdateNotOkOnTriggerTransmit</srcid><srcstatus/><internalId>672</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00172</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>2</version>
      <description>
        Name: IpduMContainedPduHeaderId
        Parameter Type: Integer
        Parent Containers: IpduMContainedTxPdu,
        Description: Header Id which is part of the ContainerPdu when this ContainedPdu is inside.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.IpduMContainedPduHeaderId.Multiplicity</srcid><srcstatus/><internalId>465</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00173</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedRxInContainerPduRef
        Parameter Type: Reference
        Parent Containers: IpduMContainedRxPdu,
        Description: Optional reference to an IpduMContainerRxPdu this IpduMContainedRxPdu may be
        received in.
        Introduction: If this IpduMContainedRxPdu shall be received in exactly one IpduMContainerRxPdu
        with IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_CONFIGURED then the
        IpduMContainedRxInContainerPduRef shall be defined. If this IpduMContainedRxPdu can be received
        in any IpduMContainerRxPdu with IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_ALL then the
        IpduMContainedRxInContainerPduRef shall NOT be defined.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IpduM/IpduMConfig/IpduMContainerRxPdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00174</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedRxPdu
        Container Type: Sub-Container
        Parent Containers: IpduMConfig,
        Description: Configuration of a received contained Pdu.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00175</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedRxPduRef
        Parameter Type: Reference
        Parent Containers: IpduMContainedRxPdu,
        Description: Reference to the Pdu which represents this ContainedPdu and is used for reception
        indication.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00176</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxInContainerPduRef
        Parameter Type: Reference
        Parent Containers: IpduMContainedTxPdu,
        Description: Reference to the container Pdu which this contained Pdu shall be collected in.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IpduM/IpduMConfig/IpduMContainerTxPdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00177</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPdu
        Container Type: Sub-Container
        Parent Containers: IpduMConfig,
        Description: Configuration of a sender ContainedPdu.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00178</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPduConfirmation
        Parameter Type: Boolean
        Parent Containers: IpduMContainedTxPdu,
        Description: This Parameter determines whether for this contained I-PDU a TxConfirmation shall
        be provided. If set to TRUE a TxConfirmation is issued. It is not used when an I-PDU is
        requested using the trigger transmit API.
        Introduction: If this Parameter is omitted, the default value shall be used.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.SWS_IpduM_00196.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ECUC_IpduM_00178_Conf_CfgClassFixed</srcid><srcstatus/><internalId>399</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00179</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPduHandleId
        Parameter Type: Integer
        Parent Containers: IpduMContainedTxPdu,
        Description: Handle Id of the ContainedPdu.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Container.IpduMContainedTxPduHandleId.postbuild</srcid><srcstatus/><internalId>462</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00180</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPduRef
        Parameter Type: Reference
        Parent Containers: IpduMContainedTxPdu,
        Description: Reference to the Pdu which represents this ContainedPdu and is used for
        transmission.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00181</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPduSendTimeout
        Parameter Type: FloatValue
        Parent Containers: IpduMContainedTxPdu,
        Description: Defines a ContainedPdu specific sender timeout which can reduce the ContainerPdu
        timer when this ContainedPdu is put inside the ContainerPdu.
        Introduction: Defined in seconds.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type: CLOSED)
        Min-Value: 0 (Type: CLOSED)
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.ASR42.SWS_IpduM_00218.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00182</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPduTrigger
        Parameter Type: Enumeration
        Parent Containers: IpduMContainedTxPdu,
        Description: Defines whether this Pdu triggers the sending of the ContainerPdu.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: IPDUM_TRIGGER_ALWAYS, AUTOSAR_ECUC
        Enumeration Literal: IPDUM_TRIGGER_NEVER, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.SWS_IpduM_00181.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00183</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerHeaderSize
        Parameter Type: Enumeration
        Parent Containers: IpduMContainerRxPdu, IpduMContainerTxPdu,
        Description: Defines the layout of the header information (header id and length)
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: IPDUM_HEADERTYPE_LONG, AUTOSAR_ECUC
        Enumeration Literal: IPDUM_HEADERTYPE_NONE, AUTOSAR_ECUC
        Enumeration Literal: IPDUM_HEADERTYPE_SHORT, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        This requirement is fully covered by IpduM.SWS_IpduM_00177, IpduM.SWS_IpduM_00204
        and IpduM.SWS_IpduM_00208.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00184</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerPduProcessing
        Parameter Type: Enumeration
        Parent Containers: IpduMContainerRxPdu,
        Description: Defines whether the handling of this ContainerPdu shall be done in the context of
        the caller (IMMEDIATE) or in the next call to IpduM_MainFunctionRx (DEFERRED)
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: IPDUM_PROCESSING_DEFERRED, AUTOSAR_ECUC
        Enumeration Literal: IPDUM_PROCESSING_IMMEDIATE, AUTOSAR_ECUC
      </description>
      <comment>
        Bugzilla RfC 71983 was incorporated.
        This is a configuration parameter requirement without functional specification.
        The functional specification is fully covered by requirement IpduM.SWS_IpduM_00211 and
        IpduM.SWS_IpduM_00202.
        AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00185</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerQueueSize
        Parameter Type: Integer
        Parent Containers: IpduMContainerRxPdu, IpduMContainerTxPdu,
        Description: Defines a local queue for handling of each ContainerPdu.
        Introduction: Defined in number of instances of this ContainerPdu.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255 (Type:
        Min-Value: 1 (Type:
      </description>
      <comment>
        The number of instances is stored in a uint8.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.QueueSizeUpperLimit</srcid><srcstatus/><internalId>457</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ECUC_IpduM_00185.RX.QueueSize</srcid><srcstatus/><internalId>413</internalId></linkedfrom><linkedfrom><srcid>IpduM.ECUC_IpduM_00185.TX.QueueSize</srcid><srcstatus/><internalId>414</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00186</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerRxAcceptContainedPdu
        Parameter Type: Enumeration
        Parent Containers: IpduMContainerRxPdu,
        Description: Defines for the received IpduMContainerRxPdu whether the list of referencing
        IpduMContainedRxPdus (via the reference IpduMContainedPduContainerRefRx) is a closed set.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: IPDUM_ACCEPT_ALL, AUTOSAR_ECUC
        Enumeration Literal: IPDUM_ACCEPT_CONFIGURED, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is fully covered by requirement
        IpduM.SWS_IpduM_00205 and IpduM.SWS_IpduM_00206
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00187</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerRxHandleId
        Parameter Type: Integer
        Parent Containers: IpduMContainerRxPdu,
        Description: Handle Id used by the PduR for RxIndication.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.IpduMContainerRxHandleId.postbuild</srcid><srcstatus/><internalId>463</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00188</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerRxPdu
        Container Type: Sub-Container
        Parent Containers: IpduMConfig,
        Description: Configuration of a receiver ContainerPdu which may collect several ContainedPdus.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00189</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerRxPduRef
        Parameter Type: Reference
        Parent Containers: IpduMContainerRxPdu,
        Description: Reference to the Pdu which represents the container and is used for reception.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00191</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerTxHandleId
        Parameter Type: Integer
        Parent Containers: IpduMContainerTxPdu,
        Description: Handle Id used by the PduR for TxConfirmation and for TriggerTransmit of the
        ContainerPdu.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.IpduMContainerTxHandleId.postbuild</srcid><srcstatus/><internalId>464</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00192</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerTxPdu
        Container Type: Sub-Container
        Parent Containers: IpduMConfig,
        Description: Configuration of a transmitted container Pdu.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00193</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerTxPduRef
        Parameter Type: Reference
        Parent Containers: IpduMContainerTxPdu,
        Description: Reference to the Pdu which represents the container and is used for transmission.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucConfigSet/EcucPduCollection/Pdu
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00194</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerTxSendTimeout
        Parameter Type: FloatValue
        Parent Containers: IpduMContainerTxPdu,
        Description: When this timeout expires the ContainerPdu is triggered for sending. The
        respective timer is started when the first Pdu is put into the ContainerPdu.
        Introduction: Defined in seconds.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 65.535 (Type: CLOSED)
        Min-Value: 0 (Type: CLOSED)
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.ASR42.SWS_IpduM_00184.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00195</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerTxSizeThreshold
        Parameter Type: Integer
        Parent Containers: IpduMContainerTxPdu,
        Description: Defines the size threshold in bytes which, when exceeded, triggers the sending of
        the ContainerPdu although the maxium Pdu size (PduLength parameter of Pdu object) has not been
        reached yet.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.SWS_IpduM_00180.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00196</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerTxTriggerMode
        Parameter Type: Enumeration
        Parent Containers: IpduMContainerTxPdu,
        Description: Defines whether this ContainerPdu is fetched via trigger transmit.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: IPDUM_DIRECT, AUTOSAR_ECUC
        Enumeration Literal: IPDUM_TRIGGERTRANSMIT, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.SWS_IpduM_00182 and
        IpduM.SWS_IpduM_00193.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00197</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMHeaderByteOrder
        Parameter Type: Enumeration
        Parent Containers: IpduMGeneral,
        Description: This parameter defines the ByteOrder of the headers inside a Container I-PDU.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: IPDUM_BIG_ENDIAN, AUTOSAR_ECUC
        Enumeration Literal: IPDUM_LITTLE_ENDIAN, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00198</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPduCollectionSemantics
        Parameter Type: Enumeration
        Parent Containers: IpduMContainedTxPdu,
        Description: Defines whether this IpduMContainedTxPdu shall be collected using a last-is-best
        or queued semantics.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Enumeration Literal: IPDUM_COLLECT_LAST_IS_BEST, AUTOSAR_ECUC
        Enumeration Literal: IPDUM_COLLECT_QUEUED, AUTOSAR_ECUC
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.SWS_IpduM_00219 and
        IpduM.SWS_IpduM_00220.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00199</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainerTxFirstContainedPduTrigger
        Parameter Type: Boolean
        Parent Containers: IpduMContainerTxPdu,
        Description: Defines if the transmission of this IpduMContainerTxPdu shall be requested right
        after the first IpduMContainedTxPdu was put into it.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.ASR42.SWS_IpduM_00189.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        API service called with wrong parameter:
        error code: IPDUM_E_PARAM
        value [hex]: 0x10
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IPDUM562</srcid><srcstatus/><internalId>381</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_1</srcid><srcstatus/><internalId>382</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_2</srcid><srcstatus/><internalId>383</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_3</srcid><srcstatus/><internalId>384</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_4</srcid><srcstatus/><internalId>385</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00153</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        API service (except IpduM_MainFunctionTx, IpduM_MainFunctionRx and IpduM_GetVersionInfo) used
        without module initialization
        error code: IPDUM_E_UNINIT
        value [hex]: 0x20
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00153_1</srcid><srcstatus/><internalId>376</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00153_2</srcid><srcstatus/><internalId>377</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00153_3</srcid><srcstatus/><internalId>378</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00153_4</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00162</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        NULL pointer checking
        error code: IPDUM_E_PARAM_POINTER
        value [hex]: 0x11
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00028</srcid><srcstatus/><internalId>201</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_5</srcid><srcstatus/><internalId>386</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_6</srcid><srcstatus/><internalId>387</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_7</srcid><srcstatus/><internalId>388</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_8</srcid><srcstatus/><internalId>389</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_9</srcid><srcstatus/><internalId>390</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_10</srcid><srcstatus/><internalId>391</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00028_11</srcid><srcstatus/><internalId>392</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00173</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The IpduM shall respect the IpduMByteOrder when interpreting the selector field value.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Multiplex.Func.Change</srcid><srcstatus/><internalId>460</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00174</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Invalid configuration set selection
        error code: IPDUM_E_INIT_FAILED
        value [hex]: 0x21
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.InitFailed</srcid><srcstatus/><internalId>466</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00175</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Inside a dynamic Container PDU IpduM shall place the header of a contained I-PDU in front of
        the contained I-PDU.
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios.
      </furtherinfo>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07001_FirstContainedTrue</srcid><srcstatus/><internalId>770</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07051_FirstContainedTrue_E_NOT_OK</srcid><srcstatus/><internalId>771</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_03003_Container_Pdu_Length</srcid><srcstatus/><internalId>929</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_12001_MuxCntr_Tx_1</srcid><srcstatus/><internalId>978</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_12002_MuxCntr_Tx_2</srcid><srcstatus/><internalId>979</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_12003_MuxCntr_Rx_1</srcid><srcstatus/><internalId>980</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_13001_MainFunctionRx_No_Init</srcid><srcstatus/><internalId>982</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_13002_MainFunctionTx_No_Init</srcid><srcstatus/><internalId>983</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_14001_MainFunctionRx</srcid><srcstatus/><internalId>984</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_15001_TxMtx</srcid><srcstatus/><internalId>985</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_15002_TxMtx2</srcid><srcstatus/><internalId>986</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_16001_ConfPending_SizeTrigger</srcid><srcstatus/><internalId>990</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_16002_SendTimeoutReset_CntrQueuing</srcid><srcstatus/><internalId>991</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00177</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Each I-PDU header shall consist of ID field and length field in the byte order determined by
        IpduMHeaderByteOrder.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05012_PduHeader_ASR1911</srcid><srcstatus/><internalId>744</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05012_PduHeader</srcid><srcstatus/><internalId>745</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05012_PduHeader_LongHeader_ASR1911</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05012_PduHeader_LongHeader</srcid><srcstatus/><internalId>747</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00178</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Placing of headers and payloads of contained I-PDUs inside a dynamic Container PDU shall be
        contiguous without any gap.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07002_TriggerImmediately</srcid><srcstatus/><internalId>772</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07003_TriggerImmediately_2</srcid><srcstatus/><internalId>773</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00179</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When a contained I-PDU with IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED
        see ECUC_IpduM_00198) is passed to IpduM via IpduM_Transmit, IpduM shall identify the
        associated Container PDU and append the contained I-PDU to its payload even if a previous
        instance of the contained I-PDU is already present in that Container PDU.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07029_ContainedQueue_1</srcid><srcstatus/><internalId>808</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07058_ContainedQueue_1_SendAwait</srcid><srcstatus/><internalId>809</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07059_ContainedQueue_1_E_NOT_OK</srcid><srcstatus/><internalId>810</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07030_ContainedQueue_2</srcid><srcstatus/><internalId>811</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00180</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If a contained I-PDU has been added to a Container PDU that has not been triggered yet, and if
        the resulting payload is bigger than IpduMContainerTxSizeThreshold the Container PDU shall be
        triggered.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</srcid><srcstatus/><internalId>623</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00181</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When adding a contained I-PDU to a Container PDU which has not been triggered yet, and if
        IpduMContainedTxPduTrigger is set to IPDUM_TRIGGER_ALWAYS, the Container PDU shall be triggered
        immediately.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</srcid><srcstatus/><internalId>624</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00182</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If IpduMContainerTxTriggerMode is set to IPDUM_DIRECT and adding a contained I-PDU would exceed
        maximum size of the Container I-PDU, first the Container PDU shall be triggered. The contained
        I-PDU shall be added to a new instance of the Container PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07015_SizeTrigger</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07043_TriggerTransmit_E_NOT_OK_3</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07028_Transmit_E_NOT_OK</srcid><srcstatus/><internalId>798</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Container.Process.QueueSizeNotReached</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00183</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT and adding a contained I-PDU
        would exceed maximum size of the Container PDU, first the Container PDU shall be queued. Then
        the contained I-PDU shall be added to a new instance of the Container PDU.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07031_TriggerTransmit_Queue_1</srcid><srcstatus/><internalId>814</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07061_TriggerTransmit_Queue_1_TxConf</srcid><srcstatus/><internalId>815</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07032_TriggerTransmit_Queue_2</srcid><srcstatus/><internalId>816</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07039_TriggerTransmit_Queue_3_LB</srcid><srcstatus/><internalId>817</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07040_Queue_4_LastIsBest</srcid><srcstatus/><internalId>818</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07057_Queue_4_LastIsBest_E_NOT_OK</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07044_TriggerTransmit_Queue_5_LB</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07053_TriggerTransmit_Queue_5_LB_E_NOT_OK</srcid><srcstatus/><internalId>821</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Container.Process.QueueSizeNotReached</srcid><srcstatus/><internalId>618</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00184</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When adding the first contained I-PDU to a Container PDU and either IpduMContainerTxSendTimeout
        of the Container PDU or IpduMContainedTxPduSendTimeout of the contained I-PDU is configured
        greater than zero, the IpduM module shall start the transmission timer of the Container PDU.
        The timer shall be initialized with the smaller non zero value of IpduMContainerTxSendTimeout
        and IpduMContainedTxPduSendTimeout.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07015_SizeTrigger</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07016_SizeTrigger_2</srcid><srcstatus/><internalId>787</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07036_TxSendTimeout_4</srcid><srcstatus/><internalId>827</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07047_TxSendTimeout_SizeTrigger</srcid><srcstatus/><internalId>828</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07052_SendCurrInstance_NoCntrQueuing</srcid><srcstatus/><internalId>832</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00185</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When a contained I-PDU is added to a Container PDU, the transmission timer of the Container PDU
        shall be updated with the contained I-PDU's timeout (IpduMContainedTxPduSendTimeout) if it is
        less than the remaining time of the Container PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07010_TxSendTimeoutMin</srcid><srcstatus/><internalId>780</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07011_TxSendTimeout</srcid><srcstatus/><internalId>781</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07013_TxSendTimeout_3</srcid><srcstatus/><internalId>783</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07014_TxSendTimeout_3_2</srcid><srcstatus/><internalId>784</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00186</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When the transmission timer of the Container PDU defined by SWS_IpduM_00184 has elapsed, the
        Container PDU shall be triggered.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</srcid><srcstatus/><internalId>626</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00187</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        After a Container PDU is triggered or being fetched by TriggerTransmit, IpduM shall calculate
        the overall size of the Container PDU. The total size builds up by the total of all payloads of
        the contained I-PDUs plus the total length of the corresponding headers. The result shall be
        the payload size of the Container PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07026_TriggerTransmit</srcid><srcstatus/><internalId>791</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07054_TriggerTransmit_E_NOT_OK</srcid><srcstatus/><internalId>792</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07050_TT_Queued_NoCntrQueuing</srcid><srcstatus/><internalId>831</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00188</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When a Container PDU is triggered, IpduM shall invoke PduR_IpduMTransmit.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07001_FirstContainedTrue</srcid><srcstatus/><internalId>770</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07051_FirstContainedTrue_E_NOT_OK</srcid><srcstatus/><internalId>771</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07090_NoErroneousDoubleTx</srcid><srcstatus/><internalId>812</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07091_NoErroneousDoubleTx2</srcid><srcstatus/><internalId>813</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07044_TriggerTransmit_Queue_5_LB</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07053_TriggerTransmit_Queue_5_LB_E_NOT_OK</srcid><srcstatus/><internalId>821</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07035_TxConfirm_Queue_NextInstance</srcid><srcstatus/><internalId>826</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00189</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        The IpduM shall wait for the transmission confirmation (regardless of the result) before
        invoking PduR_IpduMTransmit for the next instance of that Container PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Container.ReliableTxConfirmation</srcid><srcstatus/><internalId>459</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00190</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case the transmission confirmation for that Container PDU was received, the IpduM shall
        invoke PduR_IpduMTransmit for the next oldest instance of that Container PDU during the next
        call to IpduM_MainFunctionTx at the latest.
      </description>
      <comment>
        Incorporated Bugzilla RfC 71983 'Introduce separate main functions for reception and transmission',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=71983 .
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Dequeue.MainFuncTx</srcid><srcstatus/><internalId>454</internalId></linkedfrom><linkedfrom><srcid>dev.IpduM.Dequeue.TxConf</srcid><srcstatus/><internalId>455</internalId></linkedfrom><linkedfrom><srcid>dev.IpduM.Dequeue.TxOverflow</srcid><srcstatus/><internalId>456</internalId></linkedfrom><linkedfrom><srcid>dev.PartlyImplementedFunctionalities</srcid><srcstatus/><internalId>469</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00191</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case IpduMContainerTxTriggerMode is set to IPDUM_DIRECT, and PduR_IpduMTransmit returns E_OK
        for that Container PDU, IpduM shall remove that instance from the queue.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07033_Transmit_Queue_E_NOT_OK</srcid><srcstatus/><internalId>824</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00192</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When passing a Container PDU to PduR the Parameter PduInfoPtr shall contain a pointer to the
        assembled Container PDU in SduDataPtr and the total length (according to SWS_IpduM_00187) in
        SduLength.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07044_TriggerTransmit_Queue_5_LB</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07053_TriggerTransmit_Queue_5_LB_E_NOT_OK</srcid><srcstatus/><internalId>821</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00193</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT, IpduM shall keep and provide
        buffered data until it is fetched by a call to IpduM_TriggerTransmit.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00193.CQ</srcid><srcstatus/><internalId>400</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00193.LB</srcid><srcstatus/><internalId>401</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00194</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT, IpduM_TriggerTransmit shall
        copy the oldest Conainer PDU instance in the queue. If the queue is empty/ non-existent, the
        current instance of the Container PDU is copied. If the current instance of the Container PDU
        is empty/ non-existent as well, E_NOT_OK is returned by IpduM_TriggerTransmit.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07027_TriggerTransmit_E_NOT_OK</srcid><srcstatus/><internalId>793</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07031_TriggerTransmit_Queue_1</srcid><srcstatus/><internalId>814</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07061_TriggerTransmit_Queue_1_TxConf</srcid><srcstatus/><internalId>815</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07032_TriggerTransmit_Queue_2</srcid><srcstatus/><internalId>816</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07039_TriggerTransmit_Queue_3_LB</srcid><srcstatus/><internalId>817</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07040_Queue_4_LastIsBest</srcid><srcstatus/><internalId>818</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07057_Queue_4_LastIsBest_E_NOT_OK</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07044_TriggerTransmit_Queue_5_LB</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07053_TriggerTransmit_Queue_5_LB_E_NOT_OK</srcid><srcstatus/><internalId>821</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07041_ContainerSeparation</srcid><srcstatus/><internalId>823</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00195</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If PduR_IpduMTransmit has returned E_NOT_OK, the same transmit request shall be repeated during
        the next call to IpduM_MainFunctionTx. The instance of that Container PDU is queued in the
        meantime.
      </description>
      <comment>
        Incorporated Bugzilla RfC 71983 'Introduce separate main functions for reception and transmission',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=71983 .
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07041_ContainerSeparation</srcid><srcstatus/><internalId>823</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07033_Transmit_Queue_E_NOT_OK</srcid><srcstatus/><internalId>824</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00196</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the IpduM receives a TxConfirmation for a specific Container PDU, it shall translate this
        confirmation into the corresponding confirmations for those contained I-PDUs having
        IpduMContainedTxPduConfirmation set to TRUE and were contained in the last sent out instance of
        the Container I-PDU. If the same contained I-PDU is present more than once, this results in
        multiple TxConfirmations
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07025_TxConfirmationContained</srcid><srcstatus/><internalId>790</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07062_TriggerTransmit_TxConf</srcid><srcstatus/><internalId>799</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07041_ContainerSeparation</srcid><srcstatus/><internalId>823</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07034_TxConfirm_Queue_SameContainedPdu</srcid><srcstatus/><internalId>825</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00199</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If creating a new instance of a Container PDU would exceed IpduMContainerQueueSize the oldest
        instance shall be discarded. If IpduMContainerQueueSize is not configured the local instance
        shall be discarded. In both cases IPDUM_E_QUEUEOVFL shall be reported to DET via
        Det_ReportRuntimeError.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Container.Process.QueueSizeReached</srcid><srcstatus/><internalId>617</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07032_TriggerTransmit_Queue_2</srcid><srcstatus/><internalId>816</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07039_TriggerTransmit_Queue_3_LB</srcid><srcstatus/><internalId>817</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07040_Queue_4_LastIsBest</srcid><srcstatus/><internalId>818</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07057_Queue_4_LastIsBest_E_NOT_OK</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07033_Transmit_Queue_E_NOT_OK</srcid><srcstatus/><internalId>824</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00200</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        A Container PDU instance shall be dropped from the queue if it is fetched by TriggerTransmit.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07091_NoErroneousDoubleTx2</srcid><srcstatus/><internalId>813</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07031_TriggerTransmit_Queue_1</srcid><srcstatus/><internalId>814</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07061_TriggerTransmit_Queue_1_TxConf</srcid><srcstatus/><internalId>815</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07039_TriggerTransmit_Queue_3_LB</srcid><srcstatus/><internalId>817</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07040_Queue_4_LastIsBest</srcid><srcstatus/><internalId>818</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07057_Queue_4_LastIsBest_E_NOT_OK</srcid><srcstatus/><internalId>819</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07041_ContainerSeparation</srcid><srcstatus/><internalId>823</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_15004_TxTT_NewInst</srcid><srcstatus/><internalId>988</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00201</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When adding the first contained I-PDU to a Container PDU with the parameter
        IpduMContainerTxFirstContainedPduTrigger set to TRUE, IpduM shall call PduR_IpduMTransmit.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07001_FirstContainedTrue</srcid><srcstatus/><internalId>770</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07051_FirstContainedTrue_E_NOT_OK</srcid><srcstatus/><internalId>771</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00202</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, the processing of the
        received Container PDUs shall be executed in the context of IpduM_RxIndication. Otherwise, it
        is deferred to the next call to IpduM_MainFunctionRx. All deferred Container PDUs shall be
        processed in the order of their reception.
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios.
      </furtherinfo>
      <comment>
        Incorporated Bugzilla RfC 71983 'Introduce separate main functions for reception and transmission',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=71983 .
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_ASR1911</srcid><srcstatus/><internalId>711</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID</srcid><srcstatus/><internalId>712</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>713</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader</srcid><srcstatus/><internalId>714</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_ASR1911</srcid><srcstatus/><internalId>715</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID</srcid><srcstatus/><internalId>716</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>717</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader</srcid><srcstatus/><internalId>718</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05013_Deferred_Processing_OneContainer</srcid><srcstatus/><internalId>748</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05014_Deferred_Processing_MultipleContainers</srcid><srcstatus/><internalId>749</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate_AA_ASR1911</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate_AC_ASR1911</srcid><srcstatus/><internalId>751</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate</srcid><srcstatus/><internalId>752</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05019_Deferred_MF_RxIndication2_ASR1911</srcid><srcstatus/><internalId>753</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05019_Deferred_MF_RxIndication2</srcid><srcstatus/><internalId>754</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05017_Deferred_Queue_Multiple_PDUs_ASR1911</srcid><srcstatus/><internalId>756</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05017_Deferred_Queue_Multiple_PDUs</srcid><srcstatus/><internalId>757</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05018_Deferred_MF_RxIndication_ASR1911</srcid><srcstatus/><internalId>758</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05018_Deferred_MF_RxIndication</srcid><srcstatus/><internalId>759</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_08001_MainFuncRx_Def_Proc_1</srcid><srcstatus/><internalId>862</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2_ASR1911</srcid><srcstatus/><internalId>863</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2</srcid><srcstatus/><internalId>864</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00203</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If by a call of IpduM_RxIndication a Container PDU is received, the contained I-PDUs shall be
        extracted.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_ASR1911</srcid><srcstatus/><internalId>711</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID</srcid><srcstatus/><internalId>712</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>713</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader</srcid><srcstatus/><internalId>714</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_ASR1911</srcid><srcstatus/><internalId>715</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID</srcid><srcstatus/><internalId>716</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>717</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader</srcid><srcstatus/><internalId>718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00204</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For each contained I-PDU of a received Container PDU where the IpduMContainerRxPdu has
        IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_ALL the ID from the PDU header shall be used to
        identify the corresponding contained I-PDU:
        If the received Container PDU uses long or short header (IpduMContainerHeaderSize =
        IPDUM_HEADERTYPE_LONG or IPDUM_HEADERTYPE_SHORT, respectively) the ID shall be compared with
        the IpduMContainedRxPduLongHeaderId or IpduMContainedRxPduShortHeaderId, respectively, in the
        set of IpduMContainedRxPdus which do not have an IpduMContainedRxInContainerPduRef defined.
      </description>
      <comment>
        IpduMContainedPduHeaderId instead of IpduMContainedRxPduShortHeaderId
        and IpduMContainedRxPduLongHeaderId.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00204.ShortHdrId</srcid><srcstatus/><internalId>402</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00204.LongHdrId</srcid><srcstatus/><internalId>403</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off</srcid><srcstatus/><internalId>404</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00205</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If for the received Container PDU the configuration parameter
        IpduMContainerRxAcceptContainedPdu is set to IPDUM_ACCEPT_CONFIGURED, IpduM shall expect and
        match only contained I-PDUs (IpduMContainedRxPdu) that reference the IpduMContainerRxPdu in
        IpduMContainedRxInContainerPduRef.
      </description>
      <comment>
        Note that it is well possible to define several IpduMContainedRxPdus
        with the same IpduMContainedRxPdu(Short/Long)HeaderId as long as the
        IpduMContainedRxPdus are assigned to different IpduMContainerRxPdus
        (via IpduMContainedRxInContainerPduRef) with each IpduMContainerRxPdu
        having IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_CONFIGURED.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On</srcid><srcstatus/><internalId>411</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.Off</srcid><srcstatus/><internalId>412</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00206</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For a received Container PDU with IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_ALL, IpduM
        shall expect and match only IpduMContainedRxPdus which do not have an
        IpduMContainedRxInContainerPduRef defined.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</srcid><srcstatus/><internalId>407</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.Off</srcid><srcstatus/><internalId>408</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00207</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If a contained I-PDU of a received IpduMContainerRxPdu with IpduMContainerRxAcceptContainedPdu=
        IPDUM_ACCEPT_ALL can not be matched according to [SWS_IpduM_00206] then this contained I-PDU
        shall be discarded silently.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</srcid><srcstatus/><internalId>409</internalId></linkedfrom><linkedfrom><srcid>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.Off</srcid><srcstatus/><internalId>410</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00208</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For each contained I-PDU the length given in its header shall be used as the length of the
        corresponding I-PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05007_RxAcceptAll_DataLength</srcid><srcstatus/><internalId>730</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05007_RxAcceptAll_DataLength_LongHeader</srcid><srcstatus/><internalId>731</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05009_RxAcceptConfigured_DataLength</srcid><srcstatus/><internalId>734</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05009_RxAcceptConfigured_DataLength_LongHeader</srcid><srcstatus/><internalId>735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00209</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Each contained I-PDU shall be notified to PduR via PduR_IpduMRxIndication. IpduM shall indicate
        the contained I-PDUs in the same order as the I-PDUs are located inside the Container PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_ASR1911</srcid><srcstatus/><internalId>726</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data</srcid><srcstatus/><internalId>727</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_LongHeader_ASR1911</srcid><srcstatus/><internalId>728</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_LongHeader</srcid><srcstatus/><internalId>729</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05008_RxAcceptConfigured_Data</srcid><srcstatus/><internalId>732</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05008_RxAcceptConfigured_Data_LongHeader</srcid><srcstatus/><internalId>733</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Immediate</srcid><srcstatus/><internalId>907</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Deffered</srcid><srcstatus/><internalId>908</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Static</srcid><srcstatus/><internalId>909</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_RxMetaData_Negative</srcid><srcstatus/><internalId>910</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00210</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When processing a received Container PDU and detecting a header containing the ID 0 the
        processing for this Container PDU shall be stopped and the remaining bytes shall be ignored.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05003_RxHeaderIdZero</srcid><srcstatus/><internalId>719</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05003_RxHeaderIdZero_LongHeader</srcid><srcstatus/><internalId>720</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00211</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If a Container PDU is received and IpduMContainerPduProcessing is set to
        IPDUM_PROCESSING_DEFERRED, the Container PDU shall be queued.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05016_Deferred_Queue</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00212</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If receiving a new instance of a Container PDU would exceed IpduMContainerQueueSize the oldest
        instance shall be discarded and IPDUM_E_QUEUEOVFL shall be reported to DET via
        Det_ReportRuntimeError.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05016_Deferred_Queue</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00213</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When processing a received Container PDU and detecting a header where the payload length
        exceeds the remaining bytes of the container the processing for this Container PDU shall be
        stopped and the remaining bytes shall be ignored. Furthermore, IPDUM_E_HEADER shall be reported
        to DET via Det_ReportRuntimeError.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05004_LessBytesThanDLC</srcid><srcstatus/><internalId>721</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05004_LessBytesThanDLC_LongHeader</srcid><srcstatus/><internalId>722</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05026_Payload_Validation2</srcid><srcstatus/><internalId>761</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_06001_ErrorCodes</srcid><srcstatus/><internalId>768</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>311</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00214</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the remaining bytes in a Container PDU are less than the configured IpduMContainerHeaderSize
        ECUC_IpduM_00183) the remaining bytes shall be ignored.
      </description>
      <comment>
        If the header is short, it will consist of 4 bytes, 3 for the header ID and 1 for DLC.
        If the header is long, it will consist of 8 bytes, 4 for the header ID and 4
        for DLC.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05005_LessBytesThanHeaderSize</srcid><srcstatus/><internalId>723</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05005_LessBytesThanHeaderSize_LongHeader</srcid><srcstatus/><internalId>724</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05027_ShortContainerDequeue</srcid><srcstatus/><internalId>765</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00215</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Erroneous header detected
        error code: IPDUM_E_HEADER
        value [hex]: 0x30
      </description>
      <comment>
        IPDUM_E_HEADER 0x30.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00213</srcid><srcstatus/><internalId>309</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00216</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Container Queue overflow
        error code: IPDUM_E_QUEUEOVFL
        value [hex]: 0x31
      </description>
      <comment>
        IPDUM_E_QUEUEOVFL 0x31.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05016_Deferred_Queue</srcid><srcstatus/><internalId>755</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07032_TriggerTransmit_Queue_2</srcid><srcstatus/><internalId>816</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07033_Transmit_Queue_E_NOT_OK</srcid><srcstatus/><internalId>824</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00217</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When a Container PDU is received from the PDU Router, the function IpduM_RxIndication forwards
        the contained I-PDUs via the PDU Router, using PduR_IpduMRxIndication (see SWS_IpduM_00105)
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios.
      </furtherinfo>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_ASR1911</srcid><srcstatus/><internalId>711</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID</srcid><srcstatus/><internalId>712</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>713</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader</srcid><srcstatus/><internalId>714</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_ASR1911</srcid><srcstatus/><internalId>715</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID</srcid><srcstatus/><internalId>716</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>717</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader</srcid><srcstatus/><internalId>718</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_ASR1911</srcid><srcstatus/><internalId>726</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data</srcid><srcstatus/><internalId>727</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_LongHeader_ASR1911</srcid><srcstatus/><internalId>728</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_LongHeader</srcid><srcstatus/><internalId>729</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05008_RxAcceptConfigured_Data</srcid><srcstatus/><internalId>732</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05008_RxAcceptConfigured_Data_LongHeader</srcid><srcstatus/><internalId>733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00219</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        IpduM shall reject configurations in which the transmit properties (see ECUC_IpduM_00198:
        IpduMContainedTxPduCollectionSemantics) of the contained I-PDUs which are assigned to a
        specific Container PDU are mixed. A Container PDU shall contain either solely I-PDUs with
        IPDUM_COLLECT_LAST_IS_BEST or solely I-PDUs with IPDUM_COLLECT_QUEUED semantic.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Requirement is covered and verified by VSMD checker.
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03002_Mixed_Collection_Semantics</srcid><srcstatus/><internalId>928</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00220</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For contained I-PDUs, with IpduMContainedTxPduCollectionSemantics set to
        IPDUM_COLLECT_LAST_IS_BEST, IpduM shall use PduR_IpduMTriggerTransmit to fetch the PDU data
        from its upper layer immediately before it transfers the container I-PDU to the lower layer.
      </description>
      <comment>AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2994</srcid><srcstatus/><internalId>528</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3060</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3382</srcid><srcstatus/><internalId>541</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07026_TriggerTransmit</srcid><srcstatus/><internalId>791</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07054_TriggerTransmit_E_NOT_OK</srcid><srcstatus/><internalId>792</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_13004_CntrTx_UINT32_LB_WithQueuing</srcid><srcstatus/><internalId>883</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00221</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When storing contained I-PDUs into Container PDUs and IpduMContainedTxPduPriorityHandling is
        set to FALSE, the IpduM shall retain the order in which the contained I-PDUs are passed to
        IpduM. That is the first passed contained I-PDU is placed at the beginning at the container and
        so on. If a contained I-PDU with IpduMContainedTxPduCollectionSemantics set to
        IPDUM_COLLECT_LAST_IS_BEST is passed multiple times, the IpduM shall store it only once at the
        position matching its first occurrence.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07011_TxSendTimeout</srcid><srcstatus/><internalId>781</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07017_SizeTrigger_3</srcid><srcstatus/><internalId>788</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15001_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>898</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15002_CntrTx_DT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>899</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15003_CntrTx_TT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>900</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15004_CntrTx_TT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>901</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15005_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>902</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00222</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case PduR_IpduMTriggerTransmit returns E_NOT_OK for a contained I-PDU, IpduM shall omit this
        contained I-PDU silently. The associated Container PDU shall be transmitted anyway without the
        omitted contained I-PDU. All contained I-PDUs behind the skipped one shall be moved up by the
        size of the omitted contained I-PDU including its header.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07042_TriggerTransmit_E_NOT_OK_2</srcid><srcstatus/><internalId>794</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07060_TriggerTransmit_SendAwait</srcid><srcstatus/><internalId>795</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07043_TriggerTransmit_E_NOT_OK_3</srcid><srcstatus/><internalId>796</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07045_TriggerTransmit_E_NOT_OK_4</srcid><srcstatus/><internalId>797</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07046_TriggerTransmit_Queue_6_LB_NOT_OK</srcid><srcstatus/><internalId>822</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00223</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case the IpduM shall update the dynamic part just-in-time, the latest dynamic part sent by
        the upper layer shall be updated or the dynamic part referenced by IpduMInitialDynamicPart if
        no dynamic part was sent before.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMEnableJitUpdate</srcid><srcstatus/><internalId>32</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00202</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedRxPduShortHeaderId
        Parameter Type: Integer
        Parent Containers: IpduMContainedRxPdu,
        Description: ShortHeader Id which is part of the ContainerPdu when this ContainedPdu is inside.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 16777215 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Contained.HeaderId</srcid><srcstatus/><internalId>467</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00203</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedRxPduLongHeaderId
        Parameter Type: Integer
        Parent Containers: IpduMContainedRxPdu,
        Description: LongHeader Id which is part of the ContainerPdu when this ContainedPdu is inside.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Contained.HeaderId</srcid><srcstatus/><internalId>467</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00205</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMetaDataSupport
        Parameter Type: Boolean
        Parent Containers: IpduMGeneral,
        Description: This parameter enables/disables the support of meta-data feature.
        Introduction: true: enabled false: disabled
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <comment>AUTOSAR R20-11 comment: Previously implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduMMetaDataSupport.LowerMultiplicity</srcid><srcstatus/><internalId>472</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMMetaDataSupport</srcid><srcstatus/><internalId>63</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00224</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        All static and dynamic parts shall be configured to allocate exactly the same bits in the
        multiplexed and the de-multiplexed I-PDUs.
      </description>
      <rationale>
        This requirement is not applicable, it's for integration, targeting two standalone IpduM configurations.
      </rationale>
      <comment>AUTOSAR R20-11 comment: Requirement has no functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00225</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If IpduMTxTriggerMode is configured to a different value than NONE, the IpduM shall use the
        MetaData of the triggering part for sending of the multiplexed I-PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Metadata</srcid><srcstatus/><internalId>468</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00226</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If IpduMTxTriggerMode is configured to NONE, the IpduM shall use the MetaData of the last
        updated part for sending of the multiplexed I-PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Metadata</srcid><srcstatus/><internalId>468</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00227</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        On receiver side the IpduM shall forward the received MetaData along with all demultiplexed
        parts.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.EB.MetaData.Rx.GetMetadata</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>IpduM.EB.MetaData.Rx.SetMetadata</srcid><srcstatus/><internalId>102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00228</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case a Container PDU supports MetaData, the IpduM shall use the MetaData last collected from
        the contained I-PDUs when sending the Container PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Metadata</srcid><srcstatus/><internalId>468</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00229</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case the IpduM receives a Container PDU with MetaData, the IpduM shall forward the MetaData
        of the Container PDU along with all contained I-PDU that support MetaData.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.EB.MetaData.Rx.GetMetadata</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>IpduM.EB.MetaData.Rx.SetMetadata</srcid><srcstatus/><internalId>102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00230</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        IpduM shall reject configurations in which contained I-PDU supporting MetaData have a different
        MetaDataType from the MetaDataType of the Container PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Metadata</srcid><srcstatus/><internalId>468</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_91001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | IpduM_MainFunctionRx
        Syntax
        void IpduM_MainFunctionRx (void)
        Service ID [hex] | 0x11
        Sync/Async | Synchronous
        Reentrancy | Reentrant for different instances. Non reentrant for the same instance.
        Parameters (in) | None
        Parameters (inout) | None
        Parameters (out) | None
        Return value | None
        Description | This function performs the processing of the reception activities that are not
        directly handled within the calls from PduR. Per configured IpduMMainFunctionRx instance one
        IpduM_MainFunctionRx_&lt;shortName&gt; shall be implemented. Hereby &lt;shortName&gt; is the short name of
        the IpduMMainFunctionRx configuration container in the ECU configuration.
        Available via | IpduM_SchM.h
      </description>
      <comment>
        Incorporated Bugzilla RfC 71983 'Introduce separate main functions for reception and transmission',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=71983 .
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ASR43.SWS_IpduM_91003</srcid><srcstatus/><internalId>416</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_08001_MainFuncRx_Def_Proc_1</srcid><srcstatus/><internalId>862</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2_ASR1911</srcid><srcstatus/><internalId>863</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2</srcid><srcstatus/><internalId>864</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_06001_ServiceId</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_91002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Service Name | IpduM_MainFunctionTx
        Syntax
        void IpduM_MainFunctionTx (void)
        Service ID [hex] | 0x12
        Sync/Async | Synchronous
        Reentrancy | Reentrant for different instances. Non reentrant for the same instance.
        Parameters (in) | None
        Parameters (inout) | None
        Parameters (out) | None
        Return value | None
        Description | This function performs the processing of the transmission activities that are not
        directly handled within the calls from PduR. Per configured IpduMMainFunctionTx instance one
        IpduM_MainFunctionTx_&lt;shortName&gt; shall be implemented. Hereby &lt;shortName&gt; is the short name of
        the IpduMMainFunctionTx configuration container in the ECU configuration.
        Available via | IpduM_SchM.h
      </description>
      <comment>
        Incorporated Bugzilla RfC 71983 'Introduce separate main functions for reception and transmission',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=71983 .
      AUTOSAR R20-11 comment: Requirement was changed without functional impact.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ASR43.SWS_IpduM_91004</srcid><srcstatus/><internalId>417</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_09001_MainFuncTx_TxConfTimeout</srcid><srcstatus/><internalId>865</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_09002_MainFuncTx_SendTimeout</srcid><srcstatus/><internalId>866</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_09003_MainFuncTx_SendTimeout2</srcid><srcstatus/><internalId>867</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_06001_ServiceId</srcid><srcstatus/><internalId>973</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00206</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedPduOffset
        Parameter Type: Integer
        Parent Containers: IpduMContainedRxPdu, IpduMContainedTxPdu,
        Description: Static offset (in bytes) of the ContainedPdu. Tags: atp.Status=draft
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        dependency: - only valid if IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_NONE.
          - only the ContainedPdu with the highest offset within a ContainerPdu may have variable length.
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00207</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMPduUpdateBitPosition
        Parameter Type: Integer
        Parent Containers: IpduMContainedRxPdu, IpduMContainedTxPdu,
        Description: This value specifies where the PDU's Update-Bit is stored in the Container PDU (
        bit location of PDU's Update-Bit in the Container PDU). Tags: atp.Status=draft
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        dependency: - only valid if IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_NONE.
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 4294967295 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00208</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMUnusedAreasDefault
        Parameter Type: Integer
        Parent Containers: IpduMContainerTxPdu,
        Description: IpduM fills not updated areas of the Container PDU with this byte-pattern. Tags:
        atp.Status=draft
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        dependency: Only valid if IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_NONE / should
          be aligned to bus-specific padding value if available.
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00231</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If in case of updating contained I-PDUs with IpduMContainedTxPduCollectionSemantics
        IPDUM_COLLECT_LAST_IS_BEST, IpduMContainedTxPduPriorityHandling is set to FALSE and the
        container size is not sufficient for a contained I-PDU, this contained I-PDU and all following
        shall be shifted to the beginning of the next container instance.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Cntr.Last_Is_Best.Update</srcid><srcstatus/><internalId>458</internalId></linkedfrom><linkedfrom><srcid>dev.PartlyImplementedFunctionalities</srcid><srcstatus/><internalId>469</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00232</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        If the IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_NONE, the IpduM module shall
        statically place the contained I-PDUs within the Container PDU according to their configured
        IpduMContainedTxPduOffset
      </description>
      <furtherinfo>
        Justifying rule: WRN.swuts.needscoverage.count
        A requirement can end up being satisified by numerous tests because
        the module can be subject to various scenarios.
      </furtherinfo>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07081_CntrTx_Update_Bit</srcid><srcstatus/><internalId>851</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07082_CntrTx_Unused_Area</srcid><srcstatus/><internalId>852</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07083_CntrTx_TT_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>853</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07084_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>854</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07086_StaticTTLBOK</srcid><srcstatus/><internalId>855</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14005_CntrTx_Update_Bit</srcid><srcstatus/><internalId>891</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14006_CntrTx_Unused_Area</srcid><srcstatus/><internalId>892</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14011_CntrTx_Unused_Area_PartialReception</srcid><srcstatus/><internalId>893</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14007_CntrTx_TT_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>894</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14012_CntrTx_TT_Partial_Update_Bit</srcid><srcstatus/><internalId>895</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14008_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>896</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00233</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case a Static Container has a configured IpduMUnusedAreasDefault, the IpduM shall ensure
        that all not updated areas of the Container are set to the value of IpduMUnusedAreasDefault
        before the Container PDU is sent.
      </description>
      <comment>
        https://bugzilla.autosar.org/show_bug.cgi?id=80586

        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07082_CntrTx_Unused_Area</srcid><srcstatus/><internalId>852</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07086_StaticTTLBOK</srcid><srcstatus/><internalId>855</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14006_CntrTx_Unused_Area</srcid><srcstatus/><internalId>892</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14011_CntrTx_Unused_Area_PartialReception</srcid><srcstatus/><internalId>893</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00234</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For Container PDUs with static container layout and IpduMContainerTxTriggerMode is set to
        IPDUM_DIRECT, the IpduM shall trigger the Container PDU when all contained I-PDUs were updated
        by the upper layer.
      </description>
      <comment>
        https://bugzilla.autosar.org/show_bug.cgi?id=80586

        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</srcid><srcstatus/><internalId>627</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00235</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case a contained I-PDU has a configured IpduMUpdateBitPosition, the IpduM shall ensure that
        the update bit of this contained I-PDU is set if and only if the contained I-PDU was
        successfully updated.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07081_CntrTx_Update_Bit</srcid><srcstatus/><internalId>851</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07082_CntrTx_Unused_Area</srcid><srcstatus/><internalId>852</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07083_CntrTx_TT_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>853</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07084_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>854</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14005_CntrTx_Update_Bit</srcid><srcstatus/><internalId>891</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14006_CntrTx_Unused_Area</srcid><srcstatus/><internalId>892</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14011_CntrTx_Unused_Area_PartialReception</srcid><srcstatus/><internalId>893</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14007_CntrTx_TT_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>894</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14012_CntrTx_TT_Partial_Update_Bit</srcid><srcstatus/><internalId>895</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14008_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>896</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00236</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        In case a received contained I-PDU has a configured update bit, the IpduM module shall only
        process and indicate it to the upper layer if its received update-bit is set.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05020_CntrRx_Update_Bit</srcid><srcstatus/><internalId>762</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05021_CntrRx_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>763</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14001_CntrRx_Update_Bit</srcid><srcstatus/><internalId>886</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14002_CntrRx_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>887</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00237</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When processing a received Container PDU with IpduMContainerHeaderSize set to
        IPDUM_HEADERTYPE_NONE, the IpduM shall ignore all contained PDUs that are according to their
        configuration not or not completely contained in the received Container PDU. Such contained I-
        PDUs shall not be indicated to the upper layer. If Development Error Detection is configured (
        ECUC_IpduM_00132) IPDUM_E_CONTAINER shall be reported to DET via Det_ReportError.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05022_CntrRx_Det_Report</srcid><srcstatus/><internalId>764</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14003_CntrRx_Det_Report</srcid><srcstatus/><internalId>888</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00238</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For a Container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE, all contained I-
        PDUs shall have IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_LAST_IS_BEST.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_447</srcid><srcstatus/><internalId>587</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04009_IpduMContainedTxPduCollectionSemantics</srcid><srcstatus/><internalId>949</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00240</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Contained I-PDUs with a configured IpduMPduUpdateBitPosition shall only be assigned to
        Container PDUs with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_270</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_625</srcid><srcstatus/><internalId>591</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04013_TxHeaderTypeNotNone</srcid><srcstatus/><internalId>953</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_04014_RxHeaderTypeNotNone</srcid><srcstatus/><internalId>954</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00241</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For a Container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE, all contained I-
        PDUs shall have a configured IpduMContainedTxPduOffset.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_273</srcid><srcstatus/><internalId>583</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_628</srcid><srcstatus/><internalId>592</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04010_IpduMContainedTxPduOffset</srcid><srcstatus/><internalId>950</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00242</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For a Container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE and
        IpduMUnusedAreasDefault not set, all contained I-PDUs shall have a configured
        IpduMPduUpdateBitPosition.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_325</srcid><srcstatus/><internalId>585</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/IpduM_Extension.xdm.m4_422</srcid><srcstatus/><internalId>586</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04011_AllCntdIpduMPduUpdateBitPosition</srcid><srcstatus/><internalId>951</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_04012_IpduMUnusedAreasDefault</srcid><srcstatus/><internalId>952</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00245</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        All IpduMPduUpdateBitPositions shall be configured to their own not otherwise occupied bit
        position.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_checks.m_201</srcid><srcstatus/><internalId>606</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_checks.m_278</srcid><srcstatus/><internalId>610</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_04015_RxSameIpduMUpdateBit</srcid><srcstatus/><internalId>955</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_GEN_04016_TxSameIpduMUpdateBit</srcid><srcstatus/><internalId>956</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00246</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Only the last contained IPdu (according to IpduMContainedPduOffset) of a ContainerIPdu with
        static container layout (i.e. IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE) may be a
        dynamic length PDU (i.e, a PDU that at runtime may exhibit a length different from the one
        statically configured via Pdu.length of the respective Pdu). All other contained PDUs of a
        ContainerIPdu with static container layout have to be static length PDUs.
      </description>
      <comment>
        Incorporated Bugzilla RfC 76543 '[IpduM] Container Pdu not usable for CAN-FD',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=76543 .
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05023_CntrRx_Dynamic_Length</srcid><srcstatus/><internalId>766</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07083_CntrTx_TT_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>853</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07084_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>854</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14004_CntrRx_Dynamic_Length</srcid><srcstatus/><internalId>889</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14007_CntrTx_TT_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>894</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14012_CntrTx_TT_Partial_Update_Bit</srcid><srcstatus/><internalId>895</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14008_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>896</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00247</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Partly or erroneous container received
        error code: IPDUM_E_CONTAINER
        value [hex]: 0x32
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/IpduM_Int.h.m4_111</srcid><srcstatus/><internalId>477</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05024_Payload_Validation_SduLength</srcid><srcstatus/><internalId>725</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05022_CntrRx_Det_Report</srcid><srcstatus/><internalId>764</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14003_CntrRx_Det_Report</srcid><srcstatus/><internalId>888</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00209</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPduPriorityHandling
        Parameter Type: Boolean
        Parent Containers: IpduMGeneral,
        Description: This parameter enables/disables handling of priority for IpduMContainedTxPdu's
        with IpduMContainedTxPduCollectionSemantics IPDUM_LAST_IS_BEST.
        Introduction: true: enabled false: disabled
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: false
        Post-Build-Variant-Value: false
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_15001_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>898</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15002_CntrTx_DT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>899</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15003_CntrTx_TT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>900</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15004_CntrTx_TT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>901</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15005_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>902</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00210</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMContainedTxPduPriority
        Parameter Type: Integer
        Parent Containers: IpduMContainedTxPdu,
        Description: Defines a priority of a ContainedTxPdu. 255 represents the lowest priority and 0
        represent the highest priority.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_15001_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>898</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15002_CntrTx_DT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>899</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15003_CntrTx_TT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>900</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15004_CntrTx_TT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>901</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15005_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>902</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00248</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        All contained I-Pdus with Collection Semantic IPDUM_COLLECT_LAST_IS_BEST and
        IpduMContainedTxPduPriorityHandling is set to TRUE, shall have an IpduMContainedTxPduPriority.
        If the IpduMContainedTxPduPriority is not configured, the IpduMContainedTxPduPriority shall be
        set to default value 255 (lowest available priority)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/IpduM.xgen_1618</srcid><srcstatus/><internalId>613</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_15001_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>898</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15002_CntrTx_DT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>899</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15003_CntrTx_TT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>900</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15004_CntrTx_TT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>901</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15005_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>902</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15006_Priority_On_PartialNoValue</srcid><srcstatus/><internalId>903</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15007_Priority_Off</srcid><srcstatus/><internalId>904</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00249</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        When storing contained I-PDUs with IpduMContainedTxPduCollectionSemantics set to
        IPDUM_COLLECT_LAST_IS_BEST into Container PDUs and IpduMContainedTxPduPriorityHandling is set
        to TRUE, the IpduM shall collect the contained I-PDUs in respect to the
        IpduMContainedTxPduPriority (highest priority first and so on). I-PDUs with the same
        IpduMContainedTxPduPriority shall be collected in the order the send request occurred.
      </description>
      <comment>
        Defines a priority of a ContainedTxPdu. 255 represents the lowest priority and 0 represent the highest priority.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3740</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_15001_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>898</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15002_CntrTx_DT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>899</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15003_CntrTx_TT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>900</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15004_CntrTx_TT_Priority_On_With_SameValues</srcid><srcstatus/><internalId>901</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_15005_CntrTx_DT_Priority_On_With_DifferentValues</srcid><srcstatus/><internalId>902</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00250</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        For an IpduMContainerRxPdu with IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_CONFIGURED and
        IpduMContainerHeaderSize=IPDUM_HEADERTYPE_LONG or IPDUM_HEADERTYPE_SHORT the following
        constraint applies:
        IpduMContainedRxPdus with an IpduMContainedRxInContainerPduRef to that specific
        IpduMContainerRxPdu shall have unique IpduMContainedRxPduLongHeaderId or
        IpduMContainedRxPduShortHeaderId, respectively, defined in the context of that
        IpduMContainerRxPdu.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00250.UniqueHeaderId</srcid><srcstatus/><internalId>405</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00251</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        All IpduMContainedRxPdus with no IpduMContainedRxInContainerPduRef and a defined
        IpduMContainedRxPduLongHeaderId or IpduMContainedRxPduShortHeaderId, shall have a unique
        IpduMContainedRxPduLongHeaderId or IpduMContainedRxPduShortHeaderId, respectively.
      </description>
      <comment>
        Note that due to [SWS_IpduM_00206] it is NOT allowed to define several
        IpduMContainedRxPdus with the same
        IpduMContainedRxPduShortHeaderId / IpduMContainedRxPduLongHeaderId
        and no assignment to IpduMContainerRxPdu (no IpduMContainedRxInContainerPduRef defined).

        Note that it is well possible to have two IpduMContainedRxPdus with
        no assignment to IpduMContainerRxPdu (no IpduMContainedRxInContainerPduRef defined)
        which have the same header id value defined, as long as one IpduMContainedRxPdu
        has an IpduMContainedRxPduShortHeaderId defined and the other IpduMContainedRxPdu
        has an IpduMContainedRxPduLongHeaderId defined.

        Note that due to two ways how IpduMContainedRxPdus can interact with
        IpduMContainerRxPdu (IPDUM_ACCEPT_CONFIGURED and IPDUM_ACCEPT_ALL definition
        at the IpduMContainerRxPdu) it is well possible that IpduMContainedRxPdus
        with the same IpduMContainedRxPduShortHeaderId / IpduMContainedRxPduLong-HeaderId
        exist as long as the constraints defined in [SWS_IpduM_00250], [SWS_IpduM_00251]
        are fulfilled.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.SWS_IpduM_00251.UniqueHeaderId</srcid><srcstatus/><internalId>406</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00204</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        See"IpduM_x_Module"
        Module Name | IpduM
        Module Description | Configuration of the IpduM (Ipdu Multiplexer) module.
        Post-Build Variant Support | true
        Supported Config Variants | VARIANT-LINK-TIME, VARIANT-POST-BUILD, VARIANT-PRE-COMPILE
        Included containers: "IpduM_x_Included_Containers"
        Included Containers
        Container Name | Multiplicity | Scope / Dependency
        IpduMConfig | 1 | This container contains the sub containers of the IpduM module.
        The IpduMTxPathway subcontainer includes information about sent I-PDUs.
        The IpduMRxPathway includes information about received I-PDUs.
        The IpduMContainerTxPdu and IpduMContainedTxPdu include information about the sending of
        ContainerPdus.
        The IpduMContainerRxPdu and IpduMContainedRxPdu include information about the reception of
        ContainerPdus.
        IpduMGeneral | 1 | Contains the general configuration parameters of IpduM.
        IpduMPublishedInformation | 1 | Additional published parameters not covered by
        CommonPublishedInformation container. Note that these parameters do not have any configuration
        class setting, since they are published information.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00211</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMainFunctionRx
        Container Type: Sub-Container
        Parent Containers: IpduMConfig,
        Description: Each element of this container defines one instance IpduM_MainFunctionRx, in case
        multi-core distribution feature is active.
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>AUTOSAR R20-11 comment: Already implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.FlexProcessing.Multicore</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMRxProcessing</srcid><srcstatus/><internalId>55</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00212</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMainFunctionRxRef
        Parameter Type: Reference
        Parent Containers: IpduMContainerRxPdu,
        Description: Reference to the IpduM_MainFunctionRx instance this container PDU belongs to.
        Introduction: Mandatory, if more than one IpduM_MainFunctionRx is defined.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IpduM/IpduMConfig/IpduMMainFunctionRx
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>AUTOSAR R20-11 comment: Already implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.FlexProcessing.Multicore</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMRxProcessing.IpduMRxPduRef</srcid><srcstatus/><internalId>56</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00213</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMainFunctionTx
        Container Type: Sub-Container
        Parent Containers: IpduMConfig,
        Description: Each element of this container defines one instance IpduM_MainFunctionTx, in case
        multi-core distribution feature is active (mutual exclusive to ComTimeBase)
        Lower Multiplicity: 0
        infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>AUTOSAR R20-11 comment: Already implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.FlexProcessing.Multicore</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMTxProcessing</srcid><srcstatus/><internalId>58</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00214</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMainFunctionTxRef
        Parameter Type: Reference
        Parent Containers: IpduMContainerTxPdu,
        Description: Reference to the IpduM_MainFunctionTx instance this container PDU belongs to.
        Introduction: Mandatory, if more than one IpduM_MainFunctionTx is defined.
        Lower Multiplicity: 0
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Multiplicity: true
        Post-Build-Variant-Value: true
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/IpduM/IpduMConfig/IpduMMainFunctionTx
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>AUTOSAR R20-11 comment: Already implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.FlexProcessing.Multicore</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMTxProcessing.IpduMTxPduRef</srcid><srcstatus/><internalId>59</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00215</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMainRxPartitionRef
        Parameter Type: Reference
        Parent Containers: IpduMMainFunctionRx,
        Description: Reference to EcucPartition, where the according IpduM_MainFunction instance is
        assigned to.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucPartitionCollection/EcucPartition
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>AUTOSAR R20-11 comment: Already implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.FlexProcessing.Multicore</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMRxProcessing.IpduMPartitionRef</srcid><srcstatus/><internalId>61</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00216</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMainRxTimeBase
        Parameter Type: FloatValue
        Parent Containers: IpduMMainFunctionRx,
        Description: The period between successive calls to according instance of IpduM_MainFunctionRx
        in seconds. This parameter may be used by the IpduM generator to transform the values of the
        reception related timing configuration parameters of the IpduM module to internal
        implementation specific counter or tick values. The IpduM module's internal timing handling is
        implementation specific.
        Introduction: The IpduM module (generator) may rely on the fact that IpduM_MainFunctionRx is
        scheduled according to the value configured here.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: INF (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <comment>AUTOSAR R20-11 comment: Already implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.FlexProcessing.Multicore</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMRxProcessing.IpduMTimeBase</srcid><srcstatus/><internalId>57</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00217</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMainTxPartitionRef
        Parameter Type: Reference
        Parent Containers: IpduMMainFunctionTx,
        Description: Reference to EcucPartition, where the according IpduM_MainFunction instance is
        assigned to.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Destination: /AUTOSAR/EcucDefs/EcuC/EcucPartitionCollection/EcucPartition
        Destination type: ECUC-PARAM-CONF-CONTAINER-DEF
      </description>
      <comment>AUTOSAR R20-11 comment: Already implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.FlexProcessing.Multicore</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMTxProcessing.IpduMPartitionRef</srcid><srcstatus/><internalId>62</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00218</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMMainTxTimeBase
        Parameter Type: FloatValue
        Parent Containers: IpduMMainFunctionTx,
        Description: The period between successive calls to IpduM_MainFunctionTx in seconds. This
        parameter may be used by the IpduM generator to transform the values of the reception related
        timing configuration parameters of the IpduM module to internal implementation specific counter
        or tick values. The IpduM module's internal timing handling is implementation specific.
        Introduction: The IpduM module (generator) may rely on the fact that IpduM_MainFunctionTx is
        scheduled according to the value configured here.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: false
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: INF (Type: OPEN)
        Min-Value: 0 (Type: OPEN)
      </description>
      <comment>AUTOSAR R20-11 comment: Already implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.FlexProcessing.Multicore</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IpduMTxProcessing.IpduMTimeBase</srcid><srcstatus/><internalId>60</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00252</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        IpduM Container Pdus shall be processed within the MainFunction, which is referenced by the
        Container Pdu configuration parameters (i.e.IpduMContainerRxPdu and IpduMContainerTxPdu)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1159</srcid><srcstatus/><internalId>497</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1264</srcid><srcstatus/><internalId>498</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_MFFlexAlloc_CntrTx_Only</srcid><srcstatus/><internalId>658</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10001_MainFuncFlexAlloc_SendTimeout</srcid><srcstatus/><internalId>869</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10002_MainFuncFlexAlloc_SendTimeout_2</srcid><srcstatus/><internalId>870</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10003_MainFuncFlexAlloc_TxConfirm</srcid><srcstatus/><internalId>871</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10004_MainFuncFlexAlloc_TxConfirm_SendTimeout</srcid><srcstatus/><internalId>872</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10005_MainFuncFlexAlloc_TxConfirm_SendAwait</srcid><srcstatus/><internalId>873</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10006_MainFuncFlexAlloc_Dequeue</srcid><srcstatus/><internalId>874</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10007_MainFuncFlexAlloc_SizeAnnounce</srcid><srcstatus/><internalId>875</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing_ASR1911</srcid><srcstatus/><internalId>876</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing</srcid><srcstatus/><internalId>877</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>IpduM.ECUC_IpduM_00113.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxSelectorValue
        Parameter Type: Integer
        Parent Containers: IpduMRxDynamicPart,
        Description: This is the selector value that this container refers to.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 255 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM148</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduM module implementation (IpduM.c) shall include the file IpduM_Api.h.
      </description>
      <comment>
        IpduM.c includes IpduM_Api.h instead of IpduM.h.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_88</srcid><srcstatus/><internalId>488</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>366</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00148_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The file IpduM.c shall include IpduM.h.
      </description>
      <comment>
        Regarding the inclusions of IpduM.c, EB implementation has a different approach because of
        the post build feature. This is why the requirement is refined.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IPDUM.EB.IPDUM148</srcid><srcstatus/><internalId>365</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00148_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
      The file IpduM.c shall include IpduM_Cbk.h.
    </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_86</srcid><srcstatus/><internalId>487</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00148_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The file IpduM.c shall include PduR_IpduM.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_84</srcid><srcstatus/><internalId>486</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00148_4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
      The file IpduM.c shall include IpduM_Cfg.h.
    </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/IpduM_Api.h_11</srcid><srcstatus/><internalId>484</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00148_5</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        The file IpduM.c shall include Det.h optionally.
      </description>
      <comment>
        Det.h shall be included if IpduMDevErrorDetect is enabled.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_96</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00151_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        File IpduM.h shall include MemMap.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00151_1_1</srcid><srcstatus/><internalId>372</internalId></linkedfrom><linkedfrom><srcid>IpduM.ASR40.SWS_IpduM_00151_1_2</srcid><srcstatus/><internalId>373</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00151_1_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        MemMap.h inclusion at the beginning of a section shall be preceded by a
        &amp;lt;MODULE&gt;_START_SEC_&amp;lt;TYPE_PROPERTIES&amp;gt; macro.
        MemMap.h inclusion at the end of a section shall be preceded by a
        &amp;lt;MODULE&amp;gt;_STOP_SEC_&amp;lt;TYPE_PROPERTIES&amp;gt; macro.
        &amp;lt;MODULE&amp;gt;_START_SEC_&amp;lt;TYPE_PROPERTIES&amp;gt; and
        &amp;lt;MODULE&amp;gt;_STOP_SEC_&amp;lt;TYPE_PROPERTIES&amp;gt; must be balanced.
      </description>
    <comment>
      This requirement defines the placement (inside the module source) of header
      file MemMap.h.
    </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_Manual_MemMap</srcid><srcstatus/><internalId>423</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00151_1_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Particular symbols (functions, global variables) shall be mapped to memory
        sections according to the respective symbol property, including:
        - constness
        - variable size
        - initializationcharacteristics
      </description>
      <comment>
        This requirement needs a manual code review.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_Manual_MemMap</srcid><srcstatus/><internalId>423</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00151_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        File IpduM.h shall include SchM_IpduM.h.
      </description>
      <comment>
        Indirect inclusion using IpduM_Api.h.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/IpduM_Api.h_14</srcid><srcstatus/><internalId>485</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>

    <specobject>
      <id>IpduM.ASR40.SWS_IpduM_00151_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
      File IpduM.h shall include ComStack_Types.h.
    </description>
      <comment>
      Indirect inclusion using IpduM_Api.h.
    </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/IpduM_Api.h_7</srcid><srcstatus/><internalId>483</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00153_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is enabled and IpduM_RxIndication is called before the module is
        initialized, the function shall raise the DET error IPDUM_E_UNINIT and shall return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_xxx_xx091_DET</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00153_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is enabled and IpduM_Transmit is called before the module is initialized,
        the function shall raise the DET error IPDUM_E_UNINIT and shall return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_xxx_xx091_DET</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00153_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is enabled and IpduM_TxConfirmation is called before the module is initialized,
        the function shall raise the DET error IPDUM_E_UNINIT and shall return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_xxx_xx091_DET</srcid><srcstatus/><internalId>995</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00153_4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is enabled and IpduM_TriggerTransmit is called before the module is initialized,
        the function shall raise the DET error IPDUM_E_UNINIT and shall return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01001</srcid><srcstatus/><internalId>675</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM553_Conf</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Add following configuration item
        Name: IpduMTxAutomaticSelector
        Parent container: IpduMGeneral
        Type: BOOLEAN
        Multiplicity: 1
        Default value: false
        Configuration class: Pre-compile time
        Scope/Dependency: scope local
        Description: If enabled the IpduM configuration defines the selector values for transmit PDUs.
        If disabled the Com configuration defines the selector values for transmit PDUs.
      </description>
      <comment>
        For enabled configuration parameter the issue is covered by IPDUM555.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_130</srcid><srcstatus/><internalId>559</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00021</srcid><srcstatus/><internalId>664</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00098</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>

    <specobject>
      <id>IPDUM.EB.IPDUM562</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Memory required by the post-build configuration shall not be greater than IpduMDataMemSize.
        To enforce this the configuration generator shall report an error when the
        memory required is greater than IpduMDataMemSize otherwise no error shall be reported.
      </description>
      <comment>
        IpduMDataMemSize is also handled by IPDUM.EB.IPDUM557
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/IpduM_Macros.m_327</srcid><srcstatus/><internalId>482</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_50001_DataMem</srcid><srcstatus/><internalId>957</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_RxIndication is called with
        RxPduId which is not valid, then IpduM shall raise an error IPDUM_E_PARAM to Det.
      </description>
      <comment>
        RxPduId shall be less than the number of RxPathway entries configured.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_10001_Cntr_DetChecks</srcid><srcstatus/><internalId>868</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_xxx_xx092_DET</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_Transmit is called with
        TxPduId which is not valid, then IpduM shall raise an error IPDUM_E_PARAM to Det.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_10001_Cntr_DetChecks</srcid><srcstatus/><internalId>868</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_xxx_xx092_DET</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_TriggerTransmit is called with
        TxPduId which is not valid, then IpduM shall raise an error IPDUM_E_PARAM to Det.
      </description>
      <comment>
        TxPduId shall be less than the number of IpduMTxPathway entries configured.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01002</srcid><srcstatus/><internalId>676</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10001_Cntr_DetChecks</srcid><srcstatus/><internalId>868</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_TxConfirmation is called with
        TxPduId which is not valid, then IpduM shall raise an error IPDUM_E_PARAM to Det.
      </description>
      <comment>
        TxPduId shall be less than the number of IpduMTxPathway entries configured.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_10001_Cntr_DetChecks</srcid><srcstatus/><internalId>868</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_xxx_xx092_DET</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_5</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_RxIndication is called with PduInfoPtr
        as NULL_PTR, then IpduM shall raise an error IPDUM_E_PARAM_POINTER to Det.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_xxx_xx092_DET</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_6</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_RxIndication is called with SduDataPtr
        as NULL_PTR, then IpduM shall raise an error IPDUM_E_PARAM_POINTER to Det.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_xxx_xx092_DET</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_7</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_Transmit is called with PduInfoPtr
        as NULL_PTR, then IpduM shall raise an error IPDUM_E_PARAM_POINTER to Det.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_xxx_xx092_DET</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_8</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_Transmit is called with SduDataPtr
        as NULL_PTR, then IpduM shall raise an error IPDUM_E_PARAM_POINTER to Det.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_xxx_xx092_DET</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_9</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_TriggerTransmit is called with PduInfoPtr
        as NULL_PTR, then IpduM shall raise an error IPDUM_E_PARAM_POINTER to Det.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01002</srcid><srcstatus/><internalId>676</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_10</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_TriggerTransmit is called with SduDataPtr
        as NULL_PTR, then IpduM shall raise an error IPDUM_E_PARAM_POINTER to Det.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_01002</srcid><srcstatus/><internalId>676</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00028_11</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        If IpduMDevErrorDetect is configured to TRUE and IpduM_GetVersionInfo is called with NULL_PTR,
        then IpduM shall raise an error IPDUM_E_PARAM_POINTER to Det.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_02023_GetVersionInfo_NULL</srcid><srcstatus/><internalId>998</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>271</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00105.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Optional Interface

        Det_ReportError():
        Service to report development errors.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_04000_MandatoryApi</srcid><srcstatus/><internalId>651</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_xxx_xx092_DET</srcid><srcstatus/><internalId>996</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00105.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Further mandatory Interfaces

        PduR_IpduMRxIndication():
        Indication of a received I-PDU from a lower layer communication module.

        PduR_IpduMTxConfirmation():
        The lower layer communication module confirms the transmission of an I-PDU.
      </description>
      <comment>
        Changed from 'Optional Interface' to 'Further mandatory Interfaces' since there is no
        optimization implemented which makes these functions optional.

        See also deviation [ASCIPDUM-270].
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_04000_MandatoryApi</srcid><srcstatus/><internalId>651</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Interfaces</srcid><srcstatus/><internalId>446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00105.3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Further mandatory Interfaces

        PduR_IpduMTransmit():
        Requests transmission of an I-PDU.
      </description>
      <comment>
        Changed from 'Optional Interface' to 'Further mandatory Interfaces' since there is no
        optimization implemented which makes these functions optional.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_04000_MandatoryApi</srcid><srcstatus/><internalId>651</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Interfaces</srcid><srcstatus/><internalId>446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00105.4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V2.2.0</source>
      <version>1</version>
      <description>
        Further mandatory Interfaces

        PduR_IpduMTriggerTransmit():
        The lower layer communication module requests the buffer of the SDU for
        transmission from the upper layer module.
      </description>
      <comment>
        Changed from 'Optional Interface' to 'Further mandatory Interfaces' since there is no
        optimization implemented which makes these functions optional.

        See also deviation [ASCIPDUM-270].
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_04000_MandatoryApi</srcid><srcstatus/><internalId>651</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.IpduM.Interfaces</srcid><srcstatus/><internalId>446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00171.NoTransmission</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        In case the transmission of a multiplexed I-PDU is triggered
        by the update of one part and IpduMJitUpdate is configured to true for the second
        part, the multiplexed I-PDU shall not be send if the JIT-update request via
        PduR_IpduMTriggerTransmit returns E_NOT_OK. (SRS_IpduM_02816)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_1959</srcid><srcstatus/><internalId>504</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00060_JitUpdateNotOkOnTransmit</srcid><srcstatus/><internalId>671</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00171</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00171.RetVal</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The return value of IpduM_Transmit shall be E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2009</srcid><srcstatus/><internalId>505</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00060_JitUpdateNotOkOnTransmit</srcid><srcstatus/><internalId>671</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00171</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>

    <specobject>
      <id>IpduM.ECUC_IpduM_00178_Conf_CfgClassFixed</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name IpduMContainedTxPduConfirmation
        Description This Parameter determines whether for this contained I-PDU a TxConfirmation shall
                    be provided. If set to TRUE a TxConfirmation is issued. It is not used when an
                    I-PDU is requested using the trigger transmit API.
                    If this Parameter is omitted, the default value shall be used.
        Multiplicity 0..1
        Type EcucBooleanParamDef
        Default value false
        Post-Build Variant Value true
        Value Configuration Class
          Pre-compile time X
          Link time        X
          Post-build time  X
        Scope / Dependency scope: local
      </description>
      <comment>
        See <ulink url="https://jira.autosar.org/browse/AR-56606">RfC#56606</ulink>.
        Still not fixed in the SWS, not even in R19-11.
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.SWS_IpduM_00196.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00193.CQ</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT and
        IpduMContainedTxPduCollectionSemantics is IPDUM_COLLECT_QUEUED,
        IpduM shall keep and provide buffered data until it is fetched
        by a call to IpduM_TriggerTransmit. (SRS_IpduM_02820)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3373</srcid><srcstatus/><internalId>539</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07031_TriggerTransmit_Queue_1</srcid><srcstatus/><internalId>814</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07077_SizeAnnounceRetry_E_NOT_OK_Queued2</srcid><srcstatus/><internalId>842</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00193.LB</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT and
        IpduMContainedTxPduCollectionSemantics is IPDUM_COLLECT_LAST_IS_BEST,
        IpduM shall NOT keep and provide buffered data.
        The assembly of the container and payload retrieval shall be done when
        IpduM_TriggerTransmit is called. (SRS_IpduM_02820)
      </description>
      <comment>
        Behavior is according to IpduM.SWS_IpduM_00220.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2982</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3383</srcid><srcstatus/><internalId>542</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07026_TriggerTransmit</srcid><srcstatus/><internalId>791</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07054_TriggerTransmit_E_NOT_OK</srcid><srcstatus/><internalId>792</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>291</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00204.ShortHdrId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, R19-11</source>
      <version>1</version>
      <description>
        For each contained I-PDU of a received Container PDU where the
        IpduMContainerRxPdu has IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_ALL
        and IpduMContainerHeaderSize=IPDUM_HEADERTYPE_SHORT the ID shall be
        compared to IpduMContainedPduHeaderId, in the set of IpduMContainedRxPdus which
        do not have an IpduMContainedRxInContainerPduRef defined if
        RxContainerAcceptAllNoRefOnly is ON.
      </description>
      <comment>
        The parameter IpduMContainedRxPduShortHeaderId was not adopted in order
        to maintain backwards compatibility.
      </comment>
      <releases>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_ASR1911</srcid><srcstatus/><internalId>711</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_ASR1911</srcid><srcstatus/><internalId>715</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate_AA_ASR1911</srcid><srcstatus/><internalId>750</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00204.LongHdrId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, R19-11</source>
      <version>1</version>
      <description>
        For each contained I-PDU of a received Container PDU where the
        IpduMContainerRxPdu has IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_ALL
        and IpduMContainerHeaderSize=IPDUM_HEADERTYPE_LONG the ID shall be
        compared to IpduMContainedPduHeaderId, in the set of IpduMContainedRxPdus which
        do not have an IpduMContainedRxInContainerPduRef defined if
        RxContainerAcceptAllNoRefOnly is ON.
      </description>
      <comment>
        The parameter IpduMContainedRxPduLongHeaderId was not adopted in order
        to maintain backwards compatibility.
      </comment>
      <releases>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>713</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>717</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_LongHeader_ASR1911</srcid><srcstatus/><internalId>728</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05012_PduHeader_LongHeader_ASR1911</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate_AA_ASR1911</srcid><srcstatus/><internalId>750</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>For each contained I-PDU, the ID from its header shall be used to identify the corresponding
        I-PDU (Parameter IpduMContainedPduHeaderId) if IpduMRxContainerAcceptAllNoRefOnly is OFF. (SRS_IpduM_02824)</description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID</srcid><srcstatus/><internalId>712</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader</srcid><srcstatus/><internalId>714</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID</srcid><srcstatus/><internalId>716</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader</srcid><srcstatus/><internalId>718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>300</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00250.UniqueHeaderId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, R19-11</source>
      <version>1</version>
      <description>
        For an IpduMContainerRxPdu with
        IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_CONFIGURED
        the following constraint applies:
        IpduMContainedRxPdus with an IpduMContainedRxInContainerPduRef to
        that specific IpduMContainerRxPdu shall have unique
        IpduMContainedPduHeaderId, defined in the context of that IpduMContainerRxPdu.
        ( SRS_IpduM_02824)
      </description>
      <releases>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03010_IpduM_Rx_Unique_HeaderIds</srcid><srcstatus/><internalId>935</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00250</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>352</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>405</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00251.UniqueHeaderId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, R19-11</source>
      <version>1</version>
      <description>
        All IpduMContainedRxPdus with no IpduMContainedRxInContainerPduRef and
        a defined IpduMContainedPduHeaderId shall have a
        unique IpduMContainedPduHeaderId.
      </description>
      <comment>
        The parameters IpduMContainedRxPduShortHeaderId and
        IpduMContainedRxPduLongHeaderId were not adopted in order
        to maintain backwards compatibility.
      </comment>
      <releases>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_GEN_03010_IpduM_Rx_Unique_HeaderIds</srcid><srcstatus/><internalId>935</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00251</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, R19-11</source>
      <version>1</version>
      <description>
        For a received Container PDU with
        IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_ALL, IpduM shall expect
        and match only IpduMContainedRxPdus which do not have an
        IpduMContainedRxInContainerPduRef defined if IpduMRxContainerAcceptAllNoRefOnly
        is ON. (SRS_IpduM_02824)
      </description>
      <releases>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_ASR1911</srcid><srcstatus/><internalId>711</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>713</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_ASR1911</srcid><srcstatus/><internalId>726</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05012_PduHeader_ASR1911</srcid><srcstatus/><internalId>744</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate_AA_ASR1911</srcid><srcstatus/><internalId>750</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05017_Deferred_Queue_Multiple_PDUs_ASR1911</srcid><srcstatus/><internalId>756</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05018_Deferred_MF_RxIndication_ASR1911</srcid><srcstatus/><internalId>758</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2_ASR1911</srcid><srcstatus/><internalId>863</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing_ASR1911</srcid><srcstatus/><internalId>876</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_17000_HeaderIDLookupNoOOB_ASR1911</srcid><srcstatus/><internalId>993</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.Off</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>If for the Container PDU IpduMContainerRxAcceptContainedPdu is set to IPDUM_ACCEPT_ALL,
        IpduM shall expect and match all contained I-PDUs independent of
        IpduMContainedRxInContainerPduRef if IpduMRxContainerAcceptAllNoRefOnly is OFF.
        (SRS_IpduM_02824)</description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID</srcid><srcstatus/><internalId>712</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader</srcid><srcstatus/><internalId>714</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_17000_HeaderIDLookupNoOOB</srcid><srcstatus/><internalId>994</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>302</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, R19-11</source>
      <version>1</version>
      <description>
        If a contained I-PDU of a received IpduMContainerRxPdu with
        IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_ALL can not be matched
        according to [IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On] then this contained I-PDU
        shall be discarded silently. if RxContainerAcceptAllNoRefOnly is ON. (SRS_IpduM_02820, SRS_IpduM_02824)
      </description>
      <releases>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_ASR1911</srcid><srcstatus/><internalId>711</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>713</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05006_RxAcceptAll_Data_LongHeader_ASR1911</srcid><srcstatus/><internalId>728</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05010_RxAcceptAll_HeaderIDNotMatched_ASR1911</srcid><srcstatus/><internalId>736</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05010_RxAcceptAll_HeaderIDNotMatched_LongHeader_ASR1911</srcid><srcstatus/><internalId>738</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05011_RxAcceptConfigured_HeaderIDNotMatched_ASR1911</srcid><srcstatus/><internalId>740</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05012_PduHeader_ASR1911</srcid><srcstatus/><internalId>744</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05012_PduHeader_LongHeader_ASR1911</srcid><srcstatus/><internalId>746</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing_ASR1911</srcid><srcstatus/><internalId>876</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.Off</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>If an extracted contained I-PDU could not be matched based on its ID it shall be discarded
        silently if IpduMRxContainerAcceptAllNoRefOnly is OFF. (SRS_IpduM_02820, SRS_IpduM_02824)</description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05010_RxAcceptAll_HeaderIDNotMatched</srcid><srcstatus/><internalId>737</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05010_RxAcceptAll_HeaderIDNotMatched_LongHeader</srcid><srcstatus/><internalId>739</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05011_RxAcceptConfigured_HeaderIDNotMatched</srcid><srcstatus/><internalId>741</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05011_RxAcceptConfigured_HeaderIDNotMatched_LongHeader</srcid><srcstatus/><internalId>743</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>303</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>410</internalId></specobject>

    <specobject>
      <id>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, R19-11</source>
      <version>1</version>
      <description>
        If for the received Container PDU the configuration parameter
        IpduMContainerRxAcceptContainedPdu is set to IPDUM_ACCEPT_CONFIGURED,
        IpduM shall expect and match only contained I-PDUs (IpduMContainedRxPdu)
        that reference the IpduMContainerRxPdu in IpduMContainedRxInContainerPduRef
        if IpduMRxContainerAcceptAllNoRefOnly is ON. (SRS_IpduM_02824)
      </description>
      <comment>
        Note that it is well possible to define several IpduMContainedRxPdus
        with the same IpduMContainedRxPdu(Short/Long)HeaderId as long as the
        IpduMContainedRxPdus are assigned to different IpduMContainerRxPdus
        (via IpduMContainedRxInContainerPduRef) with each IpduMContainerRxPdu
        having IpduMContainerRxAcceptContainedPdu=IPDUM_ACCEPT_CONFIGURED.
      </comment>
      <releases>
        <release>AUTOSAR R19-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_ASR1911</srcid><srcstatus/><internalId>715</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader_ASR1911</srcid><srcstatus/><internalId>717</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05011_RxAcceptConfigured_HeaderIDNotMatched_LongHeader_ASR1911</srcid><srcstatus/><internalId>742</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_17000_HeaderIDLookupNoOOB_ASR1911</srcid><srcstatus/><internalId>993</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>301</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>
    <specobject>
      <id>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.Off</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>If for the Container PDU IpduMContainerRxAcceptContainedPdu is set to IPDUM_ACCEPT_CONFIGURED,
        IpduM shall expect and match only contained I-PDUs that reference the Container PDU in
        IpduMContainedRxInContainerPduRef if IpduMRxContainerAcceptAllNoRefOnly is OFF. (SRS_IpduM_02824)</description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID</srcid><srcstatus/><internalId>716</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader</srcid><srcstatus/><internalId>718</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_17000_HeaderIDLookupNoOOB</srcid><srcstatus/><internalId>994</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>301</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>

    <specobject>
      <id>IpduM.ECUC_IpduM_00185.RX.QueueSize</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name IpduMContainerQueueSize
        Description Defines a local queue for handling of each ContainerPdu.
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 1..254
        Default value 1
        Post-Build Variant Multiplicity  true
        Post-Build Variant Value  true
        Multiplicity Configuration class
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time X VARIANT-LINK-TIME
          Post-build time X VARIANT-POST-BUILD
        Value Configuration Class
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time X VARIANT-LINK-TIME
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency  scope: local
      </description>
      <comment>
        The number of instances is stored in a uint8.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_05016_Deferred_Queue</srcid><srcstatus/><internalId>755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>

    <specobject>
      <id>IpduM.ECUC_IpduM_00185.TX.QueueSize</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name IpduMContainerQueueSize
        Description Defines a local queue for handling of each ContainerPdu.
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 1..254
        Default value 1
        Post-Build Variant Multiplicity  true
        Post-Build Variant Value  true
        Multiplicity Configuration class
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time X VARIANT-LINK-TIME
          Post-build time X VARIANT-POST-BUILD
        Value Configuration Class
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time X VARIANT-LINK-TIME
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency  scope: local
      </description>
      <comment>
        The number of instances is stored in a uint8.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07033_Transmit_Queue_E_NOT_OK</srcid><srcstatus/><internalId>824</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>

    <specobject>
      <id>IpduM.ASR42.ECUC_IpduM_00190.AlwaysConsidered</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IPDUMultiplexer.pdf, V4.2.1</source>
      <version>1</version>
      <description>
        Name IpduMContainerTxConfirmationTimeout
            Description This timeout (in seconds) defines the timeout period for monitoring the
            reception of the TxConfirmation.
            If this Parameter is omitted, the default value shall be used.
        Multiplicity 0..1
        Type EcucFloatParamDef
        Range 1..65535
        Default value --
        Post-Build Variant Multiplicity  true
        Post-Build Variant Value  true
        Multiplicity Configuration class
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time X VARIANT-LINK-TIME
          Post-build time X VARIANT-POST-BUILD
        Value Configuration Class
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time X VARIANT-LINK-TIME
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency  scope: local
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        The functional specification is covered by IpduM.ASR42.SWS_IpduM_00189.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR42.ECUC_IpduM_00190</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>

    <specobject>
      <id>IpduM.ASR43.SWS_IpduM_91003</id>
      <status>approved</status>
      <source>AUTOSAR Bugzilla 71983</source>
      <version>1</version>
      <description>
        Service name: IpduM_MainFunctionRx_&amp;lt;shortName&amp;gt;
        Syntax: void IpduM_MainFunctionRx_shortName( void )
        Service ID[hex]: 0x11
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): None
        Parameters (inout): None
        Parameters (out): None
        Return value: None
        Description: This function performs the processing of the reception activities of the associated
                     IpduMContainerRxPdus that are not directly handled within the calls from PduR.
      </description>
      <comment>
        https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-772
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing_ASR1911</srcid><srcstatus/><internalId>876</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing</srcid><srcstatus/><internalId>877</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>

    <specobject>
      <id>IpduM.ASR43.SWS_IpduM_91004</id>
      <status>approved</status>
      <source>AUTOSAR Bugzilla 71983</source>
      <version>1</version>
      <description>
      Service name: IpduM_MainFunctionTx_&amp;lt;shortName&amp;gt;
      Syntax: void IpduM_MainFunctionTx_&amp;lt;shortName&amp;gt;(  void  )
      Service ID[hex]: 0x12
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This function performs the processing of the reception activities of the associated
                   IpduMContainerTxPdus / IpduMTxPathways that are not directly handled within the calls from PduR.
    </description>
      <comment>
      https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-772
    </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_10001_MainFuncFlexAlloc_SendTimeout</srcid><srcstatus/><internalId>869</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10002_MainFuncFlexAlloc_SendTimeout_2</srcid><srcstatus/><internalId>870</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10003_MainFuncFlexAlloc_TxConfirm</srcid><srcstatus/><internalId>871</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10004_MainFuncFlexAlloc_TxConfirm_SendTimeout</srcid><srcstatus/><internalId>872</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10005_MainFuncFlexAlloc_TxConfirm_SendAwait</srcid><srcstatus/><internalId>873</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10006_MainFuncFlexAlloc_Dequeue</srcid><srcstatus/><internalId>874</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_10007_MainFuncFlexAlloc_SizeAnnounce</srcid><srcstatus/><internalId>875</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>

    <specobject>
      <id>IpduM.ECUC_IpduM_00127.Postbuild</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxDynamicHandleId
        Parameter Type: Integer
        Parent Containers: IpduMTxDynamicPart,
        Description: This defines an incoming handle id. When the handle of an incoming Tx Request
        matches this id, the configured dynamic segments are copied and the IpduMTxTriggerMode is
        honored.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_02000_SymbolicNames</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04002_SymbolicNameValues40</srcid><srcstatus/><internalId>703</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00127</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00129.Postbuild</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMTxStaticHandleId
        Parameter Type: Integer
        Parent Containers: IpduMTxStaticPart,
        Description: This defines an incoming handle id. When the handle of an incoming Tx Request
        matches this id, the configured static segments are copied and the IpduMTxTriggerMode is
        honored.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: ECU
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: PRE-COMPILE, VARIANT-LINK-TIME
        Value-Configuration Class: PRE-COMPILE, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_02000_SymbolicNames</srcid><srcstatus/><internalId>648</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_04002_SymbolicNameValues40</srcid><srcstatus/><internalId>703</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00129</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>
    <specobject>
      <id>IpduM.ECUC_IpduM_00158.Postbuild</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name IpduMTxConfirmationPduId

        Description
        The handle Id to be used by the PduR to confirm the transmission of this PDU.
        The existence of this parameter is essential for the PduR generation tool to
        actually find a symbolicNameValue for the OutgoingPdu.

        Multiplicity 0..1

        Type EcucIntegerParamDef (Symbolic Name generated for this parameter)

        Range 0.. 65535

        Default value -

        Post-Build Variant Value true

        ConfigurationClass
        Pre-compile time XVARIANT-PRE-COMPILE
        Link time X VARIANT-LINK-TIME
        Post-build time XVARIANT-POST-BUILD

        Scope / Dependency scope: local
      </description>
      <comment>
        The multiplicity of this parameter has to be considered as one. The description already
        mentions that this parameter is essential for the configuration code generation.
        Please see also the deviation entry which references this requirement.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_04002_SymbolicNameValues40</srcid><srcstatus/><internalId>703</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>

    <specobject>
      <id>IpduM.ECUC_IpduM_00160.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMSelectorFieldLength
        Parameter Type: Integer
        Parent Containers: IpduMSelectorField,
        Description: Length of the selector field in bits.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Scope: LOCAL
        Origin: AUTOSAR_ECUC
        Post-Build-Variant-Value: true
        Value-Configuration Class: LINK, VARIANT-LINK-TIME
        Value-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Value-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
        Symbolic-Name-Value: false
        Max-Value: 8 (Type:
        Min-Value: 1 (Type:
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_00020</srcid><srcstatus/><internalId>663</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_00021</srcid><srcstatus/><internalId>664</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>

    <specobject>
      <id>IpduM.ECUC_IpduM_00170.1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_IpduM_R20-11.arxml</source>
      <version>1</version>
      <description>
        Name: IpduMRxDynamicSegment
        Container Type: Sub-Container
        Parent Containers: IpduMRxIndication,
        Description: The dynamic part of the multiplexed incoming I-Pdu (referenced by
        IpduMRxIndicationPduRef) can be separated into several segments.
        Introduction: For each segment one IpduMRxDynamicSegment container shall be created that
        contains the location and the length of the segment. Please note that each configured segment
        will be copied into the destination I-Pdu that is referenced in the IpduMRxDynamicPart
        container and will be copied from the same location in the multiplexed incoming I-Pdu. The
        segment layout for all dynamic Parts is always identical.
        Lower Multiplicity: 1
        Upper Multiplicity: Infinite
        Post-Build-Variant-Multiplicity: true
        Multiplicity-Configuration Class: LINK, VARIANT-LINK-TIME
        Multiplicity-Configuration Class: POST-BUILD, VARIANT-POST-BUILD
        Multiplicity-Configuration Class: PRE-COMPILE, VARIANT-PRE-COMPILE
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>

  </specobjects>
    <specobjects doctype="man">

    <specobject>
      <id>TS_IpduM_Manual_MemMap</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Test Description:
        Check that all global variables and functions are enclosed by correct memory section
        according to the respective symbol property and are followed by the inclusion of MemMap.h

        Test Precondition:

        Test Execution:
        Code review.
        01: Check that all function and global variables definitions and declarations are enclosed
            by a IPDUM_START_SEC_&lt;TYPE_PROPERTIES&gt; and IPDUM_STOP_SEC_&lt;TYPE_PROPERTIES&gt;
            symbol.
        02: Check that all memory sections are followed by the inclusion of Memmap.h
      </description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151_1_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151_1_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>372</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>

    <specobject>
      <id>TS_IpduM_Manual_InterruptCallable</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Test Description:
        Check that IpduM_TxConfirmation, IpduM_RxIndication and IpduM_TriggerTransmit are
        callable from interrupt context.

        Test Precondition:

        Test Execution:
        Code review.
        All test steps are required to fulfill IpduM.ASR40.SWS_IpduM_00086, IpduM.ASR40.SWS_IpduM_00087 and
        IpduM.ASR40.SWS_IpduM_00089.
        01: VP(IpduM.ASR40.SWS_IpduM_00086):
            Check that no Os calls apart from locking (via SchM's Enter/Exit calls) are used within
            IpduM_RxIndication and its sub functions.
        02: VP(IpduM.ASR40.SWS_IpduM_00087):
            Check that no Os calls apart from locking (via SchM's Enter/Exit calls) are used within
            IpduM_TxConfirmation and its sub functions.
        03: VP(IpduM.ASR40.SWS_IpduM_00089):
            Check that no Os calls apart from locking (via SchM's Enter/Exit calls) are used within
            IpduM_TriggerTransmit and its sub functions.
      </description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00086</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>IpduM.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_DBGINST_001</srcid><srcstatus/><internalId>640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>

    <specobject>
      <id>IpduM.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_DBGINST_001</srcid><srcstatus/><internalId>640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>

    <specobject>
      <id>IpduM.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_DBGINST_001</srcid><srcstatus/><internalId>640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>

    <specobject>
      <id>IpduM.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_DBGINST_001</srcid><srcstatus/><internalId>640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>

    <specobject>
      <id>IpduM.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_DBGINST_001</srcid><srcstatus/><internalId>640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>IpduM.EB.PBCFGM101</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: IpduM_IsValidConfig
        Syntax: Std_ReturnType IpduM_IsValidConfig( void* ConfigPtr )
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): ConfigPtr, post build configuration manager
        configuration.
        Parameters (inout): None
        Parameters (out): None
        Return value: Returns E_OK if the IpduM configuration is valid otherwise E_NOT_OK. A
        null pointer is interpreted as invalid configuration.
        Description: This function determines if the IpduM configuration is valid. This
        function can be called also before the IpduM is initialized. No error reporting
        is necessary within this function.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_IsValidConfig</srcid><srcstatus/><internalId>641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBCFGM102</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A configuration is valid
        - if the platform signature in the post build configuration equals the value
          determined by the macro TS_PlatformSigIsValid.
        - if the link time signature in the post build configuration equals the link time
          signature in the link time configuration file.
        - if the compile time signature in the post build configuration equals the value of
          the macro IPDUM_CFG_SIGNATURE.
        - if the compile time signature of Published information in the post build configuration
          equals the value of the macro IPDUM_PUBLIC_INFO_SIGNATURE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_IsValidConfig</srcid><srcstatus/><internalId>641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBCFGM104</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          CfgSignature.
        - the IpduM_Cfg.h file shall contain the macro
          IPDUM_CFG_SIGNATURE.
        - the MCG shall generate this signature value of compile time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of compile time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_IsValidConfig</srcid><srcstatus/><internalId>641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBCFGM104_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          PublicInfoSignature.
        - the IpduM_Cfg.h file shall contain the macro
          IPDUM_PUBLIC_INFO_SIGNATURE.
        - The MCG shall generate this signature value from the list of parameters of
          configuration class 'PublishedInformation' except 'Release'. The XPath function
          asc:getConfigSignature(nodeset) shall be used to determine the signature out of the
          list of parameters. The list of parameters shall be determined with the function
          asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_IsValidConfig</srcid><srcstatus/><internalId>641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBCFGM105</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the link time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          LcfgSignature.
        - the link time configuration shall contain the uint32 value
          IpduM_LcfgSignature.
        - the MCG shall generate this signature value of link time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of link time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_IsValidConfig</srcid><srcstatus/><internalId>641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBCFGM106</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For Platform verification:
        - the IpduM post build configuration structure shall contain the value
          uint32 PlatformSignature. This uint32 must be the first value of the post build
          configuration structure to guarantee the correct access not disturbed by any padding
          bytes.
        - the MCG shall generate this signature for the selected target. The generator shall
          use the x-path function asc:getPlatformSignature() to determine this value.
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
        https://issue.ebgroup.elektrobit.com/browse/ASCBASE-1485
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_IsValidConfig</srcid><srcstatus/><internalId>641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBCFGM107</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The PbcfgM support shall be enabled or disabled via the macro
        IPDUM_PBCFGM_SUPPORT_ENABLED defined in the file
        IpduM_Cfg.h.
        If the PbcfgM configuration references the IpduM configuration
        the macro is set to STD_ON otherwise, or if no PbcfgM configuration is
        available it is set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_IsValidConfig</srcid><srcstatus/><internalId>641</internalId></linkedfrom><linkedfrom><srcid>IpduM_Test_PBcfgM_Off</srcid><srcstatus/><internalId>643</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBCFGM108</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the IpduM is referenced by the PbcfgM, the parameter regarding the
        relocatable feature, shall not be editable and the MCG shall use the configuration of
        the PbcfgM.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_PBcfgM_Off</srcid><srcstatus/><internalId>643</internalId></linkedfrom><linkedfrom><srcid>IpduM_Test_PBcfgM_On</srcid><srcstatus/><internalId>644</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/IpduM_EBParameters.xdm.m4_706</srcid><srcstatus/><internalId>578</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PBCFGM110</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduM_Init() function must be extended to enable the PbcgfM
        features.
        The initialization function shall obtain the IpduM configuration
        from the PbcfgM if the PbcfgM support is enabled within this IpduM
        and the initialization function is called with a null pointer.
        The validity of the configuration shall be checked by the function
        IpduM_IsValidConfig(). The validity shall be check regardless the PbcfgM
        support is enabled or not.
        If no valid configuration can be obtained the initialization function shall
        return, leaving the IpduM uninitialized.
        In the case error reporting is enabled and no valid configuration can be obtained
        an erroneous parameter shall be indicated.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_VerifyInitWithPcfgM</srcid><srcstatus/><internalId>642</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PostBuild_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduM module shall compile and build an executable even in the absence
        of a post build configuration, i.e. without any post build generated .c and .h files
        available.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_COM_16_NoPbCfg</srcid><srcstatus/><internalId>661</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PbcfgM_General_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduM shall provide the following macros in the header file
        IpduM_Cfg.h:
        - IPDUM_RELOCATABLE_CFG_ENABLE which is set to STD_ON
          if relocatable config shall be enabled, otherwise it's set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_PBcfgM_On</srcid><srcstatus/><internalId>644</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>

    <specobject>
      <id>IpduM.EB.PbcfgM_General_6</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PbcfgM support is enabled IpduM shall define the following macros in
        IpduM_PBCfg.c:
        - TS_PB_CFG_LAYOUT_TYPE: Shall expand to the type definition of the Postbuild
          configuration layout type (e.g. IpduM_ConstConfigLayoutType)
        - TS_PB_CFG_NAME: Shall expand to the name of the structure defining the Postbuild
          configuration layout (e.g. IpduM_ConfigLayout)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM_Test_PBcfgM_Off</srcid><srcstatus/><internalId>643</internalId></linkedfrom><linkedfrom><srcid>IpduM_Test_PBcfgM_On</srcid><srcstatus/><internalId>644</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>IpduM.EB.PDULENGTHTYPE001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IpduM module shall support the following values of PduLengthType:
        [UINT32, UINT16]
      </description>
      <verifycrit>
        Use case 1 - Modules not capable of handling more than 64 kbytes of data:
          - use PduLengthType value 'UINT32' with conformance test
          - verify successful test run, verify absence of metric violations
            (MISRA-C:2012, static code analysis, compiler warnings)
        Use case 2 - Modules capable of handling more than 64 kbytes of data:
          - use conformance test which handles more than 64 kbytes of data
          - apply "boundary" tests using data length of:
            [&lt;&lt;65535,65535, 65536, &gt;131072][bytes]
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_13001_CntrTx_UINT32_NoQueuing</srcid><srcstatus/><internalId>880</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_13002_CntrTx_UINT32_LB_NoQueuing</srcid><srcstatus/><internalId>881</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_13003_CntrTx_UINT32_WithQueuing</srcid><srcstatus/><internalId>882</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_13004_CntrTx_UINT32_LB_WithQueuing</srcid><srcstatus/><internalId>883</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_13005_CntrRx_UINT32_NoQueuing</srcid><srcstatus/><internalId>884</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_13006_CntrRx_UINT32_WithQueuing</srcid><srcstatus/><internalId>885</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>IpduM.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IpduM_VerifyCodeStub</srcid><srcstatus/><internalId>645</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.IpduM.LittleEndiannessOnly</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>34</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>
    <specobject>
      <id>dev.IpduM.IpduMRxDirectComInvocation</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>52</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00140</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00142</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Interfaces</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>396</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>
    <specobject>
      <id>dev.IpduM.AutosarDebugging</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>105</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00144</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00145</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00147</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>
    <specobject>
      <id>dev.IpduM.ConsChck</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>130</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00165</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>
    <specobject>
      <id>dev.IpduM.PostBuild</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>144</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>
    <specobject>
      <id>dev.IpduM.FileInclusion</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00149</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>
    <specobject>
      <id>dev.IpduM.TxConfirmationPduId</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>176</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>
    <specobject>
      <id>dev.IpduM.UnsupportedIpduMConfigurationTimeBase</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>238</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.ECUC_IpduM_00131</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>
    <specobject>
      <id>dev.IpduM.UnsupportedIpduM_MainFunction</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>254</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00103</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00101</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Dequeue.MainFuncTx</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>272</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Dequeue.TxConf</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>288</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Dequeue.TxOverflow</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>308</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>
    <specobject>
      <id>dev.IpduM.QueueSizeUpperLimit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>325</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Cntr.Last_Is_Best.Update</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>342</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Container.ReliableTxConfirmation</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>355</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>287</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Multiplex.Func.Change</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>370</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00173</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>272</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Transmit.ServiceId</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>384</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00043</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Container.IpduMContainedTxPduHandleId.postbuild</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>398</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>
    <specobject>
      <id>dev.IpduM.IpduMContainerRxHandleId.postbuild</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>412</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00187</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>257</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>
    <specobject>
      <id>dev.IpduM.IpduMContainerTxHandleId.postbuild</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>426</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00191</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>
    <specobject>
      <id>dev.IpduM.IpduMContainedPduHeaderId.Multiplicity</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>441</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00172</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>
    <specobject>
      <id>dev.IpduM.InitFailed</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00174</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>273</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Contained.HeaderId</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>469</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>320</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>319</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>
    <specobject>
      <id>dev.IpduM.Metadata</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>484</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00228</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>326</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00226</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>324</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00225</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>323</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>328</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>
    <specobject>
      <id>dev.PartlyImplementedFunctionalities</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>500</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>288</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00231</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>334</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00142</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>
    <specobject>
      <id>dev.IpduMMaxTxPathwayCnt</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>518</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00165</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>
    <specobject>
      <id>dev.IpduMMaxTxBufferSize</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>532</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>
    <specobject>
      <id>dev.IpduMMetaDataSupport.LowerMultiplicity</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>546</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>321</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>
    <specobject>
      <id>dev.FlexProcessing.Multicore</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>562</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00211</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00212</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>357</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>359</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00218</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>362</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>
    <specobject>
      <id>dev.IpduMRxSelectorValue.UpperMultiplicity</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>583</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>
    <specobject>
      <id>dev.IpduMSelectorFieldLength.Range</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>597</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00160</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>
    <specobject>
      <id>dev.IpduMRxDynamicSegment.LowerMultiplicity</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>611</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/IpduM_Int.h.m4_111</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate/include/IpduM_Int.h.m4</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00247</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/IpduM_Int.h.m4_1006</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate/include/IpduM_Int.h.m4</sourcefile>
      <sourceline>1006</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/IpduM_Lcfg.c.m4_26</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate/src/IpduM_Lcfg.c.m4</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/src/IpduM_Lcfg.c.m4_71</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate/src/IpduM_Lcfg.c.m4</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_Macros.m_126</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_Macros.m</sourcefile>
      <sourceline>126</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.QueuingNumInstances</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_Macros.m_327</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_Macros.m</sourcefile>
      <sourceline>327</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM562</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/IpduM_Api.h_7</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/include/IpduM_Api.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>375</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/IpduM_Api.h_11</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/include/IpduM_Api.h</sourcefile>
      <sourceline>11</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/IpduM_Api.h_14</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/include/IpduM_Api.h</sourcefile>
      <sourceline>14</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00151_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_84</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>84</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_86</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>86</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>367</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_88</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>88</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>365</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_96</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00148_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>370</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_621</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>621</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_633</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>633</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_692</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>692</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>619</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_706</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>706</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMInitializationBySignalValue.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_870</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>870</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit.NoContainedPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_987</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>987</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1000</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1000</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1159</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1264</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1264</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1532</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1532</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMInitializationBySignalValue.Success</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1704</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1704</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.StaticPart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1722</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1722</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.DynamicPart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1739</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1739</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.StaticPart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1762</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1762</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.DynamicPart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_1959</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>1959</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00171.NoTransmission</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2009</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2009</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00171.RetVal</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2073</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2073</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.GetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2133</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2133</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.SetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2191</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2191</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.GetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2237</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2237</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.SetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2302</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2302</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder.NoOverFlow</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2312</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2312</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder.OverFlowWhileReading</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2321</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2321</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder.OverFlowNotRead</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2363</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2363</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2364</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2364</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_FIRST</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>625</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2365</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2365</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2366</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2366</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2585</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2585</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2613</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2613</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Process.QueueSizeNotReached</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>618</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2646</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2646</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2707</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2707</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Process.QueueSizeReached</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2741</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2741</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit.NoContainedPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2746</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2746</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Idle.WaitTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2787</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2787</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Triggered.TxConfTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>628</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2806</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2806</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Triggered.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>629</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2923</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2923</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Triggered.WaitConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>630</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2940</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2940</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Process.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>616</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2982</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2982</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193.LB</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_2994</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>2994</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3060</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3060</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3209</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3209</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3234</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3234</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3235</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3235</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_FIRST</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>625</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3236</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3236</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3237</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3237</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3240</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3240</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Process.QueueSizeNotReached</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>618</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3289</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3289</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3318</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3318</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Process.QueueSizeReached</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3371</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3371</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.CQ</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>633</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3373</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3373</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193.CQ</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3381</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3381</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.LB</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>634</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3382</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3382</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3383</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3383</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193.LB</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3393</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3393</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Process.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>616</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3416</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3416</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.MinSduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>636</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3490</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3490</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>638</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3491</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3491</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Process.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>616</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3740</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3740</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3819</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3819</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3868</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3868</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>639</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3869</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3869</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.NoOverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3870</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3870</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3893</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3893</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_3962</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>3962</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_4092</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>4092</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Establish</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/IpduM.c.m4_4126</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/src/IpduM.c.m4</sourcefile>
      <sourceline>4126</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_25</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM501</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_73</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>73</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_109</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>109</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.IpduMTxRequestMaxSduLength</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_130</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>130</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM553_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_167</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM557</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_230</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>230</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMEnableJitUpdate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_261</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>261</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDedicatedIpduProcessingSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_293</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>293</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_309</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>309</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing.IpduMTimeBase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_326</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>326</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing.IpduMPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_344</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>344</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing.IpduMRxPduRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_370</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>370</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_386</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>386</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing.IpduMTimeBase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_403</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>403</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing.IpduMPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_421</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>421</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing.IpduMTxPduRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_447</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>447</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerPduHandlingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_489</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>489</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMStaticContainerPduHandling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_533</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>533</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerQueuingRx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_578</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>578</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainedCollectQueuedTx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_623</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>623</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMMaxContainerRxLength</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_650</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>650</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_683</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>683</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_706</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>706</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_748</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>748</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataTxPrioritySupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_794</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>794</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM554_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_EBParameters.xdm.m4_823</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_EBParameters.xdm.m4</sourcefile>
      <sourceline>823</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM556</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_270</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>270</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00240</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_273</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>273</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00241</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_276</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>276</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntrRx.NoRefAcceptAll</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_325</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>325</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_422</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>422</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_447</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>447</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_504</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>504</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntdTxPduSendTimeout_TxTimeBase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_529</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>529</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.MetaData.IpduMTxMetaDataMask</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_571</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>571</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.MetaData.IpduMTxMetaDataValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_625</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>625</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00240</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_628</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>628</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00241</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_809</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>809</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntrRx.MaxPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_911</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>911</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntrTxConfirmationTimeout_TxTimeBase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_971</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>971</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntrTxSendTimeout_TxTimeBase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_1037</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>1037</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.IpduMCanFdPaddingService</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_1070</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>1070</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.Restrictions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_1612</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>1612</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.IpduMTxRequestMaxSduLength</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_1942</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>1942</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.ECUC_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_1972</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>1972</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.ECUC_IpduM_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_2042</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>2042</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/IpduM_Extension.xdm.m4_2076</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/config/IpduM_Extension.xdm.m4</sourcefile>
      <sourceline>2076</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.IpduMCanFdPaddingSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_checks.m_198</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_checks.m</sourcefile>
      <sourceline>198</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdOverlapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_checks.m_199</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_checks.m</sourcefile>
      <sourceline>199</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdSizeExceed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>604</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_checks.m_200</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_checks.m</sourcefile>
      <sourceline>200</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdUpdateBitSizeExceed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>605</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_checks.m_201</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_checks.m</sourcefile>
      <sourceline>201</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00245</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>606</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_checks.m_275</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_checks.m</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdOverlapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>607</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_checks.m_276</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_checks.m</sourcefile>
      <sourceline>276</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdSizeExceed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>608</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_checks.m_277</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_checks.m</sourcefile>
      <sourceline>277</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdUpdateBitSizeExceed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>609</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/IpduM_checks.m_278</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_macros/IpduM_checks.m</sourcefile>
      <sourceline>278</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00245</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>610</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_var/xgen/IpduM.xgen_17</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_var/xgen/IpduM.xgen</sourcefile>
      <sourceline>17</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00096</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>611</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/IpduM.xgen_18</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_var/xgen/IpduM.xgen</sourcefile>
      <sourceline>18</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>612</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/IpduM.xgen_1618</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/src/Autosar/generate_var/xgen/IpduM.xgen</sourcefile>
      <sourceline>1618</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>613</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Design requirements">
    <specobject>
      <id>IpduM.dsn.Transition.Container.Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19666</sourceline>
      <version>1</version>
      <description>
        Upon initialization (IpduM_Init()) the state of the Container
        shall be Idle.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.Init</srcid><srcstatus/><internalId>619</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>614</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Container.Idle.Process</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19679</sourceline>
      <version>1</version>
      <description>
        By adding a Contained PDU to a Container (IpduM_Transmit()), the Container
        shall be processed and transmitted.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.Idle.WaitTransmit</srcid><srcstatus/><internalId>620</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>615</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Container.Process.Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19692</sourceline>
      <version>1</version>
      <description>
        When all Contained PDUs were transmitted the state of the Container
        shall be Idle.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2940</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3393</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3491</srcid><srcstatus/><internalId>546</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>616</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Container.Process.QueueSizeReached</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19706</sourceline>
      <version>1</version>
      <description>
        When the container queue is full, the oldest instance shall be removed
        and a new instance shall be created.
      </description>
      <comment>
        Functionality tested through IpduM.SWS_IpduM_00199.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2707</srcid><srcstatus/><internalId>520</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3318</srcid><srcstatus/><internalId>537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>617</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Container.Process.QueueSizeNotReached</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19728</sourceline>
      <version>1</version>
      <description>
        When the container size is exceeded by adding a new a Contained PDU and
        the queue is not full, a new instance shall be created.
      </description>
      <comment>
        Functionality tested through IpduM.SWS_IpduM_00182, IpduM.SWS_IpduM_00183.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2613</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3240</srcid><srcstatus/><internalId>535</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>618</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19756</sourceline>
      <version>1</version>
      <description>
        Upon initialization (IpduM_Init()) the state of the Container instance
        shall be Idle.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_692</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>614</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>619</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.Idle.WaitTransmit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19776</sourceline>
      <version>1</version>
      <description>
        Upon adding the first Contained PDU to the Container (IpduM_Transmit())
        the instance shall change state from Idle to WaitTransmit.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2746</srcid><srcstatus/><internalId>522</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Idle.Process</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>620</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitTransmit.Transmit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19796</sourceline>
      <version>1</version>
      <description>
        In the state WaitTransmit Contained PDUs shall be appended to the
        Container PDU (IpduM_Transmit()).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2585</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3209</srcid><srcstatus/><internalId>530</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>621</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19810</sourceline>
      <version>1</version>
      <description>
        The Container instance shall transition from the state WaitTransmit
        to Triggered when trigger conditions are fulfilled.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</srcid><srcstatus/><internalId>623</internalId></linkedfrom><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</srcid><srcstatus/><internalId>624</internalId></linkedfrom><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_FIRST</srcid><srcstatus/><internalId>625</internalId></linkedfrom><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</srcid><srcstatus/><internalId>626</internalId></linkedfrom><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</srcid><srcstatus/><internalId>627</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>622</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19823</sourceline>
      <version>1</version>
      <description>
        The Container instance shall transition from the state WaitTransmit
        to Triggered when the container payload size exceeds IpduMContainerTxSizeThreshold.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2365</srcid><srcstatus/><internalId>515</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3236</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07004_ThresholdExceeded</srcid><srcstatus/><internalId>774</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07005_ThresholdExceeded_2</srcid><srcstatus/><internalId>775</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07015_SizeTrigger</srcid><srcstatus/><internalId>786</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07016_SizeTrigger_2</srcid><srcstatus/><internalId>787</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07017_SizeTrigger_3</srcid><srcstatus/><internalId>788</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07095_Trigger_by_PduLength_Queued</srcid><srcstatus/><internalId>844</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>622</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00180</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>278</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>623</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19847</sourceline>
      <version>1</version>
      <description>
        The Container instance shall transition from the state WaitTransmit
        to Triggered when the added Contained PDU has IpduMContainedTxPduTrigger
        set to IPDUM_TRIGGER_ALWAYS.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2363</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3234</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07002_TriggerImmediately</srcid><srcstatus/><internalId>772</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07003_TriggerImmediately_2</srcid><srcstatus/><internalId>773</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07025_TxConfirmationContained</srcid><srcstatus/><internalId>790</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07092_SizeAnnounceOnlyOnce_TrgAlways</srcid><srcstatus/><internalId>834</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07096_TrgAlways_NoConf_Queued_Dir</srcid><srcstatus/><internalId>845</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07097_TrgAlways_NoConf_Queued_TT</srcid><srcstatus/><internalId>846</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07098_DeQOrder1_NoConf_Queued_TT</srcid><srcstatus/><internalId>847</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>622</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00181</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>279</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>624</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_FIRST</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19872</sourceline>
      <version>1</version>
      <description>
        The Container instance shall transition from the state WaitTransmit
        to Triggered when the Container PDU has IpduMContainerTxFirstContainedPduTrigger
        set to TRUE.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2364</srcid><srcstatus/><internalId>514</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3235</srcid><srcstatus/><internalId>532</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07067_SizeAnnounceMFTx_LB</srcid><srcstatus/><internalId>800</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07063_SizeAnnounceOnlyOnce</srcid><srcstatus/><internalId>833</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>622</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>625</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19893</sourceline>
      <version>1</version>
      <description>
        The Container instance shall transition from the state WaitTransmit
        to Triggered when the running IpduMContainerTxSendTimeout expires.
      </description>
      <comment>
        min(IpduMContainerTxSendTimeout,IpduMContainedTxPduSendTimeout) == 0
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3819</srcid><srcstatus/><internalId>548</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07011_TxSendTimeout</srcid><srcstatus/><internalId>781</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07012_TxSendTimeout_2</srcid><srcstatus/><internalId>782</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07013_TxSendTimeout_3</srcid><srcstatus/><internalId>783</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07014_TxSendTimeout_3_2</srcid><srcstatus/><internalId>784</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07026_TriggerTransmit</srcid><srcstatus/><internalId>791</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07054_TriggerTransmit_E_NOT_OK</srcid><srcstatus/><internalId>792</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07036_TxSendTimeout_4</srcid><srcstatus/><internalId>827</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_09002_MainFuncTx_SendTimeout</srcid><srcstatus/><internalId>866</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_09003_MainFuncTx_SendTimeout2</srcid><srcstatus/><internalId>867</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>622</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>284</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>626</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19920</sourceline>
      <version>1</version>
      <description>
        The Container instance shall transition from the state WaitTransmit
        to Triggered when the Container PDU has IpduMContainerHeaderSize set to
        IPDUM_HEADERTYPE_NONE and all contained I-PDUs were updated by
        the upper layer.
      </description>
      <comment>
        All other trigger conditions still apply.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2366</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3237</srcid><srcstatus/><internalId>534</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07081_CntrTx_Update_Bit</srcid><srcstatus/><internalId>851</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07082_CntrTx_Unused_Area</srcid><srcstatus/><internalId>852</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07083_CntrTx_TT_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>853</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07084_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>854</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07086_StaticTTLBOK</srcid><srcstatus/><internalId>855</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14005_CntrTx_Update_Bit</srcid><srcstatus/><internalId>891</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14006_CntrTx_Unused_Area</srcid><srcstatus/><internalId>892</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14007_CntrTx_TT_Update_Bit_Different_Bytes</srcid><srcstatus/><internalId>894</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_14008_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</srcid><srcstatus/><internalId>896</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>622</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00234</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>337</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>627</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.Triggered.TxConfTimer</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19949</sourceline>
      <version>1</version>
      <description>
        In the state Triggered when the associated running IpduMContainerTxConfirmationTimeout
        is greater than 0, the state shall not be changed.
      </description>
      <comment>
        No calls to PduR_IpduMTransmit().
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2787</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>628</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.Triggered.Transmit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19966</sourceline>
      <version>1</version>
      <description>
        In the state Triggered Contained PDUs associated with a Container
        that has IpduMContainerTxTriggerMode set as IPDUM_TRIGGERTRANSMIT
        shall be appended to the Container if the size of of Container is not exceeded.
      </description>
      <comment>
        The associated IpduMContainerTxConfirmationTimeout is still running ( &amp;gt;0 ).
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2806</srcid><srcstatus/><internalId>524</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>629</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.Triggered.WaitConfirmation</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19984</sourceline>
      <version>1</version>
      <description>
        When PduR_IpduMTransmit() returns E_OK in the state Triggered, the SM
        shall transition to the state WaitConfirmation.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2923</srcid><srcstatus/><internalId>525</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>630</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.Transmit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>19998</sourceline>
      <version>1</version>
      <description>
        In the state WaitConfirmation calls to IpduM_Transmit() shall be
        handled by appending the Contained PDUs to the Container when
        the IpduMContainedTxPduCollectionSemantics is set to IPDUM_COLLECT_LAST_IS_BEST.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_2646</srcid><srcstatus/><internalId>519</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>631</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>20013</sourceline>
      <version>1</version>
      <description>
        Calls to IpduM_TriggerTransmit() shall be handled in the state
        WaitConfirmation.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.CQ</srcid><srcstatus/><internalId>633</internalId></linkedfrom><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.LB</srcid><srcstatus/><internalId>634</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>632</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.CQ</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>20026</sourceline>
      <version>1</version>
      <description>
        In the state WaitConfirmation when IpduM_TriggerTransmit() is called
        for Container PDUs with IpduMContainedTxPduCollectionSemantics set to
        IPDUM_COLLECT_QUEUED, the readily assembled container payload shall be
        copied to the provided buffer.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3371</srcid><srcstatus/><internalId>538</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>632</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>633</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.LB</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>20048</sourceline>
      <version>1</version>
      <description>
        In the state WaitConfirmation when IpduM_TriggerTransmit() is called
        for Container PDUs with IpduMContainedTxPduCollectionSemantics set to
        IPDUM_LAST_IS_BEST, the container shall be assembled by retrieving
        the payloads of Contained PDUs by PduR_IpduMTriggerTransmit().
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3381</srcid><srcstatus/><internalId>540</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>632</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>634</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.Triggered</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>20070</sourceline>
      <version>1</version>
      <description>
        During transmission of a Container PDU the SM shall transition from
        the state WaitConfirmation to Triggered.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.MinSduLength</srcid><srcstatus/><internalId>636</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>635</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.MinSduLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>20083</sourceline>
      <version>1</version>
      <description>
        In the state WaitConfirmation when IpduM_TriggerTransmit() is called
        for Container PDUs and the provided SduLength is less than the configured
        PduLength, the SM shall transition from the state
        WaitConfirmation to Triggered.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3416</srcid><srcstatus/><internalId>544</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_CON_07093_TriggerTransmit_E_NOT_OK_CQ_Retry</srcid><srcstatus/><internalId>835</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_CON_07094_TriggerTransmit_E_NOT_OK_LB_Retry</srcid><srcstatus/><internalId>836</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Triggered</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>635</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>636</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>20105</sourceline>
      <version>1</version>
      <description>
        During transmission of a Container PDU the SM shall transition from
        the state WaitConfirmation to Idle.
      </description>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfirmation</srcid><srcstatus/><internalId>638</internalId></linkedfrom><linkedfrom><srcid>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfTimer</srcid><srcstatus/><internalId>639</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>637</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfirmation</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>20118</sourceline>
      <version>1</version>
      <description>
        During transmission of a Container PDU the SM shall transition from
        the state WaitConfirmation to Idle when IpduM_TxConfirmation() is called.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3490</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_15005_TxTxConf_NewInst</srcid><srcstatus/><internalId>989</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>637</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>638</internalId></specobject>
    <specobject>
      <id>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfTimer</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/doc/project/design/pdf/IpduM_Design-profiled.xml</sourcefile>
      <sourceline>20138</sourceline>
      <version>1</version>
      <description>
        During transmission of a Container PDU the SM shall transition from
        the state WaitConfirmation to Idle when the associated
        IpduMContainerTxConfirmationTimeout expires.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/IpduM.c.m4_3868</srcid><srcstatus/><internalId>549</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_IPDUM_IMP_12004_MuxCntr_Tx_2</srcid><srcstatus/><internalId>981</internalId></linkedfrom><linkedfrom><srcid>TS_IPDUM_IMP_16003_State</srcid><srcstatus/><internalId>992</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>637</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>639</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IpduM_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>425</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>426</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>429</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>640</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>IpduM_Test_IsValidConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the function IpduM_IsValidConfig() is implemented as specified.
  
Test Object: 
    IpduM_IsValidConfig()
  
Test Precondition: 
    The IpduM module is not initialized.
  
Test Execution: 
    01: Call the function IpduM_IsValidConfig() with an NULL_PTR.
    02: VP:
        The function must have returned with E_NOT_OK.
    03: Create an invalid configuration regarding the endianness and alignment.
    04: Call the function IpduM_IsValidConfig() with this invalid configuration.
    05: VP(IpduM.EB.PBCFGM106):
        The function must have returned with E_NOT_OK.
    The following 3 steps are only executed if the module has a link-time configuration:
        06: Create an invalid configuration regarding the link time configuration.
        07: Call the function IpduM_IsValidConfig() with this invalid configuration.
        08: VP(IpduM.EB.PBCFGM105):
                The function must have returned with E_NOT_OK.
    09: Create an invalid configuration regarding the compile time configuration.
    10: Call the function IpduM_IsValidConfig() with this invalid configuration.
    11: VP(IpduM.EB.PBCFGM104):
        The function must have returned with E_NOT_OK.
    12: Create an invalid configuration regarding the published information configuration.
    13: Call the function IpduM_IsValidConfig() with this invalid configuration.
    14: VP(IpduM.EB.PBCFGM104_1):
        The function must have returned with E_NOT_OK.
    15: Call the function IpduM_IsValidConfig() with a valid configuration.
    16: VP:
        The function must have returned with E_OK.
    17: VP(IpduM.EB.PBCFGM107):
        Check if IPDUM_PBCFGM_SUPPORT_ENABLED is set to STD_ON.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PBCFGM101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>431</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM104_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>641</internalId></specobject>
    <specobject>
      <id>IpduM_Test_VerifyInitWithPcfgM</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the IpduM can be initialized via the PbcfgM.
  
Test Object: 
    IpduM_IsValidConfig()
  
Test Precondition: 
    The IpduM module must not have been initialized.
  
Test Execution: 
    01: Create an invalid configuration regarding the endianness and alignment.
    02: Call the function IpduM_Init() with this invalid configuration.
    03: VP:
        A Det call must have been performed correctly.
    04: Create an invalid configuration regarding the compile time configuration.
    05: Call the function IpduM_Init() with this invalid configuration.
    06: VP:
        A Det call must have been performed correctly.
    The following 3 steps are only executed if the module has a link-time configuration:
        07: Create an invalid configuration regarding the link time configuration.
        08: Call the function IpduM_Init() with this invalid configuration.
        09: VP:
            A Det call must have been performed correctly.
    10: Create an invalid configuration regarding the published information configuration.
    11: Call the function IpduM_Init() with this invalid configuration.
    12: VP:
        A Det call must have been performed correctly.
    13: Initialize the PbcfgM_GetConfig() stub that way that it can return a valid function.
    14: Call the function IpduM_Init() with a null pointer.
    15: VP:
        The function PbcfgM_GetConfig() must have been called once.
    16: VP:
        No Det call must have been performed.
    17: VP:
        The module internal configuration pointer IpduM_RootPtr must equal
        the pointer supplied to the initialization function
    18: PbcfgM_GetConfig shall return E_NOT_OK.
        set the configuration pointer which is returned to NULL_PTR
    19: Call IpduM_Init with NULL_PTR.
    20: VP(IpduM.EB.PBCFGM110):
        Check if Det error is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PBCFGM110</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>642</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>IpduM_Test_PBcfgM_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_PbcfgM_Off_Compile_Test.c</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Verify that if PbcfgM support is disabled then IpduM_PBCfg.c shall define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
      IPDUM_PBCFGM_SUPPORT_ENABLED shall be set to STD_OFF.
      IPDUM_RELOCATABLE_CFG_ENABLE shall be set to STD_OFF.
    
Test Object: None.
Test Precondition: 
      - PbcfgM configuration does not refer to module IpduM (or no config exists)
      - Include IpduM_PBcfg.c only for step 01 and 02.
      - Include IpduM_Cfg.h for step 03.
    
Test Execution: 
        01: VP(IpduM.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exists.
        02: VP(IpduM.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME has the value
            IpduM_ConfigLayoutType and IPDUM_CONFIG_NAME respectively.
        03: VP (IpduM.EB.PBCFGM107):
            Verify that IPDUM_PBCFGM_SUPPORT_ENABLED is set to STD_OFF.
        04: VP(IpduM.EB.PBCFGM108, IpduM.EB.RelocatablePBCfg):
            IPDUM_RELOCATABLE_CFG_ENABLE shall be STD_OFF
    
Test Input: 
    
Test Output: 
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>643</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>IpduM_Test_PBcfgM_On</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_PbcfgM_On_Compile_Test.c</sourcefile>
      <sourceline>24</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      1.)
      Verify that IPDUM_RELOCATABLE_CFG_ENABLE is defined
      in the header file IpduM_Cfg.h.
      2.)
      Verify that if PbcfgM support is enabled then IpduM_PBCfg.c shall NOT define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
    
Test Object: None.
Test Precondition: 
        - IPDUM_PBCFGM_SUPPORT_ENABLED = STD_ON
    
Test Execution: 
        ------------------------ 1.) ---------------------
        01: VP (IpduM.EB.PbcfgM_General_3,
                IpduM.EB.PBCFGM108,
                IpduM.EB.RelocatablePBCfg):
            Verify that IPDUM_RELOCATABLE_CFG_ENABLE is set to STD_ON.
        ------------------------ 2.) ---------------------
        02: Include IpduM_PBcfg.c.
        03: VP(IpduM.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exist.
    
Test Input: 
        None.
    
Test Output: 
        Binary file.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PbcfgM_General_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>644</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IpduM_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/build/reqm/common_req/IpduM_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(IpduM.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>645</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_00000</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_00_DetOff/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that source can be compiled if Development error detection(DET) is disabled.
      Verify that source can be compiled if IpduMVersionInfoApi is disabled.
      Verify that source can be compiled if IpduMStaticPartExists is enabled.
      Verify that source can be compiled if IpduMZeroCopy is disabled.
      Verify that source can be compiled if IpduMByteCopy is enabled.
      Verify the value of generated symbol for IpduMRxPathway, IpduMTxDynamicPart and
      IpduMTxPathway are proper.
      Verify that the macro IPDUM_BYTE_COPY has the value STD_ON.

      This test also verifies the syntax of the different APIs for disabled DET.

      This test inherently verifies that no Det error is reported since Det functions are
      not available.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    The Det functions are removed by the FileFilter.
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00133</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>646</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_01000</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_01_DetOn/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Verify that source can be compiled if Development error detection(DET) is enabled.
      Verify that source can be compiled if IpduMVersionInfoApi is enabled.
      Verify that source can be compiled if IpduMStaticPartExists is disabled.
      Verify that source can be compiled if IpduMZeroCopy is enabled.
      Verify that source can be compiled if IpduMByteCopy is disabled.
      Verify the value of generated symbol for IpduMRxPathway and IpduMTxDynamicPart are
      proper.
      Verify that the defined development errors are of type uint8.
      Verify that the macro IPDUM_BYTE_COPY has the value STD_OFF.

      This test also verifies the syntax of the different APIs for enabled DET.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    None
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00133</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>647</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_02000_SymbolicNames</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_02_SymbolicNames/source/application/test_config.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
       This test checks that running the handle ID wizard creates a valid configuration out of a
       configuration with invalid handle IDs.

       This test shall also verify that symbolic name values are generated. Target here is only to
       prove that symbolic values are generated. The scope is not on the correct look of the
       symbolic name value itself.

       Due backward compatibility reasons it shall be verified that these symbolic name values are
       also generated even unique short names are not present.

       For further tests regarding the symbolic name values see:
       TS_IPDUM_CON_04002_SymbolicNameValues40
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    All handle IDs are set to an invalid value.
    Short names of IpduMTxStaticPart and IpduMRxIndication are set except for one of each type.
  
Test Execution: 

  Ts5 build environment steps:
    The handle ID wizard is started by command line via the Merged_Makefile.mak.
    The module configuration generator provides the symbolic name value macros for the generated
    handle IDs in IpduM_SymbolicNames_PBcfg.h which is checked against the reference.
    Module code is generated, linked, and compiled with this test configuration file.

    01: VP:
      Following macros must be generated with their respective values, e.g.:

        * IpduMRxHandleId, IpduM/IpduMConfig/IpduMRxPathway/IpduMRxIndication
            IpduM_IpduMRxIndication_PduRxPw00Ind = 0U
            IpduM_IpduMRxIndication_PduRxPw01Ind = 1U
            IpduM_IpduMRxPathway_2 = 2U

        * IpduMTxConfirmationPduId, IpduM/IpduMConfig/IpduMTxPathway/IpduMTxRequest/IpduMTxStaticPart
            IpduM_IpduMTxStaticPart_PduTxPw00Sta = 0U
            IpduM_IpduMTxStaticPart_PduTxPw01Sta = 1U
            IpduM_IpduMTxPathway_2 = 2U

        * IpduM/IpduMConfig/IpduMTxPathway/IpduMTxRequest/IpduMTxDynamicPart
            IpduM_IpduMTxDynamicPart_3 = 6U
            IpduM_IpduMTxDynamicPart_4 = 5U
            IpduM_IpduMTxDynamicPart_5 = 3U
            IpduM_IpduMTxDynamicPart_6 = 4U

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00127.Postbuild</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>418</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00129.Postbuild</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>648</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>IpduM_Test_NonLegSymbolicNames</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_03_Init/source/application/Tests.c</sourcefile>
      <sourceline>35</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Checking the symbolic name macros generated when IPDUM_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined.
    
Test Object: None.
Test Precondition: 
        None.
    
Test Execution: 
      Check that macros with the names listed in output are not defined.
    
Test Input: 
        None.
    
Test Output: 
      The Symbolic name Macros that should not be defined are:
        IpduM_IpduMRxIndication_PduRxPw00Ind must not be defined
        IpduM_IpduMTxStaticPart_PduTxPw00Sta must not be defined
        IpduM_IpduMTxDynamicPart_3 must not be defined
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.LegacySymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>649</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_COM_03000_ConfigType</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_03_Init/source/application/Tests.c</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * Test that IpduM_ConfigType exists and is a structure.
  * Test if the IpduM initialization function uses a parameter of the type of
    IpduM_ConfigType.
  * The test shall prove that the Rte generator produces the correct SchM API.
  * The test shall also verify that IpduM shall not directly access the AUTOSAR OS.
  * This test verifies that the PduR module compiles for enabled initialization by signal values
    from upper layer but disabled JIT update.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
 - The Test must call at least one of the following functions since these functions call the
   schedule manager exclusive area functions.
  * IpduM_Transmit
  * IpduM_TriggerTransmit
  * IpduM_TxConfirmation
  * IpduM_MainFunctionRx
  * IpduM_MainFunctionTx

 - The test configuration must not include any schedule manager stub but the Rte MCG shall supply
   the functions:
    * SchM_Enter_IpduM_SCHM_IPDUM_EXCLUSIVE_AREA_0();
    * SchM_Exit_IpduM_SCHM_IPDUM_EXCLUSIVE_AREA_0();

 - No OS stubs should be included.

 - IpduMInitializationBySignalValue enabled, IpduMEnableJitUpdate disabled

Test Execution: 

    01: VP: Copy the IpduM configuration into a structure of the type IpduM_ConfigType. The type
            of the configuration must be of the type IpduM_ConfigType. Otherwise this would result
            in a compile error.

    02: VP: Access a data member of the type IpduM_ConfigType. If this is not possible
            IpduM_ConfigType is not a structure.

    03: VP: Call IpduM_Init() with the copied configuration. If the IpduM_Init() parameter is not a
            IpduM_ConfigType this will result in an warning.

    04: VP: The IpduM compiles including the functions
            * IpduM_Transmit
            * IpduM_TriggerTransmit
            * IpduM_TxConfirmation
            * IpduM_MainFunctionRx
            * IpduM_MainFunctionTx

    05: VP: Following symbols must be supplied
            * SchM_Enter_IpduM_SCHM_IPDUM_EXCLUSIVE_AREA_0();
            * SchM_Exit_IpduM_SCHM_IPDUM_EXCLUSIVE_AREA_0();

    06: VP: PduR module compiles for enabled initialization by signal values from upper layer but
            disabled JIT update.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00159</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.BSWMDGeneration_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.BSWMDGeneration_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMInitializationBySignalValue.Success</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMEnableJitUpdate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>650</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_04000_MandatoryApi</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_04_MandatoryApi/source/application/Tests.c</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * This test verifies that only the mandatory APIs supplied by adjacent modules are called by
    the IpduM.
  * The test shall prove that the IpduM compiles without the Det module.

  See also:
  https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-237
&lt;/para&gt;

Test Object: None.
Test Precondition: 

  * The PduR stub is configured that way that only mandatory functions needed by the IpduM are
    enabled.
  * Det stub is not included. This enforces that the Det usage by IpduM is disabled.
  * The IpduM is configured so that a minimum of APIs are compiled. No optional API must be
    compiled.
  * To verify that the IpduM is using all mandatory APIs all IpduM functions must be used
    within the test function.


Test Execution: 
    VP: The code compiles.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>396</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>651</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_ImportedTypes</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_05_ImportedTypes/source/application/IpduM_ComTest_ImportedTypes.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verify that the types listed in IPDUM102 are included:
  [IpduM.SWS_IpduM_00102:
        Module            Imported Type
      ComStack_Types  PduIdType
                      PduInfoType
      Std_Types       Std_ReturnType
                      Std_VersionInfoType]
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  The header files ComStack_Types.h and Std_Types.h are available.

Test Execution: 
  01: VP: Instances of the imported types are defined for:
             PduIdType           PduId
             PduInfoType         PduInfo
             Std_ReturnType      Std_Return
             Std_VersionInfoType Std_VersionInfo

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>652</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_ContainerPduHandling</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_06_ContainerPduHandling/source/application/Test.c.m4</sourcefile>
      <sourceline>34</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Verify that the macro IPDUM_CONTAINER_PDU_HANDLING_ENABLE is
  defined with the value of PM_IPDUM_CONTAINER_PDU_HANDLING_ENABLEChkVal when IpduMContainerPduHandlingEnable
  is configured to PM_IpduMContainerPduHandlingEnable.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMContainerPduHandlingEnable set to PM_IpduMContainerPduHandlingEnable.

Test Execution: 
  01: VP: The macro has the value of PM_IPDUM_CONTAINER_PDU_HANDLING_ENABLEChkVal.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerPduHandlingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>653</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_PBConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_07_PBConfig/source/application/Test.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * Verify that IpduM_ConfigType exists and is a structure.
  * Verify if the IpduM initialization function uses a parameter of the type of
    IpduM_ConfigType
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMContainerPduHandlingEnable set to true.

Test Execution: 
    01: VP: Copy the IpduM configuration into a structure of the type IpduM_ConfigType. The type
            of the configuration must be of the type IpduM_ConfigType. Otherwise this would result
            in a compile error.
    02: VP: Access to a data member of the type IpduM_ConfigType. If this is not possible
            IpduM_ConfigType is no structure.
    03: VP: Call IpduM_Init() with the copied configuration. If the IpduM_Init() parameter is not of
            IpduM_ConfigType this will result in a warning.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00096</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>654</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_MFFlexAlloc</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_08_MFFlexAlloc/source/application/Test.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * Verify that IpduM compiles when IpduMDedicatedIpduProcessingSupport is 
    enabled, IpduMTxProcessing is empty and IpduMRxProcessing is empty.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMDedicatedIpduProcessingSupport set to true.

Test Execution: 
    01: VP: Initialize IpduM.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>655</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_MFFlexAlloc_Rx_Only</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_09_MFFlexAlloc_Rx_Only/source/application/Test.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * Verify that IpduM compiles when IpduMDedicatedIpduProcessingSupport is 
    enabled, IpduMTxProcessing is empty and IpduMRxProcessing is NOT empty.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMDedicatedIpduProcessingSupport set to true.

Test Execution: 
    01: VP: Initialize IpduM.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>656</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_MFFlexAlloc_TxPathWay_Only</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_10_MFFlexAlloc_TxPathWay_Only/source/application/Test.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * Verify that IpduM compiles when IpduMDedicatedIpduProcessingSupport is 
    enabled, IpduMTxProcessing is NOT empty and IpduMRxProcessing is empty.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMDedicatedIpduProcessingSupport set to true.

Test Execution: 
    01: VP: Initialize IpduM.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>657</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_MFFlexAlloc_CntrTx_Only</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_11_MFFlexAlloc_CntrTx_Only/source/application/Test.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * Verify that IpduM compiles when IpduMDedicatedIpduProcessingSupport is 
    enabled, IpduMTxProcessing is NOT empty and IpduMRxProcessing is empty.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMDedicatedIpduProcessingSupport set to true.

Test Execution: 
    01: VP: Initialize IpduM.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>658</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_MFFlexAlloc_BSWMD_PartitionRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_12_MFFlexAlloc_BSWMD_PartitionRef/source/application/Test.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * Verify that IpduM compiles when IpduMDedicatedIpduProcessingSupport is 
    enabled and more EcucPartitionRefs are assigned to Rx and Tx Main Functions.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMDedicatedIpduProcessingSupport set to true.

Test Execution: 
    01: VP: Initialize IpduM.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing.IpduMPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing.IpduMPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>659</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_MFFlexAlloc_BSWMD_DiffCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_13_MFFlexAlloc_BSWMD_DiffCheck/source/application/test_config.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  * Verify that IpduM generates valid BSWMD when IpduMDedicatedIpduProcessingSupport is 
    enabled and more EcucPartitionRefs are assigned to Rx and Tx Main Functions.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMDedicatedIpduProcessingSupport set to true.

Test Execution: 
    01: VP: Check difference between reference BSWMD and generated BSWMD.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing.IpduMPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing.IpduMPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>660</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_16_NoPbCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_16_NoPbCfg/source/application/Test.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that the IpduM also compiles without any post build information.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * The merged make file holds a rule which removes all post build files after generation.

Test Execution: 
    The test run is successful when the IpduM compiles under sticking to the precondition.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00096</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>661</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_COM_HandleIdObtained</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Compile/IN/IpduM_ComTest_17_HandleID/source/application/Test.c</sourcefile>
      <sourceline>35</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      Test verifies that when a RoutingPath in PduR doesn't share the Pdus in EcuC
      among the PduRSrcPdus and PduRDestPdus, the ID is still correctly obtained.

      Test mandated by ASCIPDUM-989.
    &lt;/para&gt;
  
Test Object: Multiple-PDU-to-Container handling
Test Precondition: 
  
Test Execution: 
    01: VP: The test compiles, meaning the IDs were correctly obtained.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerPduHandlingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>662</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_00020</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>217</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  - To test IpduM_RxIndication for valid inputs for the Rx Pathway;
    where the data elements are byte aligned.
  - Verify that the received segments are copied correctly at configured IpduMSegmentPosition
    of out PDU.

  The test sequence focuses on byte-wise copy routines.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  Call IpduM_RxIndication with valid SDU for RxPathway_0
  validate the number of calls to PduR_IpduMRxIndication()
  validate the bit fields of the static part
  validate the outgoing ID of the static part
  validate the bit fields of the dynamic part
  validate the outgoing ID of the dynamic part
  the same steps are followed for RxPathway_1 and RxPathway_2

Test Input: 

Test Output: 
  The SDU data for all the Rx pathways, should be demultiplexed
  successfully
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00160.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>663</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00021</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>420</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the:
  1: IpduM will send the incoming PDU (static or dynamic) correctly with the correct outgoing
     PDU-ID when trigger condition (static or dynamic trigger) is satisfied.
  2: IpduM will convert the IpduM_TxConfirmation of a multiplexed PDU into one or two
     PduR_IpduMTxConfirmation (based on disabled IpduMInitialDynamicPart) for considered
     COM I-PDUs.
  3: Verify that the selector value is provided by the Com module and not by configuration
     parameter IpduMTxSelectorValue since IpduMTxAutomaticSelector is disabled.

  Note, for IPDUM022 the different settings of IpduMTxStaticConfirmation and
  IpduMTxDynamicConfirmation as well as existing or non-existing static parts are tested completely
  in test sequence IpduM_ConTest_04_Confirmation. Here, the requirement is tested with respect
  to byte-wise copy routines and independency of trigger mode.

  The test sequence focuses on byte-wise copy routines.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMTxAutomaticSelector is disabled.

  Tx pathway with
  - trigger mode STATIC_OR_DYNAMIC_PART_TRIGGER
  - no IpduMInitialDynamicPart
  - static part having IpduMTxStaticConfirmation enabled
  - dynamic part having IpduMTxDynamicConfirmation enabled

Test Execution: 
  01: Call IpduM_Init() (to make confirmation timeout zero)
  02: Call IpduM_Transmit() with static SDU
  03: Ensure that PduR_IpduMTransmit() is invoked
  04: Verify that the outgoing PDU-ID is the same as configured
  05: Call IpduM_TxConfirmation() for transmitted PDU-ID
  06: VP(IpduM.SWS_IpduM_00022): PduR_IpduMTxConfirmation is invoked once (since no confirmation is
      configured for the initial selector value)
  07: VP(IpduM.SWS_IpduM_00022): The confirmation handle ID is the same as configured
  08: Call IpduM_Transmit() with dynamic SDU
  09: Ensure that PduR_IpduMTransmit() is invoked
  10: Verify that the outgoing PDU-ID is the same as configured
  11: VP(IPDUM.EB.IPDUM553_Conf):
      Verify that the selector value set in the destination PDU is the one from the Com module,
      different to that of the IpduMTxSelectorValue
  12: Call IpduM_TxConfirmation() for transmitted PDU-ID
  13: VP(IpduM.SWS_IpduM_00022): PduR_IpduMTxConfirmation is invoked twice (since confirmation is
      configured for the static part and the selector value sent recently)
  14: VP(IpduM.SWS_IpduM_00022): The confirmation handle IDs are the same as configured

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00160.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM553_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>380</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>664</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00024</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>598</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test shall prove that PduR_IpduMTxConfirmation is not called while Tx confirmation is
  disabled and IpduM_TxConfirmation() is called.

  Note, for IPDUM163_Conf and IPDUM164_Conf the different settings of IpduMTxStaticConfirmation and
  IpduMTxDynamicConfirmation as well as existing or non-existing static parts are tested completely
  in test sequence IpduM_ConTest_04_Confirmation. Here, the requirement is tested with respect
  to byte-wise copy routines and independency of trigger mode.

  The test sequence focuses on byte-wise copy routines.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Tx pathway (TxPathWay1) with
  - dynamic part having IpduMTxDynamicConfirmation disabled
  - static part having IpduMTxStaticConfirmation disabled

Test Execution: 
  01: Call IpduM_Init() (to make confirmation timeout zero)
      Call IpduM_Transmit() with dynamic SDU

  02: VP: Ensure that PduR_IpduMTransmit() is invoked
      Verify that the outgoing PDU-ID is the same as configured
      Ensure that the outgoing SDU has correct dynamic part

  03: Call IpduM_TxConfirmation() for transmitted PDU-ID

  04: VP: Ensure PduR_IpduMTxConfirmation is not invoked (since confirmation is not
      configured for this TxPathWay)

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>665</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00025_InitDefaultValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>716</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that IpduM_Init() initializes all multiplexed I-PDUs with the default values
  from the IpduMIPduUnusedAreasDefault.

  This test inherently verifies that function IpduM_Init initializes module-related global
  variables.

  That the dynamic and static parts are initialized by the initialization data of the COM module
  via JIT update is checked by test case TS_IPDUM_CON_00040_JitUpdateOnTransmit.

  The test sequence focuses on byte-wise copy routines.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  JitUpdate is disabled for static and dynamic parts of some Tx pathways

Test Execution: 
  01: Call IpduM_Init()
  |--For all TxPathways with disabled JIT update
  |  (first 4, the third one with enabled initialization by signal values from upper layer)                  )
  |  02: Call IpduM_TriggerTransmit()
  |  03: VP: The content of the TxBuffer (default data) are copied to the PduInfo pointer given
  |      by the lower layer

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>666</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00026_InitDefaultValuesTTNotOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>844</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that when IpduMInitializationBySignalValue is ON,
  IpduM_Init() initializes all multiplexed I-PDUs with the default values
  from the IpduMIPduUnusedAreasDefault.
  When PduR_IpduMTriggerTransmit() returns E_NOT_OK during IpduM_Init() the payload matches
  the value set as IpduMIPduUnusedAreasDefault.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMTxPathway_0, IpduMTxPathway_1, IpduMTxPathway_2 and IpduMTxPathway_4_InitPdu have
    JitUpdate DISABLED, as such IpduM_TriggerTransmit returns E_OK with the default data
  IpduMInitializationBySignalValue is ON

Test Execution: 
  01: Call IpduM_Init()
  02: Call IpduM_TriggerTransmit() for all TxPathways with disabled JIT update (first 4)
  03: VP(IPDUM.EB.IpduMInitializationBySignalValue.Failure):
      PduR_IpduMTriggerTransmit() failed, payload consists of default values

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMInitializationBySignalValue.Failure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>667</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00030_PduInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>928</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies for trigger mode NONE and STATIC_OR_DYNAMIC_PART_TRIGGER, that the IpduM
  internal buffer is filled
  - with the pattern defined by configuration parameter IpduMIPduUnusedAreasDefault
  - the initial signal values for the initial dynamic part from upper layer
  - the initial signal values for the static part from upper layer

  This test inherently verifies that function IpduM_Init initializes module-related global
  variables.

  The test sequence focuses on byte-wise copy routines.
&lt;/para&gt;

Test Object: 
  IpduM_Init()

Test Precondition: 
  Tx Pathways configured for trigger conditions NONE and STATIC_OR_DYNAMIC_PART_TRIGGER

Test Execution: 
  01: Prepare dynamic PDUs for calls of PduR_IpduMTriggerTransmit
  02: Call IpduM_Init()
  03: VP: PduR_IpduMTriggerTansmit is called for all static parts and initial dynamic parts
          configured in the IpduMTxPathway list whereas the size of the corresponding
          IpduM I-PDU is not equal to 0 (zero).
  04: Call IpduM_TriggerTransmit() to fetch initialized outgoing PDUs
  05: VP: Outgoing PDU holds correct pattern of unused bytes and initialized dynamic ones

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00068</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>668</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00040_JitUpdateOnTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>1091</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies for trigger mode STATIC_OR_DYNAMIC_PART_TRIGGER, that if transmission
  is triggered by the update of one part then the second part having IpduMJitUpdate set to 'true'
  is updated as well via PduR_IpduMTriggerTransmit before the multiplexed I-PDU is sent.

  This test inherently verifies that the PduR module compiles for enabled JIT update in general.

  The test sequence focuses on byte-wise copy routines.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: 

Test Precondition: 
  - Tx Pathway configured for trigger condition STATIC_OR_DYNAMIC_PART_TRIGGER
  - Initial dynamic part with JitUpdate disabled and another with enabled one.
  - Static part with JitUpdate enabled.

Test Execution: 
  01: Prepare PDUs for calls of PduR_IpduMTriggerTransmit during initialisation using
      IpduMTxPw05DynamicPart_Layout_1 as initial dynamic part
  02: Call IpduM_Init()
  03: VP: PduR_IpduMTriggerTansmit is called for all static parts and initial dynamic parts
          configured in the IpduMTxPathway list whereas the size of the corresponding
          IpduM I-PDU is not equal to 0 (zero).

  04: Call IpduM_Transmit() using PDU-ID of static part
  05: VP: No update occurred on dynamic part. Outgoing PDU contains the sent static data
          and the initial dynamic data (layout_1)

  06: Change COM buffer of static PDU
  07: Call IpduM_Transmit() using PDU-ID of dynamic part layout_0
  08: VP: Update occurred on static part. Outgoing PDU contains the sent dynamic data
          and the updated static data

  09: Change COM buffer of dynamic PDU layout_0
  10: Call IpduM_Transmit() using PDU-ID of static part
  11: VP: Update occurred on dynamic part. Outgoing PDU contains the sent static data
          and the updated dynamic data (layout_0)

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMEnableJitUpdate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>669</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00050_JitUpdateOnTriggerTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>1321</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies for trigger mode NONE, that if IpduM_TriggerTransmit() is called
  on the multiplexed PDU then an update of all parts having IpduMJitUpdate set to 'true' occurs.

  The test sequence focuses on byte-wise copy routines.
  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: 

Test Precondition: 
  - Tx Pathway configured for trigger condition NONE
  - Initial dynamic part with JitUpdate disabled and another with enabled one
  - No static part exists

Test Execution: 
  01: Prepare PDU for calls of PduR_IpduMTriggerTransmit during initialisation using
      IpduMTxPw04DynamicPart_Layout_1 as initial dynamic part
  02: Call IpduM_Init()
  03: VP: PduR_IpduMTriggerTansmit is called for all static parts and initial dynamic parts
          configured in the IpduMTxPathway list whereas the size of the corresponding
          IpduM I-PDU is not equal to 0 (zero).

  04: Call IpduM_Transmit() on dynamic part having JIT update enabled (layout 0)
  05: Call IpduM_TriggerTransmit() using the confirmation PDU-ID
  06: VP: Check calling trace of PduR_IpduMTriggerTransmit
  07: VP: Check if data of multiplexed PDU contains the updated data used in step 04

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>670</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00060_JitUpdateNotOkOnTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>1458</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies for trigger mode STATIC_OR_DYNAMIC_PART_TRIGGER, that a multiplexed
  PDU is not sent when calling IpduM_Transmit() if the JitUpdate fails for the corresponding
  COM PDU having IpduMJitUpdate set to 'true'.

  The test sequence focuses on JIT Update.

  Test altered due to ASCIPDUM-1062:
  Extended by verifying that the PDU won't remain stuck after such a failure.

  Test altered due to ASCIPDUM-1063:
  Changed the expected return value, it should have been E_NOT_OK.
&lt;/para&gt;

Test Object: 

Test Precondition: 
  - Tx Pathway configured for trigger condition STATIC_OR_DYNAMIC_PART_TRIGGER
  - Static part with JitUpdate enabled.

Test Execution: 
  01: Reset PduR_IpduMTriggerTransmit stub callout
  02: Call IpduM_Init()
  03: Reset the stub trace

  04: Prepare stub. Set return value of PduR_IpduMTriggerTransmit to E_NOT_OK
  05: Call IpduM_Transmit() on dynamic part to trigger JIT update of static part
  06: VP: Check if PduR_IpduMTriggerTransmit() was called using the PDU-ID of
          static part
  07: VP(IpduM.SWS_IpduM_00171.NoTransmission):
      Check that PduR_IpduMTransmit stub is empty to ensure that no
          multiplexed PDU was sent
  08: Call the Tx MainFunction multiple times to ensure no transmission takes place
  09: VP(IpduM.SWS_IpduM_00171.RetVal):
      JIT Update fails, timeout not set
  10: PduR_IpduMTriggerTransmit() returns E_OK, transmission is successful
  11: PduR_IpduMTriggerTransmit() returns E_NOT_OK, JIT Update fails
  12: PduR_IpduMTriggerTransmit() returns E_OK, transmission is successful
  13: Once again JIT Update is successful, transmission succeeds

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00171.NoTransmission</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00171.RetVal</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>398</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>671</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00070_JitUpdateNotOkOnTriggerTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>1614</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies for trigger mode NONE, that IpduM_TriggerTransmit returns E_NOT_OK
  if any JIT update request via PduR_IpduMTriggerTransmit returns E_NOT_OK for corresponding
  COM PDU having IpduMJitUpdate set to 'true'.

  The test sequence focuses on byte-wise copy routines.
&lt;/para&gt;

Test Object: 

Test Precondition: 
  - Tx Pathway configured for trigger condition NONE
  - Initial dynamic part with JitUpdate disabled and another with enabled one.

Test Execution: 
  01: Reset PduR_IpduMTriggerTransmit stub callout
  02: Call IpduM_Init()
  03: Reset the stub trace

  04: Call IpduM_Transmit() to update dynamic part to layout_0 (JitUpdate=true)
  05: Prepare stub. Set return value of PduR_IpduMTriggerTransmit to E_NOT_OK
  06: Call IpduM_TriggerTransmit() for multiplexed PDU
  07: VP: Check if IpduM_TriggerTransmit() returned E_NOT_OK

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM550_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>672</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00080_JitUpdateOnInitialDynamicPart</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>1716</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies for trigger mode STATIC_OR_DYNAMIC_PART_TRIGGER, that if transmission
  is triggered by the update of the static part and the dynamic part was not updated until now
  then the dynamic Part is updated by the PDU referenced by IpduMInitialDynamicPart if
  IpduMJitUpdate is set to 'true' before the multiplexed I-PDU is sent.

  While focusing on byte-wise copy routines this test ensures that the latest data of the
  referenced initial dynamic part I-PDU (with IpduMJitUpdate set to 'true') is transmitted if an update
  on the dynamic part hasn't occurred by IpduM_Transmit since calling IpduM_Init().

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: 

Test Precondition: 
  - Tx Pathway configured for trigger condition STATIC_OR_DYNAMIC_PART_TRIGGER
  - Initial dynamic part with JitUpdate enabled

Test Execution: 
  01: Prepare COM buffers for calls of PduR_IpduMTriggerTransmit during initialisation using
      IpduMTxPw06DynamicPart_Layout_1 as initial dynamic part
  02: Call IpduM_Init()
  03: Reset the stub trace

  04: Prepare stub and change COM buffer of dynamic part (layout_1)
  05: Call IpduM_Transmit() using PDU-ID of static part
  06: VP: Check PduR_IpduMTriggerTransmit trace to ensure that a JIT update occurred.
  07: VP: Check PduR_IpduMTransmit trace, PDU-ID, and the contained data of the outgoing
          PDU to ensure that static data and the updated initial dynamic data (layout_1)
          was sent

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>673</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_00081_MinSduLength_Copy</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_00_ByteCopy/source/application/Tests.c</sourcefile>
      <sourceline>1848</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that during IpduM_RxIndication() of Pathways when performing
  byte-by-byte copying the SduDataPtr isn't accessed beyond SduLength.

  Test mandated by ASCIPDUM-1029.
  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: 
  IpduM_RxIndication()

Test Precondition: 
  The initially supplied SduLength is sufficiently great to extract the selector.

Test Execution: 
  01: Set the SduLength to the absolute minimum in order to extract the selector
  02: Nothing is extracted, PDU is short, silently ignored
  03: VP(IpduM.EB.RxPathWay.SduLength.Min.StaticPart):
      The static part is before the dynamic one for this particular PDU, it's extracted
  04: VP(IpduM.EB.RxPathWay.SduLength.Min.DynamicPart):
      The PDU is now sufficiently long to extract everything configured
  05: PduR_IpduMRxIndication() is called the expected number of times

Test Input: 

Test Output: 
  The SDU data for all the Rx pathways, should be demultiplexed
  successfully
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.StaticPart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.DynamicPart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>674</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_01001</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>248</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test reporting of IPDUM_E_UNINIT when the IpduM_TriggerTransmit is
  called before initializing the IPDUM.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM is uninitialized

Test Execution: 
  01: Call IpduM_TriggerTransmit with valid data
  02: VP(IpduM.SWS_IpduM_00153_4):
      Verify that Det error IPDUM_E_UNINIT is reported

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00153_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>675</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01002</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>303</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test reporting of DET error IPDUM_E_PARAM and IPDUM_E_PARAM_POINTER when IpduM_TriggerTransmit
  is called with invalid parameters.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None

Test Execution: 
  Initialize the module
  for all configured TxPathWays:
  01: Call IpduM_TriggerTransmit with PduInfoPtr == NULL_PTR.
  02: VP(IpduM.SWS_IpduM_00028_9):
      Verify that Det error IPDUM_E_PARAM_POINTER is reported.
  03: Call IpduM_TriggerTransmit with PduInfoPtr-&gt;SduDataPtr == NULL_PTR.
  04: VP(IpduM.SWS_IpduM_00028_10):
      Verify that Det error IPDUM_E_PARAM_POINTER is reported.
  05: Call IpduM_TriggerTransmit with invalid PDU-ID(less than configured minimum).
  06: VP(IpduM.SWS_IpduM_00028_3):
      Verify that Det error IPDUM_E_PARAM is reported.
  07: Call IpduM_TriggerTransmit with invalid PDU-ID(greater than configured maximum).
  08: VP(IpduM.SWS_IpduM_00028_3):
      Verify that Det error IPDUM_E_PARAM is reported.
  09: Call IpduM_TriggerTransmit with invalid SduLength(less than configured PduLength(8)).
  10: VP(IpduM.EB.TriggerTransmit.MinSduLength.Pw):
      Verify that Det error IPDUM_E_PARAM is reported.

Test Input: 

Test Output: 
  IpduM_TriggerTransmit should report IPDUM_E_PARAM
  whenever an invalid parameter is passed
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_9</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>390</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_10</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>391</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.TriggerTransmit.MinSduLength.Pw</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>676</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01003</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>422</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if the IpduM module will demultiplex the incoming PDU correctly where the
  data elements may or may not be byte aligned.
  This test inherently verifies if the IpduM module allows usage of a subset of selector values
  possible, i.e. not all selector values that are possible by the size of the selector field are
  in use.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Not all selector values possible are applied

Test Execution: 
  Call IpduM_RxIndication with valid SDU for all Rx pathways:
  - validate the number of calls to PduR_IpduMRxIndication().
  - validate the bit fields of the static part.
  - validate the outgoing ID of the static part.
  - validate the bit fields of the dynamic part.
  - validate the outgoing ID of the dynamic part.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>677</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01004</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>632</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test inherently verifies if the IpduM module
  - assembles the incoming static and dynamic PDUs correctly and sent with the correct outgoing
    PDU-ID when trigger condition(dynamic trigger) is satisfied.
  - IpduM_TriggerTransmit can be called for dynamic trigger condition.

  This test inherently verifies if the IpduM module allows usage of a subset of selector values
  possible, i.e. not all selector values that are possible by the size of the selector field are
  in use.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Not all selector values possible are applied.

Test Execution: 
  Call IpduM_Init() (to make confirmation timeout zero).
  Call IpduM_Transmit() with static SDU.
  Ensure that PduR_IpduMTransmit() is not invoked.
  Call IpduM_Transmit() with dynamic SDU.
  Ensure that PduR_IpduMTransmit() is invoked.
  Ensure that when dynamic trigger condition is met the outgoing SDU has
  both the static and dynamic parts which was stored by the IpduM.
  Verify that the outgoing PDU-ID is the same as configured.
  Verify that source is copied correctly to the destination bit fields.
  IpduM_TriggerTransmit() is called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>678</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01005</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>771</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether
    * IPDUM does not allow a new transmission request on dynamic trigger for an I-PDU, when
      confirmation timeout is not elapsed and TxConfirmation is not received for that I-PDU-ID.
    * IPDUM allows a new transmission request on dynamic trigger for an I-PDU after getting
      TxConfirmation for the same I-PDU-ID.
    * IPDUM will convert the TxConfirmation of a multiplexed PDU into two
      confirmations for the COM I-PDUs and the handle IDs are correct as per configuration.

  Note, for IPDUM022 the different settings of IpduMTxStaticConfirmation and
  IpduMTxDynamicConfirmation as well as existing or non-existing static parts are tested completely
  in test sequence IpduM_ConTest_04_Confirmation. Here, the requirement is tested with respect
  to independency of trigger mode.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Tx pathway with
  - trigger mode DYNAMIC_PART_TRIGGER
  - static part having IpduMTxStaticConfirmation enabled
  - dynamic part having IpduMTxDynamicConfirmation enabled

  TS_IPDUM_CON_01004 should be executed first.

Test Execution: 
  01: Call IpduM_Transmit() with transmitted PDU-ID without getting confirmation.
  02: VP: Ensure that PduR_IpduMTransmit() is not invoked.
  03: Call IpduM_TxConfirmation() for transmitted PduId.
  04: VP: Verify PduR_IpduMTxConfirmation() is invoked for both static and dynamic parts.
          Verify whether the confirmation handle IDs are the same as configured.

Test Input: 

Test Output: 
  IpduM_Transmit returns E_NOT_OK when we try to call with an already
  transmitted PDU without getting confirmation.IpduM_TxConfirmation calls
  PduR_IpduMTxConfirmation for both static and dynamic parts with configured
  confirmation IDs.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>679</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01006</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>868</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether
  IPDUM will assemble the incoming static and dynamic PDUs correctly and sent with the
  correct outgoing PDU-ID when trigger condition(static trigger) is satisfied.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  Call IpduM_Init()(to make confirmation timeout zero).
  Call IpduM_Transmit() with one dynamic SDU.
  Call IpduM_Transmit() with another dynamic SDU.
  Ensure that PduR_IpduMTransmit() is not invoked.
  Call IpduM_Transmit() with static SDU.
  Ensure that PduR_IpduMTransmit() is invoked.
  Verify that the outgoing PDU-ID is the same as configured.
  Verify that static part is copied correctly to the destination bit fields.
  Verify that the second dynamic SDU part is copied correctly.
  to the destination bit fields.
  Verify that both parts are multiplexed
  and copied correctly to the destination bit fields.

Test Input: 

Test Output: 
  IpduM_Transmit multiplexes the static and dynamic SDUs on static trigger
  and pass the SDU with the expected outgoing PduId.The bit fields in the source
  are copied correctly to the destination as specified in the configuration.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>680</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01007</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>984</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether
    1:IPDUM allows a new transmission request on static trigger for an I-PDU after getting
      TxConfirmation for the same I-PDU-ID.
    2:IPDUM does not allow a new transmission request on static trigger for an I-PDU, when
      confirmation timeout is not elapsed and TxConfirmation is not received for that I-PDU-ID.
    3:IPDUM will convert the TxConfirmation of a multiplexed PDU into two
      confirmations for the COM I-PDUs and the handle IDs are correct as per configuration.

  Note, for IPDUM022 the different settings of IpduMTxStaticConfirmation and
  IpduMTxDynamicConfirmation as well as existing or non-existing static parts are tested completely
  in test sequence IpduM_ConTest_04_Confirmation. Here, the requirement is tested with respect
  to independency of trigger mode.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Tx pathway with
  - trigger mode STATIC_PART_TRIGGER
  - static part having IpduMTxStaticConfirmation enabled
  - dynamic part having IpduMTxDynamicConfirmation enabled

  TS_IPDUM_CON_01006 should be executed.

Test Execution: 
  Call IpduM_TxConfirmation() for transmitted PduId.
  Verify PduR_IpduMTxConfirmation() is invoked for both static and dynamic parts.
  Verify whether the confirmation handle IDs is the same as configured.
  Call IpduM_Transmit() with static SDU.
  Ensure that PduR_IpduMTransmit() is invoked.
  Verify that the outgoing PDU-ID is the same as configured.
  Call IpduM_MainFunctionTx() once.
  Call IpduM_Transmit() with static SDU.
  Ensure that PduR_IpduMTransmit() is not invoked.

Test Input: 

Test Output: 
  IpduM calls PduR_IpduMTxConfirmation with correct handle IDs for static and dynamic parts.
  IpduM transmits the static SDU on static trigger with the expected
  outgoing PduId.The bit fields in the source are copied correctly to the
  destination as specified in the configuration.IpduM_Transmit returns E_NOT_OK
  when called before confirmation timeout becomes zero.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.ECUC_IpduM_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>681</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01008</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1093</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether
  1:IPDUM will sent the incoming dynamic PDU with correct outgoing PDU-ID when dynamic
    trigger condition is satisfied.
  2:IPDUM shall allow new transmission requests for this specific I-PDU after confirmation
    timeout is elapsed and if the TxConfirmation is not received within the configured timeout.
  3:IPDUM shall silently discard unexpected TxConfirmations.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  Call IpduM_Init()(to make confirmation timeout zero).
  Call IpduM_Transmit() with dynamic SDU.
  Ensure that PduR_IpduMTransmit() is invoked.
  Verify that the outgoing PDU-ID is the same as configured.
  Verify that dynamic part is copied correctly to the destination bit fields.
  Call IpduM_MainFunctionTx() twice(to make confirmation timeout zero).
  Call IpduM_Transmit() with dynamic SDU.
  Ensure that PduR_IpduMTransmit() is invoked.
  Verify that the outgoing PDU-ID is the same as configured.
  Call IpduM_TxConfirmation() for another PduId.
  Call IpduM_Transmit() with dynamic SDU.
  Ensure that PduR_IpduMTransmit() is not invoked.

Test Input: 

Test Output: 
  IpduM_Transmit transmits the dynamic SDU on dynamic trigger and pass the SDU with the
  expected outgoing PduId.The bit fields in the source are copied correctly to the
  destination as specified in the configuration.The confirmation timeout becomes zero
  after calling Main two times.Unexpected TxConfirmation is discarded.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>682</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01009_NoSignalValuesForInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1223</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if the IpduM_Init initializes the multiplexed I-PDUs to the unused area
  values for disabled initialization by signal values from an upper layer.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMInitializationBySignalValue shall be disabled.

Test Execution: 
  01: Call IpduM_Init() to initialize all module related global variables
  02: Call IpduM_TriggerTransmit()
  03: VP: The multiplexed I-PDU is filled with data from IpduUnusedAreasDefault

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMInitializationBySignalValue.Success</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>683</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01010</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1297</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether
  1:IpduM will not call PduR_IpduMTransmit until trigger condition is satisfied.
  2:IpduM will copy the data from the TxBuffer to the pointer given by the
     lower layer when IpduM_TriggerTransmit() is called.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  Call IpduM_Init()(to make confirmation timeout zero).
  Ensure that PduR_IpduMTransmit() is not invoked.
  Call IpduM_TriggerTransmit().
  Ensure that the contents of the TxBuffer are copied to the data pointer given by the
  lower layer.

Test Input: 

Test Output: 
  1: PduR_IpduMTransmit is not called until trigger condition(None).
  2: IpduM copies the contents of the TxBuffer(dynamic SDU) to the pointer
     given by lower layer when IpduM_TriggerTransmit() is called.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>684</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01011</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1393</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether IpduM_Transmit() returns E_NOT_OK when
  PduR_IpduMTransmit() returns with an error.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  01: Call IpduM_Init() (to make confirmation timeout zero).
  02: Call IpduM_Transmit() with static SDU.
  03: VP: Ensure that PduR_IpduMTransmit() is not invoked.
  04: Call IpduM_Transmit() with dynamic SDU.
  05: VP: Ensure that PduR_IpduMTransmit() is invoked.
  06: VP: IpduM_Transmit() must return with E_NOT_OK.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>685</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01012</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1489</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if IpduM_RxIndication is called solely for the static part if an incorrect
  selector value in the SDU is received.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None

Test Execution: 
  Call IpduM_RxIndication with invalid SDU of selector value for RxPathway_0.
  Validate the number of calls to PduR_IpduMRxIndication().
  Validate the bit fields of the static part.
  Validate the outgoing ID of the static part.
  Same steps are followed for RxPathway_1 and RxPathway_2.

Test Input: 

Test Output: 
  The SDU data for all the Rx pathways, should be demultiplexed
  successfully for the static part; while the dynamic part shall not
  be demultiplexed since the selector value is invalid
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM042.InvalidSelectorValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>686</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01013</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1604</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test to check if the confirmation timeout and the preemption of IpduM_Transmit() by IpduM_MainFunctionTx()
  is handled correctly.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
   IpduMTxTimeBase = 0.5s

   Use:
   * IpduMTxPathway_0
     - DYNAMIC_PART_TRIGGER
     - IpduMTxConfirmationTimeout = 1.0s

   * IpduMTxPathway_1
     - STATIC_PART_TRIGGER
     - IpduMTxConfirmationTimeout = 1.0s


   Hints:
   * IpduMTxPathway_0
     - IpduM_IpduMTxDynamicPart_0_0 is the symbolic handle ID for the dynamic TX PDU
       This ID is assigned by the IpduM.
     - IpduMConf_IpduMTxRequest_IpduMTxPathway_0 is the symbolic handle ID for the outgoing PDU-ID
       This ID is assigned by the PduR.

   * IpduMTxPathway_1
     - IpduM_IpduMTxPathway_1 is the symbolic handle ID for the static TX PDU
       This ID is assigned by the IpduM.
     - IpduMConf_IpduMTxRequest_IpduMTxPathway_1 is the symbolic handle ID for the outgoing PDU-ID
       This ID is assigned by the PduR.


Test Execution: 

Test Input: 
    Test steps:

    STEP01:
    * Call IpduM_Transmit() with ID for path way 0
    * Check that PduR_IpduMTransmit() is called with the right ID
    * Call IpduM_Transmit() with ID for path way 0. Function must return with an error

    STEP02:
    * Call IpduM_Transmit() with ID for path way 1
    * Check that PduR_IpduMTransmit() is called with the right ID
    * Call IpduM_MainFunctionTx() within the PduR_IpduMTransmit() call back. This will handle the timeout counter
      for path way 0 but not for path way 1.
    * Call IpduM_Transmit() with ID for path way 1. Function must return with an error

    STEP03:
    * Call IpduM_MainFunctionTx()
    * Call IpduM_Transmit() with ID for path way 0
    * Check that PduR_IpduMTransmit() is called with the right ID
    * Call IpduM_Transmit() with ID for path way 1. Function must return with an error

    STEP04:
    * Call IpduM_MainFunctionTx()
    * Call IpduM_Transmit() with ID for path way 1
    * Check that PduR_IpduMTransmit() is called with the right ID


Test Output: 

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>687</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01014</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1782</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test to check if the confirmation timeout and the preemption of IpduM_Transmit() by IpduM_TxConfirmation()
  is handled correctly.

  This test was triggered by:
  https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-117
&lt;/para&gt;

Test Object: None.
Test Precondition: 
   IpduMTxTimeBase = 0.5s

   Use:
   * IpduMTxPathway_1
     - STATIC_PART_TRIGGER
     - IpduMTxConfirmationTimeout = 1.0s


Test Execution: 

Test Input: 
    Test steps:

    STEP01:
    * Call IpduM_Transmit() with the ID for path way 1
      - Call IpduM_TxConfirmation() within the PduR_IpduMTransmit() call back. This will reset the
        time out counter.
      - Call IpduM_MainFunctionTx() within the PduR_IpduMTransmit() call back. This will test the
        main function with and ongoing transmission.
    * Check that PduR_IpduMTransmit() is called with the right ID

    STEP02:
    * Call IpduM_Transmit() with ID for path way 1. Function must return successfully.
    * Check that PduR_IpduMTransmit() is called with the right ID


Test Output: 

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>688</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01015</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1875</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether
  1:IpduM takes care about the data consistency during providing the data.
  2:IpduM will copy the data from the TxBuffer to the pointer given by the
     lower layer when IpduM_TriggerTransmit() is called.
&lt;/para&gt;

Test Object: 
  Data Consistency

Test Precondition: 

Test Execution: 
  01: Initialize IpduM.
  02: Set the provide buffer of IpduM_TriggerTransmit to data sequence A.
  03: Call IpduM_Transmit with valid SDU (dynamic part) and with data sequence B and
      verify that the request is accepted.
  04: Call IpduM_TriggerTransmit.

  Steps 05 to 07 are carried by SchM callout stubs.
  05: Verify that the provided buffer contains data sequence A during SchM_Enter_IpduM() call.
  06: VP(IpduM.SWS_IpduM_00090):
      Verify that the provided buffer contains data sequence B during SchM_Exit_IpduM() call.
  07: Assign the buffer with data sequence A at the end of SchM_Exit_IpduM() call.
  08: VP(IpduM.SWS_IpduM_00091):
      Verify that the IpduM_TriggerTransmit returned E_OK and returned the pointer with
      data sequence A.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>689</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01016</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>1984</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if the IpduM module
  - assembles the incoming static and dynamic PDUs correctly. The outgoing
    PDU-ID is sent when trigger condition(static trigger) is satisfied and
    contains the static part as well as the 'last' updated dynamic part.
  - IpduM_TriggerTransmit can be called for static trigger condition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  Call IpduM_Init() (to make confirmation timeout zero).
  For IpduMTxPathway_1 (static trigger mode):
    Call IpduM_Transmit() with dynamic SDU IpduMTxDynamicPart_1_1.
    Ensure that PduR_IpduMTransmit() is not invoked.
    Call IpduM_Transmit() with dynamic SDU IpduMTxDynamicPart_1_0.
    Ensure that PduR_IpduMTransmit() is not invoked.
    Call IpduM_Transmit() with static SDU.
    Ensure that PduR_IpduMTransmit() is invoked.
    Ensure that when static trigger condition is met the outgoing SDU has
    both the static and the last updated (IpduMTxDynamicPart_1_0) dynamic
    parts which was stored by the IpduM.
    Verify that the outgoing PDU-ID is the same as configured.
    Verify that source is copied correctly to the destination bit fields.
    IpduM_TriggerTransmit() is called.
    Verify that the static part and the 'last' dynamic part were correctly
    copied.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>690</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_01017</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_01_Full/source/application/Tests.c</sourcefile>
      <sourceline>2153</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the IpduM module correctly accepts an Sdu with a length of 1,
  having the selector placed on bit 0 with a length of 1.

  Test mandated by ASCIPDUM-1025.

  The selector value is copied as the dynamic segment.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  The ID of the RX Pathway is 3.

Test Execution: 
  01: Call IpduM_RxIndication() with the selector value of 0
  02: Verify that the PDU is forwarded to the correct ID
  03: Call IpduM_RxIndication() with the selector value of 1
  04: Verify that the PDU is forwarded to the correct ID.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>691</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_02093</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_02_ZeroCopy/source/application/Tests.c</sourcefile>
      <sourceline>150</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if the IpduM module will demultiplex the incoming PDU correctly for different
  configured Rx Pathways in ZeroCopy configuration.
  This test inherently verifies if the IpduM module allows usage of a subset of selector values
  possible, i.e. not all selector values that are possible by the size of the selector field are
  in use.

  The test sequence focuses on passing pointers for static and dynamic parts on Rx side.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM is initialized
  Not all selector values possible are applied

  IpduMZeroCopy is enabled

Test Execution: 
  Call IpduM_RxIndication with valid SDU for all Rx pathways:
  - validate the number of calls to PduR_IpduMRxIndication().
  - validate the bit fields of the static part.
  - validate the outgoing ID of the static part.
  - validate the bit fields of the dynamic part.
  - validate the outgoing ID of the dynamic part.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>692</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_02094</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_02_ZeroCopy/source/application/Tests.c</sourcefile>
      <sourceline>333</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies if the IpduM module in ZeroCopy configuration
  - converts the incoming dynamic SDU to an I-PDU with a unique I-PDU-ID sent
    out to the PDU Router using API IpduM_Transmit,
  - invokes PduR_IpduMTxConfirmation() with the corresponding dynamic handle ID, when
    receiving the Transmit confirmation for an already transmitted I-PDU within time.

  This test inherently verifies if the IpduM module allows usage of a subset of selector values
  possible, i.e. not all selector values that are possible by the size of the selector field are
  in use.

  The test sequence focuses on passing pointers for dynamic parts on Tx side.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  static and dynamic part are continuous and byte aligned.
  selector is also byte aligned (size 8 bit).
  Not all selector values possible are applied.

  IpduMZeroCopy is enabled

Test Execution: 
  Call IpduM_Transmit() with valid SDU for TxPathway_0,TxPathway_1 and TxPathway_2.
  Ensure that PduR_IpduMTransmit() has been invoked for each dynamic part.
  Verify that the outgoing PDU-ID is the same as configured.
  Verify that source is copied correctly to the destination bit fields.
  Verify PduR_IpduMTxConfirmation() is invoked.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.ECUC_IpduM_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>693</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_02095</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_02_ZeroCopy/source/application/Tests.c</sourcefile>
      <sourceline>432</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether a dynamic ID can be transmitted only after receiving the confirmation for
  the previous transmit of the corresponding multiplexed IPDUM

  Note, for IPDUM022 the different settings of IpduMTxStaticConfirmation and
  IpduMTxDynamicConfirmation as well as existing or non-existing static parts are tested completely
  in test sequence IpduM_ConTest_04_Confirmation. Here, the requirement is tested with respect
  to passing pointers for static and dynamic parts and independency of trigger mode.

  The test sequence focuses on passing pointers for dynamic parts on Tx side.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM is initialized

  Tx pathway with
  - trigger mode DYNAMIC_PART_TRIGGER
  - no IpduMInitialDynamicPart
  - no static part
  - dynamic part having IpduMTxDynamicConfirmation enabled

  IpduMZeroCopy is enabled

Test Execution: 
  Call IpduM_Transmit() with valid SDU for TxPathway_0.
  Ensure that PduR_IpduMTransmit() has been invoked once.
  Verify that the outgoing PDU-ID is the same as configured.
  Verify that source is copied correctly to the destination bit fields.
  Call IpduM_TxConfirmation() with transmitted PDU-ID and verify whether
    PduR_IpduMTxConfirmation() is invoked.
  Call IpduM_Transmit() again with the same PDU-ID and verify stub call count,
    PDU-ID, destination fields.
  Call IpduM_Transmit() again without having received the confirmation
    for previously transmitted PDU.

Test Input: 

Test Output: 
  IpduM_Transmit() should pass the SDU with the expected outgoing PduId.
  The second call of IpduM_Transmit() returns E_OK, since confirmation is received for previous transmit.
  The third call of IpduM_Transmit() returns E_NOT_OK, since confirmation is not received for previous transmit.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>694</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_02096</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_02_ZeroCopy/source/application/Tests.c</sourcefile>
      <sourceline>553</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether
  1:IPDUM discards unexpected TxConfirmations silently.
  2:IpduM_Transmit will return E_NOT_OK when called with an I-PDU without getting
    TxConfirmation.

  The test sequence focuses on passing pointers for dynamic parts on Tx side.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMZeroCopy is enabled

Test Execution: 
  IpduM is initialized
  Call IpduM_Transmit() with valid SDU for TxPathway_0.
  Ensure that PduR_IpduMTransmit() has been invoked once.
  Verify that the outgoing PDU-ID is the same as configured.
  Verify that source and destination bit fields are copied correctly.
  Call IpduM_TxConfirmation() with another PDU-ID and verify whether
    PduR_IpduMTxConfirmation() is not invoked.
  Call IpduM_Transmit() again without having received the confirmation
    for previously transmitted PDU of the same Id.

Test Input: 

Test Output: 
  IpduM_Transmit() should pass the SDU with the expected outgoing PduId.
  When IpduM_TxConfirmation() is called with another PDU-ID which was
  not transmitted earlier, PduR_IpduMTxConfirmation() is not invoked.
  When IpduM_Transmit() is called again without receiving confirmation of transmitted PDU the
  incoming confirmation is rejected and transmit function returns E_NOT_OK.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>695</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_02097</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_02_ZeroCopy/source/application/Tests.c</sourcefile>
      <sourceline>652</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether a dynamic ID can be transmitted only after confirmation timeout for the
  previous transmit of the corresponding multiplexed IPDUM, is expired

  The test sequence focuses on passing pointers for dynamic parts on Tx side.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM is initialized

  IpduMZeroCopy is enabled

Test Execution: 
  Call IpduM_Transmit() with valid SDU for TxPathway_2.
  Ensure that PduR_IpduMTransmit() has been invoked once.
  Verify that the outgoing PDU-ID is the same as configured.
  Verify that source and destination bit fields are copied correctly.
  Call IpduM_Transmit() again after expiry of the confirmation
    timeout counter for the same PDU-ID

Test Input: 

Test Output: 
  IpduM_Transmit() should pass the SDU with the expected outgoing PduId.
  The second call of IpduM_Transmit() also give the same results.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>696</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_02098_ZeroCopy</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_02_ZeroCopy/source/application/Tests.c</sourcefile>
      <sourceline>758</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test whether IpduM passes the data pointer given in IpduM_Transmit() to PduR
  if IpduMZeroCopy is enabled.

  The test sequence focuses on passing pointers for dynamic parts on Tx side.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - IpduM is initialized
  - IpduMZeroCopy is enabled

Test Execution: 
  01: Call IpduM_Transmit() with valid SDU for TxPathway_0.
  02: VP:
      Verify that the out pointer of PduR_IpduMTransmit is the same as the data pointer given
      in IpduM_Transmit.
  03: Finish transmission.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM504</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>697</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_02099_MinSduLength_ZeroCopy</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_02_ZeroCopy/source/application/Tests.c</sourcefile>
      <sourceline>853</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that during IpduM_RxIndication() of Pathways when performing
  byte-by-byte copying the SduDataPtr isn't accessed beyond SduLength.

  Test mandated by ASCIPDUM-1029.
&lt;/para&gt;

Test Object: 
  IpduM_RxIndication()

Test Precondition: 
  IpduMZeroCopy is enabled
  The initially supplied SduLength is sufficiently great to extract the selector.

Test Execution: 
  01: Call RxIndication() with an SduLength just long enough to extract the selector
  02: Nothing is extracted
  03: VP(IpduM.EB.RxPathWay.SduLength.Min.StaticPart):
      The static part is extracted
  04: VP(IpduM.EB.RxPathWay.SduLength.Min.DynamicPart):
      The dynamic part is extracted

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.StaticPart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.DynamicPart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>698</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_03099</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_03_ZeroCopyNoStatic/source/application/Tests.c</sourcefile>
      <sourceline>91</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test IpduM_RxIndication for valid inputs for the Rx Pathway;
  for zero copy and having dynamic part.

  The test sequence focuses on passing pointers for dynamic parts only.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM is initialized

Test Execution: 
  Call IpduM_RxIndication with valid SDU for RxPathway_0
  validate the number of calls to PduR_IpduMRxIndication().
  validate the bit fields of the dynamic part.
  validate the outgoing ID of the dynamic part.

Test Input: 

Test Output: 
  The SDU data for all the Rx pathways, should be demultiplexed
  successfully
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>699</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_03100</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_03_ZeroCopyNoStatic/source/application/Tests.c</sourcefile>
      <sourceline>219</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test IpduM_RxIndication for invalid selector;
  for zero copy and having dynamic part.

  The test sequence focuses on passing pointers for dynamic parts only.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None

Test Execution: 
  Call IpduM_RxIndication with invalid selector for RxPathway_0
  Ensure that PduR_IpduMRxIndication() is not called.

Test Input: 

Test Output: 
  PduR_IpduMRxIndication() is not called.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM042.InvalidSelectorValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>700</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_03101</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_03_ZeroCopyNoStatic/source/application/Tests.c</sourcefile>
      <sourceline>286</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test verifies that if the length of the Sdu is less than
  where the selector would be, an error is reported to Det.

  ASCIPDUM-1017
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None

Test Execution: 

Test Input: 

Test Output: 
  PduR_IpduMRxIndication() is not called, Det is.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RxPathWay.SduLength.Min.Selector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>701</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_04001_DisabledConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>55</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test shall verify that in case the IpduM_TxConfirmation is called the IpduM does not call
  PduR_IpduMTxConfirmation for a Tx pathway with disabled confirmation of the dynamic PDU
  and disabled confirmation of the static PDU.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM is initialized.

  Tx pathway (TxPathWay1, DYNAMIC_PART_TRIGGER) with
  - dynamic part having IpduMTxDynamicConfirmation disabled
  - static part having IpduMTxStaticConfirmation disabled

Test Execution: 
  01: Call IpduM_Transmit() for static and dynamic PDU-ID.
  02: Call IpduM_TxConfirmation() for multiplexed I-PDU.
  03: VP: PduR_IpduMTxConfirmation() is NOT called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>702</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_04002_SymbolicNameValues40</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>134</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that all configured symbolic name values are generated correctly.
    The correct generation of symbolic name values for following parameters shall be checked
    * IpduMRxHandleId
    * IpduMTxConfirmationPduId
    * IpduMTxDynamicHandleId
    * IpduMTxStaticHandleId

    In addition to the AUTOSAR 4.0 rev 3 symbolic name values the values for AUTOSAR 4.0 rev 2
    shall be checked too.

    See https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-223 for further implementation details
    beside the requirements.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Configuration shall have
  - At least two RX pathways
  - At least two TX pathways whereas at least one TX pathway has more than one dynamic part
  - At least in one TX pathway the static part must be disabled
  - A unique short name for following containers must be set.
    + /IpduM/IpduMConfig/IpduMRxPathway/IpduMRxIndication                   (/IpduMRxHandleId)
    + /IpduM/IpduMConfig/IpduMTxPathway/IpduMTxRequest/IpduMTxStaticPart    (/IpduMTxStaticHandleId)
    + /IpduM/IpduMConfig/IpduMTxPathway/IpduMTxRequest/IpduMTxDynamicPart   (/IpduMTxDynamicHandleId)
    + /IpduM/IpduMConfig/IpduMTxPathway/IpduMTxRequest                      (/IpduMTxConfirmationPduId)

  Define IPDUM_PROVIDE_LEGACY_SYMBOLIC_NAMES within the test application.

Test Execution: 
  Test for
  - AUTOSAR version = 4.0 rev3
  - AUTOSAR 4.0 rev2 &lt;= AUTOSAR version
  the following:
    01: VP: Symbolic name value macros must equal the regarding handle ID values in the
            configuration (checked exemplarily)
    02: VP: Symbolic name value macros for disabled static parts must not be defined

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00127.Postbuild</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>418</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00129.Postbuild</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>419</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00158.Postbuild</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>703</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_04003_PublishedInformation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>267</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check the correct definition of the common published information
    provided in the module header file.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP(IPDUM.EB.IPDUM507):
        Check that the correct version numbers defined in the header file.

Test Input: None.
Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM507</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>704</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_04004_TxConfTime_Zero</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>330</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that new transmission requests are accepted before IpduM_Confirmation is
  called, if IpduMTxConfirmationTimeout is configured to 0.

  This test verifies that the IpduM confirms the last transmission request and discards all other Tx
  confirmations.

  This test shall also verify that in case the IpduM_TxConfirmation is called the IpduM calls
  PduR_IpduMTxConfirmation correctly for a Tx pathway with enabled confirmation of the dynamic PDU
  while no static PDU exists.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: 
  Transmission behavior when IpduMTxConfirmationTimeout is 0.

Test Precondition: 
  IpduM is initialized.

  Tx pathway (IpduMTxPathway_2, DYNAMIC_PART_TRIGGER) with
  - dynamic part having IpduMTxDynamicConfirmation enabled
  - no static part
  - IpduMTxConfirmationTimeout = 0.0s

Test Execution: 
  01: Call IpduM_Transmit() with ID for IpduMTxDynamicPart_20.
  02: Call IpduM_Transmit() with ID for IpduMTxDynamicPart_21.
  03: VP(IPDUM.EB.IPDUM561):
      Verify that the request is accepted even though the confirmation is not given.
  04: Call IpduM_TxConfirmation for the first transmit request.
  05: VP(IPDUM.EB.IPDUM565, IpduM.SWS_IpduM_00022):
      Verify whether PduR_IpduMTxConfirmation is called for IpduMTxDynamicPart_21, i.e
      the last request got confirmed.
  06: Call IpduM_TxConfirmation for the second transmit request.
  07: VP(IPDUM.EB.IPDUM565):
      Verify that no other calls are made to make sure that no other request is processed.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM561</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IPDUM565</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>705</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_04005_DisabledConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>443</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test shall verify that in case the IpduM_TxConfirmation is called the IpduM calls
  PduR_IpduMTxConfirmation correctly for a Tx pathway with enabled confirmation of the dynamic PDU
  but disabled confirmation of the static PDU.

  This test shall verify that in case the IpduM_TxConfirmation is called the IpduM calls
  PduR_IpduMTxConfirmation correctly for a Tx pathway with disabled confirmation of the dynamic PDU
  while no static PDU exists.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM should be initialized.

  Tx pathway (TxPathWay1, DYNAMIC_PART_TRIGGER) with
  - dynamic part having IpduMTxDynamicConfirmation enabled
  - static part having IpduMTxStaticConfirmation disabled

  Tx pathway (TxPathWay2, DYNAMIC_PART_TRIGGER) with
  - dynamic part having IpduMTxDynamicConfirmation disabled
  - no static part

Test Execution: 
  01: Call IpduM_Transmit() with dynamic PDU-ID IpduMTxDynamicPart_22 of TxPathWay2.
  02: Call IpduM_Transmit() with dynamic PDU-ID IpduMTxDynamicPart_11 of TxPathWay1.

  03: Call IpduM_TxConfirmation() for transmitted PduId of IpduMTxPathway_1.
  04: VP (IpduM.SWS_IpduM_00022): PduR_IpduMTxConfirmation() is called for IpduMTxDynamicPart_11,
      for which IpduMTxDynamicConfirmation is enabled.
  05: VP (IpduM.ECUC_IpduM_00164): PduR_IpduMTxConfirmation() is NOT called for
      the static part, as IpduMTxStaticConfirmation is disabled.

  06: Call IpduM_TxConfirmation() for transmitted PduId of IpduMTxPathway_2.
  07: VP (IpduM.ECUC_IpduM_00163): PduR_IpduMTxConfirmation() is NOT
      called for IpduMTxDynamicPart_11, as IpduMTxDynamicConfirmation is disabled.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00164</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>706</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_04006_DisabledConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>550</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test shall verify that in case the IpduM_TxConfirmation is called the IpduM calls
  PduR_IpduMTxConfirmation correctly for a Tx pathway with enabled confirmation of the dynamic PDU
  and also enabled confirmation of the static PDU.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM should be initialized.

  Tx pathway (TxPathWay3, STATIC_PART_TRIGGER) with
  - static part having IpduMTxStaticConfirmation enabled
  - dynamic part having IpduMTxDynamicConfirmation enabled

Test Execution: 
  01: Call IpduM_Transmit() with dynamic PDU-ID IpduMTxDynamicPart_30 of TxPathWay3.
  02: Call IpduM_Transmit() for static part of TxPathWay3.
  03: PduR_IpduMTransmit should get called now as the trigger is STATIC_PART_TRIGGER.

  04: Call IpduM_TxConfirmation() for IpduMTxPathway_3.
  05: VP: PduR_IpduMTxConfirmation() is called for IpduMTxDynamicPart_30,
      for which IpduMTxDynamicConfirmation is enabled.
  06: VP: PduR_IpduMTxConfirmation() is called for the static part also,
      as IpduMTxStaticConfirmation is also enabled.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>707</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_04007_DisabledConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>643</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test shall verify that in case the IpduM_TxConfirmation is called the IpduM calls
  PduR_IpduMTxConfirmation correctly for a Tx pathway with disabled confirmation of the dynamic PDU
  but enabled confirmation of the static PDU.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM should be initialized.

  Tx pathway (TxPathWay3, STATIC_PART_TRIGGER) with
  - static part having IpduMTxStaticConfirmation enabled
  - dynamic part having IpduMTxDynamicConfirmation disabled

Test Execution: 
  01: Call IpduM_Transmit() with Dynamic PDU ID IpduMTxDynamicPart_32 of TxPathWay3.
  02: Call IpduM_Transmit() for static part of TxPathWay3.
  03: PduR_IpduMTransmit should get called now as the trigger is STATIC_PART_TRIGGER.

  04: Call IpduM_TxConfirmation() for IpduMTxPathway_3.
  05: VP (IpduM.SWS_IpduM_00022): PduR_IpduMTxConfirmation() is called for the static part,
      as IpduMTxStaticConfirmation is enabled.
  06: VP (IpduM.ECUC_IpduM_00163): PduR_IpduMTxConfirmation() is NOT called for the dynamic part,
      as IpduMTxDynamicConfirmation is disabled.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>708</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_04008_Timeout_OneTick</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>729</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  - This test verifies that new transmission requests are accepted only after
    confirmation timeout, for special configuration of one tick,
    i.e. IpduMTxTimeBase equals IpduMTxConfirmationTimeout.
  - This test inherently verifies the proper use of the time base given by configuration
    parameter IpduMTxTimeBase considering ticks.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
- IpduM is initialized.
- Required configuration
  - IpduMTxConfirmationTimeout of IpduMTxPathway_3 = 0.5U
  - IpduMTxTimeBase = 0.5U

Test Execution: 
  01: Call IpduM_Transmit() with static PDU-ID of IpduMTxPathway_3 successfully.
  02: Call IpduM_Transmit for the same static PDU.
  03: VP: Verify that the request is not accepted as neither the confirmation is received for the
      previous request nor confirmation timeout happened.
  04: Call IpduM_MainFunctionTx() to expire the confirmation timeout.
  05: Call IpduM_Transmit for the same static PDU.
  06: VP: Verify that the request is accepted as confirmation timeout occurred.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.ECUC_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR43.ECUC_IpduM_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.ECUC_IpduM_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>709</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_04009_Timeout_MaximumTicks</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_04_Confirmation/source/application/Tests.c</sourcefile>
      <sourceline>824</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  - This test shall verify that new transmission requests are accepted only after confirmation
    timeout, for special configuration of maximum ticks, i.e. IpduMTxConfirmationTimeout
    equals 3600.
  - This test inherently verifies the proper use of the time base given by configuration
    parameter IpduMTxTimeBase considering ticks.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
- IpduM should be initialized.
- Required configuration
  - IpduMTxConfirmationTimeout of IpduMTxPathway_0 = 3600
  - IpduMTxTimeBase = 0.5
  (maximum timeout tick = IpduMTxConfirmationTimeout/IpduMTxTimeBase = 3600/0.5 = 7200)

Test Execution: 
  01: Call IpduM_Transmit() with static PDU-ID of IpduMTxPathway_0.
  02: Verify whether PduR_IpduMTransmit is called.
  03: Call IpduM_Transmit for the same static PDU immediately before confirmation timeout elapsed.
  04: VP: Verify that the request is not accepted as neither the confirmation is received for the
      previous request nor confirmation timeout happened.
  05: Call IpduM_MainFunctionTx() to expire the confirmation timeout.
  06: Call IpduM_Transmit for the same static PDU.
  07: VP: Verify that the request is accepted as confirmation timeout occurred.
  08: Call IpduM_TxConfirmation
  09: Verify that the PduR is notified about the transmission.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.ECUC_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR43.ECUC_IpduM_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.ECUC_IpduM_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>710</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL that:
      - If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, all contained I-PDUs
        are extracted in the context of IpduM_RxIndication() immediately.
      - all contained I-PDUs are extracted, which do not have IpduMContainedRxInContainerPduRef set
      - IpduM_RxIndication() forwards the contained I-PDUs via the PDU Router, in calling
        PduR_IpduMRxIndication() with the correct handle ID.
      - Each contained I-PDU is identified by its header ID (of type short).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    00: Initialize IpduM.
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00202, IpduM.SWS_IpduM_00203,
    |         IpduM.SWS_IpduM_00204.ShortHdrId, IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On,
    |         IpduM.SWS_IpduM_00217):
    |         PduR_IpduMRxIndication() is called with correct handle ID for all contained I-PDUs.
    |  03: VP(IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On,
              IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On):
    |      CntdRxPduWithRef_1715004 IpduMContainedRxPdu has IpduMContainedRxInContainerPduRef set,
    |      it's not matched, ignored.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.ShortHdrId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>711</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>194</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL that:
      - If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, all contained I-PDUs
        are extracted in the context of IpduM_RxIndication() immediately.
      - all contained I-PDUs are extracted, independent of IpduMContainedRxInContainerPduRef.
      - IpduM_RxIndication() forwards the contained I-PDUs via the PDU Router, in calling
        PduR_IpduMRxIndication() with the correct handle ID.
      - Each contained I-PDU is identified by its header ID (of type short).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    00: Initialize IpduM.
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00202, IpduM.SWS_IpduM_00203,
    |         IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off,
              IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.Off):
    |         PduR_IpduMRxIndication() is called with correct handle ID for all contained I-PDUs.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>712</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>307</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL that:
      - If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, all contained I-PDUs
        are extracted in the context of IpduM_RxIndication() immediately.
      - all contained I-PDUs are extracted which do not have IpduMContainedRxInContainerPduRef set.
      - IpduM_RxIndication() forwards the contained I-PDUs via the PDU Router, in calling
        PduR_IpduMRxIndication() with the correct handle ID.
      - Each contained I-PDU is identified by its header ID (of type long).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    00: Initialize IpduM.
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00202, IpduM.SWS_IpduM_00203,
    |         IpduM.SWS_IpduM_00204.LongHdrId,
              IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On,
    |         IpduM.SWS_IpduM_00217):
    |         PduR_IpduMRxIndication() is called with correct handle ID for all contained I-PDUs.
    |  03: VP(IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On):
    |      PDU with Header ID 16777216 is dropped silently.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.LongHdrId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>713</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05001_RxAcceptAll_HeaderID_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>418</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL that:
      - If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, all contained I-PDUs
        are extracted in the context of IpduM_RxIndication() immediately.
      - all contained I-PDUs are extracted, independent of IpduMContainedRxInContainerPduRef.
      - IpduM_RxIndication() forwards the contained I-PDUs via the PDU Router, in calling
        PduR_IpduMRxIndication() with the correct handle ID.
      - Each contained I-PDU is identified by its header ID (of type long).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    00: Initialize IpduM.
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00202, IpduM.SWS_IpduM_00203,
    |         IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off,
              IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.Off,
    |         IpduM.SWS_IpduM_00217):
    |         PduR_IpduMRxIndication() is called with correct handle ID for all contained I-PDUs.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>714</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>531</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED that:
      - If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, all contained I-PDUs
        are extracted in the context of IpduM_RxIndication() immediately.
      - only the contained I-PDUs that refer to the respective container PDU are forwarded to PduR.
      - IpduM_RxIndication() forwards the contained I-PDUs via the PDU Router, in calling
        PduR_IpduMRxIndication() with the correct handle ID.
      - Each contained I-PDU is identified by its header ID (of type short).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs - first two contained I-PDUs referenced to respective container, 3rd one
        referenced by another container PDU and 4th one not referenced at all.
    02: VP(IpduM.SWS_IpduM_00202, IpduM.SWS_IpduM_00203, IpduM.SWS_IpduM_00204.ShortHdrId,
        IpduM.SWS_IpduM_00217, IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On):
        PduR_IpduMRxIndication() is called only for the first two contained I-PDUs.
    03: VP(IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On):
        No API was called for the other two contained I-PDUs.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.ShortHdrId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>715</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>631</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED that:
      - If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, all contained I-PDUs
        are extracted in the context of IpduM_RxIndication() immediately.
      - only the contained I-PDUs that refer to the respective container PDU are forwarded to PduR.
      - IpduM_RxIndication() forwards the contained I-PDUs via the PDU Router, in calling
        PduR_IpduMRxIndication() with the correct handle ID.
      - Each contained I-PDU is identified by its header ID (of type short).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs - first two contained I-PDUs referenced to respective container, 3rd one
        referenced by another container PDU and 4th one not referenced at all.
    02: VP(IpduM.SWS_IpduM_00202, IpduM.SWS_IpduM_00203,
        IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off,
        IpduM.SWS_IpduM_00217,
        IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.Off):
        PduR_IpduMRxIndication() is called only for the first two contained I-PDUs.
    03: VP(IpduM.SWS_IpduM_00205): No API was called for the other two contained I-PDUs.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>716</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>733</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED that:
      - If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, all contained I-PDUs
        are extracted in the context of IpduM_RxIndication() immediately.
      - only the contained I-PDUs that refer to the respective container PDU are forwarded to PduR.
      - IpduM_RxIndication() forwards the contained I-PDUs via the PDU Router, in calling
        PduR_IpduMRxIndication() with the correct handle ID.
      - Each contained I-PDU is identified by its header ID (of type long).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs - first two contained I-PDUs referenced to respective container, 3rd one
        referenced by another container PDU and 4th one not referenced at all.
    02: VP(IpduM.SWS_IpduM_00202, IpduM.SWS_IpduM_00203,
        IpduM.SWS_IpduM_00204.LongHdrId, IpduM.SWS_IpduM_00217,
        IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On):
        PduR_IpduMRxIndication() is called only for the first two contained I-PDUs.
    03: VP(IpduM.SWS_IpduM_00205): No API was called for the other two contained I-PDUs.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.LongHdrId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>717</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05002_RxAcceptConfigured_HeaderID_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>832</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED that:
      - If IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE, all contained I-PDUs
        are extracted in the context of IpduM_RxIndication() immediately.
      - only the contained I-PDUs that refer to the respective container PDU are forwarded to PduR.
      - IpduM_RxIndication() forwards the contained I-PDUs via the PDU Router, in calling
        PduR_IpduMRxIndication() with the correct handle ID.
      - Each contained I-PDU is identified by its header ID (of type long).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs - first two contained I-PDUs referenced to respective container, 3rd one
        referenced by another container PDU and 4th one not referenced at all.
    02: VP(IpduM.SWS_IpduM_00202, IpduM.SWS_IpduM_00203,
        IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off,
        IpduM.SWS_IpduM_00217,
        IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.Off):
        PduR_IpduMRxIndication() is called only for the first two contained I-PDUs.
    03: VP(IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.Off):
        No API was called for the other two contained I-PDUs.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>299</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>718</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05003_RxHeaderIdZero</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>933</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if a container PDU is received and a contained I-PDU has the header ID
    set to 0 (at the beginning, at the end or anywhere inside the container PDU), the container PDU
    processing is stopped and remaining bytes are ignored.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which has the first contained PDU
        header ID equal to 0, followed by a contained PDU with header ID greater than 0.
    02: VP: No API is called (container PDU processing is stopped).

    03: Call IpduM_RxIndication() using a container handle ID which has the first contained
        PDU header ID greater than 0, followed by a contained PDU with header ID set to 0 and
        another contained I-PDU with header ID greater than 0.
    04: VP: PduR_IpduMRxIndication() is called once, for the first contained I-PDU.
    05: VP: No API is called (container PDU processing is stopped).

    06: Call IpduM_RxIndication() using a container handle ID which has the first two contained
        PDU header ID greater than 0, followed the last contained which has the PDU header ID 0.
    07: VP: PduR_IpduMRxIndication() is called twice, for the first two contained I-PDU.
    08: VP: No API is called (container PDU processing is stopped).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>719</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05003_RxHeaderIdZero_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1093</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if a container PDU is received and a contained I-PDU has the header ID
    set to 0 (at the beginning, at the end or anywhere inside the container PDU), the container PDU
    processing is stopped and remaining bytes are ignored.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which has the first contained PDU
        header ID equal to 0, followed by a contained PDU with header ID greater than 0.
    02: VP: No API is called (container PDU processing is stopped).

    03: Call IpduM_RxIndication() using a container handle ID which has the first contained
        PDU header ID greater than 0, followed by a contained PDU with header ID set to 0 and
        another contained I-PDU with header ID greater than 0.
    04: VP: PduR_IpduMRxIndication() is called once, for the first contained I-PDU.
    05: VP: No API is called (container PDU processing is stopped).

    06: Call IpduM_RxIndication() using a container handle ID which has the first two contained
        PDU header ID greater than 0, followed the last contained which has the PDU header ID 0.
    07: VP: PduR_IpduMRxIndication() is called twice, for the first two contained I-PDU.
    08: VP: No API is called (container PDU processing is stopped).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>306</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>720</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05004_LessBytesThanDLC</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1260</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if a container PDU is received and any of the contained
    I-PDU header's payload length exceeds the remaining bytes of the container, the processing is
    stopped and the remaining bytes are ignored. Also, if development error tracing is enabled,
    IPDUM_E_HEADER is reported to DET.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container PDU which has a contained I-PDU with
        payload size bigger than the total number of remaining bytes.
    02: VP: PduR_IpduMRxIndication() is called for all contained PDUs up to the contained I-PDU
        holding the DLC exceeding the remaining bytes of the container.
    03: VP: If development error tracing is enabled IPDUM_E_HEADER is reported to DET.
    04: VP: No further API is called.

    05: Call IpduM_RxIndication() using a container PDU which has the first contained I-PDU with
        payload size bigger than the total number of remaining bytes.
    06: VP: If development error tracing is enabled IPDUM_E_HEADER is reported to DET.
    07: VP: No further API is called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>721</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05004_LessBytesThanDLC_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1384</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if a container PDU is received and any of the contained
    I-PDU header's payload length exceeds the remaining bytes of the container, the processing is
    stopped and the remaining bytes are ignored. Also, if development error tracing is enabled,
    IPDUM_E_HEADER is reported to DET.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container PDU which has a contained I-PDU with
        payload size bigger than the total number of remaining bytes.
    02: VP: PduR_IpduMRxIndication() is called for all contained PDUs up to the contained I-PDU
        holding the DLC exceeding the remaining bytes of the container.
    03: VP: If development error tracing is enabled IPDUM_E_HEADER is reported to DET.
    04: VP: No further API is called.

    05: Call IpduM_RxIndication() using a container PDU which has the first contained I-PDU with
        payload size bigger than the total number of remaining bytes.
    06: VP: If development error tracing is enabled IPDUM_E_HEADER is reported to DET.
    07: VP: No further API is called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>722</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05005_LessBytesThanHeaderSize</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1513</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if the remaining bytes in a container PDU are less than the configured
    IpduMContainerHeaderSize, they are ignored.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container PDU which has the first contained I-PDU with
        header size bigger than the container PDU.
    02: VP: No API is called (remaining bytes are ignored).

    03: Call IpduM_RxIndication() using a container PDU which has a valid contained I-PDU followed
        by a contained I-PDU which has the header size bigger than the total number of remaining
        bytes.
    04: VP: PduR_IpduMRxIndication() is called for all I-PDUs up to the contained I-PDU
        which has an incomplete header (less available bytes than the header size).
    05: VP: No API is called (remaining bytes are ignored).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>723</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05005_LessBytesThanHeaderSize_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1610</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if the remaining bytes in a container PDU are less than the configured
    IpduMContainerHeaderSize, they are ignored.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container PDU which has the first contained I-PDU with
        header size bigger than the container PDU.
    02: VP: No API is called (remaining bytes are ignored).

    03: Call IpduM_RxIndication() using a container PDU which has a valid contained I-PDU followed
        by a contained I-PDU which has the header size bigger than the total number of remaining
        bytes.
    04: VP: PduR_IpduMRxIndication() is called for all I-PDUs up to the contained I-PDU
        which has an incomplete header (less available bytes than the header size).
    05: VP: No API is called (remaining bytes are ignored).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>724</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05024_Payload_Validation_SduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1712</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if the SduLength provided during RxIndication()
    is greater than the configured value, the error IPDUM_E_CONTAINER shall be reported.

    Test mandated by ASCIPDUM-1012.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Call IpduM_RxIndication() a payload and length greater than the one configured
    02: VP(IpduM.EB.Container.Payload.Rx.Validation.SduLength, IpduM.SWS_IpduM_00247):
        Observe that IPDUM_E_CONTAINER is reported
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.Container.Payload.Rx.Validation.SduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00247</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>725</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05006_RxAcceptAll_Data_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1824</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU and the data is forwarded to PduR via
    PduR_IpduMRxIndication().
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On,
           IpduM.SWS_IpduM_00217):
    |      PduR_IpduMRxIndication() is called to forward the contained I-PDUs.
    |  03: VP(IpduM.SWS_IpduM_00209):
    |      The I-PDUs are received in the same order as they are located in the container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>726</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05006_RxAcceptAll_Data</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1939</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU and the data is forwarded to PduR via
    PduR_IpduMRxIndication().
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00217):
    |      PduR_IpduMRxIndication() is called to forward the contained I-PDUs.
    |  03: VP(IpduM.SWS_IpduM_00209):
    |      The I-PDUs are received in the same order as they are located in the container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>727</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05006_RxAcceptAll_Data_LongHeader_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2055</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU and the data is forwarded to PduR via
    PduR_IpduMRxIndication().
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00217):
    |      PduR_IpduMRxIndication() is called to forward the contained I-PDUs.
    |  03: VP(IpduM.SWS_IpduM_00209):
    |      The I-PDUs are received in the same order as they are located in the container PDU.
    |  04: VP(IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On):
    |      PDU with Header ID 4 is dropped silently.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.LongHdrId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>728</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05006_RxAcceptAll_Data_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2164</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU and the data is forwarded to PduR via
    PduR_IpduMRxIndication().
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00217):
    |      PduR_IpduMRxIndication() is called to forward the contained I-PDUs.
    |  03: VP(IpduM.SWS_IpduM_00209):
    |      The I-PDUs are received in the same order as they are located in the container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>729</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05007_RxAcceptAll_DataLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2278</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that in a container PDU which accepts all contained I-PDUs, the length given
    in I-PDU's header is used as the length of the corresponding I-PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs, which have
        the DLC at minimum, maximum and some size in between.
    |- for all contained I-PDUs:
    |  02: VP: The SduLength is the same as the length provided by the header.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00208</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>730</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05007_RxAcceptAll_DataLength_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2372</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that in a container PDU which accepts all contained I-PDUs, the length given
    in I-PDU's header is used as the length of the corresponding I-PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs, which have
        the DLC at minimum, maximum and some size in between.
    |- for all contained I-PDUs:
    |  02: VP: The SduLength is the same as the length provided by the header.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00208</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>731</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05008_RxAcceptConfigured_Data</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2466</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU and the data is forwarded to PduR via
    PduR_IpduMRxIndication().
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs - first and third contained I-PDUs referenced to respective container,
        second one referenced by another container PDU and fourth one not referenced at all.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00217):
    |      PduR_IpduMRxIndication() is called to forward the contained I-PDUs.
    |  03: VP(IpduM.SWS_IpduM_00209):
    |      The I-PDUs are received in the same order as they are located in the container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>732</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05008_RxAcceptConfigured_Data_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2565</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU and the data is forwarded to PduR via
    PduR_IpduMRxIndication().
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs - first and third contained I-PDUs referenced to respective container,
        second one referenced by another container PDU and fourth one not referenced at all.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00217):
    |      PduR_IpduMRxIndication() is called to forward the contained I-PDUs.
    |  03: VP(IpduM.SWS_IpduM_00209):
    |      The I-PDUs are received in the same order as they are located in the container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>733</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05009_RxAcceptConfigured_DataLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2664</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that in a container PDU which accepts configured contained I-PDUs,
    the length given in I-PDU's header is used as the length of the corresponding I-PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00208</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>734</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05009_RxAcceptConfigured_DataLength_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2793</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that in a container PDU which accepts configured contained I-PDUs,
    the length given in I-PDU's header is used as the length of the corresponding I-PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00208</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>304</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>735</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05010_RxAcceptAll_HeaderIDNotMatched_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2922</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for a container PDU which accepts all contained I-PDUs, that if a
    header ID can not be matched to any contained I-PDU, it is discarded silently.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained I-PDUs, where
        - the second and third contained I-PDU use a header ID that match and
        - the first and fourth do not use a header ID that match to any contained I-PDU.
    02: VP: No API is called for the header IDs that do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>736</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05010_RxAcceptAll_HeaderIDNotMatched</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3009</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for a container PDU which accepts all contained I-PDUs, that if a
    header ID can not be matched to any contained I-PDU, it is discarded silently.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained I-PDUs, where
        - the second and third contained I-PDU use a header ID that match and
        - the first and fourth do not use a header ID that match to any contained I-PDU.
    02: VP: No API is called for the header IDs that do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>737</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05010_RxAcceptAll_HeaderIDNotMatched_LongHeader_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3097</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for a container PDU which accepts all contained I-PDUs, that if a
    header ID can not be matched to any contained I-PDU, it is discarded silently.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained I-PDUs, where
        - the second and third contained I-PDU use a header ID that match and
        - the first and fourth do not use a header ID that match to any contained I-PDU.
    02: VP: No API is called for the header IDs that do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>738</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05010_RxAcceptAll_HeaderIDNotMatched_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3184</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for a container PDU which accepts all contained I-PDUs, that if a
    header ID can not be matched to any contained I-PDU, it is discarded silently.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained I-PDUs, where
        - the second and third contained I-PDU use a header ID that match and
        - the first and fourth do not use a header ID that match to any contained I-PDU.
    02: VP: No API is called for the header IDs that do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>739</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05011_RxAcceptConfigured_HeaderIDNotMatched_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3274</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for a container PDU which accepts configured contained I-PDUs, that if
    a header ID can not be matched to a configured contained I-PDU, it is discarded silently.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts configured contained I-PDUs, where
        - the second and third contained I-PDU use a header ID that match and
        - the first and fourth do not use a header ID that match.
    02: VP: No API is called for the header IDs that do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>740</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05011_RxAcceptConfigured_HeaderIDNotMatched</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3361</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for a container PDU which accepts configured contained I-PDUs, that if
    a header ID can not be matched to a configured contained I-PDU, it is discarded silently.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts configured contained I-PDUs, where
        - the second and third contained I-PDU use a header ID that match and
        - the first and fourth do not use a header ID that match.
    02: VP: No API is called for the header IDs that do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>741</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05011_RxAcceptConfigured_HeaderIDNotMatched_LongHeader_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3449</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for a container PDU which accepts configured contained I-PDUs, that if
    a header ID can not be matched to a configured contained I-PDU, it is discarded silently.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts configured contained I-PDUs, where
        - the second and third contained I-PDU use a header ID that match and
        - the first and fourth do not use a header ID that match.
    02: VP: No API is called for the header IDs that do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>742</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05011_RxAcceptConfigured_HeaderIDNotMatched_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3536</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies for a container PDU which accepts configured contained I-PDUs, that if
    a header ID can not be matched to a configured contained I-PDU, it is discarded silently.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts configured contained I-PDUs, where
        - the second and third contained I-PDU use a header ID that match and
        - the first and fourth do not use a header ID that match.
    02: VP: No API is called for the header IDs that do not match.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>743</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05012_PduHeader_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3624</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The header ID is taken from first 3 bytes of each contained I-PDU, in the order stated by
        IpduMHeaderByteOrder (LITTLE_ENDIAN), from the least to most significant byte.
      - The DLC (data length code) is taken from 4th byte of the header.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMHeaderByteOrder set to LITTLE_ENDIAN.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00177):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first 3 bytes from each
    |      header) and length (4th byte).
    |  03: VP(IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On,
           IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On):
    |      PDU with configured reference (Header ID 3) is dropped silently.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>744</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05012_PduHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3727</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The header ID is taken from first 3 bytes of each contained I-PDU, in the order stated by
        IpduMHeaderByteOrder (LITTLE_ENDIAN), from the least to most significant byte.
      - The DLC (data length code) is taken from 4th byte of the header.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMHeaderByteOrder set to LITTLE_ENDIAN.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00177):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first 3 bytes from each
    |      header) and length (4th byte).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>745</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05012_PduHeader_LongHeader_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3834</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The header ID is taken from first 4 bytes of each contained I-PDU, in the order stated by
        IpduMHeaderByteOrder (LITTLE_ENDIAN), from the least to most significant byte.
      - The DLC (data length code) is taken from next 4 bytes of the header.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMHeaderByteOrder set to LITTLE_ENDIAN.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00177):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first 4 bytes from each
    |      header) and length (next 4 bytes).
    |  03: VP(IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On):
    |      PDU with Header ID 4 is discarded silently.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.LongHdrId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>746</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05012_PduHeader_LongHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3936</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The header ID is taken from first 4 bytes of each contained I-PDU, in the order stated by
        IpduMHeaderByteOrder (LITTLE_ENDIAN), from the least to most significant byte.
      - The DLC (data length code) is taken from next 4 bytes of the header.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMHeaderByteOrder set to LITTLE_ENDIAN.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00177):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first 4 bytes from each
    |      header) and length (next 4 bytes).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00177</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>275</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>747</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05013_Deferred_Processing_OneContainer</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4043</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_MainFunctionRx().
    04: VP: Check that PduR_IpduMRxIndication() has been called 2 times.
    |- for all contained PDUs:
    |  05: VP(IpduM.SWS_IpduM_00202):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>748</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05014_Deferred_Processing_MultipleContainers</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4154</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    First container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    Second container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    Both containers PDU:
    - IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    - IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_RxIndication() with a container PDU that accepts configured contained PDUs.
    04: VP: Check that PduR_IpduMRxIndication() is not called.
    05: Call IpduM_MainFunctionRx().
    06: VP: Check that PduR_IpduMRxIndication() has been called 4 times.
    |- for all contained PDUs:
    |  07: VP(IpduM.SWS_IpduM_00202):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>749</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate_AA_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4307</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
      - The data will be updated when the same container Rx comes from IpduM_RxIndication()
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    First container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    Both containers PDU:
    - IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    - IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_RxIndication() with the same container PDU.
    04: VP: Check that PduR_IpduMRxIndication() is not called.
    05: Call IpduM_MainFunctionRx().
    06: VP: Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  07: VP(IpduM.SWS_IpduM_00202,
              IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On,
              IpduM.SWS_IpduM_00204.ShortHdrId,
              IpduM.SWS_IpduM_00204.LongHdrId):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
    |      Header IDs are compared to the value of IpduMContainedPduHeaderId from the configuration.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.ShortHdrId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00204.LongHdrId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>403</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>750</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate_AC_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4467</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
      - The data will be updated when the same container Rx comes from IpduM_RxIndication()
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    First container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    Both containers PDU:
    - IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    - IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_RxIndication() with the same container PDU.
    04: VP: Check that PduR_IpduMRxIndication() is not called.
    05: Call IpduM_MainFunctionRx().
    06: VP: Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  07: VP(IpduM.SWS_IpduM_00202):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>751</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05015_Deferred_Processing_DataUpdate</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4616</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
      - The data will be updated when the same container Rx comes from IpduM_RxIndication()
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    First container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    Both containers PDU:
    - IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    - IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_RxIndication() with the same container PDU.
    04: VP: Check that PduR_IpduMRxIndication() is not called.
    05: Call IpduM_MainFunctionRx().
    06: VP: Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  07: VP(IpduM.SWS_IpduM_00202):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>752</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05019_Deferred_MF_RxIndication2_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4766</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
      - The data will be updated when the same container Rx comes from IpduM_RxIndication()
      - Rx Indication received during PduR_IpduMRxIndication is retaining only the latest data
        for containers with IPDUM_PROCESSING_DEFERRED and no queue.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    First container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    Both containers PDU:
    - IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    - IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_RxIndication() with the same container PDU.
    04: VP: Check that PduR_IpduMRxIndication() is not called.
    05: Call IpduM_MainFunctionRx().
        - another 2 Rx Indications are received for container 0 when
          PduR_IpduMRxIndication is called
    06: VP: Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  07: VP(IpduM.SWS_IpduM_00202):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
    08: Call IpduM_MainFunctionRx().
    - another 2 Rx Indication are received for container 0 when
      PduR_IpduMRxIndication is called
    09: VP: Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  10: VP(IpduM.SWS_IpduM_00202):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
    11: VP: Call IpduM_MainFunctionRx()
       - no Rx Indication forwarded to PduR.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>753</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05019_Deferred_MF_RxIndication2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4952</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
      - The data will be updated when the same container Rx comes from IpduM_RxIndication()
      - Rx Indication received during PduR_IpduMRxIndication is retaining only the latest data
        for containers with IPDUM_PROCESSING_DEFERRED and no queue.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    First container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    Both containers PDU:
    - IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    - IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_RxIndication() with the same container PDU.
    04: VP: Check that PduR_IpduMRxIndication() is not called.
    05: Call IpduM_MainFunctionRx().
        - another 2 Rx Indications are received for container 0 when
          PduR_IpduMRxIndication is called
    06: VP: Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  07: VP(IpduM.SWS_IpduM_00202):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
    08: Call IpduM_MainFunctionRx().
    - another 2 Rx Indication are received for container 0 when
      PduR_IpduMRxIndication is called
    09: VP: Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  10: VP(IpduM.SWS_IpduM_00202):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
    11: VP: Call IpduM_MainFunctionRx()
       - no Rx Indication forwarded to PduR.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>754</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05016_Deferred_Queue</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>5142</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that if a Container PDU is received and IpduMContainerPduProcessing is set to
    IPDUM_PROCESSING_DEFERRED, the Container PDU will be queued.
    If Development Error Detection is configured IPDUM_E_QUEUEOVFL shall be reported to DET.

    Note: Test altered due to inconsistency between RX and TX regarding the number of instances.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU with IpduMContainerQueueSize set to 3. Number of instances = current + 3 = 4.
    Container PDU has IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_CONFIGURED.
    Container PDU has 3 contained PDU configured.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts only configured PDUs.
    02: Call IpduM_RxIndication() with the same container PDU.
    03: Call IpduM_RxIndication() with the same container PDU.
    04: VP: (IpduM.SWS_IpduM_00211):
        VP: (IpduM.EB.CntrRx.DequeueOrder.NoOverFlow):
            Call IpduM_MainFunctionRx()
             - check that the oldest instance of Container PDU is received by PduR:
               - check that PduR_IpduMRxIndication() is called with correct handle IDs.
               - check that the data and its length is as expected.
    05: VP: (IpduM.SWS_IpduM_00211): Check that the all instances of Container PDU is received by PduR:
               - check that PduR_IpduMRxIndication() is called with correct handle IDs.
               - check that the data and its length is as expected.
    06: VP: (IpduM.SWS_IpduM_00211): Check that the all instances of Container PDU is received by PduR:
               - check that PduR_IpduMRxIndication() is called with correct handle IDs.
               - check that the data and its length is as expected.
    07: VP: (IpduM.SWS_IpduM_00211): Call IpduM_MainFunctionRx()
             - check that PduR_IpduMRxIndication() is not called.
    08: Call IpduM_RxIndication() with the same container PDU.
    09: Call IpduM_RxIndication() with the same container PDU.
    10: Call IpduM_RxIndication() with the same container PDU.
    11: VP(IpduM.EB.CntrRx.QueuingNumInstances):
        Call IpduM_RxIndication() with the same container PDU, all instances occupied,
        No overflow
    12: VP: (IpduM.SWS_IpduM_00212): Call IpduM_RxIndication()
             with the same container PDU:
             - if IPDUM_DEV_ERROR_DETECT is STD_ON then check if
               IPDUM_E_QUEUEOVFL error has been reported.
    13: VP: (IpduM.SWS_IpduM_00212): Call IpduM_RxIndication()
             with the same container PDU:
             - if IPDUM_DEV_ERROR_DETECT is STD_ON then check if
               IPDUM_E_QUEUEOVFL error has been reported.
    14: VP: (IpduM.SWS_IpduM_00211):
        VP: (IpduM.EB.CntrRx.DequeueOrder.OverFlowNotRead):
            Call IpduM_MainFunctionRx()
             - check that the oldest instance of Container PDU is received by PduR:
               - check that PduR_IpduMRxIndication() is called with correct handle IDs.
               - check that the data and its length is as expected.
    15: VP: (IpduM.SWS_IpduM_00211): Check that all instances of Container PDU is received by PduR:
               - check that PduR_IpduMRxIndication() is called with correct handle IDs.
               - check that the data and its length is as expected.
    16: VP: (IpduM.SWS_IpduM_00211): Check that all instances of Container PDU is received by PduR:
               - check that PduR_IpduMRxIndication() is called with correct handle IDs.
               - check that the data and its length is as expected.
    17: VP: (IpduM.SWS_IpduM_00211): Check that all instances of Container PDU is received by PduR:
               - check that PduR_IpduMRxIndication() is called with correct handle IDs.
               - check that the data and its length is as expected.
    18: VP: (IpduM.SWS_IpduM_00211): Call IpduM_MainFunctionRx()
             - check that PduR_IpduMRxIndication() is not called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00211</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>307</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00212</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>308</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00185.RX.QueueSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.QueuingNumInstances</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder.NoOverFlow</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder.OverFlowNotRead</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DeferredMF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>755</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05017_Deferred_Queue_Multiple_PDUs_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>5778</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that the processing of a container Rx with IpduMContainerPduProcessing
    set to IPDUM_PROCESSING_DEFERRED will take place in the next main function cycle
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Each of the 3 containers PDU has IpduMContainerQueueSize set to 3.
    First and last containers PDU have IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_CONFIGURED.
    Second container PDU has IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_ALL.
    First container PDU has 3 contained PDU configured.
    Second and last containers have 2 contained PDU configured.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a first container PDU.
    02: Call IpduM_RxIndication() with the first container PDU.
    03: Call IpduM_RxIndication() with the second container PDU.
    04: Call IpduM_RxIndication() with the second container PDU.
    05: Call IpduM_RxIndication() with the third container PDU.
    06: Call IpduM_RxIndication() with the second container PDU.
    07: VP: (IpduM.ASR42.IpduM.SWS_IpduM_00202): Call IpduM_MainFunctionRx()
             - check that PduR_IpduMRxIndication() is called.
             - check that PduR receives the correct data:
               - the IpduM unpacks correctly the all instances in queue
                 for each container and calls PduR_IpduMRxIndication for
                 each contained PDU, using correct handle ID.
               - the data received and its length by PduR matches the expected one.
               - each unpacked instance of a container is removed from
                 queue
    08: VP: (IpduM.SWS_IpduM_00202): Call IpduM_MainFunctionRx()
              - check that PduR_IpduMRxIndication() is not called, since the queue
                is empty for each container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DeferredMF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>756</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05017_Deferred_Queue_Multiple_PDUs</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>6237</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that the processing of a container Rx with IpduMContainerPduProcessing
    set to IPDUM_PROCESSING_DEFERRED will take place in the next main function cycle
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Each of the 3 containers PDU has IpduMContainerQueueSize set to 3.
    First and last containers PDU have IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_CONFIGURED.
    Second container PDU has IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_ALL.
    First container PDU has 3 contained PDU configured.
    Second and last containers have 2 contained PDU configured.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a first container PDU.
    02: Call IpduM_RxIndication() with the first container PDU.
    03: Call IpduM_RxIndication() with the second container PDU.
    04: Call IpduM_RxIndication() with the second container PDU.
    05: Call IpduM_RxIndication() with the third container PDU.
    06: Call IpduM_RxIndication() with the second container PDU.
    07: VP: (IpduM.ASR42.IpduM.SWS_IpduM_00202): Call IpduM_MainFunctionRx()
             - check that PduR_IpduMRxIndication() is called.
             - check that PduR receives the correct data:
               - the IpduM unpacks correctly the all instances in queue
                 for each container and calls PduR_IpduMRxIndication for
                 each contained PDU, using correct handle ID.
               - the data received and its length by PduR matches the expected one.
               - each unpacked instance of a container is removed from
                 queue
    08: VP: (IpduM.SWS_IpduM_00202): Call IpduM_MainFunctionRx()
              - check that PduR_IpduMRxIndication() is not called, since the queue
                is empty for each container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DeferredMF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>757</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05018_Deferred_MF_RxIndication_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>6696</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that Rx Indication received during PduR_IpduMRxIndication is
    retained in the queue for containers with IPDUM_PROCESSING_DEFERRED and queue size specified.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Each of the 3 containers PDU has IpduMContainerQueueSize set to 3.
    First and last containers PDU have IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_CONFIGURED.
    Second container PDU has IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_ALL.
    First container PDU has 3 contained PDU configured.
    Second and last containers have 2 contained PDU configured.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a first container PDU.
    02: Call IpduM_RxIndication() with the first container PDU.
    03: Call IpduM_RxIndication() with the second container PDU.
    04: Call IpduM_RxIndication() with the second container PDU.
    05: Call IpduM_RxIndication() with the third container PDU.
    06: Call IpduM_RxIndication() with the second container PDU.
    07: VP: (IpduM.ASR42.IpduM.SWS_IpduM_00202): Call IpduM_MainFunctionRx()
             - check that PduR_IpduMRxIndication() is called.
             - check that PduR receives the correct data:
               - the IpduM unpacks correctly the all instances in queue
                 for each container and calls PduR_IpduMRxIndication for
                 each contained PDU, using correct handle ID.
               - the data received and its length by PduR matches the expected one.
               - each unpacked instance of a container is removed from
                 queue
               - another 2 Rx Indications are received for container 1 when
                 PduR_IpduMRxIndication is called.
    08: VP: (IpduM.SWS_IpduM_00202): Call IpduM_MainFunctionRx()
              - check that PduR_IpduMRxIndication() is not called, since the queue
                is empty for each container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DeferredMF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>758</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05018_Deferred_MF_RxIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7179</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that Rx Indication received during PduR_IpduMRxIndication is
    retained in the queue for containers with IPDUM_PROCESSING_DEFERRED and queue size specified.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Each of the 3 containers PDU has IpduMContainerQueueSize set to 3.
    First and last containers PDU have IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_CONFIGURED.
    Second container PDU has IpduMContainerRxAcceptContainedPdu set IPDUM_ACCEPT_ALL.
    First container PDU has 3 contained PDU configured.
    Second and last containers have 2 contained PDU configured.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a first container PDU.
    02: Call IpduM_RxIndication() with the first container PDU.
    03: Call IpduM_RxIndication() with the second container PDU.
    04: Call IpduM_RxIndication() with the second container PDU.
    05: Call IpduM_RxIndication() with the third container PDU.
    06: Call IpduM_RxIndication() with the second container PDU.
    07: VP: (IpduM.ASR42.IpduM.SWS_IpduM_00202): Call IpduM_MainFunctionRx()
             - check that PduR_IpduMRxIndication() is called.
             - check that PduR receives the correct data:
               - the IpduM unpacks correctly the all instances in queue
                 for each container and calls PduR_IpduMRxIndication for
                 each contained PDU, using correct handle ID.
               - the data received and its length by PduR matches the expected one.
               - each unpacked instance of a container is removed from
                 queue
               - another 2 Rx Indications are received for container 1 when
                 PduR_IpduMRxIndication is called.
    08: VP: (IpduM.SWS_IpduM_00202): Call IpduM_MainFunctionRx()
              - check that PduR_IpduMRxIndication() is not called, since the queue
                is empty for each container PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DeferredMF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>759</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05018_Deferred_MF_RxIndication_Overflow</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7662</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that Rx Indication received during PduR_IpduMRxIndication is
    retained in the queue for containers with IPDUM_PROCESSING_DEFERRED and queue size specified.

    Note: Test is similar to TS_IPDUM_CON_05018_Deferred_MF_RxIndication, the difference being
    is that queue overflow occurs while the RX MF is processing a Container instance.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerQueueSize is set to 3.
    IpduMContainerRxAcceptContainedPdu is set to IPDUM_ACCEPT_CONFIGURED.
  
Test Execution: 
    01: Call IpduM_RxIndication(), first instance added
    02: Call IpduM_RxIndication(), second instance added
    03: Call IpduM_RxIndication(), third instance added
    04: VP: (IpduM.EB.CntrRx.DeferredMF):
        VP: (IpduM.EB.CntrRx.DequeueOrder.OverFlowWhileReading):
        Call IpduM_MainFunctionRx()
             - check that PduR_IpduMRxIndication() is called.
             - another 2 Rx Indications are received for container 1 when
                 PduR_IpduMRxIndication is called. This causes an overflow.
             - after the processing of the first container instance is done, it
             is followed by the newest one, then the older one
             - check that PduR receives the correct data:
               - the IpduM unpacks correctly all instances in the queue
                 for each container and calls PduR_IpduMRxIndication for
                 each contained PDU, using correct handle ID.
               - the data received and its length by PduR matches the expected one.
               - each unpacked instance of a container is removed from
                 queue
    05: Container processed as expected
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DeferredMF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DequeueOrder.OverFlowWhileReading</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>760</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05026_Payload_Validation2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7964</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that if a malformed header is encountered, Det error is reported.
    The container is ignored.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: RxIndication() callled with malformed container
    02: Det is reported
    03: Container is ignored
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>761</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05020_CntrRx_Update_Bit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8044</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that verifies that in case a received contained I-PDU has a configured update bit,
    the IpduM module shall only process and indicate it to the upper layer if its received
    update-bit is set.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the container PDU
        - contained PDU 1 has offset 1, update bit 0
        - contained PDU 2 has offset 22, update bit 7
        - contained PDU 3 has offset 43, update bit 3

        Container PDU byte 0 contains value 1 only for
        contained PDUs 2 and 3.
    02: Container PDU which contains 3 IpduMContainedRxPdu is received
    03: Check Handle ID, length and payload for the contained PDUs 2 and 3
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00236</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>339</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>762</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05021_CntrRx_Update_Bit_Different_Bytes</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8152</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that verifies that in case a received contained I-PDU has a configured update bit,
    the IpduM module shall only process and indicate it to the upper layer if its received
    update-bit is set.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the container PDU
        - contained PDU 1 has offset 1, update bit 7
        - contained PDU 2 has offset 23, update bit 176
        - contained PDU 3 has offset 45, update bit 355

        All contained PDUs have the update bit set.
    02: Container PDU which contains 3 IpduMContainedRxPdu is received
        - SduLength is 65U
    03: Check Handle ID, length and payload for the contained PDUs 1, 2 and 3
        - contained PDU 1 length is 21U
        - contained PDU 2 length is 21U
        - contained PDU 3 length is 20U
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00236</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>339</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>763</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05022_CntrRx_Det_Report</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8283</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that verifies that when processing a received Container PDU with IpduMContainerHeaderSize set to
    IPDUM_HEADERTYPE_NONE, the IpduM shall ignore all contained PDUs that are according to their configuration
    not or not completely contained in the received Container PDU. Such contained I-PDUs shall not be
    indicated to the upper layer and IPDUM_E_CONTAINER shall be report if Development Error Detection is
    enabled.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the container PDU
        - contained PDU 1 has offset 1, update bit 0
        - contained PDU 2 has offset 22, update bit 7
        - contained PDU 3 has offset 43, update bit 3

        Container PDU byte 0 contains value 1 only for
        contained PDUs 2 and 3.

    02: Container PDU which contains 2 IpduMContainedRxPdu is received
        - SduLength is 43U equal to contained PDU 3 offset
    03: Check Handle ID, length and payload for the contained PDU 2
    04: Check that Det is reported.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00237</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>340</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00247</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>764</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05027_ShortContainerDequeue</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8389</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that if the header of the Container is too short,
    it's disregarded.
    The fact that the length causes no malfunction is also verified.
    See ASCIPDUM-1013.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: Receive shorter-than-necessary container
    02: Receive shorter-than-necessary container
        At this point they are queued as only the max length is verified
    03: VP(IpduM.SWS_IpduM_00214):
        The header is too short, the payload is ignored.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>765</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05023_CntrRx_Dynamic_Length</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8455</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that verifies that the last contained IPdu (according to IpduMContainedPduOffset) of
    a ContainerIPdu with static container layout may be a dynamic length PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the container PDU
        - contained PDU 1 has offset 0, no update bit
        - contained PDU 2 has offset 8, no update bit

    02: Container PDU which contains 2 IpduMContainedRxPdu is received
        - SduLength is 9U
    03: Check Handle ID, length and payload for the contained PDUs 1 and 2
        - contained PDU 1 length is 8U
        - contained PDU 2 length is 1U
    04: Prepare data for the container PDU
    05: Container PDU which contains 2 IpduMContainedRxPdu is received
        - SduLength is 16U
    06: Check Handle ID, length and payload for the contained PDUs 1 and 2
        - contained PDU 1 length is 8U
        - contained PDU 2 length is 8U
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>766</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_05025_Payload_Validation_DLC</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_05_ContainerRxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8595</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that if a malformed header is encountered, PDUM_E_HEADER is reported to DET.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call TS_endless_loop_test to check No endless loop happens
      |- TS_endless_loop_test: call IpduM_RxIndication() with bigger pdu length that causes overflow in the calculations.
    02: RxIndication() callled with malformed header
    03: Det is reported
    04: Container is ignored
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.Container.Payload.Rx.Validation.DLC.Length</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>767</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_06001_ErrorCodes</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_06_General/source/application/Tests.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that error codes are defined and hold the correct value.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    01: VP(IpduM.SWS_IpduM_00213): IPDUM_E_HEADER is defined and has the 0x30U value.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>768</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_07085_Tx_Length_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when during transmission the SduLength is 0 the PDU
    is ignored silently.

    ASCIPDUM-999.
  &lt;/para&gt;
  
Test Object: 
    IpduM_Transmit()
  
Test Precondition: 
    Container configuration item IpduMFirstContainedPduTrigger set to TRUE.
  
Test Execution: 
    01: Call IpduM_Transmit() with a PDU having SduLenth of 0
    02: VP(IPDUM.EB.ZeroPduLength.Transmission):
        Nothing is invoked
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.ZeroPduLength.Transmission</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>769</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07001_FirstContainedTrue</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>203</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that when adding the first contained I-PDU to a Container PDU
    with the parameter IpduMFirstContainedPduTrigger set to TRUE, then IpduM  calls PduR_IpduMTransmit.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container configuration item IpduMFirstContainedPduTrigger set to TRUE.
  
Test Execution: 
    00: Initialize IpduM
    01: Call IpduM_Transmit() with a contained PDU mapped to a container PDU with IpduMFirstContainedPduTrigger set to TRUE.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00201):
    |         PduR_IpduMTransmit() is called with correct handle ID
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>770</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07051_FirstContainedTrue_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>293</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that when adding the first contained I-PDU to a Container PDU
    with the parameter IpduMFirstContainedPduTrigger set to TRUE then the container
    is triggered. This test verifies what happens in case the PduR_IpduMTriggerTransmit
    returns E_NOT_OK for that contained PDU. (no transmission happens)
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container configuration item IpduMFirstContainedPduTrigger set to TRUE.
  
Test Execution: 
    00: Initialize IpduM
    01: Call IpduM_Transmit() with a contained PDU mapped to a container PDU with IpduMFirstContainedPduTrigger set to TRUE.
    |- for all contained PDUs:
    |  02: VP(IpduM.SWS_IpduM_00201):
    |         PduR_IpduMTransmit() is not called, because PduR_IpduMTriggerTransmit
              returned E_NOT_OK and container PDU is empty.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>297</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>771</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07002_TriggerImmediately</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>372</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that when adding a ContainedPdu to a Container which has not yet been triggered
    and with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS, the container
    is triggered immediately.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainedTxPduTrigger == IPDUM_TRIGGER_ALWAYS, untriggered Container
  
Test Execution: 
    00: Initialize IpduM.
    01: First call to Transmit does not trigger, IpduMConf_IpduMContainedTxPdu_IpduMContainedTxPdu_7
        has IpduMContainedTxPduTrigger configured to IPDUM_TRIGGER_NEVER
    02: Second call to Transmit triggers, IpduMConf_IpduMContainedTxPdu_IpduMContainedTxPdu_8 has
        IpduMContainedTxPduTrigger configured to IPDUM_TRIGGER_ALWAYS
    03: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS): PduR_IpduMTransmit() is called with correct handle ID.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>276</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>772</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07003_TriggerImmediately_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>489</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that when adding a ContainedPdu to a Container which has not yet been triggered
    and with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS, the container
    is triggered immediately.
    This test illustrates that indeed the IpduMContainedTxPduTrigger determines
    the triggering. (One more call to IpduM_Transmit and differet in payload)
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainedTxPduTrigger == IPDUM_TRIGGER_ALWAYS, untriggered Container
  
Test Execution: 
    00: Initialize IpduM.
    01: First call to Transmit does not trigger, IpduMConf_IpduMContainedTxPdu_IpduMContainedTxPdu_7
        has IpduMContainedTxPduTrigger configured to IPDUM_TRIGGER_NEVER
    02: Second call to Transmit does not trigger, IpduMConf_IpduMContainedTxPdu_IpduMContainedTxPdu_7
        has IpduMContainedTxPduTrigger configured to IPDUM_TRIGGER_NEVER
    03: Third call to Transmit triggers, IpduMConf_IpduMContainedTxPdu_IpduMContainedTxPdu_8 has
        IpduMContainedTxPduTrigger configured to IPDUM_TRIGGER_ALWAYS
    04: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS): PduR_IpduMTransmit() is called with correct handle ID.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>276</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>773</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07004_ThresholdExceeded</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>620</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that by having a Contained IPDU added to a Container and thus
    the payload size being greater than IpduMContainerTxSizeThreshold,
    the transmission is triggered.

    Size of Container : 50
    IpduMContainerTxSizeThreshold : 40
    The configured PduLength is considered.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  No transmission occured
    03:  Payload added to container
    04:  No transmission occured
    05:  Payload added to container
    06:  No transmission occured
    07:  Payload added to container
    08:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD): Threshold exceeded, transmission takes place
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>774</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07005_ThresholdExceeded_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>762</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that by having a Contained IPDU added to a Container and thus
    the payload size being greater than IpduMContainerTxSizeThreshold,
    the transmission is triggered.

    Size of Container : 50
    IpduMContainerTxSizeThreshold : 40

     Different payloads (in comparison with TS_IPDUM_CON_07004_ThresholdExceeded)
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  No transmission occured
    03:  Payload added to container
    04:  No transmission occured
    05:  Payload added to container
    06:  No transmission occured
    07:  Payload added to container
    08:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD): Threshold exceeded, transmission takes place
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>775</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07006_TxConfAwait</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>920</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that transmission is triggered upon the receival of an awaited TxConfirmation
    if IpduMDequeueInTxConf is set as TRUE.
    IpduMDequeueInTxConf is configured as m4_upper(PM_IpduMDequeueTxConfirm)
    The PDUs used are configured to IPDUM_TRIGGER_NEVER
    IpduMContainerQueueSize is 1.
    IpduMContainerTxConfirmationTimeout is 3.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerTxTriggerMode is IPDUM_DIRECT.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  No transmission occured
    03:  Payload added to container
    04:  Threshold exceeded, transmission occurs
    05:  Payload added to container
    06:  No transmission occured
    07:  Payload added to container
    08:  No transmission occured
    09:  TxConfirmation received
    10:  VP(IPDUM.EB.IpduMDequeueInTxConf):
         TxConfirmation m4_ifelse(PM_IpduMDequeueTxConfirm|upper,TRUE,triggers,does not trigger) the transmission
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>776</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07007_TxConfAwait_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1113</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that in case the IpduMContainerTxConfirmationTimeout &gt; 0
    and the corresponding TxConf timeout timer has elapsed or the TxConf for that Container PDU
    was received, PduR_IpduMTransmit shall be invoked for the next oldest instance of that Container PDU
    in the next main function cycle at the latest.

    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_5 has a TxConf Timeout value
    of 3 MF cycles.

    The PDUs used are configured to IPDUM_TRIGGER_NEVER
    IpduMContainerQueueSize is 1.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  No transmission occurs
    03:  Payload added to container
    04:  No transmission occurs
    05:  Payload added to container
    06:  Threshold exceeded, transmission triggered
    07:  Payload added to container
    08:  No transmission occurs
    09:  Payload added to container
    10:  No transmission occurs
    11:  Payload added to container
    12:  No transmission occurs, TxConf timeout still at 3
    13:  TxConf timeout at 2, no transmission
    14:  TxConf timeout at 1, no transmission
    15:  TxConf timeout expired
    16:  VP(IPDUM.EB.IpduMDequeueInTxConf): Transmission is triggered due to the expired timeout
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_SingleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>777</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07008_TxConfAwait_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1370</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that in case the IpduMContainerTxConfirmationTimeout &gt; 0 as long as
    the corresponding TxConf timeout timer has not elapsed and no transmission confirmation
    for that Container PDU was received, the IpduM will wait for the TxConfirmation before
    invoking PduR_IpduMTransmit for the next instance of that Container PDU

    Test shows that TxConfirm triggers transmission when DequeueInTxConf is TRUE.

    The PDUs used are configured to IPDUM_TRIGGER_NEVER
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    DequeueInTxConf is m4_upper(PM_IpduMDequeueTxConfirm).
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  No transmission occurs
    03:  Payload added to container
    04:  Transmission because of exceeded threshold
    05:  Payload added to container
    06:  No transmission occurs
    07:  Payload added to container
    08:  No transmission occurs
    09:  Payload added to container
    10:  No transmission occurs, still awaiting TxConf
    11:  TxConf received
    12:  Payload added to container
    13:  VP(IpduM.ASR42.SWS_IpduM_00189): Transmission possible
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>778</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07009_TxConfAwait_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1639</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that transmission is triggered upon the receival of an awaited TxConfirmation
    when DequeueInTxConf is TRUE.

    2 Contained PDUs used are configured to IPDUM_TRIGGER_NEVER
    1 Contained PDU is configured to IPDUM_TRIGGER_ALWAYS

    Test demanded by ASCIPDUM-804.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    DequeueInTxConf is m4_upper(PM_IpduMDequeueTxConfirm).
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
         - No transmission occured
    02:  Payload added to container
         - Threshold exceeded, transmission occurs
    03:  Payload added to container
         - No transmission occured
    04:  Attempt of adding payload to container
         is rejected because it would
         trigger transmission once more
         while still awaiting TxConfirmation
    05:  TxConfirmation received
    06:  VP(IPDUM.EB.IpduMDequeueInTxConf):
         Since DequeueInTxConf is m4_upper(PM_IpduMDequeueTxConfirm),
         TxConfirmation m4_ifelse(PM_IpduMDequeueTxConfirm|upper,TRUE,triggers,does not trigger) the transmission
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>779</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07010_TxSendTimeoutMin</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1831</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that when a contained I-PDU is added to a Container PDU,
    the transmission timer of the Container PDU shall be updated with
    the contained I-PDU's timeout (IpduMContainedTxPduSendTimeout) if it's
    less than the remaining time of the Container PDU.

    (It isn't, the Container has it configured for 3, the Contained ones
    have it disabled)
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  No transmission occurs
    03:  Payload added to container, TxSendTimeout reduced to 1
    04:  No transmission occurs, TxSendTimeout at 1
    05:  TxSendTimeout elapsed
    06:  VP(IpduM.SWS_IpduM_00185): Transmission triggered
    07:  The transmitted payload and length is as expected
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>780</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07011_TxSendTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>1959</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when the TxSendTimeout of a Container has elapsed,
    transmission will be triggered.

    3 MainFunction cycles ensure that the timer reaches 0 for
    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_7.

    Test updated to check bugfix for ASCIPDUM-964.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, TxSendTimeout set to that of the container (3 &lt; 4)
    02:  TxSendTimeout at 3
    03:  Same payload added to container, TxSendTimeout is not changed.
    04:  TxSendTimeout at 2
    05:  Same payload added to container, TxSendTimeout is not changed.
    06:  TxSendTimeout at 1
    07:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT): Transmission triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>781</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07012_TxSendTimeout_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2074</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when the TxSendTimeout of a Container has elapsed,
    transmission will be triggered.

    1 MainFunction cycle ensures that the timer reaches 0 for
    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_7.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, TxSendTimeout set to that of IpduMContainedTxPdu_18 (1 &lt; 3)
    02:  TxSendTimeout expires
    03:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT): Transmission triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>782</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07013_TxSendTimeout_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2163</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when the TxSendTimeout of a Container has elapsed,
    transmission will be triggered.

    1 MainFunction cycle ensures that the timer reaches 0 for
    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_7.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, TxSendTimeout set to 3
    02:  TxSendTimeout at 3
    03:  Payload added to container, TxSendTimeout reduced to 1 (IpduMContainedTxPdu_18)
    04:  TxSendTimeout expired
    05:  VP(IpduM.SWS_IpduM_00185)
         VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT): Transmission triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>783</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07014_TxSendTimeout_3_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2265</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when the TxSendTimeout of a Container has elapsed,
    transmission will be triggered.

    3 MainFunction cycles ensure that the timer reaches 0 for
    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_7.

    Observe that the timer does not get increased.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, TxSendTimeout set to 1
    02:  Payload added to container, TxSendTimeout does not get updated (3 &gt; 1)
    03:  TxSendTimeout expired
    04:  VP(IpduM.SWS_IpduM_00185)
         VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT): Transmission triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>283</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>784</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07048_TxSendTimeout_ConfTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2367</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when the TxSendTimeout of a Container has elapsed,
    transmission will be triggered.

    Configured values for
    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_7 in MF cycles:
      SendTimeout : 3
      TxConfTimeout: 4

    Test mandated by
    https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-836
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, TxSendTimeout set to 3
    02:  TxSendTimeout reduced to 1
    03:  TxSendTimeout expires, transmission is triggered
         TxConfTimeout is set to 4
    04:  Payload added to container, TxSendTimeout set to 3
    05:  TxSendTimeout reduced to 1
         TxConfTimeout reduced to 2
    06:  TxSendTimeout expires, no transmission is triggered
         TxConfTimeout reduced to 1
         Transmission is postponed
    07:  VP(IPDUM.EB.IpduMSendAfterConf): TxConfTimeout expires,
         transmission is triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMSendAfterConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>785</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07015_SizeTrigger</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2486</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks container pdu is triggered if size exceeds.
    Adding a third contained Pdu that exceeds container size triggers sending.

    Threshold is 40.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  No transmission occurs
    03:  Payload added to container
    04:  No transmission occurs
    05:  Payload added to container, threshold exceeded
    06:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD): Transmission triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>786</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07016_SizeTrigger_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2625</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks container pdu is triggered if size exceeds.
    It's verified that updating is according to specs, for this
    IpduMConf_IpduMContainedTxPdu_IpduMContainedTxPdu_15 is used.

    Threshold is 40.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, no transmission
    02:  Payload added to container, no transmission
    03:  Payload added to container, Threshold exceeded
    04:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD): Transmission triggered, payload updated
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>787</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07017_SizeTrigger_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2759</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks container pdu is triggered if size exceeds.
    It's verified that updating is according to specs, for this
    IpduMConf_IpduMContainedTxPdu_IpduMContainedTxPdu_14 is used.

    Threshold is 40.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
         No transmission occurs
    02:  Payload added to container
         No transmission occurs
    03:  Payload added to container
         Transmission occurs
    04:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD): Transmission triggered, payload updated
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>788</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07024_TxConfirmationTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>2895</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when the TxConfirmationTimeout passes,
    TxConfirmations for that given PDU are ignored.

    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_4 has the
    TxConfTimeout configured for 3 MFs.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, no transmission
    02:  Payload added to container, transmission triggered because of threshold
    03:  TxConfTimeout at 3
    04:  TxConfTimeout at 2
    05:  TxConfTimeout at 1
    06:  Payload updated
    07:  VP(IpduM.ASR42.SWS_IpduM_00198): TxConfirmation is ignored
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>789</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07025_TxConfirmationContained</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3018</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that if the ContainedTxPdus have IpduMContainedTxPduConfirmation
    configured as ENABLED, the TxConfirmations are forwarded as expected.

    IpduMConf_IpduMContainedTxPdu_IpduMContainedTxPdu_16 has been configured as:
    * IPDUM_TRIGGER_ALWAYS
    * IpduMContainedTxPduConfirmation ENABLED
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  Transmission because of TRIGGER_ALWAYS
    03:  TxConf received
    04:  VP(IpduM.SWS_IpduM_00196): TxConfirmation is translated
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>790</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07026_TriggerTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3106</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that IpduM provides the correct data when triggered.

    IpduMContainerQueueSize is 1.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  Payload added to container
    03:  Payload added to container
    04:  VP(SWS_IpduM_00220): PduR_IpduMTriggerTransmit() is used to fetch the data
    05:  VP(SWS_IpduM_00187): Overall size is calculated as expected
    06:  VP(SWS_IpduM_00193): Correct data in SduDataPtr (payload retained until TriggerTransmit())
    07:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT): TxSendTimeout expires (6 MFs are necessary), transmission is triggered
    08:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT, IpduM.SWS_IpduM_00193.LB): The payload is as expected
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00187</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193.LB</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>791</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07054_TriggerTransmit_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3313</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that IpduM provides the correct data when triggered.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  Payload added to container
    03:  Payload added to container
    04:  VP(SWS_IpduM_00220): PduR_IpduMTriggerTransmit() is used to fetch the data
    05:  VP(SWS_IpduM_00187): Overall size is calculated as expected
    06:  VP(SWS_IpduM_00193): Correct data in SduDataPtr (payload retained until TriggerTransmit())
    07:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT): TxSendTimeout expires (6 MFs are necessary), transmission is triggered
          - container PDU instance queued because PduR_IpduMTransmit returns E_NOT_OK
    08:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT, IpduM.SWS_IpduM_00193.LB): E_NOT_OK received, PduR_IpduMTransmit unsuccesfull
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00187</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193.LB</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>792</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07027_TriggerTransmit_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3502</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that IpduMTriggerTransmit returns E_NOT_OK when
    called for a Container Tx PDU with IpduMContainerTxTriggerMode  set to
    IPDUM_DIRECT.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduMTriggerTransmit for a Container Tx PDU with
    IpduMContainerTxTriggerMode set to IPDUM_DIRECT
    02:  VP(SWS_IpduM_00194): Returns expected value (E_NOT_OK), no data change.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>793</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07042_TriggerTransmit_E_NOT_OK_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3581</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when PduR_IpduMTriggerTransmit() returns E_NOT_OK,
    the PDU is ommited from the Container.

    IPDUM_TRIGGERTRANSMIT
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
    02:  PduR_IpduMTriggerTransmit() returns E_OK
    03:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
    04:  Because of TRIGGER_ALWAYS Contained PDU the container is sealed
    05:  (VP, SWS_IpduM_00222): Only the second PDU is retained
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>794</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07060_TriggerTransmit_SendAwait</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3718</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when PduR_IpduMTriggerTransmit() returns E_NOT_OK,
    the PDU is ommited from the Container.

    IPDUM_TRIGGERTRANSMIT

    Test modified due to ASCIPDUM-1044.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
    02:  PduR_IpduMTriggerTransmit() returns E_OK
    03:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
    04:  Because of TRIGGER_ALWAYS Contained PDU is announced
    05:  (VP, SWS_IpduM_00222): Only the second PDU is retained
          - confirmation timeout is 2
    06:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
    07:  PduR_IpduMTriggerTransmit() returns E_OK
    08:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
           - E_NOT_OK received because send await is set (awaiting for confirmation)
    09:  (VP, SWS_IpduM_00222): Call Main Function Tx for 2 times
           - confirmation timeout is decreased to 0.
           - container size is announced.
           - Only the second PDU is retained
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>795</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07043_TriggerTransmit_E_NOT_OK_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>3953</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when PduR_IpduMTriggerTransmit() returns E_NOT_OK,
    the PDU is omitted from the Container.

    IPDUM_DIRECT.
    ConfTimeout is 0.

    IpduMContainedTxPdu_8 is TRIGGER_ALWAYS.
    Threshold is 40, Container PDU size is 48.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
         Calculated size is 18 (8+10)
    02:  PduR_IpduMTriggerTransmit() returns E_OK
         Calculated size is 36 (18 + 8 + 10)
    03:  PduR_IpduMTriggerTransmit() returns E_OK
    04:  Adding the new Contained PDU exceeds the size, the old one is
         triggered and transmitted.
         New Contained PDU stored because ConfTimeout is 0
    05:  (VP: SWS_IpduM_00222): Only the second PDU is retained
    06:  Another transmission is triggered by the Contained PDU from step 04,
         E_OK is returned
        (VP: IpduM.SWS_IpduM_00182, IpduM.ASR42.SWS_IpduM_00189):
         Because of TRIGGER_ALWAYS Contained PDU the container is sealed,
         Confirmation timeout is 0, it's transmitted.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>796</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07045_TriggerTransmit_E_NOT_OK_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4111</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when PduR_IpduMTriggerTransmit() returns E_NOT_OK
    for all the Contained PDUs, the Container is dropped.

    IPDUM_DIRECT.
    TxThreshold is 20, exceeded by adding the 2nd Contained PDU
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
    02:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
    03:  PduR_IpduMTriggerTransmit() returns E_NOT_OK
    04:  Because of TRIGGER_ALWAYS Contained PDU the container would be
         sealed, but as there is no data, IpduM_TriggerTransmit() returns E_NOT_OK
         and the buffer is untouched.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>797</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07028_Transmit_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when PduR_IpduMTransmit() returns E_NOT_OK, and
    a Contained PDU is added to the Container PDU, the configured PDU length
    is not exceeded.

    Confirmation timeout is 0.
    Container is TRIGGER_FIRST

    Test demanded by ASCIPDUM-768
    (Container Tx PDU exceeds configured PDU length on IpduM_Transmit()).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerQueueSize is DISABLED. Number of instances: 1.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit for with a first Contained.
           - transmission triggered, but PduR_IpduMTransmit will return
             E_NOT_OK, no data is sent.
    02:  Call IpduM_Transmit for with a second Contained.
           - transmission not triggered, retry only in main function.
           - DET is called for overwriting
    03:  Call IpduM_Transmit for with a third Contained.
           - transmission triggered
           - PduR_IpduMTransmit will return E_OK, data is sent.
    04:  VP: Call main function.
           - PduR_IpduMTransmit is called and returns E_OK
           - Container emptied
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>280</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>798</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07062_TriggerTransmit_TxConf</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4376</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when Tx Confirmation of a container PDU
    with IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT, then
    it is translated to its contained PDUs.

    Test demanded by ASCIPDUM-872
    (Missing TxConfirmation of contained PDUs).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT
    - 3 contained PDUs which reference container PDU, first and last being configured
      to receive Tx Confirmation.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit for with a first Contained.
           - no transmission request.
    02:  Call IpduM_Transmit for with a second Contained.
           - no transmission request.
    03:  Call IpduM_Transmit for with a third Contained.
           - transmission triggered
           - PduR_IpduMTransmit() is called.
    04:  Call IpduM_TriggerTransmit():
           - contained PDUs payloads are updated through
             PduR_IpduMTriggerTransmit().
    05:  VP: Call IpduM_TxConfirmation()
            - check that for all contained PDUs which are
              configured to have a Tx Confirmation, then
              PduR_IpduMTxConfirmation() is called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>799</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07067_SizeAnnounceMFTx_LB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4522</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() during
    IpduM_MainFunctionTx() when queue is not empty.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with IpduMContainerTxFirstContainedPduTrigger enabled
    - first contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER
    - second contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS
    - third contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER
    - fourth contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS
    - fifth contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER
  
Test Execution: 
    00:   Initialize IpduM.
    01:   Payload added to container
            - size is announced because IpduMContainerTxFirstContainedPduTrigger
            - TxConfTimeout set to 2
    02:   Payload added to container
            - size is not announced, already announced
    03:   Payload added to container
            - size is not announced, already announced
    04:   Payload added to container
            - size is not announce, already announced
    05:   Payload added to container
            - size is not announced, already announced
    06:   No transmission
            - TxConfTimeout reduced to 1
    06:   Call Main Function Tx
            - TxConfTimeout expires
            - instance dropped
            - transmission request for next instance
            - TxConfTimeout set to 2
    07:   Payload added to container
            - size is not announced, already announced
    08:   Payload added to container
            - size is not announce, already announced
    09:   Call Main Function Tx
            - TxConfTimeout reduced from 2 to 1
    10:   TxConfTimeout expires
            - Transmission
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_FIRST</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>625</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Queue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>800</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07068_SizeAnnounceOnlyOnce_LB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>4755</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() only once
    for each container PDU instance.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
    Test altered due to ASCIPDUM-1044.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with IpduMContainerTxFirstContainedPduTrigger enabled
    - first contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER
    - second contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS
    - third contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER
    - fourth contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS
    - fifth contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER
  
Test Execution: 
    00:   Initialize IpduM.
    01:   Payload added to container
            - size is announced because IpduMContainerTxFirstContainedPduTrigger
    02:   Call Main Function Tx
            - size already announced, send timeout is 0 already
    03:   Payload added to container
            - TRIGGER_ALWAYS added size already announced
    04:   Call IpduM_TriggerTransmit()
            - data retrieved is correct, confirmation timeout is 1
    05:   Payload added to container PDU
            - size is not announced, awaiting confirmation
    06:   Call IpduM_TxConfirmation()
            - size is announced because of point above
    07:   Payload added to container PDU
            - size is not announced, already announced
    08:   Call IpduM_TriggerTransmit()
            - data retrieved is correct, confirmation timeout is 2
    09:   Payload added to container PDU
            - size is not announced, awaiting confirmation
    10:   Call Main Function Tx
            - confirmation timeout is decreased to 1
    11:   Payload added to container PDU
            - size is not announced, already announced
    12:   Call IpduM_TxConfirmation()
            - size is announced
    13:   Call Main Function Tx
            - confirmation timeout is decreased to 1
    14:   Payload added to container PDU
            - size is not announced, already announced
    15:   Call Main Function Tx
            - size is not announced, already announced
    16:   Call IpduM_TriggerTransmit()
            - data retrieved is correct, confirmation timeout is 1
    17:   Call Main Function Tx
            - confirmation timeout is decreased to 1
    18:   Call IpduM_TxConfirmation() in a timely manner
    19:   Payload added to container
            - size is announced because IpduMContainerTxFirstContainedPduTrigger
    20:   Payload added to container PDU
            - size is not announced, already announced
    21:   Payload added to container PDU
            - size is not announced, already announced
    22:   Payload added to container PDU
            - size is not announced, already announced, enqueue
    23:   Call IpduM_TriggerTransmit()
            - data retrieved successfully
    24:   Call IpduM_TxConfirmation()
            - size is announced
    25:   Call IpduM_TriggerTransmit()
            - data retrieved successfully
    26:   Call IpduM_TxConfirmation() in a timely manner
            - Container is empty
    27:   Call Main Function Tx
            - container is empty
    28:   Call IpduM_TriggerTransmit()
            - E_NOT_OK received, container empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_ConfirmMFTx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>801</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07071_SizeAnnounceOnlyOnce_LB_NoQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>5250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() when
    container PDU with IpduMContainerTxFirstContainedPduTrigger is set.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01: VP: Payload added to container
            - size is announced because IpduMContainerTxFirstContainedPduTrigger
    02:   Payload added to container
    03:   Call IpduM_TriggerTransmit()
            - correct data received
    04:   Payload added to container
    05:   Payload added to container
    06:   Payload added to container
    07:   Payload added to container
            - E_NOT_OK received because payload does not fit into container PDU
    08:   Call IpduM_TriggerTransmit()
            - correct data received
    09:   Call IpduM_TxConfirmation()
            - no size announcement, container PDU is empty
    10:   Call IpduM_TriggerTransmit()
            - E_NOT_OK received, current instance is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_SingleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>802</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07072_SizeAnnounceOnlyOnce_LB_NoQueuing2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>5503</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() when
    container PDU size is exceeded.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is not announced
    02:   Payload added to container
            - size is not announced
    03:   Payload added to container
            - size is announced, size exceeded
    04:   Payload added to container
            - E_NOT_OK received, one instance only
    05:   Call IpduM_TriggerTransmit()
            - correct data received
    06:   Payload added to container
            - size is not announced
    07:   Payload added to container
            - size is not announced
    08:   Payload added to container
            - Container is full, transmission
    09:   Payload added to container
            - size is not announced
            - E_NOT_OK received because payload does not fit into container PDU
    10:   Call IpduM_TriggerTransmit()
            - correct data received
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_SingleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>803</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07073_SizeAnnounceOnlyOnce_LB_NoQueuing3</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>5782</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() when
    contained PDU with IPDUM_TRIGGER_ALWAYS is added.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
    Test altered due to ASCIPDUM-1044.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is not announced
    02:   Payload added to container
            - size is announced because of IPDUM_TRIGGER_ALWAYS
    03:   Payload added to container
            - size is announced, size exceeded
    04:   Payload added to container
            - E_NOT_OK received, one instance only
    05:   Call IpduM_TriggerTransmit()
            - correct data received
    06:   Transmission request rejected
            - TxConf expected, ConfTimeout is 2
    07:   Call IpduM_TxConfirmation().
            - None configured, none forwarded.
    08:   Payload added to container
    09:   Payload added to container
    10:   Payload added to container
            - Container is full, transmission
    11:   Payload added to container
            - size is not announced
            - E_NOT_OK received because payload does not fit into container PDU
    12:   Container is already triggered
            - No transmission
            - TxConfTimeout reduced to 1
    13:   Call IpduM_TriggerTransmit()
            - correct data received
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_SingleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>804</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07076_SizeAnnounceRetry_E_NOT_OK_LB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>6080</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM shall retry calling PduR_IpduMTransmit() during
    next IpduM_MainFunctionTx() when E_NOT_OK is received either during
    IpduM_Transmit() or during IpduM_MainFunctionTx().

    Test demanded by ASCIPDUM-900.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is not announced
    02:   Payload added to container
            - size is not announced
    03:   Payload added to container
            - size is announced, size exceeded
            - E_NOT_OK received
    04:   Payload added to container
            - size is not announced
    05:   Payload added to container
            - size is not announced
    06:   Payload added to container
            - size is not announced, although size exceeded
            - container is queued
    07:   Call IpduM_MainFunctionTx()
            - repeat size announce from Transmit which received E_NOT_OK
            - E_NOT_OK received
    08:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    09:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_OK received
    10:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 2
    11:   Call IpduM_MainFunctionTx()
            - size is not announced, confirmation awaited
            - confirmation is 1
    12:   Call IpduM_MainFunctionTx()
            - size is announced, E_NOT_OK received
            - confirmation is 0
    13:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    14:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_OK received
    15:   Call IpduM_MainFunctionTx()
            - no transmission
    16:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 2
    17:   Call IpduM_MainFunctionTx()
            - no transmission
            - confirmation timeout is 1
    18:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    19:   Payload added to container
            - size is not announced
    20:   Payload added to container
            - size is not announced
            - send timeout is 3
    21:   Call IpduM_MainFunctionTx()
            - send timeout is 2
            - no transmission
    22:   Call IpduM_MainFunctionTx()
            - send timeout is 1
            - no transmission
    23:   Call IpduM_MainFunctionTx()
            - send timeout is 0
            - size is announced, E_NOT_OK received
    24:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    25:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_OK received
    26:   Call IpduM_MainFunctionTx()
            - no transmission
    27:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 2
    28:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    29:   Call IpduM_MainFunctionTx() for 3 times
            - no transmission
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstanceRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>805</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07078_SizeAnnounceRetry_E_NOT_OK_LB2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>6556</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM shall retry calling PduR_IpduMTransmit() during
    next IpduM_MainFunctionTx() when E_NOT_OK is received either during
    IpduM_Transmit() or during IpduM_MainFunctionTx().
    Test also verifies that when a contained PDU has already been added to a container instance it won't be added again nor trigger this container instance.
    Test demanded by ASCIPDUM-900.
    Test extended due to ASCIPDUM-1022.
      TxConfirmations are correctly forwarded after the queue is emptied.
    Test altered due to ASCIPDUM-1044.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is announced (IpduMContainerTxFirstContainedPduTrigger), E_NOT_OK received
    02:   Payload added to container
            - E_NOT_OK received
            - send timeout is 2
    03:   Call IpduM_MainFunctionTx()
            - transmission reattempted, container already triggered
            - E_NOT_OK received
    04:   Call IpduM_MainFunctionTx()
            - transmission reattempted
            - E_NOT_OK received
    05:   Call IpduM_MainFunctionTx()
            - repeat transmission from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    06:   Call IpduM_MainFunctionTx()
            - repeat transmission from last MFTx which received E_NOT_OK
            - E_OK received
    07:   Call IpduM_MainFunctionTx()
            - no transmission
    08:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 3
    09:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    10:   Payload added to container
            - size is announced, E_NOT_OK received
    11:   Payload added to container
            - already triggered
    12:   Payload added to container
            - already triggered
    13:   Call IpduM_MainFunctionTx()
            - repeat transmission from last Transmit which received E_NOT_OK
            - E_NOT_OK received
    14:   Call IpduM_MainFunctionTx()
            - repeat transmission from last MFTx which received E_NOT_OK
            - E_OK received
            - ConfTimeout set to 3
    15:   Call IpduM_MainFunctionTx()
            - ConfTimeout reduced to 2
    16:   Payload added to container
            - size is not announced
            - ConfTimeout is 2
    17:   Payload rejected since this message was added before to this container instance.
            - size is not announced
    18:    Call IpduM_MainFunctionTx()
            - ConfTimeout is (2 -&gt;) 1
    19:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 3
    20:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
            - Queue has 1 Container, it's announced, E_NOT_OK is received
    21:   Call IpduM_MainFunctionTx()
            - no transmission
    22:   Call IpduM_MainFunctionTx() for 2 times
            - no transmission
    23:   Payload added to container.
            - Container triggered.
    24:   Set PduR_IpduMTransmit_Stub.RetVal to E_OK
          Call IpduM_MainFunctionTx();
    25:   Confirmations forwarded for non-queued instance.
    26:   2 message added to container.
          - Container triggered by the first message (IPDUM_TRIGGER_ALWAYS).
    27:   Payload is queues since it outcomes the length of the container.
    30:   Confirmations forwarded for the first instance in the queue.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstanceRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>806</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07080_SizeAnnounceOnlyOnce_E_NOT_OK_LB_NoQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7198</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that a container remains triggered when PduR_IpduMTransmit returns E_NOT_OK.
    Test also verifies that when a contained PDU has already been added to a container it won't be added again nor trigger the container.
    Test demanded by ASCIPDUM-900.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is announced, E_NOT_OK received, id stored, E_OK returned
    02:   Payload added to container
            - already triggered, no attempt to transmit (only in MF), E_OK returned
    03:   Payload added to container
            - size is announced, E_NOT_OK received
            - container is full, size 36
    04:   Payload added to container
            - payload not added to container since it has been added before.
            - already triggered,  E_NOT_OK received
    05:   Payload added to container
            - payload not added to container since it has been added before.
            - already triggered, E_OK received
    06:   Call IpduM_MainFunctionTx()
            - triggered container is transmitted
            - TxConf timeout set to 3
    07:   Payload added to container
            - payload added to container
    08:   Payload added to container
            - E_NOT_OK received, container is awaiting TriggerTransmit
    09:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 3
    10:   Call IpduM_MainFunctionTx()
            - confirmation timeout is 2
    11:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    12:   Call IpduM_MainFunctionTx() for 3 times
            - no transmission
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_SingleInstanceRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>807</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07029_ContainedQueue_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7475</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when a contained I-PDU with
    IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED
    is passed to IpduM via IpduM_Transmit, IpduM shall identify the associated
    Container PDU and append the contained I-PDU to its payload even if a previous
    instance of the contained I-PDU is already present in that Container PDU.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU with IpduMContainerTxSizeThreshold set to 15.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with the same PDU having
         IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED,
         same length, but different data, for three(3) times.
         IpduMContainerTxSizeThreshold for Container PDU is set to 15.
    02:  VP(IpduM.SWS_IpduM_00179): Transmission is triggered and data from
         different instances of the same PDU is visible.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>808</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07058_ContainedQueue_1_SendAwait</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7571</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when a contained I-PDU with
    IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED
    is passed to IpduM via IpduM_Transmit, IpduM shall identify the associated
    Container PDU and append the contained I-PDU to its payload even if a previous
    instance of the contained I-PDU is already present in that Container PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU with IpduMContainerTxSizeThreshold set to 15.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with the same PDU having
         IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED,
         same length, but different data, for three(3) times.
         IpduMContainerTxSizeThreshold for Container PDU is set to 15.
    02:  VP(IpduM.SWS_IpduM_00179): Transmission is triggered and data from
         different instances of the same PDU is visible.
          - confirmation timeout is 2
    03:  Call IpduM_Transmit() function with the same PDU having
         IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED,
         same length, but different data, for three(3) times.
          - E_NOT_OK received because SendAwait is set,
           confirmation timeout has not elapsed
    04:  VP: Call Main Function Tx for 2 times
          - confirmation timeout decreased to 0
          - nothing is called
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>809</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07059_ContainedQueue_1_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7692</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when a contained I-PDU with
    IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED
    is passed to IpduM via IpduM_Transmit, IpduM shall identify the associated
    Container PDU and append the contained I-PDU to its payload even if a previous
    instance of the contained I-PDU is already present in that Container PDU.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU with IpduMContainerTxSizeThreshold set to 15.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with the same PDU having
         IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED,
         same length, but different data, for three(5) times.
         IpduMContainerTxSizeThreshold for Container PDU is set to 15.
    02:  VP(IpduM.SWS_IpduM_00179): Transmission is triggered and data from
         different instances of the same PDU is visible.
          - PduR_IpduMTransmit returns E_NOT_OK
    03:  Instance is dropped
    04:  VP: Call IpduM_Transmit() function with the same PDU having
         IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED,
         same length, but different data, for three(3) times.
           - current instance successfully sent since PduR_IpduMTransmit returns E_OK
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>810</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07030_ContainedQueue_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7832</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that when a contained I-PDU with
    IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED
    is passed to IpduM via IpduM_Transmit, IpduM shall identify the associated
    Container PDU and append the contained I-PDU to its payload even if a previous
    instance of the contained I-PDU is already present in that Container PDU.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU with IpduMContainerTxSizeThreshold set to 15.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with a PDU having
         IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED.
    02:  Call IpduM_Transmit() function with the another PDU having
         IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED.
    03:  Call IpduM_Transmit() function with the same PDU from first call (01:),
         having IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED,
         but different data.
    04:  VP(IpduM.SWS_IpduM_00179): Transmission is triggered.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>277</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>811</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07090_NoErroneousDoubleTx</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>7940</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    The test verifies that when the last instance of the Container PDU is dequeued
    in IpduM_TriggerTransmit() while the current instance being empty and no transmission
    (call to IpduM_Transmit()) takes place until IpduM_TxConfirmation(), no call to
    PduR_IpduMTransmit() is made from within IpduM_TxConfirmation().

    Test mandated by ASCIPDUM-1044.
    Test altered due to ASCIPDUM-1052.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT.
    IpduMContainerTxFirstContainedPduTrigger set to TRUE.
    IpduMContainerQueueSize set to 2, number of instances: 3.
    IpduMContainerTxConfirmationTimeout set to 2.
    IpduMContainerTxSendTimeout set to 3.

    For IpduMCntrTxTT_Queue10:
    IpduMContainerTxConfirmationTimeout set to 1.
    IpduMContainerTxSendTimeout set to 1.
  
Test Execution: 
    01: 3 Contained PDUs transmitted, the container gets full,
        E_NOT_OK is returned by PduR_IpduMTransmit(), it's pushed to the queue
    02: The same Contained PDUs are transmitted again, Container gets full,
        gets pushed to the queue.
        TxConfTimeout is not set due to unsuccesful transmission, instance is queued,
        SendTimeout is set to 0.
    03: VP(IPDUM.EB.IpduMContainerTT_MultipleInstanceRetry):
        Size is announced from the MainFunction, PduR_IpduMTransmit() returns E_OK.
    04: TriggerTransmit dequeues the last instance
    05: No erroneous transmission of empty containers
    06: Nothing after a while
    07: Trigger First Container, Contained PDU added, Transmission
    08: Further Contained PDUs added
    09: ConfTimeout of 1 expires
    10: No empty confirmation from TxConfirmation
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstanceRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>812</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07091_NoErroneousDoubleTx2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8253</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    The test is similar to TS_IPDUM_CON_07090_NoErroneousDoubleTx, except
    the transmission initiated from IpduM_MainFunctionTx() is interrupted by
    IpduM_TriggerTransmit() at step 3.

    The transmission initiated from IpduM_TxConfirmation() is interrupted by
    IpduM_TriggerTransmit() at step 5.

    Test mandated by ASCIPDUM-1044.
    Test mandated by ASCIPDUM-1049.
  &lt;/para&gt;
  
Test Object: IpduM_MainFunctionTx
Test Precondition: 
    IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT.
    IpduMContainerTxFirstContainedPduTrigger set to TRUE.
    IpduMContainerQueueSize set to 2.
    IpduMContainerTxConfirmationTimeout set to 2.
    IpduMContainerTxSendTimeout set to 3.
  
Test Execution: 
    01: 3 Contained PDUs transmitted, the container gets full,
        E_NOT_OK is returned by PduR_IpduMTransmit(), it's pushed to the queue
    02: The same Contained PDUs are transmitted again, Container gets full, E_NOT_OK
        is returned by PduR_IpduMTransmit(), gets pushed to the queue, queue is full
    03: The timers have expired, size is announced from the MainFunction
    04: TriggerTransmit interrupts the transmission, data is correctly retrieved
    05: The transmission initiated from the TxConfirmation is interrupted by
        TriggerTransmit.
    06: Data is correctly retrieved
    07: No erroneous transmission of empty containers
    08: Nothing after a while
    09: Trigger First Contained PDU added, Transmission
    10: Further Contained PDUs added
    11: ConfTimeout of 1 expires
    12: No empty confirmation from TxConfirmation
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>813</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07031_TriggerTransmit_Queue_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8584</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that if IpduMContainerTxTriggerMode is set to
    IPDUM_TRIGGERTRANSMIT and adding a contained I-PDU would exceed maximum size
    of the Container PDU, first the Container PDU shall be queued and then the
    contained I-PDU shall be added to a new instance of the Container PDU.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT.
    Container PDU has IpduMContainerQueueSize set to 2.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with a first PDU
    02:  Call IpduM_Transmit() function with a second PDU
    03:  Call IpduM_Transmit() function with a third PDU
    04:  Call IpduM_Transmit() function with the third PDU again
    05:  Call IpduM_Transmit() function with the second PDU again
    06:  Call IpduM_Transmit() function with the first PDU again
    07:  Call IpduM_Transmit() function with the first PDU again
    08:  VP(IpduM.SWS_IpduM_00183): Call IpduM_TriggerTransmit() for the
              Container PDU
              - check if oldest instance is received.
    09:  Transmission confirmed for previous instance
              - size is announced
    10:  Queue is not empty, size already announced
    11:  VP(IpduM.SWS_IpduM_00183): Call IpduM_TriggerTransmit() for the
              Container PDU
              - check if next oldest instance is received (queued instance)
    12:  Receive TxConfirmation and let the SendTx Timer pass so that
         PduR_IpduMTransmit is called
    13:  VP(IpduM.SWS_IpduM_00183, IpduM.SWS_IpduM_00193.CQ):
          Call IpduM_TriggerTransmit() for the
              Container PDU
              - check if next oldest instance is received (current instance).
    14:  TxConfirmation received
    15:  VP(IpduM.SWS_IpduM_00194): Call IpduM_TriggerTransmit() for the
              Container PDU
              - check if E_NOT_OK is received and data is not updated.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193.CQ</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>814</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07061_TriggerTransmit_Queue_1_TxConf</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>8912</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that if IpduMContainerTxTriggerMode is set to
    IPDUM_TRIGGERTRANSMIT and adding a contained I-PDU would exceed maximum size
    of the Container PDU, first the Container PDU shall be queued and then the
    contained I-PDU shall be added to a new instance of the Container PDU.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT.
    Container PDU has IpduMContainerQueueSize set to 2.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with a first PDU
    02:  Call IpduM_Transmit() function with a second PDU
    03:  Call IpduM_Transmit() function with a third PDU
    04:  VP(IpduM.SWS_IpduM_00183): Call IpduM_TriggerTransmit() for the
          Container PDU
          - check if next oldest instance is received (queued instance)
          - confirmation timeout is 2
    05:  Call IpduM_Transmit() function with the third PDU again
    06:  Call IpduM_Transmit() function with the second PDU again
    07:  Call IpduM_Transmit() function with the first PDU again
    08:  Call IpduM_Transmit() function with the first PDU again
          - container PDU is not announced, confirmation not received yet
    09:  Call Tx Confirmation
          - no contained PDU is confirmed since none is configured as such
          - call PduR_IpduMTransmit for the next instance
    10:  VP(IpduM.SWS_IpduM_00183): Call IpduM_TriggerTransmit() for the
          Container PDU
          - check if next oldest instance is received (queued instance)
          - confirmation timeout is 2
    11:  Call Main Function for 2 times
          - no announcement, container PDU is not sealed.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>815</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07032_TriggerTransmit_Queue_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>9179</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that if creating a new instance of a Container PDU would exceed
    IpduMContainerQueueSize the oldest instance shall be discarded and if
    IpduMContainerQueueSize is set to 0 the local instance shall be discarded.
    If Development Error Detection is configured IPDUM_E_QUEUEOVFL
    shall be reported to DET.

    Test altered due to ASCIPDUM-1240
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT.
    Container PDU has IpduMContainerQueueSize set to 2.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with a third PDU
    02:  Call IpduM_Transmit() function with a second PDU
    03:  Call IpduM_Transmit() function with a first PDU
    04:  Call IpduM_Transmit() function with the first PDU again
    05:  Call IpduM_Transmit() function with the first PDU again
    06:  Call IpduM_Transmit() function with the third PDU again
    07:  Call IpduM_Transmit() function with the first PDU again
    08:  Call IpduM_Transmit() function with the second PDU again
    09:  Call IpduM_Transmit() function with the third PDU again
    10:  Call IpduM_Transmit() function with the third PDU again
            - if IPDUM_DEV_ERROR_DETECT is STD_ON then check if
              IPDUM_E_QUEUEOVFL error has been reported.
    11:  VP(IpduM.SWS_IpduM_00183, IpduM.SWS_IpduM_00199):
              Call IpduM_TriggerTransmit() for the Container PDU
              - check if oldest instance is received.
    12:  IpduM_TxConfirmation() confirms the transmission.
         The oldest instance is in the state WAIT_CONF, due to
         IPDUM_TRIGGERTRANSMIT TxTriggerMode it's transmitted in the
         context of TxConfirmation
    13:  VP(IpduM.SWS_IpduM_00183, IpduM.EB.CntrTx.DequeueOrder.OverFlow):
              Call IpduM_TriggerTransmit() for the Container PDU
              - check if the oldest instance is received.
    14:  IpduM_TxConfirmation() confirms the transmission
         The oldest instance is in the state TRIGGERED,
           no PduR_IpduMTransmit() is called
    15:  Call the TX MainFunction 3 times
         Let the SendTx Timer pass so that PduR_IpduMTransmit is called
              - size is announced.
    16:  VP(IpduM.SWS_IpduM_00183, IpduM.EB.CntrTx.DequeueOrder.OverFlow):
              Call IpduM_TriggerTransmit() for the Container PDU
              - check if the oldest/last instance is received.
    17:  IpduM_TxConfirmation() confirms the transmission.
    18:  VP(IpduM.SWS_IpduM_00194): Call IpduM_TriggerTransmit() for the
              Container PDU
              - check if E_NOT_OK is received and data is not updated.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>816</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07039_TriggerTransmit_Queue_3_LB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>9587</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that Container PDUs having
      * IpduMContainerTxTriggerMode: IPDUM_TRIGGERTRANSMIT,
      * IpduMContainerQueueSize: &gt;0
     are queued properly by having the cumulative size
     of the Contained PDUs exceed the size of the Container.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerQueueSize set to 2.
    IpduMDequeueInTxConf is DISABLED.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with 1st Contained PDU
    02:  Call IpduM_Transmit() function with 2nd Contained PDU
    03:  Call IpduM_Transmit() function with 3rd Contained PDU,
         instance exceeds size, it's queued
    04:  IpduM_Transmit() is called, size transmitted
    05:  Call IpduM_Transmit(), 2nd Contained
    06:  Call IpduM_Transmit(), 1st Contained
    07:  Instance popped from queue by IpduM_TriggerTransmit()
    08:  Data is updated via PduR_IpduMTriggerTransmit() calls
    09:  TxConfirmations are translated and order is preserved
          - size is announced
    10:  Last queued instance is popped
    11:  Queue is empty
    12:  The same scenario is repeated, with the exception that the queue overflows
    13:  Queue overflows, the old instance composed of IpduMCntr7CntdTxQueue1
         and IpduMCntr7CntdTxQueue2 is overwritten
    14:  VP(IpduM.SWS_IpduM_00199):
         The
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>817</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07040_Queue_4_LastIsBest</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>10062</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that Container PDUs having
      * IpduMContainerTxTriggerMode: IPDUM_DIRECT,
      * IpduMContainerQueueSize: &gt;0 (2)
     are queued properly by having the cumulative size
     of the Contained PDUs exceed the size of the Container.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerQueueSize set to 2.
    IpduMDequeueInTxConf is DISABLED.
    TxSendTimeout occurs in 4 MF cycles.
    TxConfirmationTimeout occurs in 2 MF cycles.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with 1st Contained PDU
    02:  TxSendTimeout reduced to 1
    03:  Call IpduM_Transmit() function with 3rd Contained PDU,
    04:  TxSendTimeout expires, IpduM_Transmit() is called,
         E_NOT_OK, instance is queued
    05:  Data is updated via PduR_IpduMTriggerTransmit() calls
         before getting queued
    06:  Call IpduM_Transmit(), 2nd Contained
    07:  Call IpduM_Transmit(), 1st Contained
    08:  Call IpduM_Transmit(), 2nd Contained
    09:  Call IpduM_Transmit(), 3rd Contained
    10:  Instance with expired TxSendTimeout is dequeued
    11:  Instance with expired TxSendTimeout is dequeued (2nd)
    12:  TxSendTimeout expired for the Current Instance, it's sent
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>818</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07057_Queue_4_LastIsBest_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>10384</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that Container PDUs having
      * IpduMContainerTxTriggerMode: IPDUM_DIRECT,
      * IpduMContainerQueueSize: &gt;0
     are queued properly by having the cumulative size
     of the Contained PDUs exceed the size of the Container.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerQueueSize set to 2.
    IpduMDequeueInTxConf is DISABLED.
    TxSendTimeout occurs in 4 MF cycles.
    TxConfirmationTimeout occurs in 2 MF cycles.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with 1st Contained PDU
    02:  TxSendTimeout reduced to 1
    03:  Call IpduM_Transmit() function with 2nd Contained PDU,
    04:  TxSendTimeout expires, PduR_IpduMTransmit() is called,
         E_NOT_OK, instance is queued
    05:  Data is updated via PduR_IpduMTriggerTransmit() calls
         before getting queued
    06:  Call IpduM_Transmit(), 2nd Contained
    07:  Call IpduM_Transmit(), 2nd Contained updated
    08:  Call IpduM_Transmit(), 1st Contained
    09:  Call IpduM_Transmit(), 3rd Contained, doesn't fit
          - 3rd Contained added to a new instance
    10:  Call IpduM_Transmit(), 1st Contained added
          - Contained PDU will be dropped, PduR_IpduMTransmit() returns E_NOT_OK
    11:  Oldest instance is transmited
         - send timeout decreased to 3
    12:  Call Main Function Tx
          - confirmation timeout expired
          - send timeout decreased to 1
          - one container instance is dropped because confirmation timeout expired
          - another instance is dropped since all contained PDUs received
            E_NOT_OK when calling PduR_IpduMTriggerTransmit
    13:  Call Tx Confirmation
          - nothing is confirmed because confirmation timeout is expired
    14:  Call Main Function Tx
           - current instance is sent due to send timeout
    15:  Call Tx Confirmation
          - 3rd contained PDU is confirmed
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>819</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07044_TriggerTransmit_Queue_5_LB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>10708</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that data retrieval and confirmation
    is working as expected.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerQueueSize set to 2.
    IpduMDequeueInTxConf is DISABLED.
    TxSendTimeout occurs in 5 MF cycles.
    TxConfirmationTimeout occurs in 3 MF cycles.
  
Test Execution: 
    00:  Initialize IpduM
    01:  VP(SWS_IpduM_00183): Size exceeded, instance is queued
    02:  VP(SWS_IpduM_00192): PduInfoPtr correctly assembled
    03:  VP(SWS_IpduM_00194): Fill in the queue. Decrease TxConfTimeout.
    04:  VP(SWS_IpduM_00189): TxConfTimeout elapsed. Transmit next instance in queue.
    05:  VP(IPDUM.EB.IpduMSendAfterDequeue): All previous instances have been dequeued,
         extended TxSendTimeout expires.
    06:  VP(SWS_IpduM_00188): When the container is triggered, PduR_IpduMTransmit() is
          invoked. In this case it's triggered because it's already queued.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00192</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMSendAfterDequeue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>820</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07053_TriggerTransmit_Queue_5_LB_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>10931</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that data retrieval and confirmation
    is working as expected.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerQueueSize set to 2.
    IpduMDequeueInTxConf is DISABLED.
    TxSendTimeout occurs in 5 MF cycles.
    TxConfirmationTimeout occurs in 3 MF cycles.
  
Test Execution: 
    00:  Initialize IpduM
    01:  VP(SWS_IpduM_00183): Size exceeded, instance is queued
    02:  VP(SWS_IpduM_00194): Oldest instance is dequeued
    03:  VP(SWS_IpduM_00192): PduInfoPtr correctly assembled
    04:  VP(SWS_IpduM_00189): TxConfTimeout elapsed, size is
         announced for the next instance.
    05:  VP(IPDUM.EB.IpduMSendAfterDequeue): All previous instances have been dequeued,
         extended TxSendTimeout expires
    06:  VP(SWS_IpduM_00188): When the container is triggered, PduR_IpduMTransmit() is
          invoked. E_NOT_OK is received for contained PDU so in this case the container
          PDU is not queued.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>281</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00192</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>290</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMSendAfterDequeue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>821</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07046_TriggerTransmit_Queue_6_LB_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>11161</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if no data is obtained for any of the
    Contained PDUs, the Container is dropped.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerQueueSize set to 2.
    IpduMDequeueInTxConf is DISABLED.
    TxSendTimeout occurs in 5 MF cycles.
    TxConfirmationTimeout occurs in 3 MF cycles.
  
Test Execution: 
    00:  Initialize IpduM
    01:  Contained PDUs added to the Container
    02:  Container is announced (nothing obtained)
    03:  Data is retrieved, it fails
    04:  VP(SWS_IpduM_00222): Nothing is copied in IpduM_TriggerTransmit()
    05:  Waiting a considerably long time, nothing has been queued (test shows
         that nothing is dequeued, as it would happen in IpduM_MainFunctionTx())
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>317</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>822</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07041_ContainerSeparation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>11268</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that the queuing behavior is as expected.
    Test also verifies that when a contained PDU has already been added to a container instance it won't be added again nor trigger this container instance.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMCntrTxQueue6_LB  : IpduMContainedTxPduCollectionSemantics : IPDUM_COLLECT_LAST_IS_BEST
                          : IpduMContainerQueueSize                : 2
                          : Max length                             : 32
    IpduMCntrTxQueue7_LB  : IpduMContainedTxPduCollectionSemantics : IPDUM_COLLECT_LAST_IS_BEST
                          : IpduMContainerQueueSize                : 2
                          : Max length                             : 36
  
Test Execution: 
    00:  Initialize IpduM.
    01:  IpduMCntrTxQueue6_LB, 1st Contained PDU
    02:  IpduMCntrTxQueue6_LB, 2nd Contained PDU
    03:  (VP: SWS_IpduM_00198): Unexpected TxConfirmation() ignored
    04:  IpduMCntrTxQueue6_LB, 3rd Contained PDU
    05:  (VP: SWS_IpduM_00195): IpduMCntrTxQueue6_LB, 3rd Contained PDU
           Payload queued, will be dequed in next MF()
    06:  IpduMCntrTxQueue7_LB, 1st Contained PDU
    07:  IpduMCntrTxQueue7_LB, 2nd Contained PDU (previous instance is queued)
    08:  IpduMCntrTxQueue7_LB, 3rd Contained PDU
    09:  IpduMCntrTxQueue7_LB, 3rd Contained PDU which already exists in this instance.
    10:  IpduMCntrTxQueue7_LB, 1st Contained PDU
    11:  IpduMCntrTxQueue7_LB, 3rd Contained PDU
    12:  Trigger Transmit on IpduMCntrTxQueue7_LB
    13:  Tx Confirmation on IpduMCntrTxQueue7_LB, trigger next Transmit
    14:  Fill all instances for IpduMCntrTxQueue6_LB
    15:  Call Mainfunction, Transmit is triggered for next instance of IpduMCntrTxQueue6_LB
    16:  Call Mainfunction again, Transmit is triggered for next instance of IpduMCntrTxQueue6_LB
    17:  (VP: SWS_IpduM_00200),
         (VP: SWS_IpduM_00194): Oldest instance removed from queue due to TriggerTransmit()
                                from IpduMCntrTxQueue7_LB
    18:  (VP: SWS_IpduM_00196): TxConfirmation() forwarded to configured Contained PDUs
    19:  Clear the queue for IpduMCntrTxQueue7_LB
    20:  IpduMCntrTxQueue6_LB, 2nd contained PDU to trigger the container instance.
    21:  TxConfirmation() forwarded to configured Contained PDUs
    22:  Call Mainfunction to verify no further contained PDUs are sent.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00195</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>292</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>823</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07033_Transmit_Queue_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>11937</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that if PduR_Transmit has returned E_NOT_OK, the same
    Transmit request shall be repeated in the next main function cycle and
    the instance of that Container PDU is queued in the meantime.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerTxTriggerMode set to IPDUM_DIRECT.
    Container PDU has IpduMContainerQueueSize set to 2.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with a first PDU
    02:  Call IpduM_Transmit() function with a second PDU
    03:  Call IpduM_Transmit() function with a third PDU
          - transmission is triggered, but this instance of
            Container is queued, because of PduR_IpduMTransmit
            which returns E_NOT_OK.
    04:  Call IpduM_Transmit() function with the third PDU
          - this PDU is added to a new instance of Container.
    05:  VP(IpduM.SWS_IpduM_00195): Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit is called, but the oldest Container
            instance remains in queue, because E_NOT_OK is received.
    06:  VP(IpduM.SWS_IpduM_00191): Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit is called, and the oldest Container
            instance is removed from queue, because E_OK is received.
          - check if PduR has received the oldest instance of
            Container from IpduM queue.
    07:  Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit is not called
    08:  Call IpduM_Transmit() function with the third PDU
    09:  Call IpduM_Transmit() function with the second PDU
    10:  Call IpduM_Transmit() function with the first PDU
          - transmission is triggered, but this instance of
            Container is queued, because of PduR_IpduMTransmit
            which returns E_NOT_OK.
          - this PDU is added to a new instance of Container.
    11:  Call IpduM_Transmit() function with the first PDU
    12:  Call IpduM_Transmit() function with the second PDU
    13:  Call IpduM_Transmit() function with the second PDU
          - transmission should be triggered, but this instance of
            Container is queued, because of previous PduR_IpduMTransmit
            which returned E_NOT_OK.
          - this PDU is added to a new instance of Container.
    14:  Call IpduM_Transmit() function with the second PDU
    15:  Call IpduM_Transmit() function with the third PDU
    16:  VP(IpduM.SWS_IpduM_00199): Call IpduM_Transmit()
            function with the third PDU
          - transmission should be triggered, but this instance of
            Container is queued, because of previous PduR_IpduMTransmit
            which returned E_NOT_OK.
          - if IPDUM_DEV_ERROR_DETECT is STD_ON then check if
            IPDUM_E_QUEUEOVFL error has been reported.
          - this PDU is added to a new instance of Container.
    17:  Call IpduM_Transmit() function with the second PDU
    18:  Call IpduM_Transmit() function with the first PDU
    19:  VP(IpduM.SWS_IpduM_00199): Call IpduM_Transmit()
            function with the first PDU
          - transmission should be triggered, but this instance of
            Container is queued, because of previous PduR_IpduMTransmit
            which returned E_NOT_OK.
          - if IPDUM_DEV_ERROR_DETECT is STD_ON then check if
            IPDUM_E_QUEUEOVFL error has been reported.
          - this PDU is added to a new instance of Container.
    20:  Call IpduM_Transmit() function with the second PDU
    21:  Call IpduM_Transmit() function with the third PDU
    22:  Call IpduM_Transmit() function with the third PDU
          - transmission should be triggered, but this instance of
            Container is queued, because of previous PduR_IpduMTransmit
            which returned E_NOT_OK.
          - if IPDUM_DEV_ERROR_DETECT is STD_ON then check if
            IPDUM_E_QUEUEOVFL error has been reported.
          - this PDU is added to a new instance of Container.
    23:  VP(IpduM.SWS_IpduM_00195): Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit is called, but the oldest Container
            instance remains in queue, because E_NOT_OK is received.
    24:  VP(IpduM.SWS_IpduM_00191): Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit is called, and the oldest Container
            instance is removed from queue, because E_OK is received.
          - check if PduR has received the oldest instance of
            Container from IpduM queue.
    25:  VP(IpduM.SWS_IpduM_00195): Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit is called, but the oldest Container
            instance remains in queue, because E_NOT_OK is received.
    26:  VP(IpduM.SWS_IpduM_00191): Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit is called, and the oldest Container
            instance is removed from queue, because E_OK is received.
          - check if PduR has received the oldest instance of
            Container from IpduM queue.
    27:  Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit is not called because queue is empty and
            current instance is not triggered (SendTimeout: 2 -&gt; 1)
    28:  Call IpduM_MainFunctionTx() function, SendTimeout expires,
            last instance is transmitted
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00195</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>293</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>295</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00191</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>289</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>312</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00185.TX.QueueSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>824</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07034_TxConfirm_Queue_SameContainedPdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>12556</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that if the IpduM receives a TxConfirmation for a specific
    Container PDU, it shall translate this confirmation into the corresponding
    confirmations for those contained I-PDUs having IpduMContainedTxPduConfirmation
    set to TRUE and were contained in the last sent out instance of the Container I-PDU.
    If the same contained I-PDU is present more than once, this results in multiple
    TxConfirmations.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerTxTriggerMode set to IPDUM_DIRECT.
    Container PDU has IpduMContainerTxSendTimeout set to 0.001
    (1 IpduM_MainFunctionTx cycle).
    Container PDU has IpduMContainerTxConfirmationTimeout set to 0.002
    (2 IpduM_MainFunctionTx cycle).
    Container PDU has IpduMContainerQueueSize set to 1.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with a first PDU
    02:  Call IpduM_Transmit() function with the first PDU
           - check that PduR_IpduMTransmit() is not called.
    03:  Call IpduM_MainFunctionTx() function
           - check that PduR receives the data:
             - check that PduR_IpduMTransmit() is called
             - check that data and its length matches the
               expected one.
    04:  Call IpduM_MainFunctionTx() function
    05:  Call IpduM_MainFunctionTx() function
    06:  VP(IpduM.ASR42.SWS_IpduM_00198): Call IpduM_TxConfirmation() function
          - check that PduR_IpduMTxConfirmation() is not called
    07:  Call IpduM_Transmit() function with the first PDU
    08:  Call IpduM_Transmit() function with the first PDU
    09:  Call IpduM_Transmit() function with a second PDU
          - check that PduR receives the data:
             - check that PduR_IpduMTransmit() is called
             - check that data and its length matches the
               expected one.
    10:  Call IpduM_MainFunctionTx() function
    11:  VP(IpduM.SWS_IpduM_00196): Call IpduM_TxConfirmation() function
          - check that PduR_IpduMTxConfirmation() is called with correct handle ID
            - for the first PDU is called 2 times consequently.
            - for the second PDU is called 1 time.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>294</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>825</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07035_TxConfirm_Queue_NextInstance</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>12779</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that in case the IpduMContainerTxConfirmationTimeout
    is configured to a value greater than 0, and the corresponding transmission
    confirmation timeout timer has elapsed, or the transmission confirmation
    for that Container PDU was received, the IpduM shall invoke PduR_IpduMTransmit
    for the next oldest instance of that Container PDU in the next main function
    cycle at the latest.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container PDU has IpduMContainerTxTriggerMode set to IPDUM_DIRECT.
    Container PDU has IpduMContainerTxSendTimeout set to 0.002
    (2 IpduM_MainFunctionTx cycle).
    Container PDU has IpduMContainerTxConfirmationTimeout set to 0.003
    (3 IpduM_MainFunctionTx cycle).
    Container PDU has IpduMContainerQueueSize set to 2.
    Container PDU has IpduMContainerTxFirstContainedPduTrigger set to TRUE.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() function with a first PDU
          - check that PduR_IpduMTransmit() is called.
          - transmission triggered
          - no data is sent, because of PduR_IpduMTransmit() returning E_NOT_OK
          - container PDU is queued
    02:  Call IpduM_Transmit() function with the first PDU
          - check that PduR_IpduMTransmit() is called.
          - transmission triggered
          - no data is sent, because of PduR_IpduMTransmit() returning E_NOT_OK
          - container is queued
    03:  Call IpduM_Transmit() function with the first PDU
          - check that PduR_IpduMTransmit() is called.
          - transmission triggered
          - no data is sent, because of PduR_IpduMTransmit() returning E_NOT_OK
          - container is queued
    04:  Call IpduM_MainFunctionTx() function
          - PduR_IpduMTransmit() returns E_OK =&gt; transmission triggered.
          - TxConfirmationTimeout is 3
          - check that PduR receives the PDU:
            - check PduR_IpduMTransmit() is called with the correct handle ID
            - check that the data and its length matches the expected one.
    05:  Call IpduM_MainFunctionTx() function
          - TxConfirmationTimeout is 2
          - although transmission is triggered, no data is sent, because of no confirmation
            received and confirmation timeout not being 0
    06:  VP(IpduM.ASR42.SWS_IpduM_00189): Call IpduM_MainFunctionTx() function
          - TxConfirmationTimeout is 1
          - check that PduR_IpduMTransmit() is not called.
          - although transmission is triggered, no data is sent, because of no confirmation
            received and confirmation timeout not being 0
    07:  VP(IPDUM.EB.IpduMDequeueInTxConf)Call IpduM_MainFunctionTx() function
          - TxConfirmationTimeout is 0 =&gt; transmission triggered
          - check that PduR receives the PDU:
            - check PduR_IpduMTransmit() is called with the correct handle ID
            - check that the data and its length matches the expected one.
          - TxConfirmationTimeout (for current instance of container PDU) is 3
    08:  Call IpduM_MainFunctionTx() function
          - TxConfirmationTimeout is 2
          - although transmission is triggered, no data is sent, because of no confirmation
            received and confirmation timeout not being 0
    09:  VP(IpduM.ASR42.SWS_IpduM_00189): Call IpduM_MainFunctionTx() function
          - TxConfirmationTimeout is 1
          - check that PduR_IpduMTransmit() is not called.
          - although transmission is triggered, no data is sent, because of no confirmation
            received and confirmation timeout not being 0
    10:  VP(IPDUM.EB.IpduMDequeueInTxConf): Call IpduM_TxConfirmation() function
           - TxConfirmationTimeout is 1
           - confirmation received =&gt; transmission triggered
           - check that PduR receives the PDU:
             - check PduR_IpduMTransmit() is called with the correct handle ID
             - check that the data and its length matches the expected one.
m4_ifelse(PM_Permutation,p3,\-:
    11:  VP(IpduM.SWS_IpduM_00188): Call IpduM_Transmit() function for a TRIGGER_ALWAYS PDU
          - check that PduR_IpduMTransmit() is called
         Call IpduM_TxConfirmation() function for the transmitted PDU
          - check that PduR_IpduMTxConfirmation() is called
    12:  VP(IpduM.SWS_IpduM_00188): Call IpduM_Transmit() function with the same PDU as the previous transmission
          - check that PduR_IpduMTransmit() is called for the second instance of the same container
         Call IpduM_TxConfirmation() function for the transmitted PDU
:-/m4_ifelse( :endif: ))
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>286</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>826</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07036_TxSendTimeout_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>13059</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when the TxSendTimeout of a Container has elapsed,
    transmission will be triggered.

    TxSendTimeout is 6 for IpduMConf_IpduMContainerTxPdu_IpduMCntrTxQueue3.

    This behavior is the same regardless of the used
    IpduMContainedTxPduCollectionSemantics;
    in this case IPDUM_COLLECT_QUEUED is configured.

    Observe that the timer does not get increased.

    Test mandated by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-771
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, TxSendTimeout set to 6, size is 12
    02:  Payload added to container, TxSendTimeout still at 6, size is 24
    03:  As time elapses, TxSendTimeout is decreased to 3, no outgoing transmission
    04:  Payload added to container, PduR_IpduMTransmit() returns E_NOT_OK,
         container is queued. Size is 36 (reason for being triggered)
    05:  Payload added to container, TxSendTimeout set to 6, size 12
    06:  Transmission of queued container occurs, TxSendTimeout decreased to 4
         for the current instance
    07:  TxSendTimeout for for the current instance decreased to 1
    08:  TxSendTimeout expires, transmission occurs
    09:  VP(IpduM.SWS_IpduM_00185)
         VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT): Transmission triggered
    10:  Payload added to container, TxSendTimeout set to 6, size is 12
    11:  TxSendTimeOut is 5
    12:  Contained PDU with TxSendTimeout of 4 added to the container, size is 24
    13:  TxSendTimeout decreased to 2
    14:  VP(SWS_IpduM_00184): Container would overflow, queuing occurs,
           payload added to new instance.
           TxSendTimeout is set 4 (that of the Contained is less than that of
           the Container)
    15:  Normal dequeuing in MF. TxSendTimeout decreased to 3
    16:  TxSendTimeout expires, current instance is transmitted
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>827</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07047_TxSendTimeout_SizeTrigger</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>13267</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that when a Contained PDU is pushed to a
    new instance due to the previous exceeding the size limitation,
    TxSendTimeout is set correctly.

    6 MainFunction cycles ensure that the timer reaches 0 for
    IpduMConf_IpduMContainerTxPdu_IpduMCntrTxQueue3.

    4 MainFunction cycles ensure that the timer reaches 0 for
    IpduMConf_IpduMContainedTxPdu_IpduMCntr3CntdTxQueue2.

    Observe that the timer is set once the new container is
    populated.

    Test mandated by
    https://issue.ebgroup.elektrobit.com/projects/ASCIPDUM/issues/ASCIPDUM-831 .
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, size is 12
    02:  TxSendTimeout reduced to 3
    03:  Payload added to container, size is 24
    04:  Payload added to container, triggered due to size (would be 40),
         added to new instance.
    05:  TxSendTimeout reduced to 1 (it's set to 6 at step 04)
    06:  No transmission is triggered
    07:  TxSendTimeout expires, transmission is triggered
    08:  Payload added to container, size is 16, TxSendTimeout set to 6.
    09:  Payload added to container, size is 28
    10:  Payload aded to container, triggered due to size (would be 40).
         Previous instance awaiting TxConfirmation, no transmission.
    11:  VP(IpduM.EB.CntrTx.DequeueOrder.NoOverFlow):
         TxSendTimeout reduced to 3, triggered instance is transmitted.
    12:  TxSendTimeout reduced to 1 (it's set to 4 at step 10)
    13:  No transmission is triggered
    14:  TxSendTimeout expires, transmission is triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.NoOverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>828</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07049_TxSendTimeoutDelayedByDequeue</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>13410</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test checks that when the TxSendTimeout of a container
    expires in the same MainFunction cycle as an instance of
    it would be dequeued, transmission is delayed but the
    trigger is not lost.

    With the exception of the TxSendTimeout, no other
    triggering mechanism is used.

    1 MainFunction cycles ensure that the timer reaches 0 for
    IpduMConf_IpduMContainedTxPdu_IpduMCntrTxQueue8_LB.

    Collection semantics is LAST_IS_BEST.

    Number of MF cycles for timers to expire:
      TxSendTimeout:  1
      TxConfTimeout:  2

    Test mandated by
    https://issue.ebgroup.elektrobit.com/projects/ASCIPDUM/issues/ASCIPDUM-836 .

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, no transmission occurs
    02:  TxSendTimeout expires, instance would get sent but
         PduR_IpduMTransmit() returns E_NOT_OK, it's queued
    03:  Payload added to container, no transmission occurs
    04:  TxSendTimeout expires for current instance,
         previous one is dequeued.
         PduR_IpduMTransmit() returns E_OK,
         TxConfTimeout is set to 2.
    05:  TxSendTimeout for current instance is already expired,
         awaiting confirmation or the expiry of TxConfTimeout
    06:  TxConfTimeout expires, current instance is transmitted
    07:  Wait for a while and see that nothing happens
         (Timers have correctly expired)
    08:  Payload added to the container (clean new instance)
    09:  No transmission occurs
    10:  TxSendTimeout expires, ContainedPdu is updated and
         transmission is attempted. Because of failure
         (E_NOT_OK returned by PduR_IpduMTransmit()), it's queued
    11:  Payload added to new instance of container
    12:  TxSendTimeout expires for current instance,
         previous one is dequeued.
         PduR_IpduMTransmit() returns E_NOT_OK,
         everything is retained.
    13:  Dequeuing attempted, failure.
    14:  Dequeuing attempted, success.
         TxConfTimeout set to 2
    15:  TxSendTimeout for current instance is already expired,
         awaiting confirmation or the expiry of TxConfTimeout
    16:  VP(IPDUM.EB.IpduMSendAfterDequeue): As the queue is empty,
         the current instance is transmitted
    17:  Wait for a while and see that nothing happens
         (Timers have correctly expired)
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMSendAfterDequeue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>829</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07037_Dequeue_Main_Func_with_Tx_Confirm</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>13690</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when a Container is configured to have a confirmation
    timeout greater than 0 and IpduMDequeueInTxConf parameter is FALSE, it will
    be sent in the next call to IpduM_MainFunctionTx() only after have received
    the Tx confirmation for last sent instance of the Container.

    Test mandated by ASCIPDUM-789
    Test altered due to ASCIPDUM-1240
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() with a first Contained PDU
    02:  Call IpduM_Transmit() with the second Contained PDU
    03:  Call IpduM_Transmit() with the third Contained PDU
          - transmission triggered
          - check that PduR receives the PDU:
            - check PduR_IpduMTransmit() is called with the correct handle ID
            - check that the data and its length matches the expected one.
    04:  Call IpduM_Transmit() with the first Contained PDU
    05:  Call IpduM_Transmit() with a second Contained PDU
          - transmission is not triggered
    06:  Call IpduM_Transmit() with the third Contained PDU
          - transmission is not triggered
    07:  Call IpduM_Transmit() with a fourth Contained PDU
          - transmission is triggered but Container not sent
            because confirmation is expected
    08:  VP(IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_TxConfirmation() for the sent Container PDU
          - check that each Contained PDU from Container is confirmed
          - check that PduR_IpduMTransmit() is not called
    09:  VP(IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_MainFunctionTx()
          - check that oldest instance from the queue is sent
              - check that PduR receives the PDU:
                - check PduR_IpduMTransmit() is called with the correct handle ID
                - check that the data and its length matches the expected one.
    10:  VP(IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_TxConfirmation() for the sent Container PDU
          - check that each Contained PDU from Container is confirmed
          - check that PduR_IpduMTransmit() is not called
    11:  VP(IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_MainFunctionTx()
          - no transmission triggered, queue is empty
    12:  TRIGGER_ALWAYS Contained PDU added and transmitted
          - TxConfTimeout set to 5
    13:  Contained PDUs added to new instance
    14:  Instance is full
    15:  Contained PDUs added to the last free instance
    16:  TxConfirmation still pending, next oldest instance is overwritten
    17:  TxConfirmation timeout expires
    18:  VP(IpduM.EB.CntrTx.DequeueOrder.OverFlow):
         Each time the oldest instance is dequeued
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>830</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07050_TT_Queued_NoCntrQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>14323</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that in case the IpduMContainerTxConfirmationTimeout
      is configured to a value greater than 0, as long as the corresponding transmission
      confirmation timeout timer has not elapsed, and no transmission confirmation for
      that Container PDU was received, the IpduM shall wait for the TxConfirmation before
      invoking PduR_IpduMTransmit for the next instance of that Container PDU.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with confirmation timeout set to 2, in Trigger Transmit mode.
  
Test Execution: 
    00: Initialize IpduM.
    01: Payload added to container, no transmission
    02: Payload added to container, no transmission
    03: VP: Payload added to container, transmission requested
          - container size is announced.
          - confirmation timeout is 2.
    04: VP: Call IpduM_TriggerTransmit()
          - correct payload received
    05: Call Main Function Tx:
          - confirmation timeout is 1.
    06: VP: Call IpduM_Transmit and return E_NOT_OK because container
        has no queue and is still waiting for TxConfirmation.
    07: Call Main Function Tx:
          - confirmation timeout expired.
    08: Payload added to container, no transmission
    09: Payload added to container, no transmission
    10: VP: Payload added to container, transmission requested
          - container size is announced.
    11: VP: Call IpduM_TriggerTransmit()
          - correct payload received
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00187</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>285</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>831</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07052_SendCurrInstance_NoCntrQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>14561</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when send timeout elapses, container is triggered for
    sending.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with send timeout set to 3.
  
Test Execution: 
    00: Initialize IpduM.
    01: Payload added to container, no transmission
        - send timeout is 3
    02: VP: Call Main Function Tx for 3 times
        - transmission triggered, no container sent because PduR_IpduMTransmit
          returned E_NOT_OK
    03: Payload added to container, no transmission, instance is already triggered
    04: Call Main Function Tx
        - already triggered, instance in transmitted
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>282</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>832</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07063_SizeAnnounceOnlyOnce</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>14689</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() only once
    for each container PDU instance.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
    Test altered due to ASCIPDUM-1021
    Test altered due to ASCIPDUM-1044
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with IpduMContainerTxFirstContainedPduTrigger enabled
    - first contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER
    - second contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS
  
Test Execution: 
    00:   Initialize IpduM.
    01:   Payload added to container
            - size is announced because IpduMContainerTxFirstContainedPduTrigger
    02:   Call Main Function Tx
            - size already announced, send timeout is 0 already
    03:   Payload added to container
            - TRIGGER_ALWAYS added size already announced
    04:   Call IpduM_TriggerTransmit()
            - data retrieved is correct, confirmation timeout is 1
    05:   Payload added to container PDU
            - size is not announced, awaiting confirmation
    06:   The TxConfirmation is called from the SchM_Exit_IpduM function
          which interrupts the Tx MainFunction.
    07:   The postponed PduR_IpduMTransmit() is called from the TxConfirmation.
    08:   Payload added to container PDU
            - size is not announced, already announced
    09:   Call IpduM_TriggerTransmit()
            - data retrieved is correct, confirmation timeout is 1
    10:   Payload added to container PDU
            - size is not announced, awaiting confirmation
    11:   Call Main Function Tx
            - TxConfTimeout set to 1 due to transmission
    12:   Payload added to container PDU
            - size is not announced, already announced
    13:   Call IpduM_TxConfirmation()
            - The next PduR_IpduMTransmit()
              is called from the TxConfirmation
    14:   Call Main Function Tx
            - TxConfTimeout set to 1 due to transmission
    15:   Payload added to container PDU
            - size is not announced, already announced
    16:   Call IpduM_TriggerTransmit()
            - data retrieved is correct, confirmation timeout is 1
    17:   Call TxConfirmation() in a timely manner
    18:   Call Main Function Tx
            - size is not announced, container empty
    19:   Call IpduM_TriggerTransmit()
            - E_NOT_OK received, container empty
    20:   Payload added to container
            - size is announced because IpduMContainerTxFirstContainedPduTrigger
    21:   Payload added to container PDU
            - size is not announced, already announced
    22:   Payload added to container PDU
            - size is not announced, already announced
    23:   Payload added to container PDU
            - size is not announced, already announced, enqueue
    24:   Call IpduM_TriggerTransmit()
            - data retrieved successfully
    25:   Call IpduM_TxConfirmation()
            - size is announced
    26:   Call IpduM_TriggerTransmit()
            - data retrieved successfully
    27:   Call Main Function Tx twice
            - TxConfTimeout expires
            - container is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_FIRST</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>625</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_ConfirmMFTx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>833</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07092_SizeAnnounceOnlyOnce_TrgAlways</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>15134</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that PduR_IpduMTransmit() is only called once per container
    regardless of the number of IPDUM_TRIGGER_ALWAYS ContainedPdus within.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with IpduMContainerTxFirstContainedPduTrigger DISABLED
    - contained PDUs with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER, _except_
    - IpduMCntr16Cntd3TxTT_Queue contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS
  
Test Execution: 
    01: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
        Payload added to container, TRIGGER_ALWAYS, PduR_IpduMTransmit() called
    02: The same ContainedPdu is added, since it was already announced, no call to
        PduR_IpduMTransmit() is made
    03: Container assembled correctly
    04: ContainedPdu with IpduMContainedTxPduTrigger set as IPDUM_TRIGGER_NEVER is added
    05: Another ContainedPdu with IpduMContainedTxPduTrigger set as IPDUM_TRIGGER_NEVER is added,
        trigger conditions aren't fulfilled, no PduR_IpduMTransmit() is called
    06: VP(IPDUM.EB.IpduMContainerTT_ConfirmMFTx):
        Trigger conditions are still unfulfilled, no PduR_IpduMTransmit() called
    07: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
        IPDUM_TRIGGER_ALWAYS ContainedPdu added, PduR_IpduMTransmit() called
    08: IPDUM_TRIGGER_ALWAYS ContainedPdu added, no TxConfirmation() yet,
        no call to PduR_IpduMTransmit()
    09: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
        Trigger condition fulfilled, container is transmitted
    10:
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_ConfirmMFTx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>834</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07093_TriggerTransmit_E_NOT_OK_CQ_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>15348</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when IpduM_TriggerTransmit() is called with an invalid SduLength,
    E_NOT_OK is returned and
    transmission is reattempted in the next MainFunction
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
      Contained PDUs have IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED.
      Container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT.
      Container PDU has IpduMContainerQueueSize set to 2.
      SendTimeout is 3.
  
Test Execution: 
    00: Initialization
    01: Transmission after Container is full
    02: VP(IpduM.EB.TriggerTransmit.MinSduLength.Cntr):
          Length is lass than the one from Transmit, E_NOT_OK returned
          Det error reported
    03: Erroneous TriggerTransmit with correct length, E_NOT_OK returned
    04: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.MinSduLength):
          Transmission reattempted in the next MainFunction
    05: PDU correctly retrieved
    06: Transmission after SendTimeout expires, Container is not full
    07: TriggerTransmit returns E_NOT_OK when incorrect SduLength is used
        TriggerTransmit returns E_NOT_OK without previous transmission
    08: PDU added to Container which couldn't be retrieved at step 07
    09: PDU correctly retrieved with the Contained PDU added at step 08
    10: Single Contained PDU added to Container and retrieved after
        retransmission from the MainFunction
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.TriggerTransmit.MinSduLength.Cntr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.MinSduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>636</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>835</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07094_TriggerTransmit_E_NOT_OK_LB_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>15639</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when IpduM_TriggerTransmit() is called with an invalid SduLength,
    E_NOT_OK is returned and
    transmission is reattempted in the next MainFunction
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
      Contained PDUs have IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_LAST_IS_BEST.
      Container PDU has IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT.
      Container PDU has IpduMContainerQueueSize set to 2.
      SendTimeout is 5.
  
Test Execution: 
    00: Initialization
    01: Transmission because no more contained PDUs would fit
    02: VP(IpduM.EB.TriggerTransmit.MinSduLength.Cntr):
          Retrieval unsuccesful, invalid SduLength used
    03: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.MinSduLength):
          Transmission reattempted
    04: Retrieval and confirmation succesful
    05: Transmission due to expired SendTimeout
    06: Retrieval unsuccesful, invalid SduLength used
    07: ContainedPdu added to Container, not sealed
    08: Transmission reattempted
    09: Retrieval succesful
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.TriggerTransmit.MinSduLength.Cntr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.MinSduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>636</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>836</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07064_SizeAnnounceMFTx</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>15882</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() during
    IpduM_MainFunctionTx() when queue is not empty.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with IpduMContainerTxFirstContainedPduTrigger enabled
    - first contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_NEVER
    - second contained PDU with IpduMContainedTxPduTrigger set to IPDUM_TRIGGER_ALWAYS
  
Test Execution: 
    00:   Initialize IpduM.
    01:   Payload added to container
            - size is announced because IpduMContainerTxFirstContainedPduTrigger
    02:   Payload added to container
            - size is not announce, already announced
    03:   Payload added to container
            - size is not announce, already announced
    04:   Payload added to container
            - size is not announce, already announced
    05:   Payload added to container
            - size is not announce, already announced
    06:   Call Main Function Tx
            - Tx Conf Timeout expires
            - size is announced, queue is not empty
    07:   Payload added to container
            - size is not announce, already announced
    08:   Payload added to container
            - size is not announce, already announced
    09:   Call Main Function Tx
            - Tx Conf Timeout expires
            - size is announced, queue is not empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Queue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>837</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07066_SizeAnnounceOnlyOnce2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>16091</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() when
    container PDU size is exceeded.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:   Initialize IpduM.
    01: VP: Payload added to container
            - size is announced due to size triggering
    02:   Payload added to new instance
            - container added to queue
    03:   Call IpduM_TriggerTransmit()
            - correct data received
    04:   Call Main Function
            - size is announced
    05:   Call IpduM_TxConfirmation()
            - unexpected TxConfirmation is ignored
    06:   Call IpduM_TriggerTransmit()
            - correct data received
    07:   Call Main Function for 5 times
            - no size announced, current instance is empty
    08:   Call IpduM_TriggerTransmit()
            - E_NOT_OK received, current instance is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Queue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>838</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07069_SizeAnnounceOnlyOnce_Queued</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>16260</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() when
    container PDU with IpduMContainerTxFirstContainedPduTrigger is set.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01: VP: Payload added to container
            - size is announced because IpduMContainerTxFirstContainedPduTrigger
    02:   Payload added to container
    03:   Call IpduM_TriggerTransmit()
            - correct data received
    04:   Payload added to container
            - E_NOT_OK received because payload already sent and triggered
    05:   Call IpduM_TxConfirmation()
            - IpduMContainedTxPduConfirmation is OFF, TxConfirmation is not forwarded
    06:   Call IpduM_TriggerTransmit()
            - E_NOT_OK received, current instance is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_SingleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>839</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07070_SizeAnnounceOnlyOnce_Queued2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>16409</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM calls PduR_IpduMTransmit() when
    container PDU size is exceeded.

    Test demanded by ASCIPDUM-873 and ASCIPDUM-875.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is not announced
    02:   Payload added to container
            - size is not announced
    03:   Payload added to container
            - size is announced, size exceeded
    04:   Payload not added to container
            - E_NOT_OK received, one instance only
    05:   Call IpduM_TriggerTransmit()
            - correct data received
    06:   Call IpduM_TxConfirmation()
            - TxConfirmation not forwarded, IpduMContainedTxPduConfirmation  is OFF
    07:   Payload added to container
            - size is not announced
    08:   Payload added to container
            - size is not announced
    09:   Payload added to container
            - size is announced, size exceeded
    10:   Payload not added to container
            - size is not announced
            - E_NOT_OK received because payload does not fit into container PDU
    11:   Call IpduM_TriggerTransmit()
            - correct data received
    12:   Call IpduM_TxConfirmation()
            - size announcement
    13:   Call IpduM_TriggerTransmit()
            - E_NOT_OK received, current instance is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_SingleInstance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>840</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07075_SizeAnnounceRetry_E_NOT_OK_Queued</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>16676</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM shall retry calling PduR_IpduMTransmit() during
    next IpduM_MainFunctionTx() when E_NOT_OK is received either during
    IpduM_Transmit() or during IpduM_MainFunctionTx().

    Test demanded by ASCIPDUM-900.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is not announced
    02:   Payload added to container
            - size is not announced
    03:   Payload added to container
            - size is announced, size exceeded
            - E_NOT_OK received
    04:   Payload added to container
            - size is not announced
    05:   Payload added to container
            - size is not announced
    06:   Payload added to container
            - size is not announced, although size exceeded
            - container is queued
    07:   Call IpduM_MainFunctionTx()
            - repeat size announce from Transmit which received E_NOT_OK
            - E_NOT_OK received
    08:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    09:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_OK received
    10:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 2
    11:   Call IpduM_MainFunctionTx()
            - size is not announced, confirmation awaited
            - confirmation is 1
    12:   Call IpduM_MainFunctionTx()
            - size is announced, E_NOT_OK received
            - confirmation is 0
    13:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    14:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_OK received
    15:   Call IpduM_MainFunctionTx()
            - no transmission
    16:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 2
    17:   Call IpduM_MainFunctionTx()
            - no transmission
            - confirmation timeout is 1
    18:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    19:   Payload added to container
            - size is not announced
    20:   Payload added to container
            - size is not announced
            - send timeout is 3
    21:   Call IpduM_MainFunctionTx()
            - send timeout is 2
            - no transmission
    22:   Call IpduM_MainFunctionTx()
            - send timeout is 1
            - no transmission
    23:   Call IpduM_MainFunctionTx()
            - send timeout is 0
            - size is announced, E_NOT_OK received
    24:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    25:   Call IpduM_MainFunctionTx()
            - repeat size announce from last MFTx which received E_NOT_OK
            - E_OK received
    26:   Call IpduM_MainFunctionTx()
            - no transmission
    27:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 2
    28:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    29:   Call IpduM_MainFunctionTx() for 3 times
            - no transmission
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstanceRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>841</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07077_SizeAnnounceRetry_E_NOT_OK_Queued2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>17102</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM shall retry calling PduR_IpduMTransmit() during
    next IpduM_MainFunctionTx() when E_NOT_OK is received either during
    IpduM_Transmit() or during IpduM_MainFunctionTx().

    Test demanded by ASCIPDUM-900.
    Test altered due to ASCIPDUM-1044.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is announced, E_NOT_OK received
    02:   Payload added to container
    03:   Call IpduM_MainFunctionTx()
            - repeat transmission from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    04:   Call IpduM_MainFunctionTx()
            - repeat transmission from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    05:   Call IpduM_MainFunctionTx()
            - repeat transmission from last MFTx which received E_NOT_OK
            - E_NOT_OK received
    06:   Call IpduM_MainFunctionTx()
            - repeat transmission from last MFTx which received E_NOT_OK
            - E_OK received
    07:   Call IpduM_MainFunctionTx()
            - no transmission
    08:   VP(IpduM.SWS_IpduM_00193.CQ):
            Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 3
    09:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    10:   Payload added to container
            - size is announced, E_NOT_OK received
    11:   Payload added to container
    12:   Payload added to container
    13:   Call IpduM_MainFunctionTx()
            - repeat transmission from last Transmit which received E_NOT_OK
            - E_NOT_OK received
    14:   Call IpduM_MainFunctionTx()
            - repeat transmission from last MFTx which received E_NOT_OK
            - E_OK received
    15:   Call IpduM_MainFunctionTx()
            - no transmission, ConfTimeout decreased from 3 to 2
    16:   Payload added to container (new instance)
            - size is not announced,
            - ConfTimeout is 2
    17:   Payload added to container
            - size is not announced
            - ConfTimeout is 1
    18:    Call IpduM_MainFunctionTx()
            - Transmission delayed to to ConfTimeout.
    19:    Call IpduM_MainFunctionTx()
            - ConfTimeout decreased from 1 to 0, expired
            - Transmission, E_NOT_OK, pushed to the queue
    20:   Call IpduM_MainFunctionTx()
            - repeat transmission from last Transmit which received E_NOT_OK
            - E_OK received
    21:   Call IpduM_MainFunctionTx()
            - no transmission
    22:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 3
    23:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    24:   Call IpduM_MainFunctionTx() for 3 times
            - no transmission
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_MultipleInstanceRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00193.CQ</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>842</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07079_SizeAnnounceOnlyOnce_E_NOT_OK_Queued_NoQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>17459</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM reattempts transmission when it has previously failed.

    Test demanded by ASCIPDUM-900.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Payload added to container
            - size is announced, E_NOT_OK received, E_OK returned
    02:   Payload added to container
            - size is not announced, happened at step 01 when
              triggered, E_OK returned (transmission would be
              reattempted in the MF)
    03:   Payload added to container
            - payload added to container
            - container is full
    04:   Payload not added to container
            - Payload added to container, length 12
            - Previous instance dropped
            - Transmission attempted (FirstContainedPduTrigger)
    05:   Payload added to container
            - E_OK received, length 24
    06:   Call IpduM_MainFunctionTx()
            - transmission reattempted, container is already triggered
            - TxConfTimeout set to 3
    07:   Call IpduM_MainFunctionTx() 2 times
            - TxConfTimeout reduced to 1
    08:   Payload added to container
            - container is full
    09:   Payload not added to container
            - TxConfTimeout is 1
            - E_NOT_OK returned, awaiting TriggerTransmit()
    10:   Call IpduM_TriggerTransmit()
            - correct data received
            - confirmation timeout is 3
    11:   Call IpduM_MainFunctionTx()
            - confirmation timeout is 2
    12:   Call IpduM_TxConfirmation()
            - all contained PDUs are confirmed
    13:   Call IpduM_MainFunctionTx() for 3 times
            - no transmission
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_SingleInstanceRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>843</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07095_Trigger_by_PduLength_Queued</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>17731</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM triggers the container PDU instances correctly when
    an instance is triggered because the current total length of the instance exceeds the PDU length.

    Test demanded by ASCIPDUM-1209.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:   Add contained PDUs until the total length of the container instance is exceeded
    02:   VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD)
          Instance is triggered and PduR_IpduMTransmit() is called.
    03:   Call IpduM_MainFunctionTx()
    04:   Instance is triggered and PduR_IpduMTransmit() is called.
    05:   Payload added to container and IpduM_MainFunctionTx() is called
    06:   Instance is triggered and PduR_IpduMTransmit() is called.
    07:   Payload added to container and IpduM_MainFunctionTx() is called
    08:   Instance is triggered and PduR_IpduMTransmit() is called.
    09:   Call IpduM_MainFunctionTx(). Nothing happens.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.THRESHOLD</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>844</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07096_TrgAlways_NoConf_Queued_Dir</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>17859</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM triggers the container PDU instances correctly when
    IpduMContainerTxTriggerMode = IPDUM_DIRECT,
    IpduMContainerTxConfirmationTimeout is DISABLED,
    IpduMContainedTxPduCollectionSemantics = IPDUM_COLLECT_QUEUED,
    IpduMContainerQueueSize &gt; 0 (2).

    Test demanded by ASCIPDUM-1226.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container length: 36
    IpduMContainerTxFirstContainedPduTrigger = FALSE
    IpduMContainerTxSendTimeout = 6 MFs
  
Test Execution: 
    00: Initialize IpduM.
    01: Add contained PDU, TRIGGER_NEVER, length 3 (Cntr length: 7)
    02: Add contained PDU, TRIGGER_NEVER, length 8 (Cntr length: 19)
    03: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
          Add contained PDU, TRIGGER_ALWAYS, length 7 (Cntr length: 30)
          Triggered, transmitted
    04: Add contained PDU, TRIGGER_NEVER, length 8 (Cntr length: 9)
    05: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
          Add contained PDU, TRIGGER_ALWAYS, length 10 (Cntr length: 23)
          Triggered, transmitted
    06: Add contained PDU, TRIGGER_NEVER, length 2 (Cntr length: 6)
    07: SendTimeout expires, container is transmitted
    08: Call the TX MainFunctions several times, nothing happens
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>845</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07097_TrgAlways_NoConf_Queued_TT</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>18033</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM triggers the container PDU instances correctly when
    IpduMContainerTxTriggerMode = IPDUM_TRIGGERTRANSMIT,
    IpduMContainerTxConfirmationTimeout is DISABLED,
    IpduMContainedTxPduCollectionSemantics = IPDUM_COLLECT_QUEUED,
    IpduMContainerQueueSize &gt; 0 (1).

    Test demanded by ASCIPDUM-1226.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container length: 13
    IpduMContainerTxFirstContainedPduTrigger = FALSE
    IpduMContainerTxSendTimeout = 3 MFs
  
Test Execution: 
    00: Initialize IpduM.
    01: Add contained PDU, TRIGGER_NEVER, length 2 (Cntr length: 6)
    02: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
          Add contained PDU, TRIGGER_ALWAYS, length 1 (Cntr length: 11)
          Triggered, transmitted
    03: Transmission done by TriggerTransmit
    04: Add contained PDU, TRIGGER_NEVER, length 4 (Cntr length: 8)
    05: SendTimeout expires, container is transmitted
    06: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
          Add contained PDU, TRIGGER_ALWAYS, length 3 (Cntr length: 7)
          Triggered, transmitted
    07: Call the TX MainFunctions several times, nothing happens
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>846</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07098_DeQOrder1_NoConf_Queued_TT</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>18192</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM dequeues containers maintaining temporal order when
    overflows occur

    Test demanded by ASCIPDUM-1240
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container length: 13
    IpduMContainerTxFirstContainedPduTrigger = FALSE
    IpduMContainerTxSendTimeout = 3 MFs
    IpduMContainerTxTriggerMode = IPDUM_TRIGGERTRANSMIT
    IpduMContainerTxConfirmationTimeout is DISABLED
    IpduMContainedTxPduCollectionSemantics = IPDUM_COLLECT_QUEUED
    IpduMContainerQueueSize &gt; 0 (4)
  
Test Execution: 
    00: Initialize IpduM.
    01: Add contained PDU, TRIGGER_NEVER, length 1 (Cntr length: 5; Instance: 0)
    02: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
          Add contained PDU, TRIGGER_ALWAYS, length 2 (Cntr length: 11; Instance: 0)
          Triggered, transmitted
    03: Add contained PDU, length 3 (Cntr length: 7; Instance: 1)
          No outgoing transmission due to pending TriggerTransmit
    04: Add contained PDU, length 2 (Cntr length: 13; Instance: 1)
    05: Add contained PDU, length 1 (Cntr length: 5; Instance: 2)
    06: Add contained PDU, length 2 (Cntr length: 11; Instance: 2)
    07: Add contained PDU, length 1 (Cntr length: 5; Instance: 3)
    08: Add contained PDU, length 1 (Cntr length: 10; Instance: 3)
    09: Add contained PDU, length 3 (Cntr length: 7; Instance: 4)
    10: Add contained PDU, length 2 (Cntr length: 13; Instance: 4)
    11: Add contained PDU, length 1 (Cntr length: 5; Instance: 1)
        Instance 0 is in the state WAIT_CONF
    12: Add contained PDU, length 4 (Cntr length: 13; Instance: 1)
    13: Add contained PDU, length 3 (Cntr length: 7; Instance: 2)
    14: VP(IpduM.EB.CntrTx.DequeueOrder.OverFlow):
        Call IpduM_TriggerTransmit, oldest instance (0) is transmitted
    15: Call the TX MainFunction, PduR_IpduMTransmit is called
    16: Add contained PDU, length 2 (Cntr length: 13; Instance: 2)
    17: Add contained PDU, length 2 (Cntr length: 6; Instance: 4)
        Instance 3: TriggerTransmit pending
    18: VP(IpduM.EB.CntrTx.DequeueOrder.OverFlow):
        Call IpduM_TriggerTransmit, oldest instance (3) is transmitted
    19: Call the TX MainFunction, PduR_IpduMTransmit is called
    20: Call IpduM_TriggerTransmit, oldest instance (1) is transmitted
    21: Add contained PDU, length 3 (Cntr length: 13; Instance: 4)
    22: Call the TX MainFunction, PduR_IpduMTransmit is called
    23: Call IpduM_TriggerTransmit, oldest instance (2) is transmitted
    24: Call the TX MainFunction, PduR_IpduMTransmit is called
    25: Call IpduM_TriggerTransmit, oldest instance (4) is transmitted
    26: Add contained PDU, length 2 (Cntr length: 6; Instance: 0)
    27: SendTimeout expires, PduR_IpduMTransmit is called
    28: Call IpduM_TriggerTransmit, current instance (0) is transmitted
    29: Call the TX MainFunctions several times, nothing happens
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>847</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07099_DeQOrder2_NoConf_Queued_TT</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>18574</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM dequeues containers maintaining temporal order when
    multiple overlapping overflows occur

    Test demanded by ASCIPDUM-1240
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container length: 13
    IpduMContainerTxFirstContainedPduTrigger = FALSE
    IpduMContainerTxSendTimeout = 3 MFs
    IpduMContainerTxTriggerMode = IPDUM_TRIGGERTRANSMIT
    IpduMContainerTxConfirmationTimeout is DISABLED
    IpduMContainedTxPduCollectionSemantics = IPDUM_COLLECT_QUEUED
    IpduMContainerQueueSize &gt; 0 (4)
  
Test Execution: 
    00: Initialize IpduM.
    01: Add contained PDU, TRIGGER_ALWAYS, instance transmitted,
        TriggerTransmit not called, remains in the state WAIT_CONF
    02: Fill the queue. Instances states: 0: WAIT_CONF, 1-4: TRIGGERED
    03: Call TriggerTransmit followed by 2 MainFunctions and 2 TriggerTransmits
        Instances 0-2 are transmitted; 0-2: IDLE; 3-4: TRIGGERED
    04: Add contained PDU; 0: TRIGGERED; 1-2: IDLE; 3-4: TRIGGERED
    05: Add contained PDU; 0-1: TRIGGERED; 2: IDLE; 3-4: TRIGGERED
    06: Add contained PDU; 0-4: TRIGGERED; Oldest: 3
    07: Add contained PDU; 0-4: TRIGGERED; Overflow; Oldest: 4
    08: Add contained PDU; 0-4: TRIGGERED; Overflow; Oldest: 0
    09: Add contained PDU; 0-4: TRIGGERED; Overflow; Oldest: 1
    10: Call the MainFunction and TriggerTransmit, instance 1 is retrieved
        0: TRIGGERED; 1: IDLE; 2-4: TRIGGERED
    11: Call the MainFunction; no TriggerTransmit, instance 2 is announced (PduR_IpduMTransmit)
    12: Add contained PDU; 0-1: TRIGGERED; 2: WAIT_CONF; 3-4: TRIGGERED
    13: Add contained PDU; 0-1: TRIGGERED; 2: WAIT_CONF; 3-4: TRIGGERED; Overflow; Oldest: 4
    14: Call TriggerTransmit instance 2 is retrieved
        0-1: TRIGGERED; 2: IDLE; 3-4: TRIGGERED; Oldest: 4
    15: Call the MainFunction and TriggerTransmit; instance 4 is retrieved
        0-1: TRIGGERED; 2: IDLE; 3: TRIGGERED; 4: IDLE; Oldest: 0
    16: Call the MainFunction and TriggerTransmit; instance 0 is retrieved
        0: IDLE; 1: TRIGGERED; 2: IDLE; 3: TRIGGERED; 4: IDLE; Oldest: 1
    17: Call the MainFunction and TriggerTransmit; instance 1 is retrieved
        0-2: IDLE; 3: TRIGGERED; 4: IDLE; Oldest: 3
    18: VP(IpduM.EB.CntrTx.DequeueOrder.OverFlow):
        Call the MainFunction and TriggerTransmit; instance 3 is retrieved
        0-4: IDLE
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>848</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07100_DeQOrder3_NoConf_Queued_TT</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>18927</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM dequeues containers maintaining temporal order when
    overflows occur (at the "beginning" of the queue, with old instances remaining)

    Test demanded by ASCIPDUM-1240
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container length: 13
    IpduMContainerTxFirstContainedPduTrigger = FALSE
    IpduMContainerTxSendTimeout = 3 MFs
    IpduMContainerTxTriggerMode = IPDUM_TRIGGERTRANSMIT
    IpduMContainerTxConfirmationTimeout is DISABLED
    IpduMContainedTxPduCollectionSemantics = IPDUM_COLLECT_QUEUED
    IpduMContainerQueueSize &gt; 0 (4)
  
Test Execution: 
    00: Initialize IpduM.
    01: Add contained PDU, PduR_IpduMTransmit returns E_NOT_OK
    02: Fill the queue
    03: Overflow the queue; Oldest: 4
    04: Call the MainFunction, PduR_IpduMTransmit is called for instance 4
        No TriggerTransmit
    05: Overflow 2 more instances; Oldest: 2
    06: Call TriggerTransmit, instance 4 retrieved
    07: VP(IpduM.EB.CntrTx.DequeueOrder.OverFlow):
        Call the MainFunction and TriggerTransmit; instance 2; Oldest: 3
    08: Call the MainFunction and TriggerTransmit; instance 3; Oldest: 0
    09: Call the MainFunction and TriggerTransmit; instance 0; Oldest: 1
    10: Call the MainFunction and TriggerTransmit; instance 1
    11: The queue is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>849</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07101_DeQOrder4_NoConf_Queued_TT</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>19153</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM dequeues containers maintaining temporal order when
    multiple overflows occur

    Extension of TS_IPDUM_CON_07100_DeQOrder3_NoConf_Queued_TT

    Test demanded by ASCIPDUM-1252
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Container length: 13
    IpduMContainerTxFirstContainedPduTrigger = FALSE
    IpduMContainerTxSendTimeout = 3 MFs
    IpduMContainerTxTriggerMode = IPDUM_TRIGGERTRANSMIT
    IpduMContainerTxConfirmationTimeout is DISABLED
    IpduMContainedTxPduCollectionSemantics = IPDUM_COLLECT_QUEUED
    IpduMContainerQueueSize &gt; 0 (4)
  
Test Execution: 
    00: Initialize IpduM.
    01: Add contained PDU, PduR_IpduMTransmit returns E_NOT_OK
    02: Fill the queue
    03: Overflow the queue; Oldest: 4
    04: Call the MainFunction, PduR_IpduMTransmit is called for instance 4
        No TriggerTransmit
    05: Overflow 3 more instances; Oldest: 0
    06: Call TriggerTransmit, instance 4 retrieved
    07: Overflow 4 more instances; Oldest: 3
    08: Call the MainFunction, PduR_IpduMTransmit is called for instance 3
        Oldest: 4
    09: Overflow 2 more instances; Oldest: 1
    10: Call TriggerTransmit, instance 3 retrieved
    11: Call the MainFunction, PduR_IpduMTransmit is called for instance 1
    12: Overflow 1 more instance; Oldest: 4
    13: Call TriggerTransmit, instance 1 retrieved
    14: VP(IpduM.EB.CntrTx.DequeueOrder.OverFlow):
        Call the MainFunction, PduR_IpduMTransmit; instance 4; Oldest: 0
    15: Call the MainFunction and TriggerTransmit; instance 0; Oldest: 2
    16: Call the MainFunction and TriggerTransmit; instance 2
    17: The queue is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrTx.DequeueOrder.OverFlow</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>850</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07081_CntrTx_Update_Bit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>19463</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_DIRECT, the IpduM shall trigger the
    Container PDU when all contained I-PDUs were updated by the upper layer.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has offset 1, update bit 7
    - contained PDU 2 has offset 22, update bit 3
    - contained PDU 3 has offset 43, update bit 0
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 3
    02: Transmit contained PDU 1
    03: Transmit contained PDU 2
    04: Transmission triggered, check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU offset
          [contained PDU 1, 2, 3]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>851</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07082_CntrTx_Unused_Area</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>19601</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_DIRECT, the IpduM shall trigger the
    Container PDU when all contained I-PDUs were updated by the upper layer.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - container PDU has IpduMUnusedAreasDefault = 0xAA (170)
    - contained PDU 1 has offset 43, no update bit
    - contained PDU 2 has offset 22, no update bit
    - contained PDU 3 has offset 1, no update bit
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 2
    02: Transmit contained PDU 1
    03: Transmit contained PDU 3
    04: Transmission triggered, container PDU added to queue
        - contained PDU shall be arranged based on their contained PDU offset
          [contained PDU 3, 2, 1]
        - data is requested for contained PDUs
        - contained PDU 2 receives E_NOT when requesting data
    05: Container PDU dequeued, check handle IDs, length and payload
        - check payload and length
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00233</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>852</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07083_CntrTx_TT_Update_Bit_Different_Bytes</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>19760</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT, the IpduM shall trigger the
    Container PDU when all contained I-PDUs were updated by the upper layer.

    Test altered due to ASCIPDUM-1096.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has offset 1, update bit 168
    - contained PDU 2 has offset 22, update bit 339
    - contained PDU 3 has offset 43, update bit 7
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 1
    02: Transmit contained PDU 3
    03: Transmit contained PDU 2
    04: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC):
        All contained PDUs updated
        PduR_IpduMTransmit() returns E_OK
    05: Call IpduM_TriggerTransmit()
        - check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU offset
          [contained PDU 1, 2, 3]
        - last contained PDU has a length smaller (by 1) than configured PduLength
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>853</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07084_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>19916</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT, the IpduM shall
    trigger the Container PDU when all contained I-PDUs were updated by the upper layer.

    Retrieval of one Contained PDU fails (PduR_IpduMTriggerTransmit returns E_NOT_OK),
    full length of the Container is used.

    Test altered due to ASCIPDUM-1081
    Test altered due to ASCIPDUM-1096.
    Test altered due to ASCIPDUM-1111.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has offset 1, update bit 168
    - contained PDU 2 has offset 22, update bit 339
    - contained PDU 3 has offset 42, update bit 7
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 1
    02: Transmit contained PDU 3
    03: Transmit contained PDU 2
    04: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC):
        PduR_IpduMTransmit() called and returns E_OK
    05: Call IpduM_TriggerTransmit()
        - check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU offset
          [contained PDU 1, 2, 3]
        - last contained PDU is not updated
    06: VP(IpduM.EB.SWS_IpduM_00243):
        Container is trimmed
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.SWS_IpduM_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>854</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07086_StaticTTLBOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>20079</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that assembling TrigerTransmit - Last is Best Containers
    without a header (static layout) functions as expected.
    The length is truncated, 3*20 bytes occupy the Contained PDUs, 60 bytes
    is the length of the resulting Container.

    Test altered due to ASCIPDUM-1096.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Unused area are painted with the value 219.
    Contained PDU 1 has an offset of 0.
    Contained PDU 2 has an offset of 20.
    Contained PDU 3 has an offset of 40.
  
Test Execution: 
    01: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC):
        The last associated Contained PDU is updated,
        transmission is triggered.
    02: VP(IpduM.SWS_IpduM_00232):
          The order of the Contained PDUs is as configured
    03: VP(IpduM.EB.SWS_IpduM_00243):
          The last 4 bytes are trimmed.
    04: VP(IpduM.SWS_IpduM_00233):
          Due to the length and offset of the Contained PDUs
          no Container PDU area is unused.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00233</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.SWS_IpduM_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>855</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07038_Dequeue_Tx_Confirm_Q</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>20230</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when a Container is configured to have a confirmation
    timeout greater than 0 and IpduMDequeueInTxConf parameter is TRUE, it will
    be sent right away in the next call to IpduM_TxConfirmation() received
    for last sent instance of the Container, if IpduMContainerTxTriggerMode
    is IPDUM_DIRECT.

    Configured IpduMContainedTxPduCollectionSemantics : IPDUM_COLLECT_QUEUED.

    Test mandated by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-789
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() with a first Contained PDU
    02:  Call IpduM_Transmit() with the second Contained PDU
    03:  Call IpduM_Transmit() with the third Contained PDU
          - transmission triggered
          - check that PduR receives the PDU:
            - check PduR_IpduMTransmit() is called with the correct handle ID
            - check that the data and its length matches the expected one.
    04:  Call IpduM_Transmit() with the first Contained PDU
    05:  Call IpduM_Transmit() with a second Contained PDU
          - transmission is not triggered
    06:  Call IpduM_Transmit() with the third Contained PDU
          - transmission is not triggered
    07:  Call IpduM_Transmit() with a fourth Contained PDU
          - transmission is triggered but Container not sent
            because confirmation is expected
    08:  VP(IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_TxConfirmation() for the sent Container PDU
          - check that each Contained PDU from Container is confirmed
          - check that oldest instance from the queue is sent right away
              - check that PduR receives the PDU:
                - check PduR_IpduMTransmit() is called with the correct handle ID
                - check that the data and its length matches the expected one.
    09:  VP(IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_TxConfirmation() for the sent Container PDU
          - check that each Contained PDU from Container is confirmed
          - no transmission triggered, queue is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>856</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07065_BusOffRecovery</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>20491</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that IpduM recovers when lower layer bus off state
    determines E_NOT_OK to be received from PduR and IpduMDequeueInTxConf
    parameter is TRUE.

    Configured IpduMContainedTxPduCollectionSemantics : IPDUM_COLLECT_QUEUED.

    Test mandated by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-881
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU send timeout is 3
    - container PDU confirmation timeout is 2.
    - container PDU has IpduMContainerTxTriggerMode set to IPDUM_DIRECT
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container PDU
    02:  Call Main Function Tx for 3 times:
          - send timeout expires, container PDU added to queue because
            PduR_IpduMTransmit() returns E_NOT_OK
    03:  Payload added to container PDU (to the existing instance: CQ Direct)
    04:  Payload added to container PDU (to the existing instance: CQ Direct)
    05:  Payload added to container PDU (to the existing instance: CQ Direct)
    06:  Call Main Function Tx
          - PduR_IpduMTransmit() returns E_NOT_OK
          - send timeout is 2
    07:  Payload added to container PDU (new instance)
    08:  Call Main Function Tx
          - PduR_IpduMTransmit() returns E_NOT_OK
          - send timeout is 1
    09:  Call Main Function Tx
          - PduR_IpduMTransmit() returns E_NOT_OK
          - send timeout is 1
    10:  Call Main Function Tx
          - PduR_IpduMTransmit() returns E_NOT_OK
          - send timeout is 1
    11:  Call Main Function Tx
          - PduR_IpduMTransmit() returns E_NOT_OK
          - send timeout is 1
    12:  Call Main Function Tx
          - PduR_IpduMTransmit() returns E_NOT_OK
          - send timeout is 1
    13: VP:  Call Main Function Tx
          - dequeuing happens because PduR_IpduMTransmit() returns E_OK
          - confirmation timeout is 2
          - send timeout is 1
    14:  Call Main Function Tx
          - no transmit called because confirmation timeout is 1
          - send timeout is 1
    15: VP:  Call Main Function Tx
          - current instance is sent because queue is empty, send timeout expires
            and PduR_IpduMTransmit() returns E_OK
          - confirmation timeout is 2
    16:  Call Main Function Tx
          - no transmit called because empty container PDU
    17:  Call Main Function Tx
          - no transmit called because empty container PDU
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMSendAfterDequeue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>857</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07038_Dequeue_Tx_Confirm_LB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>20774</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when a Container is configured to have a confirmation
    timeout greater than 0 and IpduMDequeueInTxConf parameter is TRUE, it will
    be sent right away in the next call to IpduM_TxConfirmation() received
    for last sent instance of the Container, if IpduMContainerTxTriggerMode
    is IPDUM_DIRECT.

    Configured IpduMContainedTxPduCollectionSemantics : IPDUM_COLLECT_LAST_IS_BEST.

    Test mandated by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-792
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() with a 1st Contained PDU
    02:  Call IpduM_Transmit() with the 2nd Contained PDU again
    03:  Call IpduM_Transmit() with the 1st Contained PDU again, size reduced
    04:  Call IpduM_Transmit() with the 3rd Contained PDU again, TRIGGER_ALWAYS
          - transmission triggered
          - check that PduR receives the PDU:
            - check PduR_IpduMTransmit() is called with the correct handle ID
            - check that the data and its length matches the expected one.
    05:  Call IpduM_Transmit() with a 1st Contained PDU
          - transmission is not triggered
    06:  Call IpduM_Transmit() with the second Contained PDU again
          - transmission is not triggered
    07:  Call IpduM_Transmit() with a third Contained PDU
          - transmission is triggered but Container not sent
            because confirmation is expected
          - next instance assembled just before transmission
    VP: 08: (IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_TxConfirmation() for the sent Container PDU
          - check that each Contained PDU from Container is confirmed
          - check that oldest instance from the queue is sent right away
              - check that PduR receives the PDU:
                - check PduR_IpduMTransmit() is called with the correct handle ID
                - check that the data and its length matches the expected one.
    VP: 09: (IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_TxConfirmation() for the sent Container PDU
          - check that each Contained PDU from Container is confirmed
          - no transmission triggered, queue is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>858</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07055_Dequeue_Tx_Confirm_LB_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>21061</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when a Container is configured to have a confirmation
    timeout greater than 0 and IpduMDequeueInTxConf parameter is TRUE, it will
    be sent right away in the next call to IpduM_TxConfirmation() received
    for last sent instance of the Container, if IpduMContainerTxTriggerMode
    is IPDUM_DIRECT.

    Configured IpduMContainedTxPduCollectionSemantics : IPDUM_COLLECT_LAST_IS_BEST.

    Test mandated by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-792
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() with a 1st Contained PDU
    02:  Call IpduM_Transmit() with the 2nd Contained PDU again
    03:  Call IpduM_Transmit() with the 1st Contained PDU again, size reduced
    04:  Call IpduM_Transmit() with the 3rd Contained PDU again, TRIGGER_ALWAYS
          - transmission triggered
          - check that PduR receives the PDU:
            - check PduR_IpduMTransmit() is called with the correct handle ID
            - check that the data and its length matches the expected one.
    05:  Call IpduM_Transmit() with a 1st Contained PDU
          - transmission is not triggered
    06:  Call IpduM_Transmit() with the second Contained PDU again
          - transmission is not triggered
    07:  Call IpduM_Transmit() with a third Contained PDU
          - transmission is triggered but Container not sent
            because confirmation is expected
          - container should be added to queue, but since PduR_IpduMTriggerTransmit
            return E_NOT_OK for each contained, container is empty and
            it is not added to queue
    VP: 08: (IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_TxConfirmation() for the sent Container PDU
          - check that each Contained PDU from Container is confirmed
          - no transmission triggered, queue is empty
    VP: 09: (IPDUM.EB.IpduMDequeueInTxConf) Call IpduM_TxConfirmation() for the sent Container PDU
          - no contained is confirmed, queue is empty
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>859</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07056_Tx_Confirm_LB_NoCntrQueueing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>21337</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when a Container is configured to have a confirmation
    timeout greater than 0 and IpduMDequeueInTxConf parameter is TRUE, the
    confirmation for the respective container PDU will work succesfully.

    Configured IpduMContainedTxPduCollectionSemantics : IPDUM_COLLECT_LAST_IS_BEST.

    Test mandated by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-792
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, transmission triggered
          - check that data was transmitted correctly
    02:  Call Tx Confirmation
          - check that contained PDU has been confirmed
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>860</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_07074_Dequeue_Tx_Confirm_LB_TT</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_07_ContainerTxPdu/source/application/Tests.c.m4</sourcefile>
      <sourceline>21431</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that when a Container is configured to have a confirmation
    timeout greater than 0 and IpduMDequeueInTxConf parameter is TRUE, it will
    be sent right away in the next call to IpduM_TxConfirmation() received
    for last sent instance of the Container, if IpduMContainerTxTriggerMode
    is IPDUM_DIRECT.

    Configured IpduMContainedTxPduCollectionSemantics : IPDUM_COLLECT_LAST_IS_BEST.

    Test mandated by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-792
    Test altered due to ASCIPDUM-1044.

    Dequeue behavior was incorrect, the parameter was meant only for DIRECT PDUs.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Call IpduM_Transmit() with a 1st Contained PDU
    02:  Call IpduM_Transmit() with the 2nd Contained PDU
    03:  Call IpduM_Transmit() with the 3rd Contained PDU, TRIGGER_ALWAYS
          - PduR_IpduMTriggerTransmit() is called to retrieve the payload
          - instance is queued, size announced through PduR_IpduMTransmit()
    04:  Call IpduM_Transmit() with a 1st Contained PDU
          - transmission is not triggered
    05:  Call IpduM_Transmit() with the second Contained PDU
          - transmission is not triggered
    06:  Call IpduM_Transmit() with a third Contained PDU
          - container is triggered and queued, size is not announced because
            queue is not empty
    07:  Data is retrieved by IpduM_TriggerTransmit()
    08:  Size announced via PduR_IpduMTransmit()
    09:  Expected TxConfirmations are forwarded
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMDequeueInTxConf</linksto>
          <dstversion>4</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>861</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_08001_MainFuncRx_Def_Proc_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_08_MainFunctionRx/source/application/Tests.c.m4</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that the split mainfunction functionality behaves as expected,
    such as:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: VP(IpduM.SWS_IpduM_91001):
        Call IpduM_MainFunctionRx().
    04: VP: Check that PduR_IpduMRxIndication() has been called 2 times.
    |- for all contained PDUs:
    |  05: VP(IpduM.SWS_IpduM_00202, IpduM.ASR42.ECUC_IpduM_00184):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>862</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_08_MainFunctionRx/source/application/Tests.c.m4</sourcefile>
      <sourceline>155</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that the split mainfunction functionality behaves as expected,
    such as:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
      - The data will be updated when the same container Rx comes from IpduM_RxIndication()
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    First container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    Both containers PDU:
    - IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    - IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_RxIndication() with the same container PDU.
    04: VP: Check that PduR_IpduMRxIndication() is not called.
    05: VP(IpduM.SWS_IpduM_91001):
        Call IpduM_MainFunctionRx().
    06: VP(IpduM.SWS_IpduM_00206): Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  07: VP(IPDUM.EB.IpduM_MainFunctionRx_Processing, IpduM.SWS_IpduM_00202, IpduM.ASR42.ECUC_IpduM_00184):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduM_MainFunctionRx_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>863</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_08002_MainFuncRx_Def_Proc_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_08_MainFunctionRx/source/application/Tests.c.m4</sourcefile>
      <sourceline>306</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that the split mainfunction functionality behaves as expected,
    such as:
      - The processing of a container Rx with IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED
        will take place in the next main function cycle
      - The data will be updated when the same container Rx comes from IpduM_RxIndication()
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    First container PDU with IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_ALL.
    Both containers PDU:
    - IpduMContainerPduProcessing set to IPDUM_PROCESSING_DEFERRED.
    - IpduMHeaderByteOrder set to LITTLE_ENDIAN.
  
Test Execution: 
    01: Call IpduM_RxIndication() with a container PDU that accepts all contained PDUs.
    02: VP: Check that PduR_IpduMRxIndication() is not called.
    03: Call IpduM_RxIndication() with the same container PDU.
    04: VP: Check that PduR_IpduMRxIndication() is not called.
    05: VP(IpduM.SWS_IpduM_91001):
        Call IpduM_MainFunctionRx().
    06: VP: Check that PduR_IpduMRxIndication() has been called 2 times with the new ContainedPduHeaderId from the latest data.
    |- for all contained PDUs:
    |  07: VP(IPDUM.EB.IpduM_MainFunctionRx_Processing, IpduM.SWS_IpduM_00202, IpduM.ASR42.ECUC_IpduM_00184):
    |      PduR_IpduMRxIndication() is called with correct handle ID (first byte from each
    |      header) and length (next 3 bytes).
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>298</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduM_MainFunctionRx_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>864</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_09001_MainFuncTx_TxConfTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_09_MainFunctionTx/source/application/Tests.c</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that the split mainfunction functionality behaves as expected,
    such as:
      when the TxConfirmationTimeout passes, TxConfirmations for that given PDU are ignored.

    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_4 has
    the TxConfTimeout configured for 3 MFs.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, no transmission
    02:  Payload added to container, transmission triggered because of threshold
    03:  VP(IpduM.SWS_IpduM_91002):
         Call IpduM_MainFunctionTx(), TxConfTimeout at 3
    04:  VP(IPDUM.EB.IpduM_MainFunctionTx_Processing):
         TxConfTimeout at 2
    05:  TxConfTimeout at 1
    06:  VP(IpduM.ASR42.SWS_IpduM_00198): Unexpected TxConfirmation() ignored
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduM_MainFunctionTx_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>865</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_09002_MainFuncTx_SendTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_09_MainFunctionTx/source/application/Tests.c</sourcefile>
      <sourceline>171</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that the split mainfunction functionality behaves as expected,
    such as:
      when the TxSendTimeout of a Container has elapsed, transmission will be triggered.

    3 MainFunctionTx cycles ensure that the timer reaches 0 for
    IpduMConf_IpduMContainerTxPdu_IpduMContainerTxPdu_5.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container
    02:  VP(IpduM.SWS_IpduM_91002):
         Call IpduM_MainFunctionTx(), TxSendTimeout at 3
    03:  VP(IPDUM.EB.IpduM_MainFunctionTx_Processing):
         TxSendTimeout at 2
    04:  TxSendTimeout at 1
    05:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT): Transmission triggered
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduM_MainFunctionTx_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>866</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_09003_MainFuncTx_SendTimeout2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_09_MainFunctionTx/source/application/Tests.c</sourcefile>
      <sourceline>269</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that the split mainfunction functionality behaves as expected,
    such as:
    - when container PDU send timeout is greater than confirmation timeout,
      the send timeout counter will elapse right after confirmation timeout
      has elapsed.

      Test altered: IpduMContainerTxPdu_5 queue size enabled and set to 1.
      Otherwise the transmission would be rejected due to lack of TxConfirmation.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container PDU with send timeout set to 2, confirmation timeout set to 3.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container, no transmission
    02:  Call Main Function Tx for 2 times
          - send timeout is decreased from 2 to 0
          - container is sent
          - confirmation timeout is 3
    03:  Payload added to container, no transmission
    04:  VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT):
          Call Main Function Tx for 3 times
          - confirmation timeout decreases to 0 from 3.
          - send timeout decreases to 00
          - container is sent
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduM_MainFunctionTx_Processing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>867</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_10001_Cntr_DetChecks</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_10_ContainerDetChecks/source/application/Tests.c</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that DET errors are reported correctly
    when container part is enabled.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  
Test Execution: 
    00:  Initialize IpduM.
    01: VP: Call Rx Indication with non existent Pdu Id
        - check that Det was called.
    02: VP: Call Transmit with non existent Pdu Id
        - check that Det was called.
    03: VP: Call Trigger Transmit with non existent Pdu Id
        - check that Det was called.
    04: VP: Call Tx Confirmation with non existent Pdu Id
        - check that Det was called.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>384</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>868</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_10001_MainFuncFlexAlloc_SendTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks the correct update of send timeout of the containers
    when allocated main function is called.
    - main functions are called one after the other.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 1 has send timeout 2.
    - container 2 has 2 contained PDUs with send timeout 3 each.
    - container 3 has 2 contained PDUs with send timeout 5, respective 4.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    02:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    03:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    04:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    05:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    06:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    07:  Payload added to container 3, no transmission
          - container 3 send timeout is 5
    08:  Payload added to container 3, no transmission
          - container 3 send timeout is updated to 4
    09:  Payload added to container 3, no transmission
          - container 3 send timeout is 4
    10: Call all 3 Main Functions
          - Main Function 1 decreases container 1 send timeout to 1
          - Main Function 2 decreases container 2 send timeout to 2
          - Main Function 3 decreases container 3 send timeout to 3
    11: VP: Call all 3 Main Functions
          - Main Function 1 decreases container 1 send timeout to 0
            - container 1 is sent
          - Main Function 2 decreases container 2 send timeout to 1
          - Main Function 3 decreases container 3 send timeout to 2
    12: VP: Call all 3 Main Functions
          - Main Function 1 does not modify container 1 send timeout
            which is 0
          - Main Function 2 decreases container 2 send timeout to 0
            - container 2 is sent
          - Main Function 3 decreases container 3 send timeout to 1
    13: VP: Call all 3 Main Functions
          - Main Function 1 does not modify container 1 send timeout
            which is 0
          - Main Function 2 does not modify container 2 send timeout
            which is 0
          - Main Function 3 decreases container 3 send timeout to 0
            - container 3 is sent
    14: VP: Call all 3 Main Functions
          - Main Function 1 does not modify container 1 send timeout
            which is 0
          - Main Function 2 does not modify container 2 send timeout
            which is 0
          - Main Function 3 does not modify container 3 send timeout
            which is 0
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>869</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10002_MainFuncFlexAlloc_SendTimeout_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>361</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks the correct update of send timeout of the containers
    when allocated main function is called.
    - main functions are called separately.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 1 has send timeout 2.
    - container 2 has 2 contained PDUs with send timeout 3 each.
    - container 3 has 2 contained PDUs with send timeout 5, respective 4.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    02:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    03:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    04:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    05:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    06:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    07:  Payload added to container 3, no transmission
          - container 3 send timeout is 5
    08:  Payload added to container 3, no transmission
          - container 3 send timeout is updated to 4
    09:  Payload added to container 3, no transmission
          - container 3 send timeout is 4
    10: VP: Call 1st main function 3 times
          - Main Function 1 decreases container 1 send timeout to 1
          - Main Function 1 decreases container 1 send timeout to 0
            - container 1 is sent
          - Main Function 1 does not modify container 1 send timeout
            which is 0
    11: VP: Call 2nd main function 4 times
          - Main Function 2 decreases container 2 send timeout to 2
          - Main Function 2 decreases container 2 send timeout to 1
          - Main Function 2 decreases container 2 send timeout to 0
            - container 2 is sent
          - Main Function 2 does not modify container 2 send timeout
            which is 0
    12: VP: Call 3rd main function 5 times
          - Main Function 3 decreases container 3 send timeout to 3
          - Main Function 3 decreases container 3 send timeout to 2
          - Main Function 3 decreases container 3 send timeout to 1
          - Main Function 3 decreases container 3 send timeout to 0
            - container 3 is sent
          - Main Function 3 does not modify container 3 send timeout
            which is 0
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>870</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10003_MainFuncFlexAlloc_TxConfirm</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>669</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks the correct update of confirmation timeout of the containers
    when allocated main function is called.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 1 has send timeout 2 and confirmation timeout 3.
    - container 2 has 2 contained PDUs with send timeout 3 each, and
      confirmation timeout 4.
    - container 3 has 2 contained PDUs with send timeout 5, respective 4
      and confirmation timeout 5.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    02:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    03:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    04:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    05:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    06:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    07:  Payload added to container 3, no transmission
          - container 3 send timeout is 5
    08:  Payload added to container 3, no transmission
          - container 3 send timeout is updated to 4
    09:  Payload added to container 3, no transmission
          - container 3 send timeout is 4
    10: Call:
          - Main Function 1 for 2 times to send the container 1
            - container 1 confirmation timeout is 3
          - Main Function 2 for 3 times to send the container 2
            - container 2 confirmation timeout is 4
          - Main Function 3 for 4 times to send the container 3
            - container 3 confirmation timeout is 5
    11: Call Main Function 2 for 4 times
          - Main Function 2 decreases container 2 confirmation
            timeout to 3
          - Main Function 2 decreases container 2 confirmation
            timeout to 2
          - Main Function 2 decreases container 2 confirmation
            timeout to 1
          - Main Function 2 decreases container 2 confirmation
            timeout to 0
    12: Call Main Function 1 for 2 times
          - Main Function 1 decreases container 1 confirmation
            timeout to 2
          - Main Function 1 decreases container 1 confirmation
            timeout to 1
    13: VP: Call Tx Confirmation for container 2
          - no contained PDU is confirmed
    14: VP: Call Tx Confirmation for container 1
          - all the contained PDUs in container 1 are confirmed
    15: Call Main Function 1 for 1 time
          - Main Function 1 decreases container 1 confirmation
            timeout to 0
    16: VP: Call Tx Confirmation for container 1
          - no contained PDU is confirmed
    17: VP: Call Tx Confirmation for container 2
          - no contained PDU is confirmed
    18: VP: Call Tx Confirmation for container 3
          - all the contained PDUs in container 3 are confirmed
    19: Call Main Function 3 for 4 times
          - Main Function 3 decreases container 3 confirmation
            timeout to 4
          - Main Function 3 decreases container 3 confirmation
            timeout to 3
          - Main Function 3 decreases container 3 confirmation
            timeout to 2
          - Main Function 3 decreases container 3 confirmation
            timeout to 1
    20: VP: Call Tx Confirmation for all 3 container PDUs
          - no contained PDU is confirmed
    21: Call Main Function 3 for 1 times
          - Main Function 3 decreases container 3 confirmation
            timeout to 0
    22: VP: Call Tx Confirmation for all 3 container PDUs
          - no contained PDU is confirmed
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>871</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10004_MainFuncFlexAlloc_TxConfirm_SendTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>1097</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that correct container is sent after receiving
    confirmation, due to send timeout.

    Test altered due to:
    Container is locked until TxConfirmation if single instance.
    (RAM: No separate composition and TxConfirm lists)
    IpduMCntr1Tx_FlexAlloc queue enabled, size 1
    IpduMCntr3Tx_FlexAlloc queue enabled, size 1
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 1 has send timeout 2 and confirmation timeout 3.
    - container 2 has 2 contained PDUs with send timeout 3 each, and
      confirmation timeout 4.
    - container 3 has 2 contained PDUs with send timeout 5, respective 4
      and confirmation timeout 5.
  
Test Execution: 
    00:  Initialize IpduM.
    01:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    02:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    03:  Payload added to container 1, no transmission
          - container 1 send timeout is 2
    04:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    05:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
    06:  Payload added to container 2, no transmission
          - container 2 send timeout is 3
          - same ID as at step 04, this payload is considered
    07:  Payload added to container 3, no transmission
          - container 3 send timeout is 5
    08:  Payload added to container 3, no transmission
          - container 3 send timeout is updated to 4
    09:  Payload added to container 3, no transmission
          - container 3 send timeout is 4
    10: Call:
          - Main Function 1 for 2 times to send the container 1
            - container 1 confirmation timeout is 3
          - Main Function 2 for 3 times to send the container 2
            - container 2 confirmation timeout is 4
          - Main Function 3 for 4 times to send the container 3
            - container 3 confirmation timeout is 5
    11: Payload added to container 1, no transmission
    12: Payload added to container 1, no transmission
    13: Payload added to container 1, no transmission
          - container 1 send timeout is 2
          - container 1 confirmation timeout is 3
    14: Payload added to container 3, no transmission
    15: Payload added to container 3, no transmission
    16: Payload added to container 3, no transmission
          - container 3 send timeout is 4
          - container 3 confirmation timeout is 5
    17: Call Tx Confirmation for container 1
          - container 1 confirmation timeout is 0
    18: VP: Call Main Function 2 for 5 times
          - no container is sent
    19: VP: Call Main Function 1 for 2 times
          - Main Function 1 decreases container 1 send timeout to 1
          - Main Function 1 decreases container 1 send timeout to 0
          - container 1 is sent due to send timeout
    20: Call Main Function 3 for 4 times
          - Main Function 3 decreases container 3 confirmation
            timeout to 4, send timeout to 3
          - Main Function 3 decreases container 3 confirmation
            timeout to 3, send timeout to 2
          - Main Function 3 decreases container 3 confirmation
            timeout to 2, send timeout to 1
          - Main Function 3 decreases container 3 confirmation
            timeout to 1, send timeout remains 1
     21: VP: Call Main Function 1 for 1 time
          - no container is sent
     22: VP: Call Main Function 2 for 1 time
          - no container is sent
     23: VP: Call Main Function 3 for 1 time
          - Main Function 3 decreases container 3 send timeout to 0
          - container 3 is sent due to send timeout
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>872</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10005_MainFuncFlexAlloc_TxConfirm_SendAwait</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>1596</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that correct container is sent after receiving
    confirmation, because of size triggering in the meantime.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 1 has send timeout 2 and confirmation timeout 3.
    - container 2 has 2 contained PDUs with send timeout 3 each, and
      confirmation timeout 4.
    - container 3 has 3 contained PDUs with send timeout 5, 4, respective 5
      and confirmation timeout 5.
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>873</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10006_MainFuncFlexAlloc_Dequeue</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>2163</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that dequeue happens during next main
    function cycle.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 4 has queue size 3 and confirmation enabled with a timeout of 3.
    - container 5 has queue size 2 and confirmation disabled.
    - container 6 has no queue size specified and confirmation disabled.
    - container 4 -&gt; MF 1
    - container 5 -&gt; MF 2
    - container 6 -&gt; MF 3
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>874</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10007_MainFuncFlexAlloc_SizeAnnounce</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>2614</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that container size is announced when trigger conditions
    are fulfilled.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 7 has Queue size 2, confirmation timeout of 4, send timeout of 3.
    - container 8 has Queue size 3, no confirmation timeout, send timeout of 3.
    - container 9 has no Queue size, no confirmation timeout, send timeout of 3.
    - container 7 -&gt; MF 1
    - container 8 -&gt; MF 2
    - container 9 -&gt; MF Tx
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMContainerTT_Triggers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>875</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>3027</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that deferred processing happens on the allocated
    main function for the respective container PDU.
  &lt;/para&gt;
  &lt;para&gt;
    Test extended due to ASCIPDUM-1028.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 1 has Queue Size 3
    - container 2 has no Queue Size
    - container 3 has Queue Size 2
    - container 1 -&gt; MF 1
    - container 2 -&gt; MF 2
    - container 3 -&gt; MF Rx
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DeferredMF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00207.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>876</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10008_MainFuncFlexAlloc_DeferredProcessing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>3356</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that deferred processing happens on the allocated
    main function for the respective container PDU.
  &lt;/para&gt;
  &lt;para&gt;
    Test extended due to ASCIPDUM-1028.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 1 has Queue Size 3
    - container 2 has no Queue Size
    - container 3 has Queue Size 2
    - container 1 -&gt; MF 1
    - container 2 -&gt; MF 2
    - container 3 -&gt; MF Rx
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.SWS_IpduM_91003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CntrRx.DeferredMF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00252</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>363</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>877</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_10009_MainFuncFlexAlloc_TxPathWay_ContainerTx</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_11_MainFunctions_FlexibleAllocation/source/application/Tests.c.m4</sourcefile>
      <sourceline>3689</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  - This test shall verify that new transmission requests are accepted only after confirmation
    timeout, for special configuration of maximum ticks, i.e. IpduMTxConfirmationTimeout
    equals 3600.
  - This test inherently verifies the proper use of the time base given by configuration
    parameter IpduMTxTimeBase considering ticks.

  The test sequence focuses on confirmation handling.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - Container 1 with send timeout 2
m4_ifelse(PM_TxPathWaysEnabled,TRUE,\-:m4_dnl
  - TxPathWay with confirmation timeout set to 2, trigger on static part
  - TxPathWay -&gt; MF 1
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  - Container 1 -&gt; MF 1

Test Execution: 
m4_define(\-:PM_testStep:-/,1)\-::-/m4_dnl
m4_ifelse(PM_TxPathWaysEnabled,TRUE,\-:m4_dnl
  [@"%02d"|format(testStep)@]: Call IpduM_Transmit() with static PDU-ID of IpduMTxPathway_0.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
  [@"%02d"|format(testStep)@]: Verify whether PduR_IpduMTransmit is called.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  [@"%02d"|format(testStep)@]: Payload added to container 1.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
  [@"%02d"|format(testStep)@]: Payload added to container 1.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
  [@"%02d"|format(testStep)@]: Payload added to container 1.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
      - send timeout is 2.
  [@"%02d"|format(testStep)@]: VP: Call Main Function 2 and Main Function 3 for 2 times each\-::-/m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
      - check that no container is sent
m4_ifelse(PM_TxPathWaysEnabled,TRUE,\-:m4_dnl
      - check that TxPathWay confirmation timeout is not decreased
  [@"%02d"|format(testStep)@]: Call IpduM_Transmit for the same static PDU immediately before confirmation timeout elapsed.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
  [@"%02d"|format(testStep)@]: VP: Verify that the request is not accepted as neither the confirmation is received for the
      previous request nor confirmation timeout happened.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  [@"%02d"|format(testStep)@]: Call IpduM_MainFunctionTx() to expire the confirmation timeout.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
m4_ifelse(PM_TxPathWaysEnabled,TRUE,\-:m4_dnl
  [@"%02d"|format(testStep)@]: Call IpduM_Transmit for the same static PDU.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
  [@"%02d"|format(testStep)@]: VP: Verify that the request is accepted as confirmation timeout occurred.m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
  [@"%02d"|format(testStep)@]: Call IpduM_TxConfirmation\-::-/m4_define(\-:PM_testStep:-/,m4_eval(PM_testStep + 1))
  [@"%02d"|format(testStep)@]: Verify that the PduR is notified about the transmission.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR43.ECUC_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR43.ECUC_IpduM_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.ECUC_IpduM_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>878</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_17002_LoadPbCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_12_LoadPbCfg/source/application/Test.c</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that it is possible to load a configuration from a binary file.
      * Check that the configuration values are valid within the loaded binary file. There is no
        need to check all of them here.
      * Check that the routing paths are valid. There is no need
        to check all of them here. Therefore call a IpduM_Transmit
        and check if E_OK is received.

        This test can be removed in the case a similar integration test
        exists to simplify maintenance of this test file.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * This test must only be executed in a windows system.
    * The executable shall be compiled without the post build configuration.
    * The configuration binary shall be generated separately.
    * The configuration must be relocatable.

Test Execution: 
  00: Read the configuration from a binary file.
  01: TxContainerPduNum and RxContainerPduNum must equal the values in the initial
      Configuration.
  02: Initialize the IpduM with the configuration from the binary file.
  03: VP: The Det must not be called after the initialization.
  04: Call IpduM_Transmit with destination PduId
      IpduMConf_IpduMTxStaticPart_IpduMTxStaticPart_PduTxPw00Sta.
  05: VP: E_OK is received.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>879</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_13001_CntrTx_UINT32_NoQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_13_UINT32_PduLengthType_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that when adding 4096 contained I-PDU to a Container PDU
    then IpduM calls PduR_IpduMTransmit to transmit the entire Container PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IPduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare the payload for the first 4095 IpduMContainedTxPdus
    02: Transmit each IpduMContainedTxPdu
    03: Prepare the payload for the 4096'th IpduMContainedTxPdu
    04: Transmit the 4096'th IpduMContainedTxPdu, which triggers the
        entire IpduMContainer transmission
    05: Check that PduR_IpduMTransmit() is called with correct handle ID and length
    06: Check that correct header + payload are transmitted
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>880</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_13002_CntrTx_UINT32_LB_NoQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_13_UINT32_PduLengthType_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>260</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that when adding 4 contained I-PDU to a Container PDU,
    each of them having 16376 bytes length,
    then IpduM calls PduR_IpduMTransmit to transmit the entire Container PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IPduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare the payload for the first IpduMContainedTxPdu
    02: First IpduMContainedTxPdu is added to container
    03: No transmission occurs
    04: Prepare the payload for the second IpduMContainedTxPdu
    05: Second IpduMContainedTxPdu is added to container
    06: No transmission occurs
    07: Prepare the payload for the third IpduMContainedTxPdu
    08: Third IpduMContainedTxPdu is added to container
    09: No transmission occurs
    10: Prepare the payload for the fourth IpduMContainedTxPdu
    11: Fourth IpduMContainedTxPdu is added to container
    12: Check that PduR_IpduMTriggerTransmit() was called for each IpduMContainedTxPdu
    13: Container has been filled, transmission takes place
    14: Check for each IpduMContainedTxPdu that the correct Header + Payload were transmitted
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>881</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_13003_CntrTx_UINT32_WithQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_13_UINT32_PduLengthType_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>454</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that queuing works correctly when using QUEUED semantics,
    even if the queue is filled with containers of length 65536 (UINT32).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IPduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare the payload for the first 4095 IpduMContainedTxPdus
    02: Add payload of each IpduMContainedTxPdu to Container
    03: No transmission occurs
    04: Prepare the payload for the 4096'th IpduMContainedTxPdu
    05: Add the payload of the 4096'th IpduMContainedTxPdu to the Container
    06: Add first container in the queue, because PduR_IpduMTransmit returned E_NOT_OK
    07: Prepare the payload for the next 4095 IpduMContainedTxPdus
    08: Add payload of each IpduMContainedTxPdu to Container
    09: Prepare payload for the 4096'th IpduMContainedTxPdu
    10: Add the 4096'th IpduMContainedTxPdu in the Container, container is queued,
        transmission of the previous is pending
    11: Transmission of the first container occurs
    12: Check that PduR_IpduMTransmit() is called with correct handle ID, length,
        Header and Payload, for the FIRST CONTAINER
    13: Transmission of the second container occurs
    14: Check that PduR_IpduMTransmit() is called with correct handle ID, length,
        Header and Payload, for the SECOND CONTAINER
    15: No other transmission occurred
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>882</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_13004_CntrTx_UINT32_LB_WithQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_13_UINT32_PduLengthType_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>709</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that queuing works correctly when using LAST IS BEST semantics,
    even if the queue is filled with containers of length 65536 (UINT32).
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Fill the FIRST CONTAINER with 3 IpduMContainedTxPdu, each of them having the length of 21838 bytes
    02: Add the first IpduMContainedTxPdu in the first Container
    03: Add the second IpduMContainedTxPdu in the first Container
    04: Add the third IpduMContainedTxPdu in the first Container
    05: Check that PduR_IpduMTriggerTransmit() was called for each IpduMContainedTxPdu
    06: Add the FIRST CONTAINER in the queue, because PduR_IpduMTransmit returned E_NOT_OK
    07: No transmission occurs
    08: Fill the SECOND CONTAINER with 3 IpduMContainedTxPdu, each of them having the length of 21838 bytes
    09: Add the fourth IpduMContainedTxPdu in the second Container
    10: Add the fifth IpduMContainedTxPdu in the second Container
    11: Add the sixth IpduMContainedTxPdu in the second Container
    12: PduR_IpduMTriggerTransmit() not called, no PduR_IpduMTransmit() executed, added to the queue
    13: Fill the THIRD CONTAINER with 3 IpduMContainedTxPdu, each of them having the length of 21838 bytes
    14: Add the seventh IpduMContainedTxPdu in the third Container
    15: Add the eighth IpduMContainedTxPdu in the third Container
    16: Add the ninth IpduMContainedTxPdu in the third Container
    17: No transmission occurred
    18: FIRST CONTAINER is transmitted
    19: Check that PduR_IpduMTransmit() is called with correct handle ID, length, Header and Payload, for the FIRST CONTAINER
    20: SECOND CONTAINER is transmitted
    21: VP(IpduM.SWS_IpduM_00220):
        Not yet assembled, verify TriggerTransmits
    22: Check that PduR_IpduMTransmit() is called with correct handle ID, length, Header and Payload, for the SECOND CONTAINER
    23: THIRD CONTAINER is transmitted
    24: VP(IpduM.SWS_IpduM_00220):
        Container is assembled, payloads are retrieved just before transmission
    25: Check that PduR_IpduMTransmit() is called with correct handle ID, length, Header and Payload, for the THIRD CONTAINER
    26: Check that no other containers were transmitted
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>883</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_13005_CntrRx_UINT32_NoQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_13_UINT32_PduLengthType_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>1146</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that a reception of a Container PDU with length 65536 (UINT32),
    is processed correctly.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IPduM module shall be initialized
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the first IpduMContainedRxPdu to be received
    02: Prepare data for the second IpduMContainedRxPdu to be received
    03: Prepare data for the third IpduMContainedRxPdu to be received
    04: Container PDU which contains 3 IpduMContainedRxPdu is received
    05: Check Handle ID, length and payload for the first IpduMContainedRxPdu
    06: Check Handle ID, length and payload for the second IpduMContainedRxPdu
    07: Check Handle ID, length and payload for the third IpduMContainedRxPdu
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>884</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_13006_CntrRx_UINT32_WithQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_13_UINT32_PduLengthType_Support/source/application/Tests.c.m4</sourcefile>
      <sourceline>1405</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Tests that the reception of multiple Containers with length 65536 (UINT32),
    is processed correctly, when queuing is activated.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the first IpduMContainedRxPdu to be received
    02: Prepare data for the second IpduMContainedRxPdu to be received
    03: Prepare data for the third IpduMContainedRxPdu to be received
    04: First container is received
    05: Prepare data for the fourth IpduMContainedRxPdu to be received
    06: Prepare data for the fifth IpduMContainedRxPdu to be received
    07: Prepare data for the sixth IpduMContainedRxPdu to be received
    08: Second container is received
    09: Call IpduM_MainFunctionRx() to process the reception of the FIRST CONTAINER.
    10: Check Handle ID, length and payload for IpduMContainedRxPdu 1, from the FIRST CONTAINER
    11: Check Handle ID, length and payload for IpduMContainedRxPdu 2, from the FIRST CONTAINER
    12: Check Handle ID, length and payload for IpduMContainedRxPdu 3, from the FIRST CONTAINER
    13: Call IpduM_MainFunctionRx() to process the reception of the SECOND CONTAINER
    14: Check Handle ID, length and payload for IpduMContainedRxPdu 4, from the SECOND CONTAINER
    15: Check Handle ID, length and payload for IpduMContainedRxPdu 5, from the SECOND CONTAINER
    16: Check Handle ID, length and payload for IpduMContainedRxPdu 6, from the SECOND CONTAINER
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>885</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_14001_CntrRx_Update_Bit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that in case a received contained I-PDU has a configured update bit,
    the IpduM module shall only process and indicate it to the upper layer if its received
    update-bit is set.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the container PDU
        - contained PDU 1 has offset 1, update bit 0
        - contained PDU 2 has offset 22, update bit 7
        - contained PDU 3 has offset 43, update bit 3

        Container PDU byte 0 contains value 1 only for
        contained PDUs 2 and 3.
    02: Container PDU which contains 3 IpduMContainedRxPdu is received
    03: Check Handle ID, length and payload for the contained PDUs 2 and 3
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00236</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>339</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>886</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14002_CntrRx_Update_Bit_Different_Bytes</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>153</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that in case a received contained I-PDU has a configured update bit,
    the IpduM module shall only process and indicate it to the upper layer if its received
    update-bit is set.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the container PDU
        - contained PDU 1 has offset 1, update bit 7
        - contained PDU 2 has offset 23, update bit 176
        - contained PDU 3 has offset 45, update bit 355

        All contained PDUs have the update bit set.
    02: Container PDU which contains 3 IpduMContainedRxPdu is received
        - SduLength is 65U
    03: Check Handle ID, length and payload for the contained PDUs 1, 2 and 3
        - contained PDU 1 length is 21U
        - contained PDU 2 length is 21U
        - contained PDU 3 length is 20U
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00236</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>339</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>887</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14003_CntrRx_Det_Report</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>282</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that when processing a received Container PDU with IpduMContainerHeaderSize set to
    IPDUM_HEADERTYPE_NONE, the IpduM shall ignore all contained PDUs that are according to their configuration
    not or not completely contained in the received Container PDU. Such contained I-PDUs shall not be
    indicated to the upper layer and IPDUM_E_CONTAINER shall be report if Development Error Detection is
    enabled.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the container PDU
        - contained PDU 1 has offset 1, update bit 0
        - contained PDU 2 has offset 22, update bit 7
        - contained PDU 3 has offset 43, update bit 3

        Container PDU byte 0 contains value 1 only for
        contained PDUs 2 and 3.

    02: Container PDU which contains 2 IpduMContainedRxPdu is received
        - SduLength is 43U equal to contained PDU 3 offset
    03: Check Handle ID, length and payload for the contained PDU 2
    04: Check that Det is reported.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00237</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>340</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00247</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>347</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>888</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14004_CntrRx_Dynamic_Length</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>386</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that the last contained IPdu (according to IpduMContainedPduOffset) of
    a ContainerIPdu with static container layout may be a dynamic length PDU.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
  
Test Execution: 
    00: Initialize IpduM
    01: Prepare data for the container PDU
        - contained PDU 1 has offset 0, no update bit
        - contained PDU 2 has offset 8, no update bit

    02: Container PDU which contains 2 IpduMContainedRxPdu is received
        - SduLength is 9U
    03: Check Handle ID, length and payload for the contained PDUs 1 and 2
        - contained PDU 1 length is 8U
        - contained PDU 2 length is 1U
    04: Prepare data for the container PDU
    05: Container PDU which contains 2 IpduMContainedRxPdu is received
        - SduLength is 16U
    06: Check Handle ID, length and payload for the contained PDUs 1 and 2
        - contained PDU 1 length is 8U
        - contained PDU 2 length is 8U
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>889</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14010_CntrTx_Static_Length_0</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>526</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that if during transmission the SduLength is 0 the PDU is
    silently ignored.
  &lt;/para&gt;
  
Test Object: 
    IpduM_Transmit()
  
Test Precondition: 
  
Test Execution: 
    01: Call IpduM_Transmit() with and SduLength of 0
    02: VP(IPDUM.EB.ZeroPduLength.Transmission):
        The PDU is silently ignored, nothing is invoked.
    03: Nothing's invoked even when the SendTimeout would expire.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.ZeroPduLength.Transmission</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>890</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14005_CntrTx_Update_Bit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>600</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_DIRECT, the IpduM shall trigger the
    Container PDU when all contained I-PDUs were updated by the upper layer.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has offset 1, update bit 7
    - contained PDU 2 has offset 22, update bit 3
    - contained PDU 3 has offset 43, update bit 0
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 3
    02: Transmit contained PDU 1
    03: Transmit contained PDU 2
    04: Transmission triggered, check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU offset
          [contained PDU 1, 2, 3]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>891</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14006_CntrTx_Unused_Area</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>739</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_DIRECT, the IpduM shall trigger the
    Container PDU when all contained I-PDUs were updated by the upper layer.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - container PDU has IpduMUnusedAreasDefault = 0xAA (170)
    - contained PDU 1 has offset 43, no update bit
    - contained PDU 2 has offset 22, no update bit
    - contained PDU 3 has offset 1, no update bit
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 2
    02: Transmit contained PDU 1
    03: Transmit contained PDU 3
    04: Transmission triggered, container PDU added to queue
        - contained PDU shall be arranged based on their contained PDU offset
          [contained PDU 3, 2, 1]
        - data is requested for contained PDUs
        - contained PDU 2 receives E_NOT when requesting data
    05: Container PDU dequeued, check handle IDs, length and payload
        - check payload and length
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00233</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>892</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14011_CntrTx_Unused_Area_PartialReception</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>900</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_DIRECT, and NO UpdateBits configured,
    the reported length is correct when not all Contained PDUs are accounted for.

    Test mandated by ASCIPDUM-1081.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - container PDU has IpduMUnusedAreasDefault = 0xAA (170)
    - contained PDU 1 has offset 43, no update bit
    - contained PDU 2 has offset 22, no update bit
    - contained PDU 3 has offset 1, no update bit
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit Contained PDU 2
    02: Transmit Contained PDU 1
    03: SendTimeout expires, transmission triggered
    04: Payloads are retrieved, 20 bytes each
    05: Full length of the Container is used during transmission,
        byte pattern used for the slot of Contained PDU 3
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00233</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>336</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>893</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14007_CntrTx_TT_Update_Bit_Different_Bytes</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>1042</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT, the IpduM shall trigger the
    Container PDU when all contained I-PDUs were updated by the upper layer.

    Test altered due to ASCIPDUM-1096.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has offset 1, update bit 168
    - contained PDU 2 has offset 22, update bit 339
    - contained PDU 3 has offset 43, update bit 7
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 1
    02: Transmit contained PDU 3
    03: Transmit contained PDU 2
    04: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC):
        All contained PDUs updated
        PduR_IpduMTransmit() returns E_OK
    05: Call IpduM_TriggerTransmit()
        - check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU offset
          [contained PDU 1, 2, 3]
        - last contained PDU has a length smaller (by 1) than configured PduLength
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>894</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14012_CntrTx_TT_Partial_Update_Bit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>1204</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT, the reported length during
    transmission is suitable for the retrieval of the UpdateBit, while being truncated.

    Test mandated by ASCIPDUM-1081.
    Test altered due to ASCIPDUM-1111.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has offset 1, update bit 168
    - contained PDU 2 has offset 22, update bit 339
    - contained PDU 3 has offset 43, update bit 7
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 1
    02: Transmit contained PDU 2
    03: Call Main Function Tx for 3 times
        - send timeout expires, transmission triggered
    04: SduLength used for transmission is 63
    05: VP(IpduM.EB.SWS_IpduM_00243):
        Non-updated PDU is trimmed
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.SWS_IpduM_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>895</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14008_CntrTx_TT_Update_Bit_Different_Bytes_E_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>1349</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with static container layout and
    IpduMContainerTxTriggerMode is set to IPDUM_TRIGGERTRANSMIT, the IpduM shall
    trigger the Container PDU when all contained I-PDUs were updated by the upper layer.

    Retrieval of one Contained PDU fails (PduR_IpduMTriggerTransmit returns E_NOT_OK),
    full length of the Container is used.

    Test altered due to ASCIPDUM-1081
    Test altered due to ASCIPDUM-1096.
    Test altered due to ASCIPDUM-1111.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has offset 1, update bit 168
    - contained PDU 2 has offset 22, update bit 339
    - contained PDU 3 has offset 42, update bit 7
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 1
    02: Transmit contained PDU 3
    03: Transmit contained PDU 2
    04: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC):
        PduR_IpduMTransmit() called and returns E_OK
    05: Call IpduM_TriggerTransmit()
        - check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU offset
          [contained PDU 1, 2, 3]
        - last contained PDU is not updated
    06: VP(IpduM.EB.SWS_IpduM_00243):
        The non-updated PDU is trimmed
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.ALL_STATIC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>627</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00246</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>346</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00235</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>338</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00232</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>335</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.SWS_IpduM_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>896</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_14013_CntrTx_Unused_Area_PartialReception2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_14_Static_Container_Handling/source/application/Tests.c</sourcefile>
      <sourceline>1519</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that the Container is trimmed.

    Test mandated by ASCIPDUM-1111.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - container PDU has a configured length of 48, 44 bytes allocated
    - container PDU has IpduMUnusedAreasDefault = 0xAA (170)
    - contained PDU 1 has offset 0, no update bit
    - contained PDU 2 has offset 16, no update bit
    - contained PDU 3 has offset 24, no update bit
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit Contained PDU 1
    02: VP(IpduM.EB.SWS_IpduM_00243):
        SendTimeout expires, transmission with correct length of 16
    03: Transmit Contained PDU 2
    04: VP(IpduM.EB.SWS_IpduM_00243):
        SendTimeout expires, transmission with correct length of 24
    05: Transmit Contained PDU 3
    06: VP(IpduM.EB.SWS_IpduM_00243):
        SendTimeout expires, transmission with correct length of 44
    07: Transmit Contained PDUs 1 and 3
    08: VP(IpduM.EB.SWS_IpduM_00243):
        SendTimeout expires, transmission with correct length of 44
    09: Transmit Contained PDUs 2 and 3
    10: VP(IpduM.EB.SWS_IpduM_00243):
        SendTimeout expires, transmission with correct length of 44
    11: Transmit Contained PDUs 1 and 2
    12: VP(IpduM.EB.SWS_IpduM_00243):
        SendTimeout expires, transmission with correct length of 24
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.SWS_IpduM_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>897</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_15001_CntrTx_DT_Priority_On_With_DifferentValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_15_ContainedTxPrio/source/application/Tests.c</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with IpduMContainedTxPduPriorityHandling enabled and
    IpduMContainerTxTriggerMode set to IPDUM_DIRECT, the IpduM shall order the containeds by the priority.
    Priority defined for ContainedTxPdu. 255 represents the lowest priority and 0 represent the highest priority.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has the priority 5
    - contained PDU 2 has the priority 255
    - contained PDU 3 has the priority 55
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 2
    02: Transmit contained PDU 3
    03: Transmit contained PDU 1
    04: Transmission triggered, check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU priority
          [contained PDU 1, 3, 2]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>898</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_15002_CntrTx_DT_Priority_On_With_SameValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_15_ContainedTxPrio/source/application/Tests.c</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with IpduMContainedTxPduPriorityHandling enabled and
    IpduMContainerTxTriggerMode set to IPDUM_DIRECT, the IpduM shall order the containeds by the priority.
    Priority defined for ContainedTxPdu. 255 represents the lowest priority and 0 represent the highest priority.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has the priority 0
    - contained PDU 2 has the priority 0
    - contained PDU 3 has the priority 0
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 1
    02: Transmit contained PDU 3
    03: Transmit contained PDU 2
    04: Transmission triggered, check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU priority
          [contained PDU 1, 3, 2]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>899</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_15003_CntrTx_TT_Priority_On_With_DifferentValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_15_ContainedTxPrio/source/application/Tests.c</sourcefile>
      <sourceline>316</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with IpduMContainedTxPduPriorityHandling enabled and
    IpduMContainerTxTriggerMode set to IPDUM_TRIGGERTRANSMIT, the IpduM shall order the containeds by the priority.
    Priority defined for ContainedTxPdu. 255 represents the lowest priority and 0 represent the highest priority.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has the priority 106
    - contained PDU 2 has the priority 40
    - contained PDU 3 has the priority 12
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 1
    02: Transmit contained PDU 2
    03: Transmit contained PDU 3
    04: Call Main Function Tx for 3 times
        - send timeout expires, transmission triggered
    05: Call IpduM_TriggerTransmit()
        - check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU priority
          [contained PDU 3, 2, 1]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>900</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_15004_CntrTx_TT_Priority_On_With_SameValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_15_ContainedTxPrio/source/application/Tests.c</sourcefile>
      <sourceline>467</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with IpduMContainedTxPduPriorityHandling enabled and
    IpduMContainerTxTriggerMode set to IPDUM_DIRECT, the IpduM shall order the containeds by the priority.
    Priority defined for ContainedTxPdu. 255 represents the lowest priority and 0 represent the highest priority.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has the priority 255
    - contained PDU 2 has the priority 255
    - contained PDU 3 has the priority 255
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 1
    02: Transmit contained PDU 3
    03: Transmit contained PDU 2
    04: Call Main Function Tx for 3 times
        - send timeout expires, transmission triggered
    05: Call IpduM_TriggerTransmit()
        - check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU priority
          [contained PDU 1, 3, 2]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>901</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_15005_CntrTx_DT_Priority_On_With_DifferentValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_15_ContainedTxPrio/source/application/Tests.c</sourcefile>
      <sourceline>619</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with IpduMContainedTxPduPriorityHandling enabled and
    IpduMContainerTxTriggerMode set to IPDUM_DIRECT, the IpduM shall order the containeds by the priority.
    Priority defined for ContainedTxPdu. 255 represents the lowest priority and 0 represent the highest priority.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has the priority 5
    - contained PDU 2 has the priority 255
    - contained PDU 3 has the priority 55
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 2
    02: Transmit contained PDU 1
    03: Transmit contained PDU 3
    04: Transmission triggered, check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU priority
          [contained PDU 1, 3, 2]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>316</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
        <provcov>
          <linksto>IpduM.ECUC_IpduM_00210</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>902</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_15006_Priority_On_PartialNoValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_15_ContainedTxPrio/source/application/Tests.c</sourcefile>
      <sourceline>752</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with IpduMContainedTxPduPriorityHandling enabled and no value
    provided for IpduMContainedTxPduPriority, the default value of 255 is considered.

    Test mandated by ASCIPDUM-1080
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has the priority 15
    - contained PDU 2 has the priority NOT SPECIFIED (thus, 255)
    - contained PDU 3 has the priority 200
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 2
    02: Transmit contained PDU 3
    03: Transmit contained PDU 1
    04: SendTimeout expires
    05: Transmission triggered, check handle IDs, length and payload
        - contained PDU shall be arranged based on their contained PDU priority
          [contained PDU 1, 3, 2]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>903</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_15007_Priority_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_15_ContainedTxPrio/source/application/Tests.c</sourcefile>
      <sourceline>896</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that verifies that for Container PDUs with IpduMContainedTxPduPriorityHandling enabled and no value
    provided for IpduMContainedTxPduPriority, the default value of 255 is considered.
    As such, priority handling is OFF for the Container.

    Test is similar to:
    * TS_IPDUM_CON_15002_CntrTx_DT_Priority_On_With_SameValues
    * TS_IPDUM_CON_15004_CntrTx_TT_Priority_On_With_SameValues

    Test mandated by ASCIPDUM-1080
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduM module shall be initialized.
    - contained PDU 1 has the priority NOT SPECIFIED (thus, 255)
    - contained PDU 2 has the priority NOT SPECIFIED (thus, 255)
    - contained PDU 3 has the priority NOT SPECIFIED (thus, 255)
  
Test Execution: 
    00: Initialize IpduM
    01: Transmit contained PDU 2
    02: Transmit contained PDU 3
    03: Transmit contained PDU 1
    04: SendTimeout expires
    05: Transmission triggered, check handle IDs, length and payload
        - contained PDU shall be arranged based on the order of their arrival
          [contained PDU 2, 3, 1]
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00248</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>904</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_16000_Variant0</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_16_PBSelectable/source/application/Tests.c.m4</sourcefile>
      <sourceline>99</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that parameter values differ and are generated correctly from the configuration.
    Config under test: IpduM_Config_SelectableVariant0
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMCntr1Rx has IpduMContainerRxAcceptContainedPdu set as IPDUM_ACCEPT_CONFIGURED
    IpduMCntr2Rx has IpduMContainerHeaderSize set as IPDUM_HEADERTYPE_SHORT
                 has IpduMContainerPduProcessing set as IPDUM_PROCESSING_DEFERRED
    IpduMCntr1Tx has IpduMContainerTxFirstContainedPduTrigger set as FALSE.
    IpduMCntr6Tx has IpduMContainerHeaderSize set as IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: VP(IpduM.EB.PBSelectable.Master): Check that IpduM_PBcfg.h exists and can be included
    02: VP(IpduM.EB.PBSelectable.FileName): Verify that files IpduM_SelectableVariant0_PBcfg.h,
        IpduM_SelectableVariant1_PBcfg.h, IpduM_SelectableVariant0Lcfg.h and
        IpduM_SelectableVariant1Lcfg.h exist.
    03: VP(IpduM.EB.PBSelectable.TypeName): Verify that types IpduM_SelectableVariant0_ConstConfigLayoutType
        and IpduM_SelectableVariant1_ConstConfigLayoutType exist.
    04: 2 of the 3 Contained PDUs are extracted since the container is IPDUM_ACCEPT_CONFIGURED
    05: IPDUM_PROCESSING_DEFERRED, 2 Contained PDUs are extracted in the MainFunction, short header,
        the second one having the Header ID 22.
    06: Tx Container triggered due to size (reaching 60) (IpduMCntr1Tx)
    07: Tx Container triggered by TRIGGER_ALWAYS Contained PDU, short header (IpduMCntr6Tx)
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PBSelectable.Master</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBSelectable.FileName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBSelectable.TypeName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>905</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_16001_Variant1</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_16_PBSelectable/source/application/Tests.c.m4</sourcefile>
      <sourceline>305</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that parameter values differ and are generated correctly from the configuration.
    Config under test: IpduM_Config_SelectableVariant1
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMCntr1Rx has IpduMContainerRxAcceptContainedPdu set as IPDUM_ACCEPT_ALL.
    IpduMCntr2Rx has IpduMContainerHeaderSize set as IPDUM_HEADERTYPE_LONG
                 has IpduMContainerPduProcessing set as IPDUM_PROCESSING_IMMEDIATE
    IpduMCntr1Tx has IpduMContainerTxFirstContainedPduTrigger set as TRUE.
    IpduMCntr6Tx has IpduMContainerHeaderSize set as IPDUM_HEADERTYPE_LONG.
  
Test Execution: 
    01: VP(IpduM.EB.PBSelectable.Master): Check that IpduM_PBcfg.h exists and can be included
    02: VP(IpduM.EB.PBSelectable.FileName): Verify that files IpduM_SelectableVariant0_PBcfg.h,
        IpduM_SelectableVariant1_PBcfg.h, IpduM_SelectableVariant0Lcfg.h and
        IpduM_SelectableVariant1Lcfg.h exist.
    03: VP(IpduM.EB.PBSelectable.TypeName): Verify that types IpduM_SelectableVariant0_ConstConfigLayoutType
        and IpduM_SelectableVariant1_ConstConfigLayoutType exist.
    04: All 3 Contained PDUs are extracted since the container is IPDUM_ACCEPT_ALL
    05: IPDUM_PROCESSING_IMMEDIATE, 2 Contained PDUs are extracted with long header, the second one having
        the Header ID 222.
    06: Tx Container triggered due to IpduMContainerTxFirstContainedPduTrigger (IpduMCntr1Tx)
    07: Tx Container triggered by TRIGGER_ALWAYS Contained PDU, long header (IpduMCntr6Tx)
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.PBSelectable.Master</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBSelectable.FileName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.PBSelectable.TypeName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>906</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_RxMetaData_Immediate</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_17_Rx_MetaData/source/application/Tests.c</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU, the data is forwarded to PduR via
    PduR_IpduMRxIndication() and forward the received MetaData along with all demultiplexed parts.
  &lt;/para&gt;
  
Test Object: Metadata
Test Precondition: 
    IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs and is IMMEDIATE
    02: VP(IpduM.EB.MetaData.Rx.GetMetadata, IPDUM.EB.IpduMMetaDataSupport):
        EcuC_CopyMetaDataTypeFromPdu() is called to retrieve the metadata of the received container.
    03: VP(IpduM.EB.MetaData.Rx.SetMetadata, IPDUM.EB.IpduMMetaDataSupport, IpduM.SWS_IpduM_00209):
        For each contained Pdu:
        - Metadata is correctly set via EcuC_CopyMetaDataTypeToPdu().
        - PduR_IpduMRxIndication() is called with correct data.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.GetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.SetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>907</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_RxMetaData_Deffered</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_17_Rx_MetaData/source/application/Tests.c</sourcefile>
      <sourceline>278</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU, the data is forwarded to PduR via
    PduR_IpduMRxIndication() and forward the received MetaData along with all demultiplexed parts.
  &lt;/para&gt;
  
Test Object: Metadata
Test Precondition: 
    IpduMContainerPduProcessing is set to IPDUM_PROCESSING_DEFFERED.
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_SHORT.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs and is DEFFERED.
    02: Call IpduM_MainfunctionRx() to process the received container.
    03: VP(IpduM.EB.MetaData.Rx.GetMetadata, IPDUM.EB.IpduMMetaDataSupport):
        EcuC_CopyMetaDataTypeFromPdu() is called to retrieve the metadata of the received container.
    04: VP(IpduM.EB.MetaData.Rx.SetMetadata, IPDUM.EB.IpduMMetaDataSupport, IpduM.SWS_IpduM_00209):
        For IpduMContainedRxPdu_6:
        - Metadata is not called because the Pdu doesn't have it configured.
        - PduR_IpduMRxIndication() is called with correct data.
        For IpduMContainedRxPdu_7:
        - Metadata is correctly set via EcuC_CopyMetaDataTypeToPdu().
        - PduR_IpduMRxIndication() is called with correct data.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.GetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.SetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>908</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_RxMetaData_Static</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_17_Rx_MetaData/source/application/Tests.c</sourcefile>
      <sourceline>423</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU, the data is forwarded to PduR via
    PduR_IpduMRxIndication() and forward the received MetaData along with all demultiplexed parts.
  &lt;/para&gt;
  
Test Object: Metadata
Test Precondition: 
    IpduMContainerPduProcessing is set to IPDUM_PROCESSING_IMMEDIATE.
    IpduMContainerRxAcceptContainedPdu set to IPDUM_ACCEPT_CONFIGURED.
    IpduMContainerHeaderSize is set to IPDUM_HEADERTYPE_NONE.
  
Test Execution: 
    01: Call IpduM_RxIndication() using a container handle ID which accepts configured
        contained I-PDUs. The container doesn't have an header configured and is IMMEDIATE.
    02: VP(IpduM.EB.MetaData.Rx.GetMetadata, IPDUM.EB.IpduMMetaDataSupport):
        EcuC_CopyMetaDataTypeFromPdu() is called to retrieve the metadata of the received container.
    03: VP(IpduM.EB.MetaData.Rx.SetMetadata, IPDUM.EB.IpduMMetaDataSupport, IpduM.SWS_IpduM_00209):
        For IpduMContainedRxPdu_3 and IpduMContainedRxPdu_5:
        - Metadata is correctly set via EcuC_CopyMetaDataTypeToPdu().
        - PduR_IpduMRxIndication() is called with correct data.
        For IpduMContainedRxPdu_4:
        - Metadata is not called because the Pdu doesn't have it configured.
        - PduR_IpduMRxIndication() is called with correct data.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.GetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.SetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>909</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_RxMetaData_Negative</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_17_Rx_MetaData/source/application/Tests.c</sourcefile>
      <sourceline>591</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that each contained I-PDU is extracted in the same order as the I-PDUs
    are located inside the container PDU, the data is forwarded to PduR via PduR_IpduMRxIndication().
    Since no metadada is configured for these containers, there will be no interaction with EcuC.
  &lt;/para&gt;
  
Test Object: Metadata
Test Precondition: 
    Two containers with no metadata configured.
    One container has IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_SHORT,
    the other has it set to IPDUM_HEADERTYPE_NONE.
  
Test Execution: 
    01: Call IpduM_RxIndication() for a container with no metadata configured and
        IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_SHORT.
    02: VP(IpduM.EB.MetaData.Rx.SetMetadata, IPDUM.EB.IpduMMetaDataSupport, IpduM.SWS_IpduM_00209):
        For the contained Pdu:
        - Metadata is not called because it is not configured.
        - PduR_IpduMRxIndication() is called with correct data.
    03: Call IpduM_RxIndication() for a container with no metadata configured and
        IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE.
    04: VP(IpduM.EB.MetaData.Rx.SetMetadata, IPDUM.EB.IpduMMetaDataSupport, IpduM.SWS_IpduM_00209):
        For the contained Pdu:
        - Metadata is not called because it is not configured.
        - PduR_IpduMRxIndication() is called with correct data.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00209</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>305</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.GetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Rx.SetMetadata</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>910</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_1801_Tx_MetaData</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_18_Tx_MetaData/source/application/Tests.c.m4</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
  Test MetaData Handling for Transmission and trigger the container in case the contained PDU has different metadata value than for the current container instance.
  Test the padding vaules are added correctly.
m4_ifelse(PM_IpduMMetaDataTxPrioritySupport,ENABLED,\-:m4_dnl
  Test the priority handling.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  Configure metadata for some Contained PDUs
  IpduMContainedTxPduCollectionSemantics set as PM_IPDUM_COLLECT_SEMANTICS
  IpduMMetaDataTxPrioritySupport set as PM_IpduMMetaDataTxPrioritySupport
  
Test Execution: 
  01: Initialize IpduM
  02: Initialize EcuC_GetMetaDataCanId (0x18A2FF0D)
  03: Call IpduM_Transmit for IpduMContainedTxPdu_1
  04: IpduMContainerTxPdu_1 should have metadata=0xFF0D
  05: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.FirstRequest):
      Check call of EcuC_GetMetaDataCanId
  06: Initialize EcuC_GetMetaDataCanId (0x1CFEFA0D)
  07: Call IpduM_Transmit for IpduMContainedTxPdu_7
  08: IpduMContainerTxPdu_1 should have metadata=0xFF0D which is the same as the first Contained PDU
  09: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData)
      Check call of EcuC_GetMetaDataCanId
  10: Call IpduM_Transmit for IpduMContainedTxPdu_3
  11: The calculated Metadata is 0xFA0D which is different than the current instance of the container_1 0xFF0D which will trigger the first instance &amp;
      Add the new request with new instance and with new calculated metaData value =0xFF0D.
  12: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData\-::-/m4_ifelse(PM_IpduMMetaDataTxPrioritySupport,ENABLED,\-:, IpduM.EB.MetaData.Tx.Priority.Establish, IpduM.EB.MetaData.Tx.Priority.Transmit:-/))
      Check call of EcuC_SetMetaDataCanId
  13: VP(IpduM.EB.CanFdPadding.IpduMCanFdPaddingService, IpduM.EB.CanFdPadding.IpduMCanFdPaddingSupport IpduM.EB.CanFdPadding.Restrictions, IpduM.EB.CanFdPadding.Behavior)
       Check call of PduR_IpduMTransmit &amp; the transmitted data (including the padding)
  14: Initialize EcuC_GetMetaDataCanId (0x0000FA0F)
  15: The calculated Metadata is 0xFA0F which is the different as the current instance of the container_1 has metaData 0xFA0D
      add new instance with metadata 0xFA0F which will be triggered as the Contained PDU has IPDUM_TRIGGER_ALWAYS so this new instance will be triggered and with metaData Value =0xFA0F
  16: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData)
      Check call of EcuC_GetMetaDataCanId
  17: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData,IpduM.EB.CanFdPadding.IpduMCanFdPaddingService,  IpduM.EB.CanFdPadding.IpduMCanFdPaddingSupport IpduM.EB.CanFdPadding.Restrictions, IpduM.EB.CanFdPadding.Behavior)
      Check call of EcuC_SetMetaDataCanId &amp; PduR_IpduMTransmit twice
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.ContainerTxMetaData.FirstRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.MetaData.IpduMTxMetaDataValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.MetaData.IpduMTxMetaDataMask</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.StoreTxMetaData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.ContainerTxMetaData.Request</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.IpduMCanFdPaddingSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.IpduMCanFdPaddingService</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.Restrictions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Establish</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>911</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_1802_Tx_MetaData_Mainfunction</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_18_Tx_MetaData/source/application/Tests.c.m4</sourcefile>
      <sourceline>315</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
  Test MetaData Handling for Transmission and trigger the container in case the contained PDU has different metadata value than for the current container instance
m4_ifelse(PM_IpduMMetaDataTxPrioritySupport,ENABLED,\-:m4_dnl
  Test the priority handling.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  Configure metadata for some Contained PDUs
  Contained PDUs are configured as IPDUM_COLLECT_QUEUED
  IpduMMetaDataTxPrioritySupport configured as PM_IpduMMetaDataTxPrioritySupport
  
Test Execution: 
  01: Initialize IpduM
  02: Initialize EcuC_GetMetaDataCanId (0x18A2FF0D)
  03: call of IpduM_Transmit for IpduMContainedTxPdu_1
  04: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.FirstRequest):
      IpduMContainerTxPdu_1 should have metadata=0xFF0D
      Check call of EcuC_GetMetaDataCanId
  05: Initialize EcuC_GetMetaDataCanId (0x1CFEFA0D)
  06: Call IpduM_Transmit for IpduMContainedTxPdu_7
  07: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData)
      IpduMContainerTxPdu_1 should have metadata=0xFF0D which is the same as the first Contained PDU
      Check call of EcuC_GetMetaDataCanId
  08: Call IpduM_Transmit for IpduMContainedTxPdu_3
  09: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData)
      The calculated Metadata is 0xFA0D which is different than the current instance of the container_1 0xFF0D which will trigger the first instance &amp;
      Add the new request with new instance and with new calculated metaData value =0xFF0D.
      PduR_IpduMTransmit() returns E_NOT_OK.
      Check call of EcuC_SetMetaDataCanId
      Check call of PduR_IpduMTransmit
  10: Call IpduM_MainFunctionTx to retry the transmission.
  11: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData\-::-/m4_ifelse(PM_IpduMMetaDataTxPrioritySupport,ENABLED,\-:, IpduM.EB.MetaData.Tx.Priority.Establish, IpduM.EB.MetaData.Tx.Priority.Transmit:-/))
      Check call of EcuC_SetMetaDataCanId
      Check call of PduR_IpduMTransmit
  12: Initialize EcuC_GetMetaDataCanId (0x0000FA0F)
  13: The calculated Metadata is 0xFA0F which is the different as the current instance of the container_1 has metaData 0xFA0D
      Add new instance with metadata 0xFA0F which will be triggered as the Contained PDU has IPDUM_TRIGGER_ALWAYS so this new instance will be triggered and with metaData Value =0xFA0F
      Call IpduM_Transmit()
  14: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData)
      Check call of EcuC_GetMetaDataCanId
  15: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData)
      Check call of EcuC_SetMetaDataCanId &amp; PduR_IpduMTransmit twice
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.ContainerTxMetaData.FirstRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.MetaData.IpduMTxMetaDataValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.MetaData.IpduMTxMetaDataMask</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.StoreTxMetaData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.ContainerTxMetaData.Request</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Establish</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>912</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_1803_Tx_MetaData_NoMetadata</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_18_Tx_MetaData/source/application/Tests.c.m4</sourcefile>
      <sourceline>562</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  &lt;para&gt;
  Negative test for MetaData Handling on Transmission.
  Metadata will not be Get and Set if the container and contained Pdus don't have metadata configured.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
  Metadata feature is enabled.
  Metadata is not configured for the container and contained Pdus.
  
Test Execution: 
  01: Initialize IpduM
  02: Call IpduM_Transmit for IpduMContainedTxPdu_2
  03: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.FirstRequest):
      EcuC_GetMetaDataCanId is not called.
      EcuC_SetMetaDataCanId is not called.
      PduR_IpduMTransmit() returns E_NOT_OK.
  04: Call IpduM_MainFunctionTx to retry the transmission.
  05: VP(IPDUM.EB.MetaData.IpduMTxMetaDataValue, IPDUM.EB.MetaData.IpduMTxMetaDataMask, IpduM.EB.MetaData.ContainerTxMetaData.Request, IpduM.EB.MetaData.StoreTxMetaData)
      EcuC_GetMetaDataCanId is not called.
      EcuC_SetMetaDataCanId is not called.
      PduR_IpduMTransmit() returns E_OK.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.ContainerTxMetaData.FirstRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.MetaData.IpduMTxMetaDataValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.MetaData.IpduMTxMetaDataMask</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.StoreTxMetaData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.ContainerTxMetaData.Request</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>913</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_19000_PrioCQ</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_19_Tx_MetaDataPrio/source/application/Tests.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test MetaData Priority handling (transmission) for IPDUM_COLLECT_QUEUED Containers.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Configured MetaData
    IpduMContainedTxPduCollectionSemantics set as IPDUM_COLLECT_QUEUED
    IpduMMetaDataTxPrioritySupport ENABLED
    IpduMMetaDataSupport DISABLED
    IpduMHeaderByteOrder set as IPDUM_LITTLE_ENDIAN
    IpduMContainerQueueSize set as 2
  
Test Execution: 
    01: Add first ContainedPdu, Priority: 6
    02: Add second ContainedPdu, Priority: 4
    03: Add third ContainedPdu, TRIGGER_ALWAYS, Priority: 5
        PduR_IpduMTransmit returns E_NOT_OK, instance queued
    04: VP(IpduM.EB.MetaData.Tx.Priority.Establish):
        Priority of the Container is 4
    05: VP(IpduM.EB.MetaData.Tx.Priority.Transmit):
        MetaData of the Container is updated
    06: Instance queued, payload OK
    07: Add first ContainedPdu to new instance, Priority: 2
    08: Add first ContainedPdu to new instance, Priority: 3
    09: Container dequeued in MF
    10: VP(IpduM.EB.MetaData.Tx.Priority.Transmit):
        MetaData of the Container is updated: 4
    11: SendTimeout expires for second instance
    12: VP(IpduM.EB.MetaData.Tx.Priority.Transmit):
        MetaData of the Container is updated: 2
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataTxPrioritySupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Establish</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>914</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_19001_PrioLB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_19_Tx_MetaDataPrio/source/application/Tests.c</sourcefile>
      <sourceline>259</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test MetaData Priority handling (transmission) for IPDUM_COLLECT_LAST_IS_BEST Containers.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Configured MetaData
    IpduMContainedTxPduCollectionSemantics set as IPDUM_COLLECT_LAST_IS_BEST
    IpduMMetaDataTxPrioritySupport ENABLED
    IpduMMetaDataSupport DISABLED
    IpduMHeaderByteOrder set as IPDUM_LITTLE_ENDIAN
  
Test Execution: 
    01: Add first ContainedPdu, Priority: 5
    02: Add second ContainedPdu, Priority: None, MetaData not configured
    03: Transmit first ContainedPdu again, update priority, Priority: 1
    04: Add third ContainedPdu, TRIGGER_ALWAYS, Priority: 3, instance full,
        PduR_IpduMTransmit returns E_NOT_OK, queued
    05: VP(IpduM.EB.MetaData.Tx.Priority.Establish, IpduM.EB.MetaData.Tx.Priority.Transmit):
        Container priority set to 1
    06: Add first ContainedPdu to second instance, Priority: 6
    07: Dequeue first instance
    08: Priority set correctly, instance transmitted
    09: SendTimeout expires for second instance, priority correctly set to 6
        (Priority set on correct instance)
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataTxPrioritySupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Establish</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>915</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_19002_NoPrioCntdCQ</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_19_Tx_MetaDataPrio/source/application/Tests.c</sourcefile>
      <sourceline>474</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test MetaData Priority handling (transmission) for IPDUM_COLLECT_QUEUED Containers
    which have no ContainedPdus with MetaData configured
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Configured MetaData
    IpduMContainedTxPduCollectionSemantics set as IPDUM_COLLECT_QUEUED
    IpduMMetaDataTxPrioritySupport ENABLED
    IpduMMetaDataSupport DISABLED
    IpduMHeaderByteOrder set as IPDUM_LITTLE_ENDIAN
    IpduMContainerTxFirstContainedPduTrigger set
  
Test Execution: 
    01: ContainedPdu added to instance, no MetaData configured
        IpduMContainerTxFirstContainedPduTrigger set for the Container
    02: VP(IpduM.EB.MetaData.Tx.Priority.Transmit,
           IpduM.EB.MetaData.Tx.Priority.Transmit.NoContainedPrio):
        No MetaData for the Contained, Priority set to lowest
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit.NoContainedPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>916</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_19003_NoPrioCntdLB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Conformance/IN/IpduM_ConTest_19_Tx_MetaDataPrio/source/application/Tests.c</sourcefile>
      <sourceline>563</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test MetaData Priority handling (transmission) for IPDUM_COLLECT_LAST_IS_BEST Containers
    which have no ContainedPdus with MetaData configured
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Configured MetaData
    IpduMContainedTxPduCollectionSemantics set as IPDUM_COLLECT_LAST_IS_BEST
    IpduMMetaDataTxPrioritySupport ENABLED
    IpduMMetaDataSupport DISABLED
    IpduMHeaderByteOrder set as IPDUM_LITTLE_ENDIAN
    IpduMContainerTxFirstContainedPduTrigger set
  
Test Execution: 
    01: ContainedPdu added to instance, no MetaData configured
        IpduMContainerTxFirstContainedPduTrigger set for the Container
    02: VP(IpduM.EB.MetaData.Tx.Priority.Transmit,
           IpduM.EB.MetaData.Tx.Priority.Transmit.NoContainedPrio):
        No MetaData for the Contained, Priority set to lowest
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.MetaData.Tx.Priority.Transmit.NoContainedPrio</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>917</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_GEN_01000_SelUpperBoundViolation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_01_SelectorField/source/application/test_config.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a configuration error is reported if the selector field
      is not fully part of one segment within each dynamic part while IpduMTxAutomaticSelector
      is disabled. Therefore the selector field is moved to a position where it is only
      partly covered by one dynamic segment but still fully covered by the other dynamic
      segments.
      The test is applied without using the destination bit parameter of the
      configured segments.

      This test focuses on partly containment of the selector field by violating the
      upper bound of the corresponding dynamic segment by changing the selector
      field position.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMTxAutomaticSelector is disabled
    - Selector field set to an arbitrary byte within PDU (IpduMTxPathway_0)
    -- IpduMSelectorFieldPosition: 32
    -- IpduMSelectorFieldLength: 2
    - Each dynamic part specifies exactly one segment enclosing the selector field
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration by setting IpduMSelectorFieldPosition
        to a value where it violates the upper bound of exactly one dynamic segment but is
        still fully contained by the other dynamic segments of
        /IpduM/IpduM/Ipdum_Config_0/IpduMTxPathway_0/IpduMTxRequest
    02: VP:
        The MCG must issue an error that the selector field must be fully contained within one
        segment of each dynamic part
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM558</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>918</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_01010_SelFullyContainment</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_01_SelectorField/source/application/test_config.h</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a configuration error is reported if the selector field
      is not fully part of one segment within each dynamic part while IpduMTxAutomaticSelector
      is disabled. Therefore one dynamic segment containing the selector field is moved to a
      position completely outside of the selector field by configuring the IpduMDestinationBit
      accordingly.

      This test focuses on fully containment of the selector field by using copy routines.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMTxAutomaticSelector is disabled
    - Selector field set to first byte within PDU (IpduMTxPathway_1)
    -- IpduMSelectorFieldPosition: 6
    -- IpduMSelectorFieldLength: 2
    - One dynamic part (IpduMTxDynamicPart_1_0) configured with a segment having
      IpduMSegmentLength and IpduMSegmentPosition greater than 8 but IpduMDestinationBit
      smaler than IpduMSelectorFieldPosition
    - One dynmic part (IpduMTxDynamicPart_1_1) configured with a segement at the first
      byte enclosing the selector field (IpduMDestinationBit is disabled)
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration by enabling
    IpduMTxDynamicPart_1_1/IpduMSegment_0/IpduMDestinationBit and setting it to 32 (selector field
    is not contained in segment anymore)
    02: VP:
        The MCG must issue an error that the selector field must be fully contained within one
        segment of each dynamic part
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM558</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>919</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_01020_SelLowerBoundViolation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_01_SelectorField/source/application/test_config.h</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test verifies for disabled IpduMTxAutomaticSelector if a generator error is reported in
      case the selector field is only partly contained within a segment of the dynamic part.
      Therefore one dynamic segment containing the selector field is moved to a position
      where the selector field is only partly contained.

      This test focuses on partly containment of the selector field by violating the
      lower bound of the corresponding dynamic segment by changing the segment position.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMTxAutomaticSelector is disabled
    - Selector field set to an arbitrary byte within PDU (IpduMTxPathway_0)
    -- IpduMSelectorFieldPosition: 32
    -- IpduMSelectorFieldLength: 2
    - Each dynamic part specifies exactly one segment enclosing the selector field
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration by setting IpduMSegmentPosition of
        IpduMCopyBitField_0_0 to 33. In this case the selector field is only partly contained
        in IpduMCopyBitField_0_0 by violating the lower bound of the segment.
    02: VP:
        The MCG must issue an error that the selector field must be fully contained within one
        segment of each dynamic part
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM558</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>920</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_GEN_02000_AutoSelLowerBoundViolation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_02_SelectorField/source/application/test_config.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a configuration warning is reported if the selector field
      is partly covered by any segment of the dynamic part while IpduMTxAutomaticSelector
      is enabled. Therefore the selector field is moved to a position where it is
      (partly) contained by at least one dynamic segment.

      This test focuses on partly containment of the selector field by violating the
      lower bound of the corresponding dynamic segment(s) by changing the selector
      field position.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMTxAutomaticSelector is enabled
    - Selector field set to an arbitrary byte within PDU (IpduMTxPathway_0) without overlapping
      with any of the static and dynamic segments
    -- IpduMSelectorFieldPosition: 32
    -- IpduMSelectorFieldLength: 2
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration by setting IpduMSelectorFieldPosition
        to a value where it violates the lower bound of at least one segment of the dynamic part
    02: VP:
        The MCG must issue a warning for each dynamic segment the selector field overlaps
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM559</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>921</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_02010_AutoSelFullyContainment</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_02_SelectorField/source/application/test_config.h</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a configuration warning is reported if the selector field
      is fully covered by at least one dynamic segment while IpduMTxAutomaticSelector
      is enabled. By using IpduMDestinationBit a dynamic segment is moved to a position where
      it fully contains the selector field.

      This test focuses on copy routines and fully containment of the selector field.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMTxAutomaticSelector is enabled
    - Selector field set to first byte within PDU (IpduMTxPathway_1)  without overlapping
      with any of the static and dynamic segments considering IpduMDestinationBit
    -- IpduMSelectorFieldPosition: 6
    -- IpduMSelectorFieldLength: 2
    - One dynamic part (IpduMTxDynamicPart_1_0) configured with a segment having
      IpduMSegmentLength smaler than 6, IpduMSegmentPosition greater than 8, and IpduMDestinationBit
      set to 0
    - One dynmic part (IpduMTxDynamicPart_1_1) configured with a segement right befor the
      selector field and a segment right after the selector field (IpduMDestinationBit is disabled)
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration by enabling
        IpduMTxDynamicPart_1_1/IpduMSegment_0/IpduMDestinationBit and setting it to 2 (selector field
        is fully contained by first segment of IpduMTxDynamicPart_1_1)
    02: VP:
        The MCG must issue a warning that the selector field should not be part of a segment if
        IpduMTxAutomaticSelector is enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM559</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>922</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_02015_AutoSelFullyStaticContainment</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_02_SelectorField/source/application/test_config.h</sourcefile>
      <sourceline>90</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test verifies for enabled IpduMTxAutomaticSelector if a generator warning is reported in
      case the selector field is fully contained within any segment of the static part.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMTxAutomaticSelector is enabled
    - Selector field set to an arbitrary byte within PDU (IpduMTxPathway_2)
    -- IpduMSelectorFieldPosition: 5
    -- IpduMSelectorFieldLength: 2
    - The selector field is not part of any static or dynamic segment
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration by moving the selector field
        to a position where it is fully contained by a static segment
    02: VP:
        The MCG must issue a warning that the selector field should not be part
        of a static segment.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM559</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>923</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_02020_AutoSelUpperBoundViolation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_02_SelectorField/source/application/test_config.h</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a configuration warning is reported if the selector field
      is partly covered by any segment of the dynamic part while IpduMTxAutomaticSelector
      is enabled. Therefore the selector field is moved to a position where it is
      (partly) contained by at least one dynamic segment.

      This test focuses on partly containment of the selector field by violating the
      upper bound of the corresponding dynamic segment(s) by changing the selector
      field position.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMTxAutomaticSelector is enabled
    - Selector field set to an arbitrary byte within PDU (IpduMTxPathway_0)
    -- IpduMSelectorFieldPosition: 32
    -- IpduMSelectorFieldLength: 2
    - The selector field is not part of any static or dynamic segment
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration by moving the selector field
        to a position where it violates the upper bound of at least one dynamic segment
    02: VP:
        The MCG must issue a warning that the selector field should not be part
        of a segment if IpduMTxAutomaticSelector is enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM559</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>924</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_02030_AutoSelStaticBoundViolation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_02_SelectorField/source/application/test_config.h</sourcefile>
      <sourceline>162</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test verifies for enabled IpduMTxAutomaticSelector if a generator warning is reported in
      case the selector field is partly contained within any segment of the static part.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMTxAutomaticSelector is enabled
    - Selector field set to an arbitrary byte within PDU (IpduMTxPathway_2)
    -- IpduMSelectorFieldPosition: 5
    -- IpduMSelectorFieldLength: 2
    - The selector field is not part of any static or dynamic segment
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration by moving the selector field
        to a position where it is partly contained by a static segment
    02: VP:
        The MCG must issue a warning that the selector field should not be part
        of a static segment.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM559</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>925</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_GEN_03000_IpduMContainedTxPduSendTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when all ContainedTxPdus have
      IpduMContainedTxPduSendTimeout disabled and the ContainerTxPdu referenced by them does
      not provide IpduMContainerTxSendTimeout.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with IpduMContainerTxSendTimeout disabled for ContainerTxPdu and
        IpduMContainedTxPduSendTimeout disabled for all ContainedTxPdus.
    02: VP:
        The MCG must issue an error that the the ContainerTxPdu has to provide a
        IpduMContainerTxSendTimeout if all the ContainedTxPdu do not provide one.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00218</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>926</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03001_IpduMContainedTxPduConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when ContainedTxPdu has
      IpduMContainedTxPduConfirmation enabled but the referenced ContainerTxPdu has
      IpduMContainerTxConfirmationTimeout disabled.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with IpduMContainedTxPduConfirmation enabled for ContainedTxPdu
        and IpduMContainerTxConfirmationTimeout disabled for ContainerTxPdu.
    02: VP:
        The MCG must issue an error that the ContainerTxPdu has to provide a
        IpduMContainerTxConfirmationTimeout if one ContainedTxPdu has
        IpduMContainedTxPduConfirmation enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR42.SWS_IpduM_00197</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>927</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03002_Mixed_Collection_Semantics</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when one ContainedTxPdu has
      IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_QUEUED and another
      ContainedTxPdu has IpduMContainedTxPduCollectionSemantics set to
      IPDUM_COLLECT_LAST_IS_BEST, both belonging the the same ContainerTxPdu.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with one ContainedTxPdu with IpduMContainedTxPduCollectionSemantics
        set to IPDUM_COLLECT_QUEUED and another ContainedTxPdu having
        IpduMContainedTxPduCollectionSemantics set to IPDUM_COLLECT_LAST_IS_BEST, both belonging
        the the same ContainerTxPdu.
    02: VP:
        The MCG must issue an error saying that mixed IpduMContainedTxPduCollectionSemantics
        are not allowed within a container.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00219</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>928</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03003_Container_Pdu_Length</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when one Contained Tx PDU
      has a PDU length that is greater than its Container Pdu length minus
      IpduMContainerHeaderSize.

      This test is demanded by ASCIPDUM-706.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with one ContainedTxPdu having PDU length set to 5 and its
        Container PDU length having length 8 and IpduMContainerHeaderSize set to
        IPDUM_HEADERTYPE_SHORT and another ContainedTxPdu having PDU length set to
        3 and its Container PDU length having length 8 and IpduMContainerHeaderSize set to
        IPDUM_HEADERTYPE_LONG.
    02: VP:
        The MCG must issue 2 errors saying that ContainerPdu length must be at least the
        size of one Contained Pdu + header size!.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>929</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03005_IpduM_CntdTxPduSendTimeout_TxTimeBase</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>138</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when IpduMContainedTxPduSendTimeout
      is not divisible by IpduMTxTimeBase.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
        The MCG must issue 1 errors saying that timers must be divisible by IpduMTxTimeTimeBase.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntdTxPduSendTimeout_TxTimeBase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>930</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03006_IpduM_CntrTxSendTimeout_TxTimeBase</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>164</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when IpduMContainerTxSendTimeout
      is not divisible by IpduMTxTimeBase.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
        The MCG must issue 1 errors saying that timers must be divisible by IpduMTxTimeTimeBase.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntrTxSendTimeout_TxTimeBase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>931</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03007_IpduM_CntrTxConfirmationTimeout_TxTimeBase</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>190</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when IpduMContainerTxConfirmationTimeout
      is not divisible by IpduMTxTimeBase.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
        The MCG must issue 1 errors saying that timers must be divisible by IpduMTxTimeTimeBase.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntrTxConfirmationTimeout_TxTimeBase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>932</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03008_IpduM_TxFlexAlloc_SingleMF</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>216</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a IpduMTxPathWay and IpduMContainerTxPdu is allocated
      to a single MF.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
        The MCG must issue 2 errors saying that a IpduMTxPathWay and IpduMContainerTxPdu must be allocated
        to a single MF.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMTxProcessing.IpduMTxPduRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>933</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03009_IpduM_RxFlexAlloc_SingleMF</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>243</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a IpduMContainerRxPdu is allocated
      to a single MF.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
        The MCG must issue 1 error saying that a IpduMContainerRxPdu must be allocated
        to a single MF.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMRxProcessing.IpduMRxPduRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>934</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03010_IpduM_Rx_Unique_HeaderIds</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>270</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that an IpduMContainedRxPdu has a unique
      IpduMContainedPduHeaderId with the applicable contraints.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMGeneral/IpduMRxContainerAcceptAllNoRefOnly is TRUE.
    All ContainedPDUs have the same Header ID configured: 3.
  
Test Execution: 
    01: VP(IpduM.SWS_IpduM_00250.UniqueHeaderId):
        The MCG must issue 2 errors saying that IpduMContainedRxPdu_2 and
        IpduMContainedRxPdu_3 must have a unique ID.
    02: VP(IpduM.SWS_IpduM_00251.UniqueHeaderId):
        The MCG must issue 2 errors saying that IpduMContainedRxPdu_4 and
        IpduMContainedRxPdu_5 must have a unique ID.

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00250.UniqueHeaderId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00251.UniqueHeaderId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>406</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>935</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03012_IpduM_CntrRx_MaxPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>305</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that IpduMContainerRxPdu PduLength does not
      exceed IpduMMaxContainerRxLength.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
        The MCG must issue 1 error saying that a IpduMContainerRxPdu
        PduLength exceeds IpduMMaxContainerRxLength.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntrRx.MaxPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>936</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03013_IpduM_CntrRx_NoRefAcceptAll</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>332</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that contained Rx PDU does not
      reference container Rx PDU with IpduMContainerRxAcceptContainedPdu
      set to IPDUM_ACCEPT_ALL.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
        The MCG must issue 1 error saying that a contained Rx PDU
        references a container PDU with IpduMContainerRxAcceptContainedPdu
        set to IPDUM_ACCEPT_ALL.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMCntrRx.NoRefAcceptAll</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>937</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03014_IpduM_CntrRx_RxProc_DeferredOnly</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>361</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that only container Rx PDUs with IPDUM_DEFERRED_PROCESSING
      are allowed for IpduMRxPduRef.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
    The MCG must issue 1 error saying that a Rx PDU container
    allows only Deferred Rx containers.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CntrRx.AllowOnlyDeferred</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>938</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_03016_IpduM_ID_of_Deferred</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_03_ContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>388</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      The test verifies that the IpduMContainerRxHandleIds of deferred Container PDUs
      are less than those of the Contained PDUs' with IpduMContainerPduProcessing set
      as IPDUM_PROCESSING_IMMEDIATE.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP:
        The MCG must issue an error stating the ID is invalid and it has to be less.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.RxContainerId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>939</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_GEN_04000_IpduMStaticContainerPduHandling</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      IpduMStaticContainerPduHandling is disabled and IPDUM_HEADERTYPE_NONE
      is used.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with IpduMStaticContainerPduHandling disabled.
    02: VP:
        The MCG must issue an error saying that the IpduMStaticContainerPduHandling must be
        enabled in order to use IPDUM_HEADERTYPE_NONE.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMStaticContainerPduHandling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>940</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04001_IpduMRx_CntdOverlapping_Cntd</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      contained PDUs belonging to the same container PDU overlap with 
      another contained PDU.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Rx PDU overlapping with another contained Rx PDU.
    02: VP:
        The MCG must issue an error saying that contained PDUs belonging to the
        same container PDU overlap with another contained PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdOverlapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>941</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04002_IpduMRx_CntdOverlapping_UpdateByte</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      contained PDU overlap with a byte which contains an update bit.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Rx PDU overlapping with a byte which contains an update bit.
    02: VP:
        The MCG must issue an error saying that contained PDU overlap with 
        a byte which contains an update bit.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdOverlapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>942</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04003_IpduMTx_CntdOverlapping_Cntd</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      contained PDUs belonging to the same container PDU overlap with 
      another contained PDU.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Tx PDU overlapping with another contained Tx PDU.
    02: VP:
        The MCG must issue an error saying that contained PDUs belonging to the
        same container PDU overlap with another contained PDU.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdOverlapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>943</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04004_IpduMTx_CntdOverlapping_UpdateByte</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>128</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      contained PDU overlap with a byte which contains an update bit.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Tx PDU overlapping with a byte which contains an update bit.
    02: VP:
        The MCG must issue an error saying that contained PDU overlap with 
        a byte which contains an update bit.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdOverlapping</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>944</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04005_IpduMRx_CntdSizeExceed</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>157</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      contained PDU exceeds the container PDU configured PduLength.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Rx PDU exceeding the container PDU configured PduLength.
    02: VP:
        The MCG must issue an error saying that contained PDU exceeds 
        the container PDU configured PduLength.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdSizeExceed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>945</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04006_IpduMTx_CntdSizeExceed</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>186</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      contained PDU exceeds the container PDU configured PduLength.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Tx PDU exceeding the container PDU configured PduLength.
    02: VP:
        The MCG must issue an error saying that contained PDU exceeds 
        the container PDU configured PduLength.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdSizeExceed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>946</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04007_IpduMRx_CntdUpdateBitSizeExceed</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>215</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      IpduMPduUpdateBitPosition exceeds container PDU length.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Rx PDU with IpduMPduUpdateBitPosition 
        exceeding container PDU length.
    02: VP:
        The MCG must issue an error saying that IpduMPduUpdateBitPosition 
        exceeds container PDU length.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdUpdateBitSizeExceed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>947</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04008_IpduMTx_CntdUpdateBitSizeExceed</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>245</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when 
      IpduMPduUpdateBitPosition exceeds container PDU length.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Tx PDU with IpduMPduUpdateBitPosition 
        exceeding container PDU length.
    02: VP:
        The MCG must issue an error saying that IpduMPduUpdateBitPosition 
        exceeds container PDU length.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.HeaderTypeNone.CntdUpdateBitSizeExceed</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>948</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04009_IpduMContainedTxPduCollectionSemantics</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported for a 
      container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE, 
      which has a contained PDU has IpduMContainedTxPduCollectionSemantics 
      set to IPDUM_COLLECT_QUEUED.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Tx PDU has IpduMContainedTxPduCollectionSemantics 
        set to IPDUM_COLLECT_QUEUED.
    02: VP:
        The MCG must issue an error saying that only IPDUM_COLLECT_LAST_IS_BEST collection
        semantic is allowed.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00238</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>341</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>949</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04010_IpduMContainedTxPduOffset</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>307</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported for a 
      container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE 
      and one contained PDU without IpduMContainedTxPduOffset configured.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Tx PDU without IpduMContainedTxPduOffset
        configured.
    02: VP:
        The MCG must issue an error saying that contained PDU must have
        IpduMContainedTxPduOffset configured.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00241</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>343</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>950</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04011_AllCntdIpduMPduUpdateBitPosition</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>338</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported for a 
      container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE,
      IpduMUnusedAreasDefault not set and one contained PDU without 
      IpduMPduUpdateBitPosition configured.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with contained Tx PDU without IpduMPduUpdateBitPosition
        configured.
    02: VP:
        The MCG must issue an error saying that all contained PDU must have
        IpduMPduUpdateBitPosition configured.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>951</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04012_IpduMUnusedAreasDefault</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>370</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported for a 
      container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE,
      IpduMUnusedAreasDefault not set and all contained PDU without 
      IpduMPduUpdateBitPosition configured.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with all contained Tx PDU without IpduMPduUpdateBitPosition
        configured and container Tx PDU without IpduMUnusedAreasDefault configured.
    02: VP:
        The MCG must issue an error saying that IpduMUnusedAreasDefault must be enabled.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00242</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>952</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04013_TxHeaderTypeNotNone</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>401</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported for a 
      container PDU with IpduMContainerHeaderSize not set to IPDUM_HEADERTYPE_NONE
      and all contained PDU with IpduMPduUpdateBitPosition configured.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with container Tx PDU with IpduMContainerHeaderSize 
        not set to IPDUM_HEADERTYPE_NONE and all contained PDU with 
        IpduMPduUpdateBitPosition configured.
    02: VP:
        The MCG must issue an error saying that contained PDUs with 
        IpduMPduUpdateBitPosition must only be assigned to container PDUs
        with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00240</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>953</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04014_RxHeaderTypeNotNone</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>434</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported for a 
      container PDU with IpduMContainerHeaderSize not set to IPDUM_HEADERTYPE_NONE
      and all contained PDU with IpduMPduUpdateBitPosition configured.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with container Rx PDU with IpduMContainerHeaderSize 
        not set to IPDUM_HEADERTYPE_NONE and all contained PDU with 
        IpduMPduUpdateBitPosition configured.
    02: VP:
        The MCG must issue an error saying that contained PDUs with 
        IpduMPduUpdateBitPosition must only be assigned to container PDUs
        with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00240</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>954</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04015_RxSameIpduMUpdateBit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>467</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported for a 
      container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE
      and two contained PDUs having the same IpduMPduUpdateBitPosition.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with two contained Rx PDUs having the same 
        IpduMPduUpdateBitPosition.
    02: VP:
        The MCG must issue an error saying that two contained PDUs
        have the same IpduMPduUpdateBitPosition.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00245</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>955</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_04016_TxSameIpduMUpdateBit</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_04_StaticContainerPdu/source/application/test_config.h</sourcefile>
      <sourceline>498</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported for a 
      container PDU with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE
      and two contained PDUs having the same IpduMPduUpdateBitPosition.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with two contained Tx PDUs having the same 
        IpduMPduUpdateBitPosition.
    02: VP:
        The MCG must issue an error saying that two contained PDUs
        have the same IpduMPduUpdateBitPosition.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00245</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>956</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_GEN_50001_DataMem</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_05_DataMem/source/application/test_config.h</sourcefile>
      <sourceline>10</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  IpduMDataMemSize is not configured great enough for the current configuration
  (IpduMZeroCopy is true).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMDataMemSize is configured as 675
  Configuration contains Pathways and Containers

Test Execution: 
    01: Call the IpduM MCG
    02: VP(IPDUM.EB.IPDUM562):
        The MCG must issue an error stating that the configured memory is less than that
        needed by the configuration.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM562</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>957</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_GEN_60000_Tx_CanFd_Padding_MetaData</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_06_InvalidConfiguration_2/source/application/test_config.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported on Tx side when configuring  MetaDataItemType different than CAN_ID_32.
      Besides some validation checks realted to CanFd as:
        IpduMCanFdPaddingService cannot be used with IpduMContainerHeaderSize set to IPDUM_HEADERTYPE_NONE.
        IpduMCanFdPaddingService cannot be used if IpduMUnusedAreasDefault is enabled.
        IpduMCanFdPaddingService can be used only with IpduMContainerTxTriggerMode set to IPDUM_DIRECT.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM XDM_1 with an invalid TX configuration.
        Set MetaDataItemType for both IpduMContainedTxPdu and IpduMContainerTxPdu to ETHERNET_MAC_64
    02: enable IpduMCanFdPaddingService and
        Set
        IpduMUnusedAreasDefault with any value
        IpduMContainerHeaderSize to IPDUM_HEADERTYPE_NONE
        IpduMContainerTxTriggerMode to IPDUM_DIRECT
    03: Errors should be produced to indicate wrong configurations.
  
Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.IpduMCanFdPaddingService</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>IpduM.EB.CanFdPadding.Restrictions</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>958</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_60001_NoMetaData</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_GenTest_06_InvalidConfiguration_2/source/application/test_config.h</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a configuration error is reported when
      IpduMMetaDataSupport is set to True and EcucMetaDataHandlingEnabled
      is set to False.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM XDM_1 with the specified invalid configuration.
    02: The XDM must issue the following error:
        '..Enable Ecuc MetaData Handling to be able to enable MetaData use..'
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>959</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_GEN_00001_Rx_SelectorBoundary</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>9</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when a selector field crosses a
      byte boundary. This has to be done for the IpduMSelectorFieldPosition in the RX
      path of the IpduM configuration.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with an invalid RX configuration.
        Set
        IpduM/IpduMConfig/Ipdum_Config_0/IpduMRxPathway/IpduMRxPathway_0/IpduMRxIndication/
        IpduMSelectorField/IpduMSelectorFieldPosition
        to 7 and set
        IpduM/IpduMConfig/Ipdum_Config_0/IpduMRxPathway/IpduMRxPathway_0/IpduMRxIndication/
        IpduMSelectorField/IpduMSelectorFieldLength.
        to 2. The setting is done by merging erroneous configurations to a correct configuration.
    02: VP:
        The MCG must issue an error that the byte boundary is violated for RX parameter:
        IpduM/IpduMConfig/Ipdum_Config_0/IpduMRxPathway/IpduMRxPathway_0/IpduMRxIndication/
        IpduMSelectorField.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>960</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_00002_Tx_SelectorBoundary</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a generator error is reported when a selector field crosses a
      byte boundary. This has to be done for the IpduMSelectorFieldPosition in the TX
      path of the IpduM configuration.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with an invalid TX configuration.
        Set
        IpduM/IpduMConfig/Ipdum_Config_0/IpduMTxPathway/IpduMTxPathway_0/IpduMTxRequest/
        IpduMSelectorField/IpduMSelectorFieldPosition
        to 15 and set
        IpduM/IpduMConfig/Ipdum_Config_0/IpduMTxPathway/IpduMTxPathway_0/IpduMTxRequest/
        IpduMSelectorField/IpduMSelectorFieldLength
        to 9.
    02: VP: The MCG must issue an error that the byte boundary is violated for TX parameter:
        IpduM/IpduMConfig/Ipdum_Config_0/IpduMTxPathway/IpduMTxPathway_0/IpduMTxRequest/
        IpduMSelectorField.
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>961</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_00003_ByteCopy_Segment</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that if IpduMByteCopy is enabled, IpduMSegmentPosition shall be
      byte aligned. This has to be done for both static and dynamic segments of IpduMRxPathway and
      IpduMTxPathway of the IpduM configuration.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - IpduMByteCopy should be enabled.
    - Configure IpduMSegmentPosition such that it is not byte aligned
     * IpduMRxPathway_0
       * IpduMRxDynamicPart_0/IpduMSegment/IpduMCopyBitField_0/IpduMSegmentPosition = 31.
       * IpduMRxStaticSegment/IpduMCopyBitField_0/IpduMSegmentPosition = 33.
     * IpduMTxPathway_0
       * IpduMTxDynamicPart_5/IpduMSegment/IpduMCopyBitField_0/IpduMSegmentPosition = 31.
       * IpduMTxStaticSegment/IpduMCopyBitField_0/IpduMSegmentPosition = 29.
  
Test Execution: 
    01: Call the IpduM MCG with an invalid RX and TX configuration.
    02: VP():
        The MCG must issue an error for all four paths that "IpduMSegmentPosition shall be byte aligned."
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM551</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>962</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_00004_SegmentOverlap</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that generator should issue an error if static or dynamic part segments
      overlaps in IpduM I-PDU. That is the sum of the total dynamic segment length and
      static segment length shall be less than the total PDU length (IpduMOutgoingPduRef/PduLength * 8).
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    * IpduMTxPathway_0/IpduMTxRequest/IpduMTxDynamicPart/IpduMTxDynamicPart_5/IpduMSegment/
      IpduMCopyBitField_0/IpduMSegmentLength  = 30 bits
    * IpduMTxPathway_0/IpduMTxRequest/IpduMTxStaticPart/IpduMSegment/IpduMCopyBitField_0/
      IpduMSegmentLength  = 35 bits
    * IpduMTxRequest/IpduMOutgoingPduRef/PduLength = 8 bytes
  
Test Execution: 
    01: Call the IpduM MCG with an invalid TX configuration in which total segment length exceeds
        PduLength i.e, (30+35) &gt; 8*8.
    02: VP():
        The MCG must issue the error as:
        "Static or dynamic part segments overlap in IpduM I-PDU at./AUTOSAR/TOP-LEVEL-PACKAGES
        /IpduM/ELEMENTS/IpduM/IpduMConfig/Ipdum_Config_0/IpduMTxPathway/IpduMTxPathway_0."
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.ECUC_IpduM_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>963</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_00005_ConfTime</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>153</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that the generator should issue a warning if the configured
      IpduMTxConfirmationTimeout is not a multiple of IpduMTxTimeBase.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    * IpduMTxTimeBase = 0.5
    * IpduMTxPathway/IpduMTxPathway_0/IpduMTxRequest/IpduMTxConfirmationTimeout = 1.1
  
Test Execution: 
    01: Call the IpduM MCG with an invalid configuration.
    02: VP():
        The MCG must issue the warning:
        "IpduMTxConfirmationTimeout is not a multiple of IpduMTxTimeBase"
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.ASR40.ECUC_IpduM_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>964</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_00006_InitialDynamicPart</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>181</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test verifies that a configuration error is reported when IpduMEnableJitUpdate and
      IpduMInitializationBySignalValue is enabled but no valid IpduMInitialDynamicPart is provided.

      Note: That no error is reported for disabled IpduMInitialDynamicPart and IpduMEnableJitUpdate
      is considered for the positive test run, the one without the erroneous setting.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - enabled IpduMInitializationBySignalValue (compliant to AUTOSAR 4.0.3)
    - enabled IpduMEnableJitUpdate (compliant to AUTOSAR 4.0.3)
    - invalid configured IpduMInitialDynamicPart (empty)
  
Test Execution: 
    01: Call the IpduM MCG with the specified invalid configuration.
    02: The MCG must issues one occurrence of the errors:
        '..IpduMInitializationBySignalValue is enabled but no valid reference to a dynamic part is chosen..'
        '..IpduMEnableJitUpdate is enabled but no valid reference to a dynamic part is chosen..'
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMEnableJitUpdate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>IPDUM.EB.IpduMInitializationBySignalValue.Success</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>965</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_00007_IpduMTxRequestMaxSduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>214</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      IpduMTxRequestMaxSduLength is set to a value less than the PduLength referenced
      by IpduMTxRequest/IpduMOutgoingPduRef.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - PduLength &gt; IpduMTxRequestMaxSduLength
  
Test Execution: 
    01: Call the IpduM MCG with the specified invalid configuration.
    02: The MCG must issue the following error:
        '..The value of IpduMTxRequestMaxSduLength is less than the PduLength..'
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.EB.IpduMTxRequestMaxSduLength</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>966</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_00008_ZeroPduLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      IpduMOutgoingPduRef is set to a Pdu with PduLength set to 0.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - PduLength = 0
  
Test Execution: 
    01: Call the IpduM MCG with the specified invalid configuration.
    02: The MCG must issue the following error:
        '..The configured PduLength of 0 is invalid..'
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.ZeroPduLength.Configured</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>967</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_GEN_00009_NoMetaData</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Generic/IN/IpduM_Gen_00_InvalidConfiguration/source/application/test_config.h</sourcefile>
      <sourceline>265</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    &lt;para&gt;
      This test shall verify that a configuration error is reported when
      IpduMMetaDataSupport is set to True and EcucMetaDataHandlingEnabled
      is set to False.
    &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Call the IpduM MCG with the specified invalid configuration.
    02: The MCG must issue the following error and warning:
        '..Enable Ecuc MetaData Handling to be able to enable MetaData use..'
        '..IpduMMetaDataSupport is set to TRUE but no container has MetaData configured..'
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IpduMMetaDataSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>968</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_00000</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_00_AutomaticSelector/source/application/Tests.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Verify IpduMTxAutomaticSelector functionality
Test Description: 
&lt;para&gt;
  - Verify whether the configured selectorValue is correctly set in the transmitted
    dynamic part.

  The test sequence focuses on automatic selector value setting.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
Automatic selector is enabled.

Test Execution: 
  01: Call IpduM_Init() (to make confirmation timeout zero).
  02: Call IpduM_Transmit() with a PDU which is triggered.
  03: VP: (IPDUM.EB.IPDUM555) Ensure that PduR_IpduMTransmit() is invoked,
      IpduMTxSelectorValue is set in the destination PDU.
  04: Do not call IpduM_TxConfirmation().
  05: Call IpduM_Transmit() with a PDU which is triggered.
  06: VP: Ensure that PduR_IpduMTransmit() is not invoked.
  07: Call IpduM_TxConfirmation() for the transmitted PDU.
  08: VP: Ensure PduR_IpduMTxConfirmation is invoked once for the PDU.
  09: VP: Verify whether the confirmation handle ID is the same as configured.
  10: Call IpduM_MainFunctionTx().
  11: VP: Ensure that PduR_IpduMTransmit() is not invoked.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM555</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>969</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_01000_BC_RX</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_01_BitCopy/source/application/Tests.c</sourcefile>
      <sourceline>215</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test bit copy routines for received messages
Test Description: 
&lt;para&gt;
  To test IpduM_RxIndication for valid inputs for the Rx Pathway;
  where the data elements are not byte aligned.

  The test sequence focuses on bit-wise copy routines.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  Call IpduM_RxIndication with valid SDU for RxPathway_0
  validate the number of calls to PduR_IpduMRxIndication().
  validate the bit fields of the static part.
  validate the outgoing ID of the static part.
  validate the bit fields of the dynamic part.
  validate the outgoing ID of the dynamic part.
  the same steps are followed for RxPathway_1 and RxPathway_2.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>970</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_01001_BC_TX</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_01_BitCopy/source/application/Tests.c</sourcefile>
      <sourceline>387</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: Test bit copy routines for transmitted messages
Test Description: 
&lt;para&gt;
  To test whether the outgoing PDU is correctly assembled with a unique PDU-ID
  from the static and dynamic parts using bit copy routines.

  Note, for IPDUM022 the different settings of IpduMTxStaticConfirmation and
  IpduMTxDynamicConfirmation as well as existing or non-existing static parts are tested completely
  in test sequence IpduM_ConTest_04_Confirmation. Here, the requirement is tested with respect
  to bit-wise copy routines and independency of trigger mode.

  The test sequence focuses on bit-wise copy routines.

  Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  Call IpduM_Init() (to make confirmation timeout zero).
  Call IpduM_Transmit() with static SDU.
  Ensure that PduR_IpduMTransmit() is invoked.
  Verify that the outgoing PDU-ID is the same as configured.
  Ensure that the outgoing SDU has correct static part.
  Call IpduM_TxConfirmation() for transmitted PDU-ID.
  Ensure PduR_IpduMTxConfirmation is invoked once(since no confirmation is configured
  for the initial selector value).
  Verify whether the confirmation handle Id is the same as configured.
  Call IpduM_Transmit() with dynamic SDU.
  Ensure that PduR_IpduMTransmit() is invoked.
  Verify that the outgoing PDU-ID is the same as configured.
  Ensure that the outgoing SDU has correct static part and dynamic part.
  Call IpduM_TxConfirmation() for transmitted PDU-ID.
  Ensure PduR_IpduMTxConfirmation is invoked twice(since confirmation is configured
  for the static part and the selector value sent recently).
  Verify whether the confirmation handle IDs are the same as configured.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>971</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_01002_LittleEndianOnly</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_01_BitCopy/source/application/Tests.c</sourcefile>
      <sourceline>569</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To verify that IpduM follows LITTLE_ENDIAN byte order while copying segments,
  i.e the data starting from "start bit" till "end bit" of source (pointer given in IpduM_Transmit)
  shall be copied to the destination (PduInfoPtr provided by PduR) in LITTLE_ENDIAN byte order.

  The test sequence focuses on bit-wise copy routines.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - IpduMByteCopy is disabled.
  - IpduMTxTriggerMode is STATIC_OR_DYNAMIC_PART_TRIGGER.
  - Use IpduMTxPathway_1 for transmission.

     Segment | CopyBitField  |  SegLength  |   SegPosition
    --------------------------------------------------------
     Static  |      0        |     20      |       42(byte5)
             |               |             |
     Dynamic |      0        |     22      |       16(byte3)


Test Execution: 
  01: Initialize IpduM.
  02: Call IpduM_Transmit() for static SDU.
  03: VP:
      Verify that IpduM followed LITTLE_ENDIAN byte order while copying the static data to destination
      buffer. 20 bits of source data starting from bit position 42 to 61 shall be copied to
      destination buffer from 42nd bit to 61st bit in LITTLE_ENDIAN format. That is the LSB bit shall
      be copied to the lower bit position of destination byte.
  04: Finish the transmission of static part.
  05: Call IpduM_Transmit() for dynamic SDU.
  06: VP:
      Verify that IpduM followed LITTLE_ENDIAN byte order while copying the dynamic data to destination
      buffer. 22 bits of source data starting from bit position 16 to 37 shall be copied to
      destination buffer from 16th bit to 37th bit in LITTLE_ENDIAN format. That is the LSB bit shall
      be copied to the lower bit position of destination byte.
  07: Finish the transmission of dynamic part.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM560</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>972</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_06001_ServiceId</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_06_General/source/application/Tests.c</sourcefile>
      <sourceline>54</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This tests the correctness of all IpduM function Service IDs
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
    01: VP: The Macro value of each Macro must equal the specification value.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>329</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>973</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_06002_CheckDefensiveProgramming</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_06_General/source/application/Tests.c</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
     This test shall verify that the defensive programming macros are existing within the IpduM.
     Additionally a basic function test shall be done.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Disable:
        PRECONDITION_ASSERT
        POSTCONDITION_ASSERT
        INVARIANT_ASSERT
        STATIC_ASSERT

    Enable:
        UNREACHABLE_CODE_ASSERT


Test Execution: 
    01: Call disabled asset macros.
    02: VP: The Det must not have been called.
    03: Call the UNREACHABLE_CODE_ASSERT macro.
    04: VP: The Det must have been called.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM563</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>974</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_11001_AdjacentModuleVendorSymbolicNames</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_11_General2/source/application/Tests.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that symbolic name values generated for the adjacent module PduR are
    generated with the correct PDU IDs.
    This test shall safeguard that other tests are using the correct PDU ID values within its tests.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    IPDUM_PROVIDE_ADJACENT_MODULE_VENDOR_SYMBOLIC_NAMES must be defined.

Test Execution: 
    01: VP: Symbolic name value macros must equal the regarding ID value in the configuration
    02: VP: Symbolic name value macros for disabled static parts must not be defined
    03: VP: Symbolic name value macros for disabled dynamic TxConfirmation are not defined

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM564</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>975</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_11002_Tx_ZC_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_11_General2/source/application/Tests.c</sourcefile>
      <sourceline>143</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that if IpduMZeroCopy is disabled the PDU (segments) will be copied
    to the IpduMSegmentPosition of the multiplexed PDU sent to the lower layer.

    Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * IpduMZeroCopy is disabled
    * Following parameters for the TX path way shall be used
      - Static part:
          + Start bit 24
          + Length 1 byte

      - Dynamic parts:
          + Start bit 32
          + Length 1 byte

          + Start bit 40
          + Length 1 byte


Test Execution: 
    The basic idea of the test is that a dynamic and a static part is transfered. In the end
    it shall be checked that the bits where copied to the right place. A reference array is used for
    comparison. The PduR internal RAM must be set to a known value for the comparison with the
    reference array.

    01: Clean up the IpduM internal RAM and initialize the IpduM
    02: Transmit the dynamic part
    03: Transmit the static part
    04: Call trigger transmit to get the outgoing PDU
    05: VP: The outgoing PDU is identical with the reference PDU


Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM505</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>976</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_11003_Rx_ZC_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_11_General2/source/application/Tests.c</sourcefile>
      <sourceline>269</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that if IpduMZeroCopy is disabled the incoming PDU will be
    demultiplexed and the demultiplexed PDUs are copied to the IpduMSegmentPosition of the PDU sent
    to the upper layer.

    Test altered due to ASCIPDUM-1225.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * The IpduM is initialized
    * IpduMZeroCopy is disabled
    * Following parameters for the path way shall be used
      - Dynamic part:
          + Start bit 0
          + Length 1 byte

      - Static part:
          + Start bit 16
          + Length 1 byte


Test Execution: 
    The basic idea of the test is that a dynamic and a static part is received. In the end
    it shall be checked that the bits are copied to the right place in the PDUs which are indicated
    to the upper layer.

    01: Call IpduM_RxIndication() with the RX PDU info
    02: VP: The value is copied at the right place at the static PDU
    03: VP: The value is copied at the right place at the dynamic PDU


Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IPDUM.EB.IPDUM506</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>977</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_12001_MuxCntr_Tx_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_12_MultiplexedContainer/source/application/Tests.c</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test verifies that data is forwarded to the expected destination
    when an IpduMContainedTxPdu and an IpduMTxRequest are mapped to the same PDU.

    This test was mandated by:
    https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-740 .

    Note: Routing back the PDU is a configuration task.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Transmitting static part
    02: Transmiting dynamic part
    03: VP: PduR_IpduMTransmit() is called with the correct ID
    04: ContainedTxPdu sent with sendTimeOut of 1
    05: VP: PduR_IpduMTransmit() is called with the correct ID

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>978</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_12002_MuxCntr_Tx_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_12_MultiplexedContainer/source/application/Tests.c</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test verifies that data is forwarded to the expected destination
    when an IpduMContainedTxPdu and an IpduMTxRequest are mapped to the same PDU.

    Same as TS_IPDUM_IMP_12001_MuxCntr_Tx_1 but without the static part.

    This test was mandated by:
    https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-740 .

    Note: Routing back the PDU is a configuration task.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Transmiting dynamic part
    02: VP: PduR_IpduMTransmit() is called with the correct ID
    03: ContainedTxPdu sent with sendTimeOut of 1
    04: VP: PduR_IpduMTransmit() is called with the correct ID

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>979</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_12003_MuxCntr_Rx_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_12_MultiplexedContainer/source/application/Tests.c</sourcefile>
      <sourceline>192</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test verifies that data is forwarded to the expected destination
    when an IpduMContainerRxPdu and an IpduMRxIndication (IpduMRxPathway)
    are mapped to the same PDU.

    This test was mandated by:
    https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-740 .

    Note: Routing back the PDU is a configuration task.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Transmiting dynamic part
    02: VP: PduR_IpduMRxIndication() is called with the correct ID
        (RxPathway)
    03: VP: PduR_IpduMRxIndication() is called with the correct ID
        (RxContainer)

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>980</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_12004_MuxCntr_Tx_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_12_MultiplexedContainer/source/application/Tests.c</sourcefile>
      <sourceline>255</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test verifies that the timeout value used between Transmit and
    TriggerTransmit is as expected when IpduMContainerTxConfirmationTimeout is DISABLED.

    This test was mandated by:
    https://jira.elektrobit.com/browse/ASCIPDUM-1236
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    IpduMTxTimeBase: 0.005
    IpduMContainerTxTriggerMode: IPDUM_TRIGGERTRANSMIT
    IpduMContainerTxConfirmationTimeout: DISABLED
    IpduMContainerTxFirstContainedPduTrigger: ENABLED
    IpduMContainerQueueSize: DISABLED
    IpduMHeaderByteOrder: IPDUM_LITTLE_ENDIAN

Test Execution: 
    01: Add ContainedPdu, transmission triggered due to IpduMContainerTxFirstContainedPduTrigger
    02: Timeout for TriggerTransmit is 198 MainFunctions (1.008 / 0.005 = 201.6 =&gt; 202)
        Call the MainFunction 201 times
    03: Payload retrieved succesfully by IpduM_TriggerTransmit(), within time limit
    04: Add ContainedPdu, transmission triggered due to IpduMContainerTxFirstContainedPduTrigger
    05: Call the MainFunction 202 times, timeout expires
    06: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfTimer):
        Instance transitioned to IDLE state, IpduM_TriggerTransmit() returns E_NOT_OK
    07: Add ContainedPdu, transmission triggered due to IpduMContainerTxFirstContainedPduTrigger ( IDLE )
    08: Call the MainFunction 201 times
    09: Add second ContainedPdu to the instance
    10: Payload with both ContainedPdus retrieved by IpduM_TriggerTransmit()

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>639</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>981</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_13001_MainFunctionRx_No_Init</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_13_MainFunction_Rx_Tx_No_Init/source/application/Tests.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that if IpduM is not initialized,
    the call to IpduM_MainFunctionRx() do not make NULL_PTR
    accesses.

    Test demanded by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-750.

&lt;/para&gt;

Test Object: None.
Test Precondition: 
    IpduM module is not initialized. (IpduM_Init is not called)

Test Execution: 
    01: VP: Call IpduM_MainFunctionRx() to ensure that the module does not access
            NULL_PTR when module is not initialized.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>982</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_13002_MainFunctionTx_No_Init</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_13_MainFunction_Rx_Tx_No_Init/source/application/Tests.c</sourcefile>
      <sourceline>88</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that if IpduM is not initialized,
    the call to IpduM_MainFunctionTx() do not make NULL_PTR
    accesses.

    Test demanded by https://issue.ebgroup.elektrobit.com/browse/ASCIPDUM-750.

&lt;/para&gt;

Test Object: None.
Test Precondition: 
    IpduM module is not initialized. (IpduM_Init is not called)

Test Execution: 
    01: VP: Call IpduM_MainFunctionTx() to ensure that the module does not access
            NULL_PTR when module is not initialized.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>983</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_14001_MainFunctionRx</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_14_MainFunction_Rx/source/application/Tests.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that calling Main Function Rx
    with no Deferred containers configured does not
    lead to undefined behavior

&lt;/para&gt;

Test Object: None.
Test Precondition: 
    No containers with deferred processing configured.
    IpduM module initialized.

Test Execution: 
    01: VP: Call IpduM_MainFunctionRx() to ensure that the module does not
        behave unexpectdly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>984</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_15001_TxMtx</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_15_Container_TxMtx/source/application/Tests.c</sourcefile>
      <sourceline>224</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Test reentrancy between Main Function Tx and Transmit when PduR_IpduMTransmit()
    is called. (outside protected section).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Container PDU with 1 contained PDU with send timeout 2.

Test Execution: 
    00: Initialize IpduM.
    01: Payload added to container PDU, no transmission.
    02: Call Main Function Tx
        - send timeout decreases to 1
    03: VP: Call Main Function Tx
        - send timeout decreases to 0
        - container is sent
        - Transmit is called in between, trying to add one contained PDU
          to the container PDU which is already under transmission =&gt;
          E_NOT_OK received.
        - check that container was sent successfully.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>985</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_15002_TxMtx2</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_15_Container_TxMtx/source/application/Tests.c</sourcefile>
      <sourceline>357</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Test reentrancy between Transmit and Main Function Tx when PduR_IpduMTransmit()
    is called. (outside protected section).
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  Container PDU with 1 contained PDU with send timeout 2.

Test Execution: 
    00: Initialize IpduM.
    01: Payload added to container PDU, no transmission.
    02: VP: Payload added to container PDU, transmission triggered.
        - container PDU is sent
        - Main Function Tx is called for 2 times in the meantime,
          triggering the container PDU due to send timeout
        - check that container PDU is sent only once
    02: Call Main Function Tx
        - container PDU is not sent (since is empty)
    03: VP: Call Main Function Tx
        - send timeout decreases to 0
        - container is sent
        - Transmit is called, trying to add one contained PDU
          to the container PDU which is already under transmission =&gt;
          E_NOT_OK received.
        - check that container was sent successfully.
    05: VP: Payload added to container PDU, transmission triggered.
        - container PDU is sent

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>986</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_15003_TxTT</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_15_Container_TxMtx/source/application/Tests.c</sourcefile>
      <sourceline>501</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Test the usecase when Transmit is interrupted by TriggerTransmit
    in the state IPDUM_TXCNTR_ST_WAIT_CONF.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMContainedTxPduCollectionSemantics: IPDUM_COLLECT_QUEUED
  IpduMContainerQueueSize: DISABLED
  IpduMContainedTxPduTrigger: IPDUM_TRIGGER_ALWAYS
  IpduMContainerTxConfirmationTimeout: DISABLED

Test Execution: 
    00: Initialize IpduM.
    01: Add first ContainedPdu, state changed to IPDUM_TXCNTR_ST_WAIT_CONF
    02: Add second ContainedPdu, IpduM_TriggerTransmit called in callout
    03: VP(IpduM.SWS_IpduM_00090):
        Verify that the payload is correct, unset callout
    04: Add first ContainedPdu, state changed to IPDUM_TXCNTR_ST_WAIT_CONF
        Transmission occured because the state was changed to IDLE in IpduM_TriggerTransmit
    05: Call IpduM_TriggerTransmit directly, verify that the payload is correct

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>987</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_15004_TxTT_NewInst</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_15_Container_TxMtx/source/application/Tests.c</sourcefile>
      <sourceline>622</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Test the usecase when Transmit is interrupted by TriggerTransmit
    in the state IPDUM_TXCNTR_ST_WAIT_CONF (head) before the creation of a new
    instance.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMContainedTxPduCollectionSemantics: IPDUM_COLLECT_QUEUED
  IpduMContainerQueueSize: 2
  IpduMContainedTxPduTrigger: IPDUM_TRIGGER_ALWAYS
  IpduMContainerTxConfirmationTimeout: DISABLED
  IpduMContainerTxTriggerMode: IPDUM_TRIGGERTRANSMIT

Test Execution: 
    00: Initialize IpduM.
    01: Add first ContainedPdu, state changed to IPDUM_TXCNTR_ST_WAIT_CONF (TRIGGER_ALWAYS)
    02: Add second ContainedPdu, IpduM_TriggerTransmit called in callout
    03: VP(IpduM.SWS_IpduM_00200):
        Verify that the payload is correct, instance retrieved and dropped
        PDU from step 2 added to new instance
    04: Add second ContainedPdu to the second instance
    05: Call the MainFunction, SendTimeout expires (1 MF),
        ConfTimeout set to 3 (for TriggerTransmit)
    06: Call the MainFunction twice, ConfTimeout: 3 -&gt; 1
    07: Call the MainFunction, state is IPDUM_TXCNTR_ST_WAIT_CONF;
        Interrupted by TriggerTransmit just as the ConfTimeout expires
    08: Add first ContainedPdu to 3rd instance (TRIGGER_ALWAYS)
    09: Call TriggerTransmit, check that the payload is correct

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>296</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>988</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_15005_TxTxConf_NewInst</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_15_Container_TxMtx/source/application/Tests.c</sourcefile>
      <sourceline>773</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Test the usecase when Transmit is interrupted by TxConfirmation
    in the state IPDUM_TXCNTR_ST_WAIT_CONF (head) before the creation of a new
    instance.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduMContainedTxPduCollectionSemantics: IPDUM_COLLECT_QUEUED
  IpduMContainerQueueSize: 2
  IpduMContainedTxPduTrigger: IPDUM_TRIGGER_ALWAYS
  IpduMContainerTxConfirmationTimeout: 2
  IpduMContainerTxTriggerMode: IPDUM_DIRECT

Test Execution: 
    00: Initialize IpduM.
    01: Add first ContainedPdu, state changed to IPDUM_TXCNTR_ST_WAIT_CONF (TRIGGER_ALWAYS)
    02: Add second ContainedPdu, IpduM_TxConfirmation called in callout
    03: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfirmation):
        Verify the confirmation is forwarded to PduR
        PDU from step 2 added to new instance
        ConfTimeout set to 2
    04: Call the MainFunction, ConfTimeout: 2 -&gt; 1
    05: Call the MainFunction, state is IPDUM_TXCNTR_ST_WAIT_CONF;
        Interrupted by TxConfirmation just as the ConfTimeout expires
    06: Add first ContainedPdu to 3rd instance (TRIGGER_ALWAYS)
    07: Call TxConfirmation, check that it's forwarded to PduR

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>638</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>989</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_16001_ConfPending_SizeTrigger</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_16_ContainerTx/source/application/Tests.c</sourcefile>
      <sourceline>54</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that the container size is not exceeded
    and transmissions are refused while awaiting confirmation.

    Test altered due to:
    Triggering happens when the instance couldn't fit another Contained PDU
    (current length + header &gt; configured length)
    IpduMCntr1Tx_Queued length: 13 -&gt; 17
    IpduMCntr2Tx_LB length: 13 -&gt; 17
    No queuing, the instance is locked until confirmed or timeout expires.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 1 has send timeout 2 and confirmation timeout 3.
    - container 2 has 2 contained PDUs with send timeout 3 each, and
      confirmation timeout 4.
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>990</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_16002_SendTimeoutReset_CntrQueuing</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_16_ContainerTx/source/application/Tests.c</sourcefile>
      <sourceline>267</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test that checks that container send timeout is reset
    after adding to queue.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    - container 3 has send timeout 2
    - container 4 has send timeout 3
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>274</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>991</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_16003_State</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_16_ContainerTx/source/application/Tests.c</sourcefile>
      <sourceline>419</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    The test verifies that the state transitions are in the following order:
      IDLE      (IPDUM_TXCNTR_ST_IDLE)
      WAIT_TX   (IPDUM_TXCNTR_ST_WAIT_TX)
      TRIGGERED (IPDUM_TXCNTR_ST_TRIGGERED)
      WAIT_CONF (IPDUM_TXCNTR_ST_WAIT_CONF)
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    IpduMCntr1Tx_Queued
      IpduMContainerTxTriggerMode: IPDUM_DIRECT
      Cfg idx: 0
      IpduMContainerTxConfirmationTimeout: 3
      IpduMContainerTxSendTimeout: 2
      IpduMContainerQueueSize: 0

    IpduMCntr2Tx_LB
      IpduMContainerTxTriggerMode: IPDUM_DIRECT
      Cfg idx: 1
      IpduMContainerTxConfirmationTimeout: 4
      IpduMContainerTxSendTimeout
      IpduMContainerQueueSize: 0

    IpduMCntr3Tx_Queued
      IpduMContainerTxTriggerMode: IPDUM_TRIGGERTRANSMIT
      Cfg idx: 2
      IpduMContainerTxConfirmationTimeout: 0
      IpduMContainerTxSendTimeout: 2
      IpduMContainerQueueSize: 1

    IpduMCntr4Tx_LB
      IpduMContainerTxTriggerMode: IPDUM_TRIGGERTRANSMIT
      Cfg idx: 3
      IpduMContainerTxConfirmationTimeout: 0
      IpduMContainerTxSendTimeout: 0
      IpduMContainerQueueSize: 1
  
Test Execution: 
    01: VP(IpduM.dsn.Transition.Instance.Init):
        State is IDLE after Init
    02: VP(IpduM.dsn.Transition.Instance.Idle.WaitTransmit):
        State is WAIT_TX after transmission
    03: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Transmit):
        In WAIT_TX PDUs are appended to the container
    04: VP(IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT):
        Trigger condition changes the state to TRIGGERED
        Note: Not transitioned to WAIT_CONF due to PduR_IpduMTransmit()
        returning E_NOT_OK
        (Note: All the conditions are tested within the Conformance tests)
    05: VP(IpduM.dsn.Transition.Instance.Triggered.WaitConfirmation):
        PduR_IpduMTransmit returned E_OK, state is WAIT_CONF
    06: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfTimer):
        TxConf timer expires, state is IDLE
    07: VP(IpduM.dsn.Transition.Instance.Idle.WaitTransmit,
           IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS):
        Trigger condition fulfilled, state is TRIGGERED.
        Note: PduR_IpduMTransmit returns E_NOT_OK, state remains TRIGGERED
    08: VP(IpduM.dsn.Transition.Instance.Triggered.Transmit):
        Contained PDUs are appended to the container in the state TRIGGERED
    09: VP(IpduM.dsn.Transition.Instance.Triggered.TxConfTimer):
        The previous instance is expecting a TxConfirmation (TxConf timer running),
        the state remains: TRIGGERED
    10: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.LB):
        Container is assembled in WAIT_CONF
    11: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.Transmit):
        Contained PDU is appended to the container is WAIT_CONF
    12: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.CQ):
        The readily assembled container is transmitted in WAIT_CONF
    13: VP(IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfirmation):
        TxConfirmation causes transition into IDLE
    14: VP(IpduM.dsn.Transition.Container.Process.Idle):
        Contained PDUs transmitted, state is IDLE
    15: Verify that the second instances (out of the 3) do not write to the
        memory allocated for the 3rd one.
        All values shall be 0 (memset to 0 at Init).
        Instance variable, payload buffer and PDU list checked for TT CQ Container
        Instance variable and PDU list checked for TT LB Container (no payload buffer)
  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>619</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Idle.WaitTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.SENDTOUT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitTransmit.Triggered.TRG_ALWAYS</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Triggered.TxConfTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>628</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Triggered.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>629</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.Triggered.WaitConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>630</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.CQ</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>633</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.TriggerTransmit.LB</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>634</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfTimer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>639</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Instance.WaitConfirmation.Idle.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>638</internalId></provcov>
        <provcov>
          <linksto>IpduM.dsn.Transition.Container.Process.Idle</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>616</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>992</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_IMP_17000_HeaderIDLookupNoOOB_ASR1911</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_18_ContainerRx/source/application/Tests.c.m4</sourcefile>
      <sourceline>265</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that no out of bounds access occurs when the short header ID within
    the payload is greater than anything configured.

    Test mandated by ASCIPDUM-1034.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Header IDs:
      IpduMContainedRxPdu_Short_0: 16777213
      IpduMContainedRxPdu_Short_1: 16777214
      IpduMContainedRxPdu_Long_0: 4294967293
      IpduMContainedRxPdu_Long_1: 4294967294
    The configured short header ID has a maximum value of 16777214 (the one in the payload
      has to be greater).
    The configured long header ID has a maximum value of 4294967294 (the one in the payload
      has to be greater).
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.On</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>993</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_IMP_17000_HeaderIDLookupNoOOB</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Implementation/IN/IpduM_ImpTest_18_ContainerRx/source/application/Tests.c.m4</sourcefile>
      <sourceline>516</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    Test verifies that no out of bounds access occurs when the short header ID within
    the payload is greater than anything configured.

    Test mandated by ASCIPDUM-1034.
  &lt;/para&gt;
  
Test Object: None.
Test Precondition: 
    Header IDs:
      IpduMContainedRxPdu_Short_0: 16777213
      IpduMContainedRxPdu_Short_1: 16777214
      IpduMContainedRxPdu_Long_0: 4294967293
      IpduMContainedRxPdu_Long_1: 4294967294
    The configured short header ID has a maximum value of 16777214 (the one in the payload
      has to be greater).
    The configured long header ID has a maximum value of 4294967294 (the one in the payload
      has to be greater).
  
Test Execution: None.
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00205.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00206.RxContainerAcceptAllNoRefOnly.Off</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>994</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_xxx_xx091_DET</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Include/IpduM_ConfCommon/source/application/Test_Det.c</sourcefile>
      <sourceline>87</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test reporting of IPDUM_E_UNINIT when the APIs are
  called before initializing the IPDUM
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  IpduM is uninitialized

Test Execution: 
  Call IpduM_RxIndication with valid data
  Verify that Det error IPDUM_E_UNINIT is reported
  Call IpduM_Transmit with valid data
  Verify that Det error IPDUM_E_UNINIT is reported
  Call IpduM_TxConfirmation with valid data
  Verify that Det error IPDUM_E_UNINIT is reported

Test Input: 

Test Output: 
  APIs IpduM_RxIndication, IpduM_Transmit and IpduM_TxConfirmation should report DET error
  IPDUM_E_UNINIT, if called before the IPDUM is initialized
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00153_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00153_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00153_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>995</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_xxx_xx092_DET</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Include/IpduM_ConfCommon/source/application/Test_Det.c</sourcefile>
      <sourceline>156</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test reporting of DET error IPDUM_E_PARAM and IPDUM_E_PARAM_POINTER
  when APIs are called with invalid parameters.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  None

Test Execution: 
  01: Call IpduM_Init with NULL pointer.
  02: Verify that Det error IPDUM_E_PARAM_POINTER is reported.

  03: Initialize the module.

  04: Call IpduM_RxIndication with NULL pointer.
  05: VP(IpduM.SWS_IpduM_00028_5):
      Verify that Det error IPDUM_E_PARAM_POINTER is reported.

  06: Call IpduM_RxIndication with SduDataPtr set to NULL pointer.
  07: VP(IpduM.SWS_IpduM_00028_6):
      Verify that Det error IPDUM_E_PARAM_POINTER is reported.

  08: Call IpduM_RxIndication with invalid PDU-ID.
  09: VP(IpduM.SWS_IpduM_00028_1):
      Verify that Det error IPDUM_E_PARAM is reported.

  10: Call IpduM_Transmit with NULL pointer.
  11: VP(IpduM.SWS_IpduM_00028_7):
      Verify that Det error IPDUM_E_PARAM_POINTER is reported.

  12: Call IpduM_Transmit with SduDataPtr set to NULL pointer.
  13: VP(IpduM.SWS_IpduM_00028_8):
      Verify that Det error IPDUM_E_PARAM_POINTER is reported.

  14: Call IpduM_Transmit with invalid PDU-ID.
  15: VP(IpduM.SWS_IpduM_00028_2):
      Verify that Det error IPDUM_E_PARAM is reported.

  16: Call IpduM_TxConfirmation with invalid PDU-ID.
  17: VP(IpduM.SWS_IpduM_00028_4):
      Verify that Det error IPDUM_E_PARAM is reported.

  18: Call IpduM_TxConfirmation() with an invalid PDU-ID.
  19: VP(IpduM.SWS_IpduM_00028_4):
      Verify that Det error IPDUM_E_PARAM is reported.

  20: Call IpduM_TxConfirmation() with an invalid PDU-ID.
  21: VP(IpduM.SWS_IpduM_00028_4):
      Verify that Det error IPDUM_E_PARAM is reported.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>385</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>386</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>387</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_7</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_8</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00105.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>996</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_IPDUM_CON_XX022_GetVersionInfo</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Include/IpduM_GetVersionInfo/source/application/GetVersionInfo_test.c.m4</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Test to request the version information using IpduM_GetVersionInfo.
  This test shall be performed with IpduMVersionInfoApi set to true and false to test
  the function and the macro implementation.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
    01: Set the Version information values to invalid value before the call of IpduM_GetVersionInfo.
    02: Call IpduM_GetVersionInfo with a valid address.
    03: VP: Check the returned version information. The version information returned must be those
            that are configured/hard coded in the module.
    04: VP: Verify that the macro implementation of IpduM_GetVersionInfo exists if
            IpduMVersionInfoApi is disabled and the function if enabled.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>IpduM.ASR40.SWS_IpduM_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>997</internalId></specobject>
    <specobject>
      <id>TS_IPDUM_CON_02023_GetVersionInfo_NULL</id>
      <status>approved</status>
      <source>EB test case specification (asc_IpduM)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_IpduM/test/ts5/Include/IpduM_GetVersionInfo/source/application/GetVersionInfo_test.c.m4</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  To test the IpduM_GetVersionInfo API with NULL_PTR as parameter.
  This test must only be performed when IpduMVersionInfoApi is set to true.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
  01: Call IpduM_GetVersionInfo with NULL_PTR as parameter.
  02: VP(IpduM.SWS_IpduM_00028_11):
      Check whether a DET error IPDUM_E_PARAM_POINTER is reported.

Test Input: None.
Test Output: 
  IpduM_GetVersionInfo should report IPDUM_E_PARAM_POINTER
  whenever an invalid parameter is passed
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>IpduM.SWS_IpduM_00028_11</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>392</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>998</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
