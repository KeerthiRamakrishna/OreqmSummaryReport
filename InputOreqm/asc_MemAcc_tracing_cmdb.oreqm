<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_MemAcc_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_Native/asc_MemAcc_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_Native/asc_MemAcc_requirements_AUTOSAR_SWS_MemoryAccess_ASR_R21-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_Native/asc_MemAcc_requirements_EB_Refinements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_Native/asc_MemAcc_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/common_req/MemAcc_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/common_req/MemAcc_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 19:27:51 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_MemAcc_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_Native/asc_MemAcc_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_Native/asc_MemAcc_requirements_AUTOSAR_SWS_MemoryAccess_ASR_R21-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_Native/asc_MemAcc_requirements_EB_Refinements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_Native/asc_MemAcc_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/common_req/MemAcc_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/common_req/MemAcc_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="lim">
    <specobject>
      <id>lim.MemAcc.EB_INTREQ_MemAcc_JobInfo</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          <code>MemAcc_GetProcessedLength</code> shall be called from a task that does not preempt
          the task of the <code>MemAcc_MainFunction</code> in order to obtain consistent data 
          for the memory area job.
      </description>
      <rationale>
        Internal data for the job is not accessed atomically in the MemAcc module.
        Protecting the job internal data with a lock would inccur a high runtime overhead 
        for the MemAcc main function processing, which would be incompatible 
        with the specified range for <code>MemAccMainFunctionPeriod</code> of [1E-4 .. 1].
      </rationale>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>
    <specobject>
      <id>lim.MemAcc.EB_INTREQ_MemAcc_ProcessedLength</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
          The MemAcc module returns via <code>MemAcc_GetProcessedLength</code> API
          the sum of the succesfully processed bytes and 
          last number of bytes sent to the underlying memory driver.
      </description>
      <rationale>
        Due to the synchronous nature of MemAcc_GetProcessedLength, it is not possible for MemAcc to know
        whether the last command sent to the underlying memory driver was succesfully processed 
        when the getter is called.
      </rationale>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>
    <specobject>
      <id>lim.MemAcc.EB_INTREQ_MemAcc_MemoryAlignment</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        The integrator must ensure the natural alignment of the variables(based on their memory mapping)
        and of struct fields(no packed stucts)
      </description>
      <rationale>
        Atomic access to variables is needed.
      </rationale>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.DataAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>MemAcc.SWS_MemAcc_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        All MemAcc services, i.e. erase, read and write, shall support access requests
        which cross memory device boundaries based on the logical/physical memory mapping.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.CrossDeviceBoundaryOperation.Read</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>MemAcc.CrossDeviceBoundaryOperation.Write</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>MemAcc.CrossDeviceBoundaryOperation.Erase</srcid><srcstatus/><internalId>187</internalId></linkedfrom><linkedfrom><srcid>MemAcc.CrossDeviceBoundaryOperation.Compare</srcid><srcstatus/><internalId>188</internalId></linkedfrom><linkedfrom><srcid>MemAcc.CrossDeviceBoundaryOperation.BlankCheck</srcid><srcstatus/><internalId>189</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00078</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        An address area shall only be assigned to one upper layer module.
      </description>
      <rationale>
        Since only one memory job is allowed per address area, there’s a 1:1 relation between address area and upper layer.
      </rationale>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00079</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description> Within a sub-address area, only a uniform sector size is allowed. </description>
      <rationale>
        A sub-address area maps to a sector batch.
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_542</srcid><srcstatus/><internalId>460</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00080</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description> Start address and length of address areas shall be aligned to the physical sectors.</description>
      <rationale>
        Start address and length of memory accesses have to be aligned to the physical segmentation.
      </rationale>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module shall coordinate conflicting memory accesses by multiple upper layers.
      </description>
      <rationale>
        Typically, code- and data flash share the same flash controller and therefore
        it’s not possible to perform a write access at the same time.
        Since code- and data flash write access might happen at the same time for the software update use case,
        the memory stack needs to coordinate these accesses
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1314</srcid><srcstatus/><internalId>349</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Mem_BlankCheck_Prio_Preemption</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Requests_2_Areas_2_Mem_Drvs_Wait</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_Prio_Wait</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_Prio_Preemption</srcid><srcstatus/><internalId>585</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00007</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module shall only coordinate conflicting resource accesses.
        The access dependencies shall be configurable in the configuration tool.
      </description>
      <rationale>
        Only relevant resource conflicts shall be coordinated to prevent any performance impact.
      </rationale>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module shall support multiple memory access requests from different upper layers for distinct memory areas at the same time.
        In case there is a hardware resource conflict, the memory stack shall still accept the access request and process it once the resource is free.
      </description>
      <rationale>
        The AUTOSAR BSW upper layers shall not have to deal with any retry mechanisms as this would affect every upper layer.
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1457</srcid><srcstatus/><internalId>361</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1513</srcid><srcstatus/><internalId>366</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1567</srcid><srcstatus/><internalId>371</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1625</srcid><srcstatus/><internalId>376</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1688</srcid><srcstatus/><internalId>381</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Requests_2_Areas_2_Mem_Drvs_Wait</srcid><srcstatus/><internalId>564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module shall allow only one job request per address area.
      </description>
      <rationale>
        Simplification of job management since one address area can only have one upper layer
        and job request are typically requested sequentially from the upper layer.
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1444</srcid><srcstatus/><internalId>359</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1500</srcid><srcstatus/><internalId>364</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1554</srcid><srcstatus/><internalId>369</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1612</srcid><srcstatus/><internalId>374</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1675</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_InvalidRequest</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_Invalid</srcid><srcstatus/><internalId>604</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_Invalid</srcid><srcstatus/><internalId>622</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_Invalid</srcid><srcstatus/><internalId>638</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Based on MemAccAddressAreaPriority, MemAcc shall prioritize memory access requests from AUTOSAR BSW upper layer modules.
      </description>
      <rationale>
        Writing crash non-volatile data shall have priority over background software update tasks.
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc_Queue.c_117</srcid><srcstatus/><internalId>426</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Mem_BlankCheck_Prio_Preemption</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Requests_2_Areas_2_Mem_Drvs_Wait</srcid><srcstatus/><internalId>564</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_Prio_Wait</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_Prio_Preemption</srcid><srcstatus/><internalId>585</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The prioritization of memory operations shall use the Mem_Suspend and Mem_Resume service if the memory hardware supports this functionality.
        If the memory hardware does not support a suspend/resume functionality, the prioritization shall be implemented on a page/page burst, respectively sector/sector burst basis.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Prioritization.SuspendResume</srcid><srcstatus/><internalId>193</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Prioritization.Page</srcid><srcstatus/><internalId>194</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Prioritization.PageBurst</srcid><srcstatus/><internalId>195</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Prioritization.Sector</srcid><srcstatus/><internalId>196</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Prioritization.SectorBurst</srcid><srcstatus/><internalId>197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If a job end notification function is configured by MemAccJobEndNotificationName, MemAcc shall notify the upper layer BSW module by calling the configured notification function.
      </description>
      <comment>
        In case no notification function is configured, the upper layer BSW module has to poll the MemAcc job status.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAccJobEndNotification</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2039</srcid><srcstatus/><internalId>386</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Successful_Max_Retry</srcid><srcstatus/><internalId>599</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_Max_Retry</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If the MemAcc module is not able to process a job request, e.g. due to a pending request on the same address area or due to an invalid parameter,
        the job request shall be rejected by an E_NOT_OK return code.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Request.MultipleRequestsForSameAreaReturnCode</srcid><srcstatus/><internalId>198</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Request.InvalidParameter</srcid><srcstatus/><internalId>199</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00113</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        After initialization via the MemAcc_Init service, the job processing status shall be set to MEMACC_JOB_IDLE.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1402</srcid><srcstatus/><internalId>356</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobStatus_Failed_TEST</srcid><srcstatus/><internalId>549</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00104</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case the job processing was completed or no job is currently pending, the job processing status shall be set to MEMACC_JOB_IDLE.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1096</srcid><srcstatus/><internalId>338</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1346</srcid><srcstatus/><internalId>353</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>593</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>594</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>615</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>616</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>627</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>628</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Once a job request was accepted, the job processing status shall be set to MEMACC_JOB_PENDING.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1010</srcid><srcstatus/><internalId>327</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobStatus_Pending_TEST</srcid><srcstatus/><internalId>550</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00112</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        After initialization via the MemAcc_Init service, the job result shall be set to MEMACC_MEM_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1400</srcid><srcstatus/><internalId>355</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobResult_Init</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00105</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case the job processing was completed successfully, the job result shall be set to MEMACC_MEM_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1091</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Erase_TEST</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>593</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>594</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>615</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>616</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>627</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>628</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00106</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case the job processing was completed but the result of the last MemAcc job didn’t meet the expected result,
        e.g. a blank check operation was applied on a non-blank memory area, the job result shall be set to MEMACC_MEM_INCONSISTENT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Request.Inconsistent.BlankCheck</srcid><srcstatus/><internalId>200</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Request.Inconsistent.Compare</srcid><srcstatus/><internalId>201</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00107</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case the last memory operation was completed but the ECC circuit corrected an ECC error,
        the job result shall be set to MEMACC_MEM_ECC_CORRECTED.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAccECC</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00108</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case the last memory operation didn’t complete due to an uncorrectable ECC error,
        the job result shall be set to MEMACC_MEM_ECC_UNCORRECTED.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAccECC</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case the last memory operation was canceled, the job result shall be set to MEMACC_MEM_CANCELED.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interaction.Cbk.Canceled</srcid><srcstatus/><internalId>511</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Dsn.Interaction.Polling.Canceled</srcid><srcstatus/><internalId>513</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00109</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case the memory operation was not successfully completed for any other reason,
        the job result shall be set to MEMACC_MEM_FAILED.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1159</srcid><srcstatus/><internalId>344</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1321</srcid><srcstatus/><internalId>350</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_CheckFailed</srcid><srcstatus/><internalId>586</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_Retry</srcid><srcstatus/><internalId>596</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_NoRetry</srcid><srcstatus/><internalId>597</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>601</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Failed_Job</srcid><srcstatus/><internalId>618</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>619</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_Retry</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_NoRetry</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>635</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00087</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If enabled by MemAccUseEraseBurst, MemAcc shall align and split the Mem driver erase requests according to the erase burst size of the Mem driver.
      </description>
      <comment>
        Enabling burst mode also increases the latency when a job shall be processed with a higher priority.
        Therefore, system integrators have to consider the maximum latency when configuring the burst modes.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1867</srcid><srcstatus/><internalId>383</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>593</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>594</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_2_Drv_Burst</srcid><srcstatus/><internalId>595</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00101</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If enabled by MemAccUseReadBurst, MemAcc shall align and split the Mem driver read requests according to the read burst size of the Mem driver.
      </description>
      <comment>
        Enabling burst mode also increases the latency when a job shall be processed with a higher priority.
        Therefore, system integrators have to consider the maximum latency when configuring the burst modes.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.ReadBurst</srcid><srcstatus/><internalId>269</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_632</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>615</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>616</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_2_Drv_Burst</srcid><srcstatus/><internalId>617</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00102</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If enabled by MemAccUseWriteBurst, MemAcc shall align and split the Mem driver write requests according to the write burst size of the Mem driver.
      </description>
      <comment>
        Enabling burst mode also increases the latency when a job shall be processed with a higher priority.
        Therefore, system integrators have to consider the maximum latency when configuring the burst modes.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_671</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Burst</srcid><srcstatus/><internalId>627</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_1_Drv_Burst</srcid><srcstatus/><internalId>628</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_2_Drv_Burst</srcid><srcstatus/><internalId>629</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00085</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If enabled by MemAccUseMemFuncPtrTable, MemAcc shall call the Mem driver service functions via the Mem driver function pointer table.
        Otherwise the MemAcc shall directly call the Mem driver service functions.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00083</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module implementation shall be hardware independent.
      </description>
      <rationale>
        The MemAcc module will be used with different kinds of Mem drivers, e.g., for internal and external memory devices.
        Thus, MemAcc has to be completely hardware independent.
      </rationale>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00098</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module implementation shall support multiple Mem drivers.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module shall check static configuration parameters statically (at the latest during compile time) for correctness.
        (SRS_BSW_00323, SRS_BSW_00167, SRS_BSW_00004)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.EB.FLs.Burst.Erase</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.FLs.Burst.Read</srcid><srcstatus/><internalId>232</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.FLs.Burst.Write</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.Mem.Burst.Erase</srcid><srcstatus/><internalId>234</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.Mem.Burst.Read</srcid><srcstatus/><internalId>235</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.Mem.Burst.Write</srcid><srcstatus/><internalId>236</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.SubArea.MemInvocation</srcid><srcstatus/><internalId>237</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.AddressArea.LogicalAddresses</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.AddressArea.AddressAreaId</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>MemAcc.EB.Mem.MemNamePrefix</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If MemAccNumberOfEraseRetries is set to a value &amp;gt; 0, MemAcc shall retry the Mem driver erase operation according to the configured value.
      </description>
      <rationale>
        Upper layers shall not have to deal with transient memory erase issues.
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_716</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_Retry</srcid><srcstatus/><internalId>596</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_NoRetry</srcid><srcstatus/><internalId>597</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_Drvs_Successful_Retry</srcid><srcstatus/><internalId>598</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Successful_Max_Retry</srcid><srcstatus/><internalId>599</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_Max_Retry</srcid><srcstatus/><internalId>600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00100</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If MemAccNumberOfWriteRetries is set to a value &amp;gt; 0, MemAcc shall retry the Mem driver write operation according to the configured value.
      </description>
      <rationale>
        Upper layers shall not have to deal with transient memory write issues.
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_704</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_Retry</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_Drvs_Successful_Retry</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Successful_Max_Retry</srcid><srcstatus/><internalId>633</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_Max_Retry</srcid><srcstatus/><internalId>634</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>635</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module shall split memory access requests for the Mem driver layer according to page/page burst,
        respectively sector/sector burst sizes.
      </description>
      <rationale>
         Mem driver expects request aligned to the physical segmentation.
      </rationale>
      <comment>
        Refined by MemAcc.SWS_MemAcc_00087, MemAcc.SWS_MemAcc_00101, MemAcc.SWS_MemAcc_00102
        Shall be further refined for page/sector memory access for read/write/erase
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.MemoryAccess.Read.Page</srcid><srcstatus/><internalId>190</internalId></linkedfrom><linkedfrom><srcid>MemAcc.MemoryAccess.Write.Page</srcid><srcstatus/><internalId>191</internalId></linkedfrom><linkedfrom><srcid>MemAcc.MemoryAccess.Erase.Sector</srcid><srcstatus/><internalId>192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00004</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case the start address or the length of a memory request is not aligned to the physical segmentation of the respective memory device,
        MemAcc shall reject such job requests with E_NOT_OK.
      </description>
      <rationale>
        Memory requests must be aligned to the physical memory segmentation.
      </rationale>
      <comment>
        This requirement is informational only, 
        it is further refined by SWS_MemAcc_00046, SWS_MemAcc_00051, SWS_MemAcc_00055, SWS_MemAcc_00060, SWS_MemAcc_00064.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
     <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00081</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The MemAcc module shall support address areas larger than 4GBytes,
        thus MemAcc_AddressType and MemAcc_LengthType shall be defined as a 64-Bit types
        in case the address area configuration of one address area exceeds 4GBytes.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc64BitSupport</srcid><srcstatus/><internalId>264</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00082</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If all address areas don’t exceed 4GBytes, MemAcc_AddressType and MemAcc_LengthType shall be defined as a 32-Bit types.
      </description>
      <rationale>
        Avoid unnecessary overhead due to 64-Bit types.
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc64BitSupport</srcid><srcstatus/><internalId>264</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10038</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Type of error   Related error code  Error value
        API service called without module initialization                                                MEMACC_E_UNINIT                 0x01
        API service called with NULL pointer argument                                                   MEMACC_E_PARAM_POINTER          0x02
        API service called with wrong address area ID                                                   MEMACC_E_PARAM_ADDRESS_AREA_ID  0x03
        API service called with address and length not belonging to the passed address area ID          MEMACC_E_PARAM_ADDRESS_LENGTH   0x04
        API service called with a hardware ID not belonging to the passed address area ID               MEMACC_E_PARAM_HW_ID            0x05
        API service called for an address area ID with a pending job request                            MEMACC_E_BUSY                   0x06
        Dynamic MEM driver activation failed due to inconsistent MEM driver binary                      MEMACC_E_MEM_INIT_FAILED        0x07
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc.h_133</srcid><srcstatus/><internalId>273</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10037</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Module            Header File         Imported Type
          Mem               Mem.h               Mem_AddressType
                                                Mem_ConfigType
                                                Mem_DataType
                                                Mem_HwServiceIdType
                                                Mem_InstanceIdType
                                                Mem_JobResultType
                                                Mem_LengthType
         Std                Std_Types.h         Std_ReturnType
                                                Std_VersionInfoType
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10000</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_AddressAreaIdType (draft)
        Kind Type
        Derived from uint16
        Description Unique address area ID type.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_AddressAreaIdType</srcid><srcstatus/><internalId>482</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_AddressType (draft)
        Kind Type
        Derived from Basetype Variation  uint32 –  uint64
        Description Logical memory address type.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_AddressType</srcid><srcstatus/><internalId>483</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_ConfigType (draft)
        Kind Structure
        Description Postbuild configuration structure type.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_ConfigType</srcid><srcstatus/><internalId>484</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_DataType (draft)
        Kind Type
        Derived from uint8
        Description General data type.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_DataType</srcid><srcstatus/><internalId>485</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_JobResultType (draft)
        Kind Enumeration
        Range:
             MEMACC_MEM_OK              0x00 The last MemAcc job was finished successfully  
             MEMACC_MEM_FAILED          0x01 The last MemAcc job resulted in an unspecific failure and the job was not completed
             MEMACC_MEM_INCONSISTENT    0x02 The results of the last MemAcc job didn’t meet the expected result, e.g. a blank check operation was applied on a non-blank memory area
             MEMACC_MEM_CANCELED        0x03 The last MemAcc job was canceled
             MEMACC_MEM_ECC_UNCORRECTED 0x04 The last memory operation returned an uncorrectable ECC error
             MEMACC_MEM_ECC_CORRECTED   0x05 The last memory operation returned a correctable ECC error
        Description Asynchronous job result type.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_JobResultType</srcid><srcstatus/><internalId>488</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Dsn.Interaction.Cbk.CancelFinishedJob</srcid><srcstatus/><internalId>512</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_JobStatusType (draft)
        Kind Enumeration
        Range:
             MEMACC_JOB_IDLE 0x00 Job processing was completed or no job currently pending
             MEMACC_JOB_PENDING 0x01 A job is currently being processed
        Description Asynchronous job status type.
        Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_JobStatusType</srcid><srcstatus/><internalId>489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_JobType (draft)
        Kind Enumeration
        Range:
             MEMACC_NO_JOB            0x00  – No job currently pending
             MEMACC_WRITE_JOB         0x01  – Write job pending
             MEMACC_READ_JOB          0x02  – Read job pending
             MEMACC_COMPARE_JOB       0x03  – Compare job pending
             MEMACC_ERASE_JOB         0x04  – Erase job pending
             MEMACC_MEMHWSPECIFIC_JOB 0x05  – Hardware specific job pending
             MEMACC_BLANKCHECK_JOB    0x06  – Blank check job pending
             MEMACC_REQUESTLOCK_JOB   0x07  – Request lock job pending
        Description Type for asynchronous jobs.
                    Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_JobType</srcid><srcstatus/><internalId>490</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_LengthType (draft)
        Kind Type
        Derived from Basetype Variation  uint32 –  uint64
        Description Job length type.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_LengthType</srcid><srcstatus/><internalId>491</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemoryInfoType (draft)
        Kind Structure
        Elements
          LogicalStartAddress   Type MemAcc_AddressType  Comment Logical start address of sub address area
          PhysicalStartAddress  Type MemAcc_AddressType  Comment Physical start address of sub address area
          MaxOffset             Type MemAcc_LengthType   Comment Size of sub address area in bytes -1
          EraseSectorSize       Type uint32  Comment Size of a sector in bytes
          EraseSectorBurstSize  Type uint32  Comment Size of a sector burst in bytes. Equals SectorSize in case burst is  disabled
          ReadPageSize          Type uint32  Comment Read size of a page in bytes
          WritePageSize         Type uint32  Comment Write size of a page in bytes
          ReadPageBurstSize     Type uint32  Comment Size of a read page burst in bytes. Equals ReadPageSize in case burst is disabled
          WritePageBurstSize    Type uint32  Comment Size of a page burst in bytes. Equals WritePageSize in case burst is  disabled
          HwId                  Type uint32  Comment Referenced memory driver hardware identifier
        Description This structure contains information of Mem device characteristics. It can be accessed via the  MemAcc_GetMemoryInfo() service.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_MemoryInfoType</srcid><srcstatus/><internalId>494</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_JobInfoType (draft)
        Kind Structure
        Elements
          LogicalAddress    Type uint32  Comment Address of currently active address area request
          Length            Type uint32  Comment Length of the currently active address area request
          HwId              Type MemAcc_HwIdType  Comment Referenced memory driver hardware identifier
          MemInstanceId     Type uint32  Comment Instance ID of the current memory request
          MemAddress        Type uint32  Comment Physical address of the current memory driver request
          MemLength         Type uint32  Comment Length of memory driver request
          CurrentJob        Type MemAcc_JobType  Comment Currently active MemAcc job
          MemResult         Type MemAcc_JobResultType  Comment Current or last Mem driver result
          LogicalAddress    Type uint64 Comment Address of currently active address area request
        Description This structure contains information the current processing state of the MemAcc module.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_JobInfoType</srcid><srcstatus/><internalId>487</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.JobInfoType</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_HwIdType (draft)
        Kind Enumeration
        Range 0 - 4294967295
        The name of each enum parameter is constructed from the Mem module name and the Mem instance name
        Description Type for the unique numeric identifiers of all Mem hardware instances used for hardware specific requests.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_HwIdType</srcid><srcstatus/><internalId>486</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemApiType (draft)
        Kind Structure
        Elements
                  UniqueId                 Type uint64  Comment Unique ID
                  Flags                    Type uint64  Comment Header flags
                  Header                   Type uint64  Comment Address of Mem driver header structure
                  Delimiter                Type uint64  Comment Address of Mem driver delimiter field
                  InitFunc                 Type MemAcc_MemInitFuncType* Comment Mem_Init function pointer
                  MainFunc                 Type MemAcc_MemMainFuncType* Comment Mem_Main function pointer
                  GetJobResultFunc         Type MemAcc_MemGetJobResultFuncType* Comment Mem_GetJobResult function pointer
                  ReadFunc                 Type MemAcc_MemReadFuncType* Comment Mem_Read function pointer
                  WriteFunc                Type MemAcc_MemWriteFuncType* Comment Mem_Write function pointer
                  EraseFunc                Type MemAcc_MemEraseFuncType* Comment Mem_Erase function pointer
                  PropagateErrorFunc       Type MemAcc_MemPropagateErrorFuncType* Comment Mem_PropagateError function pointer
                  BlankCheckFunc           Type MemAcc_MemBlankCheckFuncType* Comment Mem_BlankCheck function pointer
                  SuspendFunc              Type MemAcc_MemSuspendFuncType* Comment Mem_Suspend function pointer
                  ResumeFunc               Type MemAcc_MemResumeFuncType* Comment Mem_Resume function pointer
                  HwSpecificServiceFunc    Type MemAcc_MemHwSpecificServiceFuncType* Comment Hardware specific service function pointer
        Description This structure contains elements for accessing the Mem driver service functions
                  and consistency information.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemAddressType
        Kind Type  
        Derived from MemAcc_AddressType  
        Description Physical memory device address type  
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemConfigType
        Kind Type  
        Derived from void  
        Description Memory driver configuration structure type
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemDataType
        Kind Type  
        Derived from unit8  
        Description General data type
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemInstanceIdType
        Kind Type  
        Derived from uint32  
        Description Memory driver instance ID type
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_MemInstanceIdType</srcid><srcstatus/><internalId>493</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemJobResultType
        Kind Enumeration  
        Range:
          MEM_JOB_OK             0x00 The last job has been finished successfully
          MEM_JOB_PENDING        0x01 A job is currently being processed
          MEM_JOB_FAILED         0x02 Job failed for some unspecific reason
          MEM_INCONSISTENT       0x03 The checked page is not blank
          MEM_ECC_UNCORRECTED    0x04 Uncorrectable ECC errors occurred during memory access
          MEM_ECC_CORRECTED      0x05 Correctable ECC errors occurred during memory access  
        Description Asynchronous job result type
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemLengthType
        Kind Type  
        Derived from uint32  
        Description Physical memory device length type
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemHwServiceIdType (draft)
        Kind Type
        Derived from uint32
        Description Index type for Mem driver hardware specific service table.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.MemAcc_MemHwServiceIdType</srcid><srcstatus/><internalId>492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91000</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemInitFuncType
        Kind Function Pointer
        Syntax void (*MemAcc_MemInitFuncType) (  MemAcc_MemConfigType* configPtr  )
        Parameters (in) configPtr Pointer to the Mem driver configuration data structure.
        Parameters (inout) None
        Parameters (out) None
        Return value None
        Description Function pointer for the Mem_Init service for the invocation of the Mem driver API via function pointer interface
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemDeInitFuncType
        Kind Function Pointer
        Syntax void (*MemAcc_MemDeInitFuncType) (void)
        Parameters (in) None
        Parameters (inout) None
        Parameters (out) None
        Return value None
        Function pointer for the Mem_DeInit service for the invocation of the Mem driver API via function pointer interface.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc_MemGetJobResultFuncType (draft)
        Kind Function Pointer
        Syntax MemAcc_MemJobResultType (*MemAcc_MemGetJobResultFuncType) (MemAcc_MemInstanceIdType instanceId)
        Parameters (in) instanceId ID of the related memory driver instance.
        Parameters (inout) None
        Parameters (out) None
        Return value MemAcc_MemJobResultType  Most recent job result.
        Description Function pointer for the Mem_JobResultType service for the invocation of the Mem driver API via function pointer interface.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemSuspendFuncType
         Kind Function Pointer
         Syntax void (*MemAcc_MemSuspendFuncType) (MemAcc_MemInstanceIdType instanceId)
         Parameters (in) instanceId ID of the related memory driver instance.
         Parameters (inout) None
         Parameters (out) None
         Return value None
         Description Function pointer for the Mem_Suspend service for the invocation of the Mem driver API via function pointer interface.
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemResumeFuncType
         Kind Function Pointer
         Syntax void (*MemAcc_MemResumeFuncType) (MemAcc_MemInstanceIdType instanceId)
         Parameters (in) instanceId ID of the related memory driver instance.
         Parameters (inout) None
         Parameters (out) None
         Return value None
         Description Function pointer for the Mem_Resume service for the invocation of the Mem driver API via function pointer interface
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemPropagateErrorFuncType
         Kind Function Pointer
         void (*MemAcc_MemPropagateErrorFuncType) (MemAcc_MemInstanceIdType instanceId)
         Parameters (in) instanceId ID of the related memory driver instance.
         Parameters (inout) None
         Parameters (out) None
         Return value None
         Description Function pointer for the Mem_PropagateError service for the invocation of the Mem driver API via function pointer interface.
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemReadFuncType
         Kind Function Pointer
         Syntax Std_ReturnType (*MemAcc_MemReadFuncType) (MemAcc_MemInstanceIdType instanceId, MemAcc_MemAddressType sourceAddress, MemAcc_MemLengthType length, MemAcc_MemDataType* destinationDataPtr)
         Parameters (in) instanceId ID of the related memory driver instance.
                         sourceAddress Physical address to read data from.
                         length Read length in bytes.
         Parameters (inout) None
         Parameters (out) destinationDataPtr Destination memory pointer to store the read data.
         Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
           E_NOT_OK: The requested job has not been accepted by the module.
           E_MEM_SERVICE_NOT_AVAIL: The service function is not implemented.
         Description Function pointer for the Mem_Read service for the invocation of the Mem driver API via function pointer interface.
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_MemReadFuncType</srcid><srcstatus/><internalId>256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemWriteFuncType
         Kind Function Pointer
         Syntax void (*MemAcc_MemWriteFuncType) (Std_ReturnType return, MemAcc_MemInstanceIdType instanceId, MemAcc_MemAddressType targetAddress,  const MemAcc_MemDataType* sourceDataPtr,  MemAcc_MemLengthType length)
         Parameters (in) 
                         return   E_OK: The requested job has been accepted by the module.
                                  E_NOT_OK: The requested job has not been accepted by the module.
                                  E_MEM_SERVICE_NOT_AVAIL: The service function is not implemented.
                         instanceId ID of the related memory driver instance.
                         targetAddress Physical write address (aligned to page size).
                         sourceDataPtr Source data pointer (aligned to page size).
                         length Write length in bytes (aligned to page size).
         Parameters (inout) None
         Parameters (out) None
         Return value None 
         Description Function pointer for the Mem_Write service for the invocation of the Mem driver API via function pointer interface.
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_MemWriteFuncType</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemEraseFuncType
         Kind Function Pointer
         Syntax void (*MemAcc_MemEraseFuncType) (  Std_ReturnType return,  MemAcc_MemInstanceIdType instanceId,  MemAcc_MemAddressType targetAddress,  MemAcc_MemLengthType length  )
         Parameters (in) 
                         return   E_OK: The requested job has been accepted by the module.
                                  E_NOT_OK: The requested job has not been accepted by the module.
                                  E_MEM_SERVICE_NOT_AVAIL: The service function is not implemented.
                         instanceId ID of the related memory driver instance.
                         targetAddress Physical erase address (aligned to sector size).
                         length Erase length in bytes (aligned to sector size).
         Parameters (inout) None
         Parameters (out) None
         Return value None 
         Description Function pointer for the Mem_Erase service for the invocation of the Mem driver API via function pointer interface.
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_MemEraseFuncType</srcid><srcstatus/><internalId>258</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemBlankCheckFuncType
         Kind Function Pointer
         Syntax void (*MemAcc_MemBlankCheckFuncType) (Std_ReturnType return, MemAcc_MemInstanceIdType instanceId, MemAcc_MemAddressType targetAddress, MemAcc_MemLengthType length)
         Parameters (in)
                         return   E_OK: The requested job has been accepted by the module.
                                  E_NOT_OK: The requested job has not been accepted by the module.
                                  E_MEM_SERVICE_NOT_AVAIL: The service function is not implemented. 
                         instanceId ID of the related memory driver instance.
                         targetAddress Physical blank check address.
                         length Blank check length.
         Parameters (inout) none
         Parameters (out) None
         Return value None
         Description Function pointer for the Mem_BlankCheck function for the invocation of the Mem driver API via function pointer interface.
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_MemBlankCheckFuncType</srcid><srcstatus/><internalId>259</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemHwSpecificServiceFuncType
         Kind Function Pointer
         Syntax void (*MemAcc_MemHwSpecificServiceFuncType) (Std_ReturnType return, MemAcc_MemInstanceIdType instanceId, MemAcc_MemHwServiceIdType hwServiceId, MemAcc_MemDataType* dataPtr, MemAcc_MemLengthType* lengthPtr)
         Parameters (in) 
                          return  E_OK: The requested job has been accepted by the module.
                                  E_NOT_OK: The requested job has not been accepted by the module.
                                  E_MEM_SERVICE_NOT_AVAIL: The service function is not implemented. 
                          instanceId ID of the related memory driver instance.
                          hwServiceId Hardware specific service request identifier for dispatching the request.
                          lengthPtr Size pointer of the passed data.
         Parameters (inout) dataPtr Request specific data pointer.
         Parameters (out) None
         Description Function pointer for the Mem_HwSpecificService function for the invocation of the Mem driver API via function pointer interface.
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_MemHwSpecificServiceFuncType</srcid><srcstatus/><internalId>260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_91001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         Name MemAcc_MemMainFuncType
         Kind Function Pointer
         Syntax void (*MemAcc_MemMainFuncType) (void)
         Parameters (in) None
         Parameters (inout) None
         Parameters (out) None
         Return value None
         Description Function pointer for the Mem_MainFunction service for the invocation of the Mem driver API via function pointer interface.
         Tags: atp.Status=draft
         Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_Init (draft)
        Syntax void MemAcc_Init (  const MemAcc_ConfigType* configPtr  )
        Service ID [hex] 0x01
        Sync/Async Synchronous
        Reentrancy Non Reentrant
        Parameters (in) configPtr Pointer to selected configuration structure.
        Parameters (inout) None
        Parameters (out) None
        Return value None
        Description Initialization function - initializes all variables and sets the module state to initialized.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.Init</srcid><srcstatus/><internalId>505</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The service MemAcc_Init shall initialize the MemAcc module internal states.
        If MemAccMemInvocation is set to INDIRECT_DYNAMIC or INDIRECT_STATIC, MemAcc_Init shall also initialize
        all available Mem drivers by calling the Mem driver’s individual initialization functions.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_DeInit (draft)
        Syntax void MemAcc_DeInit (void)
        Service ID [hex] 0x01
        Sync/Async Synchronous
        Reentrancy Non Reentrant
        Parameters (in) None
        Parameters (inout) None
        Parameters (out) None
        Return value None
        Description Deinitialize module. If there are still access jobs pending, they are immediately terminated and
          the module state is set to unitialized. Therefore, MemAcc must be re-initialized before it will
          accept any new job requests after this service is processed.
        Tags: atp.Status=draft
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.DeInit</srcid><srcstatus/><internalId>270</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00111</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The service MemAcc_DeInit shall de-initialize the MemAcc module internal states.
        If MemAccMemInvocation is set to INDIRECT_DYNAMIC or INDIRECT_STATIC,
        MemAcc_Deinit shall also de-initialize all available Mem drivers by calling the Mem driver’s individual de-initialization functions.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_GetVersionInfo (draft)
        Syntax void MemAcc_GetVersionInfo (Std_VersionInfoType* versionInfoPtr)
        Service ID [hex] 0x02
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in) None
        Parameters (inout) None
        Parameters (out) versionInfoPtr Pointer to where to store the version information of this module.
        Return value None
        Description Service to return the version information of the MemAcc module.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.GetVersionInfo</srcid><srcstatus/><internalId>504</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetVersionInfo shall
        raise the development error MEMACC_E_PARAM_POINTER if the argument is a NULL pointer. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2428</srcid><srcstatus/><internalId>418</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetVersionInfo_Invalid_TEST</srcid><srcstatus/><internalId>562</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_GetJobResult (draft)
        Syntax MemAcc_JobResultType MemAcc_GetJobResult (MemAcc_AddressAreaIdType addressAreaId  )
        Service ID [hex] 0x05
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in) addressAreaId Numeric identifier of address area.
        Parameters (inout) None
        Parameters (out) None
        Return value MemAcc_JobResultType Most recent job result of the referenced address area.
        Description Returns the consolidated job result of the address area referenced by addressAreaId.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.GetJobResult</srcid><srcstatus/><internalId>500</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00092</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The service MemAcc_GetJobResult shall return the consolidated result of the last MemAcc job.
        Note: If a MemAcc job is still pending, the API returns the result of the last MemAcc job.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interaction.Polling.JobResult</srcid><srcstatus/><internalId>514</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.GetJobResult</srcid><srcstatus/><internalId>268</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetJobResult shall check that the MemAcc module has been initialized.
        If this check fails, MemAcc_GetJobResult shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2120</srcid><srcstatus/><internalId>396</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobResult_Invalid_TEST</srcid><srcstatus/><internalId>546</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled  by MemAccDevErrorDetect, the service MemAcc_GetJobResult shall check that the provided addressAreaId is consistent
        with the configuration. If this check fails, MemAcc_GetJobResult shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2107</srcid><srcstatus/><internalId>394</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobResult_Invalid_TEST</srcid><srcstatus/><internalId>546</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_GetJobStatus (draft)
        Syntax MemAcc_JobStatusType MemAcc_GetJobStatus (MemAcc_AddressAreaIdType addressAreaId  )
        Service ID [hex] 0x05
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in) addressAreaId Numeric identifier of address area.
        Parameters (inout) None
        Parameters (out) None
        Return value MemAcc_JobStatusType Most recent job result of the referenced address area.
        Description Returns the status of the MemAcc job referenced by addressAreaId.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_GetJobStatus.ServiceID</srcid><srcstatus/><internalId>272</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.GetJobStatus</srcid><srcstatus/><internalId>501</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00117</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, 
        the service MemAcc_GetJobStatus shall check that the MemAcc module has been initialized. 
        If this check fails, MemAcc_GetJobStatus shall raise the development error MEMACC_E_UNINIT (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2158</srcid><srcstatus/><internalId>401</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobStatus_Invalid_TEST</srcid><srcstatus/><internalId>548</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00118</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The service MemAcc_GetJobStatus shall return MEMACC_JOB_IDLE for the referenced 
        addressAreaId if MemAcc is not processing a job request.c(SRS_MemHwAb_14040)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2151</srcid><srcstatus/><internalId>399</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobStatus_Failed_TEST</srcid><srcstatus/><internalId>549</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00119</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The service MemAcc_GetJobStatus shall return MEMACC_JOB_PENDING for 
        the referenced addressAreaId if MemAcc is currently processing a job request.(SRS_MemHwAb_14040)
      </description>
      <furtherinfo>
        Most of test cases use GetJobStatus to check if the request is done or not, so this requirement is 
        covered in many test cases which violates rule "swuts.needscoverage.count"
      </furtherinfo>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2152</srcid><srcstatus/><internalId>400</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea</srcid><srcstatus/><internalId>590</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_1_Drv</srcid><srcstatus/><internalId>591</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_Retry</srcid><srcstatus/><internalId>596</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_NoRetry</srcid><srcstatus/><internalId>597</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_Drvs_Successful_Retry</srcid><srcstatus/><internalId>598</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>601</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea</srcid><srcstatus/><internalId>612</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_1_Drv</srcid><srcstatus/><internalId>613</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Failed_Job</srcid><srcstatus/><internalId>618</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>619</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea</srcid><srcstatus/><internalId>624</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_1_Drv</srcid><srcstatus/><internalId>625</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_Retry</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_NoRetry</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>635</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_GetMemoryInfo (draft)
        Syntax Std_ReturnType MemAcc_GetMemoryInfo (  MemAcc_AddressAreaIdType addressAreaId,  MemAcc_AddressType address,  MemAcc_MemoryInfoType* memoryInfoPtr  )
        Service ID [hex] 0x06
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in)
          addressAreaId Numeric identifier of address area.
          address Address in logical address space from which corresponding
                  memory device information shall be retrieved.
        Parameters (inout) None
        Parameters (out) memoryInfoPtr Destination memory pointer to store the memory device
        information.
        Return value Std_ReturnType E_OK: The requested addressAreaId and address are valid.
                                    E_NOT_OK: The requested addressAreaId and address are invalid.
        Description
          This service function retrieves the physical memory device information of a specific address
          area. It can be used by an upper layer to get all necessary information to align the start address
          and trim the length for erase/write jobs.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.GetMemoryInfo</srcid><srcstatus/><internalId>502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00035</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled  by MemAccDevErrorDetect, the service MemAcc_GetMemoryInfo shall check that the MemAcc module has been initialized.
        If this check fails, MemAcc_GetMemoryInfo shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2266</srcid><srcstatus/><internalId>406</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetMemoryInfo_Invalid_TEST</srcid><srcstatus/><internalId>551</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00036</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetMemoryInfo shall check that the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_GetMemoryInfo shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2180</srcid><srcstatus/><internalId>402</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetMemoryInfo_Invalid_TEST</srcid><srcstatus/><internalId>551</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetMemoryInfo shall raise the development error MEMACC_E_PARAM_POINTER
        if the memoryInfoPtr argument is a NULL pointer. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2187</srcid><srcstatus/><internalId>403</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetMemoryInfo_Invalid_TEST</srcid><srcstatus/><internalId>551</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_GetProcessedLength (draft)
        Syntax MemAcc_LengthType MemAcc_GetProcessedLength (  MemAcc_AddressAreaIdType addressAreaId  )
        Service ID [hex] 0x07
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in) addressAreaId Numeric identifier of address area.
        Parameters (inout) None
        Parameters (out) None
        Return value MemAcc_LengthType Processed length of current job (in bytes).
        Description
        Returns the accumulated number of bytes that have already been processed in the current job.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.GetProcessedLength</srcid><srcstatus/><internalId>503</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00120</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        The service MemAcc_GetProcessedLength shall return the processed length of the current MemAcc job referenced by addressAreaId. 
        If the job finished successfully, MemAcc_GetProcessedLength shall return the requested job length of the finished job until a new MemAcc job request is received for the referenced addressAreaId. 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2302</srcid><srcstatus/><internalId>409</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Erase_TEST</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Read_TEST</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Compare_TEST</srcid><srcstatus/><internalId>557</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Write_TEST</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Canceled_TEST</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_2_SubAreas_1_MemDrv</srcid><srcstatus/><internalId>576</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.MemAcc.EB_INTREQ_MemAcc_ProcessedLength</srcid><srcstatus/><internalId>1</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00038</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetProcessedLength shall check
        that the MemAcc module has been initialized.
        If this check fails, MemAcc_GetProcessedLength shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2308</srcid><srcstatus/><internalId>410</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Invalid_TEST</srcid><srcstatus/><internalId>554</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00039</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetProcessedLength shall check
        that the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_GetProcessedLength shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_852</srcid><srcstatus/><internalId>318</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2295</srcid><srcstatus/><internalId>408</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Invalid_TEST</srcid><srcstatus/><internalId>554</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_GetJobInfo (draft)
        Syntax void MemAcc_GetJobInfo (MemAcc_AddressAreaIdType addressAreaId,MemAcc_JobInfoType* jobInfoPtr)
        Service ID [hex] 0x08
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in) addressAreaId Numeric identifier of address area.
        Parameters (inout) None
        Parameters (out) jobInfoPtr Structure pointer to return the detailed processing information of
        the current job.
        Return value None
        Description
          Returns detailed information of the current memory job like memory device ID, job type, job
          processing state or job result, address area as well as address and length.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.GetJobInfo</srcid><srcstatus/><internalId>499</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.MemAcc.EB_INTREQ_MemAcc_JobInfo</srcid><srcstatus/><internalId>0</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00040</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetJobInfo shall check that
        the MemAcc module has been initialized.
        If this check fails, MemAcc_GetJobInfo shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2369</srcid><srcstatus/><internalId>414</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Invalid_TEST</srcid><srcstatus/><internalId>541</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00041</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetJobInfo shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_GetJobInfo shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2332</srcid><srcstatus/><internalId>411</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Invalid_TEST</srcid><srcstatus/><internalId>541</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00042</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_GetJobInfo shall raise the development error MEMACC_E_PARAM_POINTER
        if the memoryInfoPtr argument is a NULL pointer. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2339</srcid><srcstatus/><internalId>412</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Invalid_TEST</srcid><srcstatus/><internalId>541</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_ActivateMem (draft)
        Syntax Std_ReturnType MemAcc_ActivateMem (MemAcc_AddressType headerAddress, MemAcc_HwIdType hwId)
        Service ID [hex] 0x14
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in) hwId Unique numeric memory driver identifier.
        Parameters (in) headerAddress Physical start address of Mem driver header structure.
        Parameters (inout) None
        Parameters (out) None
        Return value Std_ReturnType E_OK: Mem driver activation successful.
                                    E_NOT_OK: Mem driver activation failed.
        Description
          Dynamic activation and initialization of a Mem driver referenced by hwId and headerAddress.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_ActivateMem</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00121</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is set to INDIRECT_DYNAMIC, the service MemAcc_ActivateMem shall initialize the Mem driver referenced by hwId and headerAddress
        and update the internal driver activation state. (SRS_MemHwAb_14045, SRS_MemHwAb_14047)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_ActivateMem</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00088</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_ActivateMem shall check
        that the MemAcc module has been initialized.
        If this check fails, MemAcc_ActivateMem shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_ActivateMem</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00089</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_ActivateMem shall ensure
        the validity of the Mem driver binary by checks in the following sequence:
        1. Comparing the header address field with the start address of the Mem driver  binary
           (if the Mem driver was not compiled as a relocatable binary)
        2. Unique ID validity
        3. Availability and consistency of the delimiter field
        If any of these checks fails, MemAcc_ActivateMem shall raise the development error MEMACC_E_MEM_INIT_FAILED.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_ActivateMem</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10034</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_DeactivateMem (draft)
        Syntax Std_ReturnType MemAcc_DeactivateMem ( MemAcc_HwIdType hwId,  MemAcc_AddressType headerAddress  )
        Service ID [hex] 0x15
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in) hwId Unique numeric memory driver identifier.
                        headerAddress Physical start address of Mem driver header structure.
        Parameters (inout) None
        Parameters (out) None
        Return value Std_ReturnType E_OK: Mem driver deactivation successful.
                                    E_NOT_OK: Mem driver deactivation failed.
        Description Dynamic deactivation of a Mem driver referenced by hwId and headerAddress.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_ActivateMem</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00122</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
         If MemAccMemInvocation is set to INDIRECT_DYNAMIC, the service MemAcc_DeactivateMem shall de-initialize 
         the Mem driver referenced by hwId and headerAddress and update the internal driver activation state. (SRS_MemHwAb_14045, SRS_MemHwAb_14047)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_ActivateMem</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00090</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_DeactivateMem shall check that the MemAcc module has been initialized.
        If this check fails, MemAcc_DeactivateMem shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_ActivateMem</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00123</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case a MemAcc job is still pending, the service MemAcc_DeactivateMem shall return E_NOT_OK without any further action.
        without any further action.
        Note: After calling the MemAcc_DeactivateMem service, the integration code shall
              also clear the memory area where the corresponding Mem driver is stored to prevent
              accidental execution of a Mem driver.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_ActivateMem</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_Cancel (draft)
        Syntax void MemAcc_Cancel (  MemAcc_AddressAreaIdType addressAreaId  )
        Service ID [hex] 0x04
        Sync/Async Asynchronous
        Reentrancy Reentrant
        Parameters (in) addressAreaId Numeric identifier of address area.
        Parameters (inout) None
        Parameters (out) None
        Return value None
        Description
          Triggers a cancel operation of the pending job for the address area referenced by the addressAreaId.
          Cancelling affects only jobs in pending state. For any other states, the request will be ignored.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.Cancel</srcid><srcstatus/><internalId>496</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        When the MemAcc_Cancel service is called by an upper layer,
        the MemAcc module shall wait for the completion of a pending Mem job
        and stop further processing of the current MemAcc job.
      </description>
      <rationale>
        Not all memory devices support a cancel operation in hardware.
        To keep the behavior consistent, the cancel operation is only applied on the physical segmentation.
      </rationale>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1057</srcid><srcstatus/><internalId>330</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1303</srcid><srcstatus/><internalId>348</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2076</srcid><srcstatus/><internalId>391</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Erase_TEST</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Read_TEST</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Write_TEST</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Compare_TEST</srcid><srcstatus/><internalId>529</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_Cancel</srcid><srcstatus/><internalId>569</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00029</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        In case no MemAcc job is pending, the MemAcc_Cancel service shall just return without any further action,
        i.e., the result of the last MemAcc job shall not be affected.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2071</srcid><srcstatus/><internalId>390</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Invalid_Cancel_TEST</srcid><srcstatus/><internalId>528</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Cancel shall check
        that the MemAcc module has been initialized.
        If this check fails, MemAcc_Cancel shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2083</srcid><srcstatus/><internalId>392</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Uninit</srcid><srcstatus/><internalId>524</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00031</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Cancel shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_Cancel shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2062</srcid><srcstatus/><internalId>389</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Invalid_Cancel_TEST</srcid><srcstatus/><internalId>528</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_Read (draft)
        Syntax Std_ReturnType MemAcc_Read (MemAcc_AddressAreaIdType addressAreaId,  MemAcc_AddressType sourceAddress,  MemAcc_DataType* destinationDataPtr,  MemAcc_LengthType length)
        Service ID [hex] 0x09
        Sync/Async Asynchronous
        Reentrancy Reentrant
        Parameters (in)
                        addressAreaId Numeric identifier of address area.
                        sourceAddress Read address in logical address space.
                        length Read length in bytes (aligned to read page size)
        Parameters (inout) None
        Parameters (out) destinationDataPtr Destination memory pointer to store the read data.
        Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
                                    E_NOT_OK: The requested job has not been accepted by the module.
                                    E_MEM_SERVICE_NOT_AVAIL: The underlying Mem driver service function is not available.
        Description:
          Triggers a read job to copy data from the source address into the referenced destination data buffer.
          The result of this service can be retrieved using the MemAcc_GetJobResult API.
          If the read operation was successful, the result of the job is MEMACC_MEM_OK.
          If the read operation failed, the result of the job is either MEMACC_MEM_FAILED in case of a general error or
          MEMACC_MEM_ECC_CORRECTED/MEMACC_MEM_ECC_UNCORRECTED in case of a correctable/uncorrectable ECC error.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.Read</srcid><srcstatus/><internalId>507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00043</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Read shall check
        that the MemAcc module has been initialized.
        If this check fails, MemAcc_Read shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1468</srcid><srcstatus/><internalId>362</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Read_Uninit</srcid><srcstatus/><internalId>611</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00044</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Read shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_Read shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_781</srcid><srcstatus/><internalId>301</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Read_Invalid</srcid><srcstatus/><internalId>622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00045</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Read shall raise the development error MEMACC_E_PARAM_POINTER
        if the destinationDataPtr argument is a NULL pointer. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_790</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Read_Invalid</srcid><srcstatus/><internalId>622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00046</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Read shall raise the development error MEMACC_E_PARAM_ADDRESS_LENGTH
        if the address range defined by sourceAddress and length is invalid,  i.e. not aligned to MemReadPageSize. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_799</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_808</srcid><srcstatus/><internalId>310</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_817</srcid><srcstatus/><internalId>313</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Read_Invalid</srcid><srcstatus/><internalId>622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00047</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Read shall raise the development error MEMACC_E_BUSY
        if a previous MemAcc job for the same addressAreaId  is still being processed. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1450</srcid><srcstatus/><internalId>360</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Read_Invalid</srcid><srcstatus/><internalId>622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_Write (draft)
        Syntax Std_ReturnType MemAcc_Write (  MemAcc_AddressAreaIdType addressAreaId,  MemAcc_AddressType targetAddress,  const MemAcc_DataType* sourceDataPtr,  MemAcc_LengthType length  )
        Service ID [hex] 0x0a
        Sync/Async Asynchronous
        Reentrancy Reentrant
        Parameters (in)
          addressAreaId Numeric identifier of address area.
          targetAddress Write address in logical address space.
          sourceDataPtr Source data pointer (aligned to MemAccBufferAlignmentValue).
          length Write length in bytes (aligned to page size).
        Parameters (inout) None
        Parameters (out) None
        Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
                                    E_NOT_OK: The requested job has not been accepted by the module.
                                    E_MEM_SERVICE_NOT_AVAIL: The underlying Mem driver service function is not available.
        Description
          Triggers a write job to store the passed data to the provided address area with given address and length.
          The result of this service can be retrieved using the MemAcc_GetJobResult API.
          If the write operation was successful, the job result is MEMACC_MEM_OK.
          If there was an issue writing the data, the result is MEMACC_MEM_FAILED.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.Write</srcid><srcstatus/><internalId>510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00048</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Write shall check that
        the MemAcc module has been initialized.
        If this check fails, MemAcc_Write shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1524</srcid><srcstatus/><internalId>367</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_Uninit</srcid><srcstatus/><internalId>623</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00049</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Write shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_Write shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_782</srcid><srcstatus/><internalId>302</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_Invalid</srcid><srcstatus/><internalId>638</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00050</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Write shall raise the development error MEMACC_E_PARAM_POINTER
        if the sourceDataPtr argument is a NULL pointer. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_791</srcid><srcstatus/><internalId>305</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_Invalid</srcid><srcstatus/><internalId>638</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00051</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Write shall raise the development error MEMACC_E_PARAM_ADDRESS_LENGTH
        if the address range defined by targetAddress and length is invalid, i.e. not aligned to MemWritePageSize. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_800</srcid><srcstatus/><internalId>308</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_809</srcid><srcstatus/><internalId>311</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_818</srcid><srcstatus/><internalId>314</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_Invalid</srcid><srcstatus/><internalId>638</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00052</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Write shall raise the development error MEMACC_E_BUSY
        if a previous MemAcc job for the same addressAreaId is still being processed. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1506</srcid><srcstatus/><internalId>365</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_Invalid</srcid><srcstatus/><internalId>638</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_Erase (draft)
        Syntax Std_ReturnType MemAcc_Erase (  MemAcc_AddressAreaIdType addressAreaId,  MemAcc_AddressType targetAddress,  MemAcc_LengthType length  )
        Service ID [hex] 0x0b
        Sync/Async Asynchronous
        Reentrancy Reentrant
        Parameters (in)
          addressAreaId Numeric identifier of address area.
          targetAddress Erase address in logical address space (aligned to sector size).
          length Erase length in bytes (aligned to sector size).
        Parameters (inout) None
        Parameters (out) None
        Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
                                    E_NOT_OK: The requested job has not been accepted by the module.
                                    E_MEM_SERVICE_NOT_AVAIL: The underlying Mem driver service function is not available.
        Description:
           Triggers an erase job of the given area defined by targetAddress and length.
           The result of this service can be retrieved using the Mem_GetJobResult API.
           If the erase operation was successful, the result of the job is MEM_JOB_OK.
           If the erase operation failed, e.g. due to a hardware issue, the result of the job is MEM_JOB_FAILED.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.Erase</srcid><srcstatus/><internalId>498</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00053</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Erase shall check that
        the MemAcc module has been initialized.
        If this check fails, MemAcc_Erase shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1578</srcid><srcstatus/><internalId>372</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_Uninit</srcid><srcstatus/><internalId>589</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Erase shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_Erase shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID.c(SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_853</srcid><srcstatus/><internalId>319</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_Invalid</srcid><srcstatus/><internalId>604</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00055</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Erase shall raise the development error MEMACC_E_PARAM_ADDRESS_LENGTH
        if the address range defined by targetAddress and length is invalid, i.e. not aligned to MemEraseSectorSize. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_861</srcid><srcstatus/><internalId>321</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_869</srcid><srcstatus/><internalId>323</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_877</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_Invalid</srcid><srcstatus/><internalId>604</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Erase shall raise the development error MEMACC_E_BUSY
        if a previous MemAcc job for the same addressAreaId is still being processed. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1560</srcid><srcstatus/><internalId>370</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_Invalid</srcid><srcstatus/><internalId>604</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_Compare (draft)
        Syntax Std_ReturnType MemAcc_Compare (  MemAcc_AddressAreaIdType addressAreaId,  MemAcc_AddressType sourceAddress,  const MemAcc_DataType* dataPtr,  MemAcc_LengthType length  )
        Service ID [hex] 0x0c
        Sync/Async Asynchronous
        Reentrancy Reentrant
        Parameters (in)
          addressAreaId Numeric identifier of address area.
          sourceAddress Compare address in logical address space.
          dataPtr Pointer to user data which shall be compared to data in memory.
          length Compare length in bytes.
        Parameters (inout) None
        Parameters (out) None
        Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
                                    E_NOT_OK: The requested job has not been accepted by the module.
                                    E_MEM_SERVICE_NOT_AVAIL: The underlying Mem driver service function is not available.
        Description
          Triggers a job to compare the passed data to the memory content of the provided address area.
          The job terminates, if all bytes matched or a difference was detected.
          The result of this service can be retrieved using the MemAcc_GetJobResult() API.
          If the compare operation determined a mismatch, the result code is MEMACC_MEM_INCONSISTENT.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.Compare</srcid><srcstatus/><internalId>497</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00057</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Compare shall check that
        the MemAcc module has been initialized.
        If this check fails, MemAcc_Compare shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1636</srcid><srcstatus/><internalId>377</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Uninit</srcid><srcstatus/><internalId>530</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00058</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Compare shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_Compare shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_783</srcid><srcstatus/><internalId>303</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Invalid</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00059</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Compare shall raise the development error MEMACC_E_PARAM_POINTER
        if the dataPtr argument is a NULL pointer. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_792</srcid><srcstatus/><internalId>306</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Invalid</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00060</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Compare shall raise the development error MEMACC_E_PARAM_ADDRESS_LENGTH
        if the address range defined by sourceAddress and length is invalid, i.e. not aligned to MemReadPageSize.  (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_801</srcid><srcstatus/><internalId>309</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_810</srcid><srcstatus/><internalId>312</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_819</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Invalid</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00061</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_Compare shall raise the development error MEMACC_E_BUSY
        if a previous MemAcc job for the same addressAreaId  is still being processed. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1618</srcid><srcstatus/><internalId>375</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Invalid</srcid><srcstatus/><internalId>531</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00114</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If the compare operation determined a mismatch, the result code returned by the MemAcc_GetJobResult service shall be set to MEMACC_MEM_INCONSISTENT,
        otherwise MemAcc_GetJobResult shall return MEMACC_MEM_OK. (SRS_MemHwAb_14040)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Compare.JobResult.Mismatch</srcid><srcstatus/><internalId>204</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Compare.JobResult.Match</srcid><srcstatus/><internalId>205</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_BlankCheck (draft)
        Syntax Std_ReturnType MemAcc_BlankCheck ( MemAcc_AddressAreaIdType addressAreaId,  MemAcc_AddressType targetAddress,  MemAcc_LengthType length  )
        Service ID [hex] 0x0d
        Sync/Async Asynchronous
        Reentrancy Reentrant
        Parameters (in) addressAreaId Numeric identifier of address area.
                        targetAddress Blank check address in logical address space.
                        length Blank check length in bytes.
        Parameters (inout) None
        Parameters (out) None
        Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
                                    E_NOT_OK: The requested job has been rejected by the module.
                                    E_MEM_SERVICE_NOT_AVAIL: The underlying Mem driver service function is not available and no job was started.
        Description:
         Checks if the passed address space is blank, i.e. erased and writeable.
         The result of this service can be retrieved using the MemAcc_GetJobResult API.
         If the address area defined by targetAddress and length is blank,
         the result is MEMACC_MEM_OK, otherwise the result is MEMACC_MEM_INCONSISTENT.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.BlankCheck</srcid><srcstatus/><internalId>495</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00062</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_BlankCheck shall check that
        the MemAcc module has been initialized
        If this check fails, MemAcc_BlankCheck shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1710</srcid><srcstatus/><internalId>382</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_Uninit</srcid><srcstatus/><internalId>581</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00063</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_BlankCheck shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_BlankCheck shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_854</srcid><srcstatus/><internalId>320</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_InvalidRequest</srcid><srcstatus/><internalId>588</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_BlankCheck shall raise the development error MEMACC_E_PARAM_ADDRESS_LENGTH
        if the address range defined by sourceAddress and length is invalid, i.e. not aligned to MemReadPageSize.. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_862</srcid><srcstatus/><internalId>322</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_870</srcid><srcstatus/><internalId>324</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_878</srcid><srcstatus/><internalId>326</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_InvalidRequest</srcid><srcstatus/><internalId>588</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00065</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_BlankCheck shall raise the development error MEMACC_E_BUSY
        if a previous MemAcc job for the same addressAreaId is still being processed. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1681</srcid><srcstatus/><internalId>380</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_InvalidRequest</srcid><srcstatus/><internalId>588</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10028</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_HwSpecificService (draft)
        Syntax Std_ReturnType MemAcc_HwSpecificService (  MemAcc_AddressAreaIdType addressAreaId,  MemAcc_HwIdType hwId,  MemAcc_MemHwServiceIdType hwServiceId,  MemAcc_DataType* dataPtr,  MemAcc_LengthType* lengthPtr  )
        Service ID [hex] 0xe
        Sync/Async Asynchronous
        Reentrancy Reentrant
        Parameters (in)
          addressAreaId Numeric identifier of address area.
          hwId Unique numeric memory driver identifier.
          hwServiceId Array index pointing to the hardware specific service function pointer.
          dataPtr Data pointer pointing to the job buffer. Value can be NULL_PTR, if not needed.
                  If dataPtr is used by the hardware specific service, the pointer must be valid until the job completed.
        Parameters (inout)
          lengthPtr Size pointer of the data passed by dataPtr. Can be NULL_PTR if
          dataPtr is also NULL_PTR.
        Parameters (out) None
        Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
                                    E_NOT_OK: The requested job has not been accepted by the module.
                                    E_MEM_SERVICE_NOT_AVAIL: The underlying Mem driver service function is not available.
        Description
          Triggers a hardware specific job request referenced by hwServiceId.
          Service specific data can be passed/retrieved by dataPtr.
          The result of this service can be retrieved using the MemAcc_GetJobResult API. If the
          hardware specific operation was successful, the result of the job is MEMACC_MEM_OK.
          If the hardware specific operation failed, the result of the job is MEMACC_MEM_FAILED.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAccHwSpecificService</srcid><srcstatus/><internalId>266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00066</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_HwSpecificService shall check that
        the MemAcc module has been initialized.
        If this check fails, MemAcc_HwSpecificService shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAccHwSpecificService</srcid><srcstatus/><internalId>266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00067</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_HwSpecificService shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_HwSpecificService shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_MemHwSpecificServiceFuncType</srcid><srcstatus/><internalId>260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00068</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_HwSpecificService shall raise the development error MEMACC_E_PARAM_HW_ID
        if the Mem driver hardware identification given by hwId is invalid or not assigned to the passed addressAreaId. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAccHwSpecificService</srcid><srcstatus/><internalId>266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00070</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_HwSpecificService shall raise the development error MEMACC_E_BUSY
        if a previous MemAcc job for the same addressAreaId is still being processed.c(SRS_BSW_00323)</description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAccHwSpecificService</srcid><srcstatus/><internalId>266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_RequestLock (draft)
        Syntax Std_ReturnType MemAcc_RequestLock (  MemAcc_AddressAreaIdType addressAreaId,  MemAcc_AddressType address,  MemAcc_AddressType length,  void* lockNotificationFctPtr  )
        Service ID [hex] 0x11
        Sync/Async Asynchronous
        Reentrancy Reentrant
        Parameters (in)
          addressAreaId Numeric identifier of address area.
          address Logical start address of the address area to identify the Mem driver to be locked.
          length Length of the address area to identify the Mem driver to be locked.
          lockNotificationFctPtr Pointer to address area lock notification callback function.
        Parameters (inout) None
        Parameters (out) None
        Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
                                    E_NOT_OK: The requested job has been rejected by the module
        Description Request lock of an address area for exclusive access. Once the lock is granted, the referenced
        lock notification function is called by MemAcc.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.AddressAreaLock</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.RequestLock</srcid><srcstatus/><internalId>509</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00115</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        MemAcc_RequestLock shall lock all memory accesses of the Mem driver referenced by the addressAreaId, address and length parameter.
        If an upper layer calls a MemAcc service function for an address area which is locked for direct memory access,
        MemAcc shall still accept the memory access request for the address area but shall not forward the access request to the corresponding Mem driver until the lock request is released by the MemAcc_ReleaseLock service.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.RequestLock.DriverLock</srcid><srcstatus/><internalId>206</internalId></linkedfrom><linkedfrom><srcid>MemAcc.RequestLock.RequestLockedArea</srcid><srcstatus/><internalId>207</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00116</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        MemAcc shall wait until the address area referenced by addressAreaId is idle
        before it calls the lock notification function referenced by lockNotificationFctPtr
        to notify the upper layer module that the lock of the address area was successfully acquired.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.AddressAreaLock</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1180</srcid><srcstatus/><internalId>345</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_Pending_Area</srcid><srcstatus/><internalId>567</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_Pending_Drv</srcid><srcstatus/><internalId>568</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_Job_End</srcid><srcstatus/><internalId>570</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_Queued_Job</srcid><srcstatus/><internalId>571</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_Retry_Job</srcid><srcstatus/><internalId>572</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_2_Areas</srcid><srcstatus/><internalId>573</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00099</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_RequestLock shall check that
        the MemAcc module has been initialized.
        If this check fails, MemAcc_RequestLock shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2496</srcid><srcstatus/><internalId>422</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_Uninit</srcid><srcstatus/><internalId>565</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00071</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_RequestLock shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_RequestLock shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2464</srcid><srcstatus/><internalId>420</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Lock_Invalid</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00072</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_RequestLock shall raise the development error MEMACC_E_PARAM_POINTER
        if the lockNotificationFctPtr argument is a NULL pointer. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2471</srcid><srcstatus/><internalId>421</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Lock_Invalid</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00073</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_RequestLock shall raise the development error MEMACC_E_PARAM_ADDRESS_LENGTH
        if the address range defined by address and length is invalid, i.e. not mapped to a specific Mem driver. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.AddressAreaLock</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10031</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_ReleaseLock (draft)
        Syntax Std_ReturnType MemAcc_ReleaseLock (  MemAcc_AddressAreaIdType addressAreaId,  MemAcc_AddressType address,  MemAcc_LengthType length  )
        Service ID [hex] 0x12
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in)
          addressAreaId Numeric identifier of address area.
          address Logical start address to identify lock area.
          length Length to identify lock area.
        Parameters (inout) None
        Parameters (out) None
        Return value Std_ReturnType E_OK: The requested job has been accepted by the module.
                                    E_NOT_OK: The requested job has been rejected by the module.
        Description Release access lock of provided address area.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.AddressAreaLock</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>dev.MemAcc.MemAcc_ReleaseLock.SyncAsync</srcid><srcstatus/><internalId>271</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.ReleaseLock</srcid><srcstatus/><internalId>508</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00076</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_ReleaseLock shall check that
        the MemAcc module has been initialized.
        If this check fails, MemAcc_ReleaseLock shall raise the development error MEMACC_E_UNINIT. (SRS_BSW_00406)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2551</srcid><srcstatus/><internalId>425</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_ReleaseLock_Uninit</srcid><srcstatus/><internalId>566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00093</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_ReleaseLock shall check that
        the provided addressAreaId is consistent with the configuration.
        If this check fails, MemAcc_ReleaseLock shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2526</srcid><srcstatus/><internalId>424</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Lock_Invalid</srcid><srcstatus/><internalId>574</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00077</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service MemAcc_ReleaseLock shall raise the development error MEMACC_E_PARAM_ADDRESS_LENGTH
        if the address range defined by address and length is invalid, i.e. not aligned to MemEraseSectorSize.  (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.AddressAreaLock</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name MemAcc_MainFunction (draft)
        Syntax void MemAcc_MainFunction ( void )
        Service ID [hex] 0x03
        Sync/Async Synchronous
        Reentrancy Non Reentrant
        Parameters (in) None
        Parameters (inout) None
        Parameters (out) None
        Return value None
        Description
          Service to handle the requested jobs and the internal management operations.
          Depending on the configuration MemAcc will call the Mem driver main functions.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Interfaces.MainFunction</srcid><srcstatus/><internalId>506</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_00084</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is set to INDIRECT_DYNAMIC or INDIRECT_STATIC, MemAcc shall call all Mem main functions within MemAcc_MainFunction.
        MemAcc_MainFunction shall only call the Mem main function if there is a job request pending for the corresponding Mem driver.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Driver.IndirectStatic.MainFunction</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Driver.IndirectDynamic.MainFunction</srcid><srcstatus/><internalId>203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10036</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        API Function         Header File       Description
        Mem_BlankCheck          Mem.h      Triggers a job to check the erased state of the page  which is referenced by targetAddress.
                                           The result of  this service can be retrieved using the Mem_GetJobResult  API.
                                           If the checked page is blank, the result of the  job is MEM_JOB_OK. Otherwise, if the page is  not erased, the result is MEM_INCONSISTENT.
        Mem_Erase               Mem.h      Triggers an erase job of the given sector/sector batch defined by targetAddress and length.
                                           The result of this service can be retrieved using the Mem_GetJobResult API.
                                           If the erase operation was successful, the result of the job is MEM_JOB_OK.
                                           If the erase operation failed, e.g. due to a hardware issue, the result of the job is MEM_JOB_FAILED.
        Mem_GetJobResult        Mem.h      Service to return results of the most recent job.
        Mem_HwSpecificService   Mem.h      Triggers a hardware specific memory driver job.
                                           dataPtr can be used to pass and return data to/from this service.
                                           This service is just a dispatcher to the hardware specific service implementation referenced by hwServiceId.
                                           The result of this service can be retrieved using the Mem_GetJobResult API.
                                           If the hardware specific operation was successful, the result of the job is MEM_JOB_OK.
                                           If the hardware specific operation failed, the result of the job is MEM_JOB_FAILED.
        Mem_Init                Mem.h      Initialization function - initializes all variables and  sets the module state to initialized.
        Mem_MainFunction        Mem.h      Service to handle the requested jobs and the  internal management operations.
        Mem_PropagateError      Mem.h      This service can be used to report an access error in case the Mem driver cannot provide the access  error information - typically for ECC faults.
                                           It is  called by the system ECC handler to propagate an ECC error to the memory upper layers.
        Mem_Read                Mem.h      Triggers a read job to copy the from the source  address into the referenced destination data buffer.
                                           The result of this service can be retrieved using the Mem_GetJobResult API.
                                           If the read operation was successful, the result of the job is MEM_JOB_OK.
                                           If the read operation failed, the result of the job is either MEM_JOB_FAILED in case of a general error
                                           or MEM_ECC_CORRECTED/MEM_ECC_UNCORRECTED in case of a correctable/uncorrectable ECC error.
       Mem_Write                Mem.h      Triggers a write job to store the passed data to the  provided address area with given address and  length.
                                           The result of this service can be retrieved using the Mem_GetJobResult API.
                                           If the write operation was successful, the job result is MEM_JOB_OK.
                                           If there was an issue writing the data, the result is MEM_FAILED.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10035</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        API Function        Header File     Description
        Det_ReportError         Det.h       Service to report development errors.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10029</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name AddressAreaJobEndNotification (draft)
        Syntax void AddressAreaJobEndNotification(  MemAcc_AddressAreaIdType addressAreaId,  MemAcc_JobResultType jobResult  )
        Service ID [hex] 0x0f
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in)
          addressAreaId Numeric identifier of address area.
          jobResult Result of the last MemAcc operation.
        Parameters (inout) None
        Parameters (out) None
        Return value None
        Description MemAcc application job end notification callback. The function name is configurable.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.AddressAreaJobEndNotification</srcid><srcstatus/><internalId>480</internalId></linkedfrom><linkedfrom><srcid>MemAcc.Dsn.Interaction.Cbk.CancelFinishedJob</srcid><srcstatus/><internalId>512</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>
    <specobject>
      <id>MemAcc.SWS_MemAcc_10032</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Service Name ApplicationLockNotification (draft)
        Syntax void ApplicationLockNotification(void)
        Service ID [hex] 0x14
        Sync/Async Synchronous
        Reentrancy Reentrant
        Parameters (in) None
        Parameters (inout) None
        Parameters (out) None
        Return value None
        Description Address area lock application callback. The function name is configurable.
        Tags: atp.Status=draft
        Available via MemAcc.h
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>MemAcc.Dsn.Types.ApplicationLockNotification</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Module Name MemAcc
        Module Description The MemAcc (Memory Access module) coordinates the memory  access by multiple users
        in order to avoid conflicts with this shared  memory resource.
        The module abstracts from the memory device specific addressing
        scheme and provides a logical addressing scheme to the upper
        layer.
        Post-Build Variant Support false
        Supported Config Variants *, VARIANT-POST-BUILD, VARIANT-PRE-COMPILE
        Included Containers
        Container Name              Multiplicity  Scope / Dependency
        MemAccAddressArea Configuration 1..65535  This container includes the configuration of
                                                  AddressArea specific parameters for the MemAcc
                                                  module.
                                                  An AddressArea is a logical area of memory. Upper
                                                  layers only use logical addresses to access the
                                                  address area. It is the job of MemAcc to map between
                                                  logical and physical addresses. An AddressArea
                                                  contains SubAddressAreas and each
                                                  SubAddressArea is part of a physically continuous
                                                  memory area (sector batch).
                                                  Tags:
                                                  atp.Status=draft
        MemAccGeneral                   1         General configuration parameters of the MemAcc.
                                                  Tags:
                                                  atp.Status=draft
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_15</srcid><srcstatus/><internalId>431</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Container Name MemAccGeneral
        Parent Container MemAcc
        Description General configuration parameters of the MemAcc.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_860</srcid><srcstatus/><internalId>474</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00024</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAcc64BitSupport
        Parent Container MemAccGeneral
        Description If this option is selected, the address type shall be implemented in 64Bit.
        atp.Status=draft
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value false
        Value Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_923</srcid><srcstatus/><internalId>477</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccCompareApi
        Parent Container MemAccGeneral
        Description This parameter enables/disables the function MemAcc_Compare().
        This function allows to compare data stored in a buffer with data stored in memory.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value false
        Value Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_944</srcid><srcstatus/><internalId>478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccDevErrorDetect
        Parent Container MemAccGeneral
        Description Switches the development error detection and notification on or off.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value
        Post-Build Variant Value  false
        Value Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_966</srcid><srcstatus/><internalId>479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccMainFunctionPeriod
        Parent Container MemAccGeneral
        Description This value specifies the fixed call cycle for MemAcc_MainFunction().
        Additionally, if a job is ongoing on a Mem, the underlying
        Mem_MainFunction will be triggered directly by MemAcc at this fixed
        call cycle.
        MemAcc does not depend on a fixed cycle time; in can be triggered at
        arbitrary rates.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucFloatParamDef
        Range [1E-4 .. 1]
        Default Value 0.005
        Post-Build Variant Value false
        Value Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_873</srcid><srcstatus/><internalId>475</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccUseMemFuncPtrTable
        Parent Container MemAccGeneral
        Description This parameter defines if the Mem driver functions are called using the  Mem function pointer table API.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value true
        Post-Build Variant Value false
        Value Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_902</srcid><srcstatus/><internalId>476</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Container Name MemAccAddressAreaConfiguration
        Parent Container MemAcc
        Description This container includes the configuration of AddressArea specific  parameters
        for the MemAcc module.
        An AddressArea is a logical area of memory. Upper layers only use
        logical addresses to access the address area. It is the job of MemAcc
        to map between logical and physical addresses. An AddressArea
        contains SubAddressAreas and each SubAddressArea is part of a
        physically continuous memory area (sector batch).
        Tags:
        atp.Status=draft
        Post-Build Variant Multiplicity true
        Multiplicity Configuration Class
                Pre-compile time X VARIANT-PRE-COMPILE
                Link time –
                Post-build time X VARIANT-POST-BUILD
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_59</srcid><srcstatus/><internalId>432</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccAddressAreaId
        Parent Container MemAccAddressAreaConfiguration
        Description This value specifies a unique identifier which is used to reference to an AddressArea.
        This identifier is used as parameter for MemAcc jobs in order to
        distinguish between several AddressAreas with the same logical
        addresses.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucIntegerParamDef (Symbolic Name generated for this parameter)
        Range 0 .. 65535
        Default Value 0
        Post-Build Variant Value false
        Value Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_82</srcid><srcstatus/><internalId>433</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccAddressAreaPriority
        Parent Container MemAccAddressAreaConfiguration
        Description This value specifies the priority of an AddressArea compared to other AddressAreas (0 = lowest priority, 65535 = highest priority).
        For each AddressArea only one job can be processed at a time.
        MemAcc processes the jobs priority based. In case a job with a higher
        priority is requested by an upper layer, the lower priority jobs are
        suspended until the higher priority job is completed.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0 .. 65535
        Default Value 0
        Post-Build Variant Value true
        Value Configuration
        Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_113</srcid><srcstatus/><internalId>435</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00025</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccBufferAlignmentValue
        Parent Container MemAccAddressAreaConfiguration
        Description Buffer alignment value inherited by MemAcc upper layer modules.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0 .. 255
        Default Value
        Post-Build Variant Value false
        Value Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_141</srcid><srcstatus/><internalId>436</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00027</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccJobEndNotificationName
        Parent Container MemAccAddressAreaConfiguration
        Description Job end notification function which is called after MemAcc job  completion.
        If this parameter is left empty, no job end notification is  triggered and the upper layer module needs to poll the job results.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucFunctionNameDef
        Default Value
        Regular Expression
        Post-Build Variant Value false
        Value Configuration
        Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency
        Included Containers
        Container Name                    Multiplicity Scope / Dependency
        MemAccSubAddressAreaConfiguration    1..65536  This container includes the configuration parameters for
                                                       a physically continuous area of memory.
        Tags:
        atp.Status=draft
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_164</srcid><srcstatus/><internalId>437</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Container Name MemAccSubAddressAreaConfiguration
        Parent Container MemAccAddressAreaConfiguration
        Description This container includes the configuration parameters for a physically continuous area of memory.
        Tags:
        atp.Status=draft
        Post-Build Variant Multiplicity true
        Multiplicity Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_189</srcid><srcstatus/><internalId>438</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00015</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccLogicalStartAddress
        Parent Container MemAccSubAddressAreaConfiguration
        Description This value specifies the logical start address of the SubAddressArea.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0 .. 18446744073709551615
        Default Value 0
        Post-Build Variant Value true
        Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_205</srcid><srcstatus/><internalId>439</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccMemInvocation
        Parent Container MemAccSubAddressAreaConfiguration
        Description Defines how the Mem driver services are accessed and how the Mem  driver is scheduled and activated/initialized.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range
        DIRECT_STATIC   Mem driver is linked with application.
                            Mem service functions are directly
                            called by MemAcc. Mem_Init is called
                            by EcuM and Mem_MainFunction is
                            triggered by SchM.
                            Tags:
                            atp.Status=draft
        INDIRECT_DYNAMIC Mem driver is linked as a separate
                            binary and is dynamically activated.
                            MemAcc will use Mem driver header
                            table to invoke Mem service functions.
                            Call of Mem_Init and
                            Mem_MainFunction is handled by
                            MemAcc.
                            Tags:
                            atp.Status=draft
        INDIRECT_STATIC  Mem driver is linked with application.
                          MemAcc will use Mem driver header
                          table to invoke Mem service functions.
                          Call of Mem_Init and
                          Mem_MainFunction is handled by
                          MemAcc.
                          Tags:
                          atp.Status=draft
        Default Value DIRECT_STATIC
        Post-Build Variant
        Value
        false
        Value Configuration
        Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_453</srcid><srcstatus/><internalId>455</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00017</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccMemNamePrefix
        Parent Container MemAccSubAddressAreaConfiguration
        Description Depending on the MemAccUseMemFuncPtrTable configuration,
        this  prefix is either used to reference the Mem driver header structure or the according Mem API function.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucStringParamDef
        Default Value
        Regular Expression
        Post-Build Variant Value false
        Value Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_495</srcid><srcstatus/><internalId>457</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccNumberOfEraseRetries
        Parent Container MemAccSubAddressAreaConfiguration
        Description This value specifies the number of retries of a failed erase job.
          0: No retry, a failed job will be aborted immediately
          &gt; 0: Retry the number of times before aborting the job.
          Tags:
          atp.Status=draft
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 0 .. 255
        Default Value 0
        Post-Build Variant Multiplicity false
        Post-Build Variant Value true
        Multiplicity Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Value Configuration
        Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_277</srcid><srcstatus/><internalId>442</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccNumberOfSectors
        Parent Container MemAccSubAddressAreaConfiguration
        Description This value specifies the number of physical sectors of the SubAddressArea.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 1 .. 4294967295
        Default Value 1
        Post-Build Variant Value true
        Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_229</srcid><srcstatus/><internalId>440</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccNumberOfWriteRetries
        Parent Container MemAccSubAddressAreaConfiguration
        Description This value specifies the number of retries of a failed write job.
          0: No retry, a failed job will be aborted immediately
          &gt; 0: Retry the number of times before aborting the job.
          Tags:
        atp.Status=draft
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 0 .. 255
        Default Value 0
        Post-Build Variant Multiplicity false
        Post-Build Variant Value        true
        Multiplicity Configuration Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Value Configuration
        Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_307</srcid><srcstatus/><internalId>443</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00016</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccSectorOffset
        Parent Container MemAccSubAddressAreaConfiguration
        Description This value specifies the sector offset of the SubAddressArea in case
        the SubAddressArea should not start with the first sector of the  referenced MemSectorBatch.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0 .. 4294967295
        Default Value 0
        Post-Build Variant Value true
        Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_253</srcid><srcstatus/><internalId>441</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccUseEraseBurst
        Parent Container MemAccSubAddressAreaConfiguration
        Description This parameter enables erase bursting for the related sub address  area.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value true
        Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_337</srcid><srcstatus/><internalId>444</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccUseReadBurst
        Parent Container MemAccSubAddressAreaConfiguration
        Description This parameter enables read bursting for the related sub address area.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value False
        Post-Build Variant Value true
        Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_366</srcid><srcstatus/><internalId>447</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccUseWriteBurst
        Parent Container MemAccSubAddressAreaConfiguration
        Description This parameter enables write bursting for the related sub address area.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value true
        Value Configuration
        Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_398</srcid><srcstatus/><internalId>450</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>
    <specobject>
      <id>MemAcc.ECUC_MemAcc_00023</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_MemoryAccess.pdf</source>
      <version>1</version>
      <description>
        Name MemAccSectorBatchRef
        Parent Container MemAccSubAddressAreaConfiguration
        Description Reference to MemSectorBatch mapped to the SubAddressArea.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type Reference to MemSectorBatch
        Post-Build Variant Value true
        Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_543</srcid><srcstatus/><internalId>461</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.VariantPostBuild</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>MemAcc.CrossDeviceBoundaryOperation.Read</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        Read service shall support access requests which cross memory device boundaries
        based on the logical/physical memory mapping.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_Drvs</srcid><srcstatus/><internalId>614</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_2_Drv_Burst</srcid><srcstatus/><internalId>617</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>
    <specobject>
      <id>MemAcc.CrossDeviceBoundaryOperation.Write</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        Write service shall support access requests which cross memory device boundaries
        based on the logical/physical memory mapping.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_Drvs</srcid><srcstatus/><internalId>626</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_2_Drv_Burst</srcid><srcstatus/><internalId>629</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_Drvs_Successful_Retry</srcid><srcstatus/><internalId>632</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>
    <specobject>
      <id>MemAcc.CrossDeviceBoundaryOperation.Erase</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        Erase service shall support access requests which cross memory device boundaries
        based on the logical/physical memory mapping.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_Drvs</srcid><srcstatus/><internalId>592</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_2_Drv_Burst</srcid><srcstatus/><internalId>595</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_Drvs_Successful_Retry</srcid><srcstatus/><internalId>598</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>
    <specobject>
      <id>MemAcc.CrossDeviceBoundaryOperation.Compare</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        Compare service shall support access requests which cross memory device boundaries
        based on the logical/physical memory mapping.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_2_Drvs</srcid><srcstatus/><internalId>534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>
    <specobject>
      <id>MemAcc.CrossDeviceBoundaryOperation.BlankCheck</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        Blank check service shall support access requests which cross memory device boundaries
        based on the logical/physical memory mapping.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_2_Drvs_NotAvailable</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Mem_BlankCheck_Prio_Preemption</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_2_Drvs_Available</srcid><srcstatus/><internalId>583</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>
    <specobject>
      <id>MemAcc.MemoryAccess.Read.Page</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        The MemAcc module shall split memory access read requests for the Mem driver layer according to read page size
        if MemAccUseReadBurst is disabled
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_646</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea</srcid><srcstatus/><internalId>612</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_1_Drv</srcid><srcstatus/><internalId>613</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_2_Drvs</srcid><srcstatus/><internalId>614</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Failed_Job</srcid><srcstatus/><internalId>618</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>619</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_2_Areas_1_Drv_Wait</srcid><srcstatus/><internalId>620</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_2_Areas_1_Drv_Preempted</srcid><srcstatus/><internalId>621</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>
    <specobject>
      <id>MemAcc.MemoryAccess.Write.Page</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        The MemAcc module shall split memory access write requests for the Mem driver layer according to write page size
        if MemAccUseWriteBurst is disabled
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_687</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea</srcid><srcstatus/><internalId>624</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_1_Drv</srcid><srcstatus/><internalId>625</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_Retry</srcid><srcstatus/><internalId>630</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_NoRetry</srcid><srcstatus/><internalId>631</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_2_Drvs_Successful_Retry</srcid><srcstatus/><internalId>632</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Successful_Max_Retry</srcid><srcstatus/><internalId>633</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_Max_Retry</srcid><srcstatus/><internalId>634</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>635</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_2_Areas_1_Drv_Wait</srcid><srcstatus/><internalId>636</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>
    <specobject>
      <id>MemAcc.MemoryAccess.Erase.Sector</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        The MemAcc module shall split memory access sector erase requests for the Mem driver layer according to sector size
        if MemAccUseEraseBurst is disabled
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1880</srcid><srcstatus/><internalId>384</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea</srcid><srcstatus/><internalId>590</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_1_Drv</srcid><srcstatus/><internalId>591</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_2_Drvs</srcid><srcstatus/><internalId>592</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_NoRetry</srcid><srcstatus/><internalId>597</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_DrvRequest</srcid><srcstatus/><internalId>601</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_2_Areas_1_Drv_Wait</srcid><srcstatus/><internalId>602</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_2_Areas_1_Drv_Preempted</srcid><srcstatus/><internalId>603</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>
    <specobject>
      <id>MemAcc.Prioritization.SuspendResume</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        The prioritization of memory operations shall use the Mem_Suspend and Mem_Resume service if the memory hardware supports this functionality.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_SuspendResume</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>
    <specobject>
      <id>MemAcc.Prioritization.Page</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the memory hardware does not support a suspend/resume functionality, the prioritization shall be implemented on a page
        when page mode is used by current service that uses the hardware.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Mixed_APIs_Prio_Wait</srcid><srcstatus/><internalId>605</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Mixed_APIs_Prio_Wait_Failed</srcid><srcstatus/><internalId>606</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Mixed_APIs_Prio_Mid_Wait</srcid><srcstatus/><internalId>607</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Mixed_APIs_Prio_Mid_Preempted</srcid><srcstatus/><internalId>608</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Mixed_APIs_Prio_Preempted_Failed</srcid><srcstatus/><internalId>609</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Mixed_APIs_Prio_Diff_Drvs</srcid><srcstatus/><internalId>610</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_2_Areas_1_Drv_Wait</srcid><srcstatus/><internalId>620</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_2_Areas_1_Drv_Wait</srcid><srcstatus/><internalId>636</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>
    <specobject>
      <id>MemAcc.Prioritization.PageBurst</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the memory hardware does not support a suspend/resume functionality, the prioritization shall be implemented on a page burst 
        when page burst mode is used by current service that uses the hardware.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Burst_2_Areas_Preempted</srcid><srcstatus/><internalId>539</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_2_Areas_1_Drv_Preempted</srcid><srcstatus/><internalId>621</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_2_Areas_1_Drv_Preempted</srcid><srcstatus/><internalId>637</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>
    <specobject>
      <id>MemAcc.Prioritization.Sector</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the memory hardware does not support a suspend/resume functionality, the prioritization shall be implemented on a sector 
        when sector mode is used by current service that uses the hardware.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_2_Areas_1_Drv_Wait</srcid><srcstatus/><internalId>602</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Mixed_APIs_Prio_Wait_Failed</srcid><srcstatus/><internalId>606</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Mixed_APIs_Prio_Mid_Wait</srcid><srcstatus/><internalId>607</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>
    <specobject>
      <id>MemAcc.Prioritization.SectorBurst</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the memory hardware does not support a suspend/resume functionality, the prioritization shall be implemented on a sector burst
        when sector burst mode is used by current service that uses the hardware.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_2_Areas_1_Drv_Preempted</srcid><srcstatus/><internalId>603</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>
    <specobject>
      <id>MemAcc.Request.MultipleRequestsForSameAreaReturnCode</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the MemAcc module is not able to process a job request, due to a pending request on the same address area, 
        the job request shall be rejected by an E_NOT_OK return code.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_776</srcid><srcstatus/><internalId>300</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_847</srcid><srcstatus/><internalId>317</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_InvalidRequest</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_Invalid</srcid><srcstatus/><internalId>604</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_Invalid</srcid><srcstatus/><internalId>622</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_Invalid</srcid><srcstatus/><internalId>638</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>
    <specobject>
      <id>MemAcc.Request.InvalidParameter</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the MemAcc module is not able to process a job request, due to an invalid parameter, 
        the job request shall be rejected by an E_NOT_OK return code.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_775</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_846</srcid><srcstatus/><internalId>316</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_InvalidRequest</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Erase_Invalid</srcid><srcstatus/><internalId>604</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Read_Invalid</srcid><srcstatus/><internalId>622</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_Invalid</srcid><srcstatus/><internalId>638</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>
    <specobject>
      <id>MemAcc.Request.Inconsistent.BlankCheck</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        In case the a blank check job processing was completed but the result of the job didn’t meet the expected result,
        (was applied on a non-blank memory area), the job result shall be set to MEMACC_MEM_INCONSISTENT.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1132</srcid><srcstatus/><internalId>341</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_CheckFailed</srcid><srcstatus/><internalId>586</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>
    <specobject>
      <id>MemAcc.Request.Inconsistent.Compare</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        In case the a compare job processing was completed but the result of the job didn’t meet the expected result,
        (the comparison revealed different memory content than the checked one), the job result shall be set to MEMACC_MEM_INCONSISTENT.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1072</srcid><srcstatus/><internalId>331</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_1_SubArea</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_2_SubAreas_1_Drv</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>
    <specobject>
      <id>MemAcc.Driver.IndirectStatic.MainFunction</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is set to INDIRECT_STATIC, MemAcc shall call all Mem main functions within MemAcc_MainFunction
        if there is a job request pending for the corresponding Mem driver.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00084</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
    <specobject>
      <id>MemAcc.Driver.IndirectDynamic.MainFunction</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is set to INDIRECT_DYNAMIC, MemAcc shall call all Mem main functions within MemAcc_MainFunction
        if there is a job request pending for the corresponding Mem driver.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.MemAcc_Indirect</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00084</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>
    <specobject>
      <id>MemAcc.Compare.JobResult.Mismatch</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the compare operation determined a mismatch, the result code returned by the MemAcc_GetJobResult service shall be set to MEMACC_MEM_INCONSISTENT
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1073</srcid><srcstatus/><internalId>332</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_1_SubArea</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_2_SubAreas_1_Drv</srcid><srcstatus/><internalId>533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>
    <specobject>
      <id>MemAcc.Compare.JobResult.Match</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If the compare operation determined a match, the result code returned by the MemAcc_GetJobResult service shall be set to MEMACC_MEM_OK
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1092</srcid><srcstatus/><internalId>335</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_2_Drvs</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_2_Areas_2_Drvs_Wait</srcid><srcstatus/><internalId>535</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_2_Areas_2_Drvs_Preempted</srcid><srcstatus/><internalId>536</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Wait_HighPrio_Failed</srcid><srcstatus/><internalId>537</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Burst_1_Area</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Burst_2_Areas_Preempted</srcid><srcstatus/><internalId>539</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_2_SubAreas_1_MemDrv</srcid><srcstatus/><internalId>576</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>
    <specobject>
      <id>MemAcc.RequestLock.DriverLock</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        MemAcc_RequestLock shall lock all memory accesses of the Mem driver referenced by the addressAreaId, address and length parameter.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.MemAcc.AddressAreaLock</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>
    <specobject>
      <id>MemAcc.RequestLock.RequestLockedArea</id>
      <status>approved</status>
      <source>EB Refinement</source>
      <version>1</version>
      <description>
        If an upper layer calls a MemAcc service function for an address area which is locked for direct memory access,
        MemAcc shall still accept the memory access request for the address area but shall not forward the access request to the corresponding Mem driver until the lock request is released by the MemAcc_ReleaseLock service.
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_RequestLock_Queued_Job</srcid><srcstatus/><internalId>571</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    <!-- EB specific features ====================================================================== -->
    <specobject>
      <id>MemAcc.EB.ECUC_UserHeader</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         MemAccUserHeader
        Description:  Defines user specific header files for user-defined symbols.
        Multiplicity: 1
        Type:         EcucStringParamDef
        Range:        0 .. 255
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_821</srcid><srcstatus/><internalId>473</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_Invocation_Legacy</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name MemAccMemInvocation
        Parent Container MemAccSubAddressAreaConfiguration
        Description Defines how the Mem/Fls driver services are accessed and how the Mem/Fls  driver is scheduled and activated/initialized.
        Tags:
        atp.Status=draft
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range 
        DIRECT_LEGACY       Fls driver is linked with application.
                            Fls service functions are directly
                            called by MemAcc. Fls_Init is called
                            by EcuM and Fls_MainFunction is
                            triggered by SchM.
                            Tags:
                            atp.Status=draft
    
        Default Value DIRECT_STATIC
        Post-Build Variant
        Value
        false
        Value Configuration
        Class
        Pre-compile time X All Variants
        Link time –
        Post-build time –
        Scope / Dependency
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_454</srcid><srcstatus/><internalId>456</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_SectorBatchRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name MemAccFlsEepSectorBatchRef      
        Parent Container MemAccSubAddressAreaConfiguration 
        Description Reference to FlsEepSectorBatch mapped to the SubAddressArea.
        Tags:
        atp.Status=draft
        Multiplicity 0..1
        Type Reference to FlsEepSectorBatch
        Post-Build Variant Value true
        Value Configuration Class
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time –
        Post-build time –
        Scope / Dependency scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_521</srcid><srcstatus/><internalId>459</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_SectorBatch</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepSectorBatch
        Description:  Configuration description of a programmable sector or sector batch.
        Multiplicity: 1..*
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_568</srcid><srcstatus/><internalId>462</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>  
    <specobject>
      <id>MemAcc.EB.ECUC_SectorBatch_StartPhysicalAddress</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepStartAddress
        Description:  Physical start address of the sector in Fls/Eep.
        Multiplicity: 1
        Type:         INTEGER
        Range:        1 .. 18446744073709551615
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_592</srcid><srcstatus/><internalId>463</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_PageSize_Read</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepReadChunkSize
        Description:  Size of chunks in which a read job is split and sent to a legacy driver in normal mode.
                      It should be a multiple of FlsMaxReadNormalMode/EepReadUnitSize.
                      This size will behave for upper layer in same way as MemDrv read page size: read jobs length shall be a multiple of this size, and prioritization of other pending jobs will be done only after finishing an ongoing chunk.
                      For faster reads, burst mode shall be enabled and configured with coarser read size.
                      Note that handling of an available fast driver mode is not handled by MemAcc.
        Multiplicity: 1
        Type:         INTEGER
        Range:        1 .. 4294967295
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_615</srcid><srcstatus/><internalId>464</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_PageSize_Write</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepWriteChunkSize
        Description:  Size of chunks in which a write job is split and sent to a legacy driver in normal mode.
                      It should be a multiple of FlsMaxWriteNormalMode/EepWriteUnitSize.
                      This size will behave for upper layer in same way as MemDrv write page size: read jobs length shall be a multiple of this size, and prioritization of other pending jobs will be done only after finishing an ongoing chunk.
                      For flash drivers, depending on usual write sizes, a multiple of FlsMaxWriteNormalMode could be more efficient in terms of write speed. 
                      The downside of optimizing the write in bigger chunks is that the upper layer has to provide MemAcc the jobs in a buffer that has the size multiple of this configuration
                      For more flexible alignment requirements and fast write of bigger jobs, burst mode shall be enabled and configured with coarser size.
                      Note that handling of an available fast driver mode is not handled by MemAcc.
        Multiplicity: 1
        Type:         INTEGER
        Range:        1 .. 4294967295
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_642</srcid><srcstatus/><internalId>465</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_SectorSize_Erase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepEraseSectorSize
        Description:  Defines Fls/Eep sector size during erase operation,
                      It is equivalent to FlsSectorSize/EepEraseUnitSize. 
        Multiplicity: 1
        Type:         INTEGER
        Range:        1 .. 4294967295
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_671</srcid><srcstatus/><internalId>466</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_NumberOfSectors</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepNumberOfSectors
        Description:  Number of contiguous sectors with identical values for MemSectorSize and MemPageSize.
        Multiplicity: 1
        Type:         INTEGER
        Range:        1 .. 65536
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_695</srcid><srcstatus/><internalId>467</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_EraseCycles</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepSpecifiedEraseCycles
        Description:  Defines maximum Fls/Eep erase cycles per sector batch. 
        Multiplicity: 1
        Type:         INTEGER
        Range:        0 .. 4294967295
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_719</srcid><srcstatus/><internalId>468</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_BurstSettings</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepBurstSettings
        Description:  Container for burst setting configuration parameters of the Mem driver. 
        Multiplicity: 0..1
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_742</srcid><srcstatus/><internalId>469</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_BurstPageSize_Read</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepReadBurstSize
        Description:  Defines maximum Fls/Eep burst page size during read operation.
        Multiplicity: 1
        Type:         INTEGER
        Range:        0 .. 4294967295
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_749</srcid><srcstatus/><internalId>470</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_BurstPageSize_Write</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepWriteBurstSize
        Description:  Defines maximum Fls/Eep burst page size during write operation.
        Multiplicity: 1
        Type:         INTEGER
        Range:        0 .. 4294967295
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_772</srcid><srcstatus/><internalId>471</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.ECUC_BurstSectorSize_Erase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         FlsEepEraseBurstSize
        Description:  Defines maximum Fls/Eep burst sector size during erase operation.
        Multiplicity: 1
        Type:         INTEGER
        Range:        0 .. 4294967295
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_795</srcid><srcstatus/><internalId>472</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.MemoryAccess.Compare.Page</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The MemAcc module shall split memory access compare requests for the Mem driver layer according to read page size
        if MemAccUseReadBurst is disabled.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_647</srcid><srcstatus/><internalId>292</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_1_SubArea</srcid><srcstatus/><internalId>532</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_1_Area_2_Drvs</srcid><srcstatus/><internalId>534</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_2_Areas_2_Drvs_Wait</srcid><srcstatus/><internalId>535</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_2_Areas_2_Drvs_Preempted</srcid><srcstatus/><internalId>536</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.MemoryAccess.Compare.Burst</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The MemAcc module shall split memory access compare requests for the Mem driver layer up to read burst size
        if MemAccUseReadBurst is enabled.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_633</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Burst_1_Area</srcid><srcstatus/><internalId>538</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Compare_Burst_2_Areas_Preempted</srcid><srcstatus/><internalId>539</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.MemoryAccess.BlankCheck.Page</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The MemAcc module shall split memory access BlankCheck requests for the Mem driver layer according to read page size
        if MemAccUseReadBurst is disabled.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_648</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_1_Drv_Available</srcid><srcstatus/><internalId>582</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_Prio_Wait</srcid><srcstatus/><internalId>584</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_1_Drv_Failed_DrvRequest</srcid><srcstatus/><internalId>587</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.MemoryAccess.BlankCheck.Burst</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The MemAcc module shall split memory access BlankCheck requests for the Mem driver layer up to read burst size
        if MemAccUseReadBurst is enabled.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_634</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Mem_BlankCheck_Prio_Preemption</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_2_Drvs_Available</srcid><srcstatus/><internalId>583</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.GetMemoryInfo.InvalidAddress</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled by MemAccDevErrorDetect, the service GetMemoryInfo 
        shall raise the development error MEMACC_E_PARAM_ADDRESS_LENGTH if the address range defined 
        by address is invalid.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2194</srcid><srcstatus/><internalId>404</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetMemoryInfo_Invalid_TEST</srcid><srcstatus/><internalId>551</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.GetJobStatus.InvalidAddressAreaId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If development error detection is enabled  by MemAccDevErrorDetect, the service MemAcc_GetJobStatus 
        shall check that the provided addressAreaId is consistent with the configuration, if this check fails 
        MemAcc_GetJobStatus shall raise the development error MEMACC_E_PARAM_ADDRESS_AREA_ID.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2144</srcid><srcstatus/><internalId>398</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobStatus_Invalid_TEST</srcid><srcstatus/><internalId>548</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.GetJobResult.Init.NewRequest</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Once a job request was accepted, the job processing result shall be set to MEMACC_MEM_OK.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1012</srcid><srcstatus/><internalId>328</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobResult_Init</srcid><srcstatus/><internalId>547</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.MemoryAccess.GetJobInfo.ActiveJob</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The service MemAcc_GetJobInfo shall return the current memory driver result if the current sub area
        being processed is the one for which the corresponding driver is executing a command.
      </description>
      <rationale>
        Since a job might get preempted by a higher priority job.
      </rationale>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2395</srcid><srcstatus/><internalId>415</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Read_TEST</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Compare_TEST</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.MemoryAccess.GetJobInfo.InactiveJob</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The service MemAcc_GetJobInfo shall return the previous memory driver result if the related request 
        already processed or it is waiting for the driver busy executing a command from a higher priority area.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2400</srcid><srcstatus/><internalId>416</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Read_TEST</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Write_TEST</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Compare_TEST</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.FLs.Burst.Erase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is "DIRECT_LEGACY" and MemAccUseEraseBurst is enabled, FlsEepBurstSettings of
        the referenced MemAccFlsEepSectorBatchRef shall be configured.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_357</srcid><srcstatus/><internalId>445</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.FLs.Burst.Read</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is "DIRECT_LEGACY" and MemAccUseReadBurst is enabled, FlsEepBurstSettings of
        the referenced MemAccFlsEepSectorBatchRef shall be configured.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_389</srcid><srcstatus/><internalId>448</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.FLs.Burst.Write</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is "DIRECT_LEGACY" and MemAccUseWriteBurst is enabled, FlsEepBurstSettings of
        the referenced MemAccFlsEepSectorBatchRef shall be configured.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_418</srcid><srcstatus/><internalId>451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.Mem.Burst.Erase</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is "DIRECT_STATIC" and MemAccUseEraseBurst is enabled, MemBurstSettings of
        the referenced MemAccSectorBatchRef shall be configured.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_358</srcid><srcstatus/><internalId>446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.Mem.Burst.Read</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is "DIRECT_STATIC" and MemAccUseReadBurst is enabled, MemBurstSettings of
        the referenced MemAccSectorBatchRef shall be configured.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_390</srcid><srcstatus/><internalId>449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.Mem.Burst.Write</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is "DIRECT_STATIC" and MemAccUseWriteBurst is enabled, MemBurstSettings of
        the referenced MemAccSectorBatchRef shall be configured.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_419</srcid><srcstatus/><internalId>452</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.SubArea.MemInvocation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For all subareas that span over the same driver, MemAccMemInvocation type has to be the same. 
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccAddressSubArea.java_156</srcid><srcstatus/><internalId>428</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.AddressArea.LogicalAddresses</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Each Address area shall provide a contiguous pool of logical addresses.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccAddressArea.java_112</srcid><srcstatus/><internalId>427</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.AddressArea.AddressAreaId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        MemAccAddressAreaId shall be unique, as it is used as parameter for MemAcc jobs in order to
        distinguish between several AddressAreas with the same logical addresses.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_108</srcid><srcstatus/><internalId>434</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.Mem.MemNamePrefix</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If MemAccMemInvocation is "DIRECT_STATIC", the configured MemAccMemNamePrefix shall 
        match the referenced Mem driver name as it is used to reference the according Mem APIs.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_513</srcid><srcstatus/><internalId>458</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.Legacy.DataTypes</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        MemAcc shall only support legacy drivers (Fls/Eep) configured for 32 bits.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Int_Types.h_31</srcid><srcstatus/><internalId>274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.VariableWrite.Configuration</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:         MemAccUseVariableWrite
        Description:  Enable/Disable of Write Jobs with variable length for a specific SubArea.
        Multiplicity: 1
        Type:         EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value: false
        Value Configuration Class:
        Pre-compile time: X All Variants
        Link time: -
        Post-build time: -
        Scope / Dependency: scope: local
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_427</srcid><srcstatus/><internalId>453</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.VariableWrite.Dependency</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        EB parameter "MemAccUseVariableWrite" shall only be enabled for a SubArea when parameter "MemAccUseWriteBurst" is enabled for that SubArea.
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/MemAcc.xdm.m4_450</srcid><srcstatus/><internalId>454</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.VariableWrite.Functionality</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When EB parameter "MemAccUseVariableWrite" is enabled the MemAcc shall trigger Write jobs for values between 
        "WriteChunkSize" and "WriteBurstSize".
      </description>
      <comment>
        This means Write Jobs will not be split any more by "WriteChunkSize".
      </comment>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_681</srcid><srcstatus/><internalId>295</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_VarWrite_1</srcid><srcstatus/><internalId>577</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_VarWrite_2</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_VarWrite_3</srcid><srcstatus/><internalId>579</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_VarWrite_4</srcid><srcstatus/><internalId>580</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.DataAccess</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Data shared between APIs and main function shall be accessed atomically.
      </description>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.MemAcc.EB_INTREQ_MemAcc_MemoryAlignment</srcid><srcstatus/><internalId>2</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    <specobject>
      <id>MemAcc.EB.BSWMD.ExclusiveAreas</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The MemAcc module description (BSWMD) shall contain
        the information on the exclusive areas required by the module's implementation.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifySchmExclusiveAreas</srcid><srcstatus/><internalId>522</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>MemAcc.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemAcc_DBGINST_001</srcid><srcstatus/><internalId>520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>

    <specobject>
      <id>MemAcc.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemAcc_DBGINST_001</srcid><srcstatus/><internalId>520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>

    <specobject>
      <id>MemAcc.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemAcc_DBGINST_001</srcid><srcstatus/><internalId>520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>

    <specobject>
      <id>MemAcc.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemAcc_DBGINST_001</srcid><srcstatus/><internalId>520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>

    <specobject>
      <id>MemAcc.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemAcc_DBGINST_001</srcid><srcstatus/><internalId>520</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>MemAcc.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MemAcc_VerifyCodeStub</srcid><srcstatus/><internalId>521</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.MemAcc.VariantPostBuild</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>29</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.JobInfoType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAccJobEndNotification</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>100</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_MemReadFuncType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>145</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_MemWriteFuncType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>190</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_MemEraseFuncType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>234</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_MemBlankCheckFuncType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>280</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_MemHwSpecificServiceFuncType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>327</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00067</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_ActivateMem</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>358</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00121</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00088</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00122</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00123</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_SuspendResume</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>389</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.SuspendResume</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_Indirect</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>423</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Driver.IndirectStatic.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Driver.IndirectDynamic.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00111</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91000</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc64BitSupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>458</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00081</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00082</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.AddressAreaLock</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>492</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
        <provcov>
          <linksto>MemAcc.RequestLock.DriverLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00073</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00077</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAccHwSpecificService</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>523</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00066</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00068</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAccECC</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>583</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.GetJobResult</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>613</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.ReadBurst</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>643</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.DeInit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>672</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_ReleaseLock.SyncAsync</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>702</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
    <specobject>
      <id>dev.MemAcc.MemAcc_GetJobStatus.ServiceID</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>732</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/MemAcc.h_133</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc.h</sourcefile>
      <sourceline>133</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/MemAcc_Int_Types.h_31</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Int_Types.h</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.Legacy.DataTypes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_19</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>19</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemInstanceIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>493</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_23</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_HwIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_27</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_AddressAreaIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_31</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_DataType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>485</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_35</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>35</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemHwServiceIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_41</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>41</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_JobResultType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_85</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_JobStatusType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>489</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_103</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_JobType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>490</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_155</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>155</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.AddressAreaJobEndNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>480</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_169</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>169</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.ApplicationLockNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_177</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>177</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_ConfigType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>484</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_184</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>184</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_JobInfoType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>487</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
    <specobject>
      <id>src/Autosar/include/MemAcc_Types.h_206</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/include/MemAcc_Types.h</sourcefile>
      <sourceline>206</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemoryInfoType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_632</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>632</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_633</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>633</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.Compare.Burst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_634</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>634</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.BlankCheck.Burst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_646</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>646</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Read.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_647</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>647</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.Compare.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_648</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>648</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.BlankCheck.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_671</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>671</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_681</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>681</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.VariableWrite.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_687</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>687</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_704</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>704</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_716</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>716</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_775</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>775</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.InvalidParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_776</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>776</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.MultipleRequestsForSameAreaReturnCode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_781</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>781</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_782</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>782</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_783</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>783</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_790</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>790</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_791</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>791</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00050</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_792</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>792</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_799</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>799</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_800</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>800</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_801</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>801</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_808</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>808</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_809</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>809</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_810</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>810</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_817</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>817</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_818</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>818</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_819</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>819</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_846</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>846</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.InvalidParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_847</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>847</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.MultipleRequestsForSameAreaReturnCode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_852</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>852</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_853</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>853</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_854</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>854</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_861</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>861</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_862</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>862</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_869</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>869</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_870</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>870</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_877</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>877</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_878</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>878</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1010</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1010</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1012</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1012</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.GetJobResult.Init.NewRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1023</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1023</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.SubAreaJobState.NewJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>517</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1057</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1057</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1072</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1072</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.Inconsistent.Compare</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1073</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1073</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Mismatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1085</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1085</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.SubAreaJobState.JobDone</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>519</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1091</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1091</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1092</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1092</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1093</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1093</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.JobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1094</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1094</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Cbk.CancelFinishedJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1096</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1096</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1130</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1130</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.JobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1131</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1131</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Cbk.CancelFinishedJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1132</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1132</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.Inconsistent.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1157</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1157</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.JobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1158</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1158</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Cbk.CancelFinishedJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1159</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1159</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1180</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1180</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1301</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1301</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.Canceled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>513</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1302</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1302</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Cbk.Canceled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>511</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1303</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1303</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1314</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1314</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1321</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1321</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1326</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1326</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.SubAreaJobState.JobRequested</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>516</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1332</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1332</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.SubAreaJobState.BusyDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>518</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1346</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1346</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1374</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1374</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>505</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1400</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1400</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00112</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1402</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1402</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1412</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1412</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.SubAreaJobState.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1423</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1423</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Read</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>507</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1444</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1444</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1450</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1450</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1457</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1457</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1468</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1468</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1480</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1480</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>510</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1500</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1500</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1506</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1506</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1513</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1513</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1524</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1524</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1535</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1535</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1554</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1554</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1560</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1560</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1567</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1567</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1578</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1578</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1591</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1591</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Compare</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>497</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1612</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1612</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1618</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1618</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1625</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1625</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1636</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1636</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1649</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1649</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>495</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1675</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1675</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1681</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1681</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1688</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1688</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1710</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1710</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00062</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1867</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1867</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1880</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1880</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Erase.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_1959</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>1959</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>506</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2039</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2039</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2040</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2040</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Cbk.CancelFinishedJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2049</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2049</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>496</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2062</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2062</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2071</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2071</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2076</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2076</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2083</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2083</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2094</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2094</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2107</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2107</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2114</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2114</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.JobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2120</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2120</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2130</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2130</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2144</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2144</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.GetJobStatus.InvalidAddressAreaId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2151</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2151</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2152</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2152</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2158</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2158</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00117</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2180</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2180</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00036</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2187</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2187</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2194</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2194</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.GetMemoryInfo.InvalidAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2209</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2209</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetMemoryInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>405</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2266</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2266</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2279</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2279</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2295</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2295</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2302</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2302</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2308</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2308</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>410</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2332</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2332</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2339</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2339</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2353</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2353</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2369</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2369</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2395</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2395</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.GetJobInfo.ActiveJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2400</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2400</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.GetJobInfo.InactiveJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2421</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2421</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2428</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2428</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2444</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2444</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.RequestLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>509</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2464</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2464</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00071</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2471</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2471</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00072</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2496</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2496</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00099</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2507</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2507</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.ReleaseLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2526</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2526</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/MemAcc.c.m4_2551</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc.c.m4</sourcefile>
      <sourceline>2551</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/MemAcc_Queue.c_117</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/src/MemAcc_Queue.c</sourcefile>
      <sourceline>117</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccAddressArea.java_112</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccAddressArea.java</sourcefile>
      <sourceline>112</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.AddressArea.LogicalAddresses</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccAddressSubArea.java_156</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccAddressSubArea.java</sourcefile>
      <sourceline>156</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.SubArea.MemInvocation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccConfig.java_675</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccConfig.java</sourcefile>
      <sourceline>675</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_AddressType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>
    <specobject>
      <id>src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccConfig.java_676</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccConfig.java</sourcefile>
      <sourceline>676</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_LengthType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_15</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_59</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_82</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_108</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>108</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.AddressArea.AddressAreaId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_113</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>113</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_141</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>141</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_164</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>164</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_189</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>189</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_205</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>205</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_229</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>229</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_253</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>253</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_277</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>277</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_307</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>307</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_337</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>337</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_357</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>357</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.FLs.Burst.Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_358</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>358</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.Mem.Burst.Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_366</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>366</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_389</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>389</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.FLs.Burst.Read</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_390</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>390</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.Mem.Burst.Read</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_398</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>398</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_418</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>418</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.FLs.Burst.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_419</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>419</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.Mem.Burst.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_427</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>427</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.VariableWrite.Configuration</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_450</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>450</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.VariableWrite.Dependency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_453</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>453</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_454</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>454</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_Invocation_Legacy</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_495</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>495</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_513</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>513</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.Mem.MemNamePrefix</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_521</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>521</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_SectorBatchRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_542</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>542</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00079</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_543</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_568</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>568</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_SectorBatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_592</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>592</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_SectorBatch_StartPhysicalAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_615</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>615</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_PageSize_Read</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_642</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>642</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_PageSize_Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_671</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>671</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_SectorSize_Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_695</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>695</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_NumberOfSectors</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_719</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>719</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_EraseCycles</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_742</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>742</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_BurstSettings</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_749</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>749</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_BurstPageSize_Read</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_772</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>772</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_BurstPageSize_Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_795</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>795</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_BurstSectorSize_Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_821</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>821</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.ECUC_UserHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_860</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>860</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_873</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_902</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>902</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_923</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>923</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_944</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>944</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/MemAcc.xdm.m4_966</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/src/Autosar/config/MemAcc.xdm.m4</sourcefile>
      <sourceline>966</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.ECUC_MemAcc_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>MemAcc.Dsn.Types.AddressAreaJobEndNotification</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11252</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_155</srcid><srcstatus/><internalId>283</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.ApplicationLockNotification</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11269</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_169</srcid><srcstatus/><internalId>284</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10032</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_AddressAreaIdType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11286</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_27</srcid><srcstatus/><internalId>277</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10000</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_AddressType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11303</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccConfig.java_675</srcid><srcstatus/><internalId>429</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_ConfigType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11320</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_177</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_DataType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11337</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_31</srcid><srcstatus/><internalId>278</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_HwIdType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11354</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_23</srcid><srcstatus/><internalId>276</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_JobInfoType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11371</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_184</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_JobResultType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11388</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_41</srcid><srcstatus/><internalId>280</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_JobStatusType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11405</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_85</srcid><srcstatus/><internalId>281</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_JobType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11422</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_103</srcid><srcstatus/><internalId>282</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_LengthType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11439</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/plugin.MemAccExt.Autosar/Java/eb/tresos/memacc/dataextract/MemAccConfig.java_676</srcid><srcstatus/><internalId>430</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_MemHwServiceIdType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11456</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_35</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_MemInstanceIdType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11473</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_19</srcid><srcstatus/><internalId>275</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_91011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Types.MemAcc_MemoryInfoType</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11490</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/include/MemAcc_Types.h_206</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetMemoryInfo_Burst_Disabled_TEST</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetMemoryInfo_Burst_Enabled_TEST</srcid><srcstatus/><internalId>553</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetMemoryInfo_Mem_Burst_Disabled</srcid><srcstatus/><internalId>575</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.BlankCheck</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11507</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_2_Drvs_NotAvailable</srcid><srcstatus/><internalId>540</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_BlankCheck_1_Drv_Available</srcid><srcstatus/><internalId>582</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1649</srcid><srcstatus/><internalId>378</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.Cancel</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11524</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Erase_TEST</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Read_TEST</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Compare_TEST</srcid><srcstatus/><internalId>529</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2049</srcid><srcstatus/><internalId>388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.Compare</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11541</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1591</srcid><srcstatus/><internalId>373</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.Erase</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11558</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1535</srcid><srcstatus/><internalId>368</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10025</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.GetJobInfo</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11575</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Erase_TEST</srcid><srcstatus/><internalId>542</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Read_TEST</srcid><srcstatus/><internalId>543</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Write_TEST</srcid><srcstatus/><internalId>544</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetJobInfo_Compare_TEST</srcid><srcstatus/><internalId>545</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2353</srcid><srcstatus/><internalId>413</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10022</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.GetJobResult</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11592</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2094</srcid><srcstatus/><internalId>393</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.GetJobStatus</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11609</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2130</srcid><srcstatus/><internalId>397</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.GetMemoryInfo</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11626</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2209</srcid><srcstatus/><internalId>405</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.GetProcessedLength</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11643</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Invalid_TEST</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Erase_TEST</srcid><srcstatus/><internalId>555</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Read_TEST</srcid><srcstatus/><internalId>556</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Compare_TEST</srcid><srcstatus/><internalId>557</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Write_TEST</srcid><srcstatus/><internalId>558</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Canceled_TEST</srcid><srcstatus/><internalId>559</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetProcessedLength_Failed_TEST</srcid><srcstatus/><internalId>560</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2279</srcid><srcstatus/><internalId>407</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.GetVersionInfo</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11660</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2421</srcid><srcstatus/><internalId>417</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_GetVersionInfo_Valid_TEST</srcid><srcstatus/><internalId>561</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10016</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11677</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1374</srcid><srcstatus/><internalId>354</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.MainFunction</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11694</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1959</srcid><srcstatus/><internalId>385</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.Read</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11710</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1423</srcid><srcstatus/><internalId>358</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.ReleaseLock</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11727</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2507</srcid><srcstatus/><internalId>423</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.RequestLock</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11744</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2444</srcid><srcstatus/><internalId>419</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interfaces.Write</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11761</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1480</srcid><srcstatus/><internalId>363</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ComTest_VerifyStubs</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10024</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interaction.Cbk.Canceled</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11778</sourceline>
      <version>1</version>
      <description>When upper layer callback is configured, after a cancel request of a previously requested job, callback shall be called with MEMACC_E_JOB_CANCELED after last started med driver job is finished if there are more mem driver jobs to be processed.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1302</srcid><srcstatus/><internalId>347</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Erase_TEST</srcid><srcstatus/><internalId>525</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interaction.Cbk.CancelFinishedJob</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11795</sourceline>
      <version>1</version>
      <description>When upper layer callback is configured, after a cancel request of a previously requested job, callback shall be called with consolidated job result after last started mem driver job is finished if there are NO more mem driver jobs to be processed.
</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1094</srcid><srcstatus/><internalId>337</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1131</srcid><srcstatus/><internalId>340</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1158</srcid><srcstatus/><internalId>343</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2040</srcid><srcstatus/><internalId>387</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Erase_TEST</srcid><srcstatus/><internalId>525</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_10039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interaction.Polling.Canceled</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11817</sourceline>
      <version>1</version>
      <description>&lt;description/&gt;</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1301</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Erase_TEST</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Read_TEST</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Write_TEST</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Compare_TEST</srcid><srcstatus/><internalId>529</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.Interaction.Polling.JobResult</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11834</sourceline>
      <version>1</version>
      <description>The service MemAcc_GetJobResult shall return the consolidated result of the last MemAcc job if the job finishes without being canceled by user request.</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1093</srcid><srcstatus/><internalId>336</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1130</srcid><srcstatus/><internalId>339</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1157</srcid><srcstatus/><internalId>342</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_2114</srcid><srcstatus/><internalId>395</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Erase_TEST</srcid><srcstatus/><internalId>525</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Read_TEST</srcid><srcstatus/><internalId>526</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Write_TEST</srcid><srcstatus/><internalId>527</internalId></linkedfrom><linkedfrom><srcid>TS_MEMACC_ConTest_Cancel_Compare_TEST</srcid><srcstatus/><internalId>529</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00092</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.SubAreaJobState.Init</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11851</sourceline>
      <version>1</version>
      <description>The SubArea job state is initialized to MEMACC_IDLE</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1412</srcid><srcstatus/><internalId>357</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.SubAreaJobState.JobRequested</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11861</sourceline>
      <version>1</version>
      <description>If the driver needed by a SubArea job is available and the job requested successfully,  SubArea job state is set to MEMACC_INPROGRESS</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1326</srcid><srcstatus/><internalId>351</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.SubAreaJobState.NewJob</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11871</sourceline>
      <version>1</version>
      <description>AFter the reception of a new valid request, all subAreas states that the request spans over them shall set to MEMACC_WAITING </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1023</srcid><srcstatus/><internalId>329</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.SubAreaJobState.BusyDriver</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11881</sourceline>
      <version>1</version>
      <description>If the driver needed by a SubArea job is busy,  SubArea job state is set to MEMACC_WAITING
</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1332</srcid><srcstatus/><internalId>352</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>
    <specobject>
      <id>MemAcc.Dsn.SubAreaJobState.JobDone</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/doc/project/design/pdf/MemAcc_Design-profiled.xml</sourcefile>
      <sourceline>11892</sourceline>
      <version>1</version>
      <description>After the processing of SubArea requests is done , SubArea job state is set to MEMACC_IDLE
</description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/MemAcc.c.m4_1085</srcid><srcstatus/><internalId>333</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MemAcc_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/common_req/MemAcc_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MemAcc_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/build/reqm/common_req/MemAcc_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(MemAcc.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ComTest_VerifySchmExclusiveAreas</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Compile/IN/MemAcc_Compile_SchM_ExclusiveAreas/source/application/Tests.c</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test checks that SchM exclusive area API is
  correctly generated by the RTE generator
  based on the MemAcc basic module software description

Test Object: 

Test Precondition: 

Test Execution: 


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.BSWMD.ExclusiveAreas</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ComTest_VerifyStubs</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Compile/IN/MemAcc_Compile_VerifyStubs/source/application/Tests.c</sourcefile>
      <sourceline>70</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid read requests regarding API return and Det error codes.

Test Object: 

Test Precondition: 

Test Execution: 


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_AddressAreaIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_LengthType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_AddressType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_DataType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>485</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemoryInfoType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_JobInfoType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>487</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_JobStatusType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>489</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_JobResultType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_JobType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>490</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemHwServiceIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_HwIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_ConfigType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>484</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.ApplicationLockNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemInstanceIdType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>493</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>505</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>496</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Read</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>507</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>510</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Types.AddressAreaJobEndNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>480</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>495</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetMemoryInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Compare</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>497</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.ReleaseLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.RequestLock</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>509</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_Cancel_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Cancel/source/application/Tests.c</sourcefile>
      <sourceline>64</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests invalid cancel requests regarding API return and Det error codes for : 
    - uninitialized module and valid address area
    - uninitialized module and invalid address area

Test Object: 

Test Precondition: 

Test Execution: 
  01: Call cancel function with a valid address area id
  02: Call main function few times
  03: VP: Check that module calls Det_ReportError for uninitialized module
  04: Call cancel function with an invalid address area id
  05: Call main function few times
  06: VP: Check that module calls Det_ReportError for uninitialized module
  07: VP: Det_ReportError API is called 2 times

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00030</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Cancel_Erase_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Cancel/source/application/Tests.c</sourcefile>
      <sourceline>132</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests the cancellation of an erase request in all states :
    - job is waiting
    - job is in progress
    - job is done
  and check that callback is called correctly

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function
  03: Call Cancel function
  04: Call MemAcc_MainFunction
  05: VP: Check that erase request canceled and job status is idle
  06: VP: address area callback is called correctly
  07: Call erase function
  08: Call main function
  09: VP: Driver erase is called with length of single page (256)
  10: VP: Driver erase is called with the correct physical address
  11: Call Cancel function
  12: Call main function
  13: VP: Check that erase request canceled and job status is idle
  14: VP: address area callback is called correctly
  15: Call erase function
  16: Call main function
  17: VP: Driver erase is called with length of single page (128)
  18: VP: Driver erase is called with the correct physical address
  19: Call Cancel function  after the first sub area processed
  20: Call Main Function
  21: VP: Check that erase request canceled and job status is idle
  22: VP: address area callback is called correctly
  23: Call erase function
  24: Call main function
  25: VP: Driver erase is called with length of single page (128)
  26: VP: Driver erase is called with the correct physical address
  27: Call Cancel function after erase request is done
  28: Call Main Function
  29: VP: Check that erase request done , cancel did not affect it
  30: VP: address area callback is called correctly
  31: VP: Driver erase API is called 3 times

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>496</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.Canceled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>513</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.JobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Cbk.Canceled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>511</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Cbk.CancelFinishedJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Cancel_Read_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Cancel/source/application/Tests.c</sourcefile>
      <sourceline>280</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests the cancellation of an read request in all states :
    - job is waiting
    - job is in progress
    - job is done

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call read function
  03: Call Cancel function
  04: Call MemAcc_MainFunction
  05: VP: Check that read request canceled and job status is idle
  06: Call read function
  07: Call main function
  08: VP: Driver read is called with length of single page (8)
  09: VP: Driver read is called with the correct physical address
  10: Call Cancel function
  11: Call main function
  12: VP: Check that read request canceled and job status is idle
  13: Call read function
  14: Call main function
  15: VP: Driver read is called with length of single page (256)
  16: VP: Driver read is called with the correct physical address
  17: Call Cancel function
  18: Call Main Function
  19: VP: Check that read request done , cancel did not affect it
  20: VP: Driver read API is called 2 times

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>496</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.Canceled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>513</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.JobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Cancel_Write_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Cancel/source/application/Tests.c</sourcefile>
      <sourceline>385</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests the cancellation of write request in all states :
    - job is waiting
    - job is in progress
    - job is done

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call read function
  03: Call Cancel function
  04: Call MemAcc_MainFunction
  05: VP: Check that read request canceled and job status is idle
  06: Call read function
  07: Call main function
  08: VP: Driver read is called with length of single page (8)
  09: VP: Driver write is called with the correct physical address
  10: Call Cancel function
  11: Call main function
  12: VP: Check that write request canceled and job status is idle
  13: Call write function
  14: Call main function
  15: VP: Driver write is called with length of single page (256)
  16: VP: Driver write is called with the correct physical address
  17: Call Cancel function
  18: Call Main Function
  19: VP: Check that write request done , cancel did not affect it
  20: VP: Driver write API is called 2 times

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.Canceled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>513</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.JobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Invalid_Cancel_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Cancel/source/application/Tests.c</sourcefile>
      <sourceline>487</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests all invalid Cancel requests :
    -  call MemAcc_Cancel with invalid address area id
    -  call MemAcc_Cancel for idle address area id

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call cancel function with an invalid address area id
  03: VP: Check that module calls Det_ReportError for invalid address area id
  04: Call cancel function for an idle address area
  05: VP: Det_ReportError API is called once

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00031</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Cancel_Compare_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Cancel/source/application/Tests.c</sourcefile>
      <sourceline>544</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests the cancellation of an compare request in all states :
    - job is waiting
    - job is in progress
    - job is done

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call compare function
  03: Call Cancel function
  04: Call MemAcc_MainFunction
  05: VP: Check that compare request canceled and job status is idle
  06: Call compare function
  07: Call main function
  08: VP: Driver compare is called with length of single page (8)
  09: VP: Driver compare is called with the correct physical address
  10: Call Cancel function
  11: Call main function
  12: VP: Check that compare request canceled and job status is idle
  13: Call compare function
  14: Call main function
  15: VP: Driver Read is called with length of single page (8)
  16: VP: Driver compare is called with the correct physical address
  17: Call Cancel function
  18: Call Main Function
  19: VP: Check that compare request done , cancel did not affect it
  20: VP: Driver Read API is called twice

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.Cancel</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>496</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.Canceled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>513</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interaction.Polling.JobResult</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid compare requests regarding API return and Det error codes for
  uninitialized module and valid parameters
  uninitialized module and invalid address area, invalid length, invalid address, and invalid data pointer

Test Object: 

Test Precondition: 

Test Execution: 
  01: VP: Call Compare function with valid parameters before MemAcc initialization
  02: Call main function few times
  03: VP: Driver Read API is not called
  04: VP: Det reported correctly for MemAcc Compare
  05: VP: Call Compare function with invalid area ID
  06: Call main function few times
  07: VP: Driver Read API is not called
  08: VP: Det reported correctly for MemAcc Compare
  09: VP: Call Compare function with invalid length(0)
  10: Call main function few times
  11: VP: Driver Read API is not called
  12: VP: Det reported correctly for MemAcc Compare
  13: VP: Call Compare function with invalid length(too big)
  14: VP: Call main function few times
  15: VP: Driver Read API is not called
  16: VP: Det reported correctly for MemAcc Compare
  17: VP: Call Compare function with invalid address (too big)
  18: VP: Call main function few times
  19: VP: Driver Read API is not called
  20: VP: Det reported correctly for MemAcc Compare
  21: VP: Call Compare function with invalid address(too small)
  22: VP: Call main function few times
  23: VP: Driver Read API is not called
  24: VP: Det reported correctly for MemAcc Compare
  25: VP: Call Compare function with invalid buffer
  26: VP: Call main function few times
  27: VP: Driver Read API is not called
  28: VP: Det reported correctly for MemAcc Compare

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>416</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid compare requests regarding API return and Det error codes for:
    - Invalid address area 
    - Invalid length
    - Invalid start address
    - Invalid destination pointer
    - Invalid address area state

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare function with invalid area ID
  03: Call main function few times
  04: VP: Driver Read API is not called
  05: VP: Det reported correctly for MemAcc Compare
  06: VP: Call Compare function with invalid area ID and invalid length
  07: Call main function few times
  08: VP: Driver Read API is not called
  09: VP: Det reported correctly for MemAcc Compare
  10: VP: Call Compare function with invalid area ID and invalid data pointer
  11: Call main function few times
  12: VP: Driver Read API is not called
  13: VP: Det reported correctly for MemAcc Compare
  14: VP: Call Compare function with invalid length(0)
  15: Call main function few times
  16: VP: Driver Read API is not called
  17: VP: Det reported correctly for MemAcc Compare
  18: VP: Call Compare function with invalid length(too big)
  19: Call main function few times
  20: VP: Driver Read API is not called
  21: VP: Det reported correctly for MemAcc Compare
  22: VP: Call Compare function with invalid length (over area)
  23: Call main function few times
  24: VP: Driver Read API is not called
  25: VP: Det reported correctly for MemAcc Compare
  26: VP: Call Compare function with invalid address (too big)
  27: VP: Call main function few times
  28: VP: Driver Read API is not called
  29: VP: Det reported correctly for MemAcc Compare
  30: VP: Call Compare function with invalid address(too small)
  31: Call main function few times
  32: VP: Driver Read API is not called
  33: VP: Det reported correctly for MemAcc Compare
  34: VP: Call Compare function with invalid buffer
  35: Call main function few times
  36: VP: Driver Read API is not called
  37: VP: Det reported correctly for MemAcc Compare
  38: VP: Call Compare function with invalid buffer and invalid length
  39: Call main function few times
  40: VP: Driver Read API is not called
  41: VP: Det reported correctly for MemAcc Compare
  42: VP: Call Compare function with unaligned start address
  43: Call main function few times
  44: VP: Driver Read API is not called
  45: VP: Det reported correctly for MemAcc Compare
  46: VP: Call Compare function with unaligned end address
  47: Call main function few times
  48: VP: Driver Read API is not called
  49: VP: Det reported correctly for MemAcc Compare
  50: VP: Call Compare function with valid params
  51: VP: Call Compare function with valid params, for pending area
  52: Call main function
  53: VP: Driver read is called with length of single page (4)
  54: VP: Driver read is called with physical address starting 2048
          and increased by 4 after each successful request
  55: VP: Check Job result
  56: VP: Driver Read API is called only for first Compare

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00058</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00059</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00061</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00060</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_1_Area_1_SubArea</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>743</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests a compare request that spans over a single sub area in case of lower layer finishing
  and in case of pending, while a mismatch at the first byte

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare function: [Area 0 logical address 640+48 length 52 bytes]
  03: Call main function
  04: VP: Driver read is called with length of single page (4)
  05: VP: Driver read is called with physical address starting 2048 + 48, and increased by 4 after each successful request
  06: VP: Driver Read API is called 1 time
  07: VP: Check Job result
  08: Reset stub variables
  09: VP: Call Compare function
  10: Set Driver status to MEMIF_JOB_PENDING
  11: Call main function 3 times
  12: VP: Check that no read was triggered
  13: Set Driver status to MEMIF_JOB_OK
  14: Call main function till job is finished
  15: VP: Driver Read API is called 1 time
  16: VP: Check Job result

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Mismatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Request.Inconsistent.Compare</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.Compare.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_1_Area_2_SubAreas_1_Drv</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>863</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a compare request that spans over multiple sub area in case of lower layer finishing
  and in case of pending, while a mismatch at the last byte

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare function: [Area 0 logical address 640+212 length of 52 bytes]
  03: Call main function
  04: VP: Driver read is called with length of single page (4)
  05: VP: Driver read is called with the correct physical address
  06: VP: Driver read is called with length of single page (4)
  07: VP: Driver read is called with the correct physical address
  08: VP: Driver Read API is called 13 times
  09: VP: Check Job result
  10: Reset stub variables
  11: VP: Call Compare function: [Area 0 logical address 640+212 length of 52 bytes]
  12: Set Driver status to MEMIF_JOB_PENDING
  13: Call main function 4 times
  14: Set Driver status to MEMIF_JOB_OK
  15: Call main function till job is finished
  16: VP: Driver Read API is called 13 times
  17: VP: Check Job result

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Mismatch</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Request.Inconsistent.Compare</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_1_Area_2_Drvs</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>997</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a compare request that spans over multiple sub areas handled by multiple drivers

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare function: [Area 1, logical address 248 length 56 bytes]
  03: Call main function
  04: VP: Driver read is called with length of single page (4)
  05: VP: Driver read is called with the correct physical address
  06: VP: Driver read is called with length of single page (8)
  07: VP: Driver read is called with the correct physical address
  08: VP: Driver Read APIs are called 2 / 6 times
  09: VP: Check Job result
  10: Reset stub variables
  11: VP: Call Compare function: [Area 1, logical address 248 length 56 bytes]
  12: Set Driver 1 status to MEMIF_JOB_PENDING
  13: Call main function 4 times
  14: VP: No read function was called
  15: Set Driver status to MEMIF_JOB_OK
  16: Call main function
  17: VP: Driver read is called with length of single page (4)
  18: VP: Driver read is called with the correct physical address
  19: Set Driver status to MEMIF_JOB_PENDING
  20: Set Driver status to MEMIF_JOB_OK, expect resuming of area 1 read
  21: VP: Driver read is called with length of single page (8)
  22: VP: Driver read is called with the correct physical address
  23: VP: Driver Read API are called 2 / 6 times
  24: VP: Check Job result

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.Compare.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Compare</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_2_Areas_2_Drvs_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>1189</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests compare requests that spans over multiple sub areas handled by multiple drivers
  checking sequentiality and priority of jobs, high prio starts before low prio

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare functions: [Area 1 logical address 248 length 56] &amp; [Area0 logical address 896 length 192]
  04: Call main function
  05: Set GetJob return to MEMIF_JOB_OK,
  06: VP: Driver read is called with length of single page (4)
  07: VP: Driver read is called with the correct physical address [area 0, sub-area 1 drv 0]
  08: VP: Driver read is not called for drv 1
  09: VP: Driver read is called with length of single page (4)
  10: VP: Driver read is called with the correct physical address [area 1, sub-area 0 drv 0]
  11: VP: Driver read is called with length of single page (8)
  12: VP: Driver read is called with the correct physical address [area 0 sub-area 2 drv 1]
  13: VP: Driver read is called with length of single page (8)
  14: VP: Driver read is called with the correct physical address [area 0 sub-area2 drv 1]
  15: VP: Driver read is called with length of single page (8)
  16: VP: Driver read is called with the correct physical address [area 1 sub-area 1 drv 1]
  17: VP: Driver Read APIs are called 34(32 for area 0, 2 for area 1) / 14 times ( 6 for area 0, 8 for area1)
  18: VP: Check Job result
  19: VP: Check Job result

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.Compare.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_2_Areas_2_Drvs_Preempted</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>1355</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests compare requests that spans over multiple sub areas handled by multiple drivers
  checking sequentiality and priority of jobs,
  high prio read interrupts low prio read only after current page operation finishes

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare function: [Area 1 logical address 248 length 72]
  03: Set GetJob return to MEMIF_JOB_PENDING by read function via stub callout
  04: Call main function
  05: Set GetJob return to MEMIF_JOB_OK for Fls_1 drv
  06: VP: Driver read is called with length of single page (4)
  07: VP: Driver read is called with the correct physical address [area 1, sub-area 0 drv 0]
  08: VP: Call Compare function: [Area 0 logical address 640 length 8]
  09: VP: Higher prio read waits for lower prio page read
  10: Finish lower prio page read, setup for higher prio read
  11: VP: Driver read is called with length of single page (4)
  12: VP: Driver read is called with the correct physical address [area 0, sub-area 0 drv 0]
  13: VP: Driver read is not called for drv 1
  14: Set GetJob return to MEMIF_JOB_OK for Fls drv
  15: Read Index setup for lower prio read
  16: VP: Driver read is called with length of single page (4)
  17: VP: Driver read is called with the correct physical address [area 1, sub-area 0 drv 0]
  18: VP: Driver read is not called for drv 1 as processing is done sequentially
  19: Set GetJob return to MEMIF_JOB_OK for Fls drv
  20: VP: Driver read is called with length of single page (8)
  21: VP: Driver read is called with the correct physical address [area 1, sub-area 1 drv 1]
  22: VP: Driver read is called with length of single page (8)
  23: VP: Driver read is called with the correct physical address [area 1, sub-area 1 drv 1]
  24: VP: Call Compare function: [Area 0 logical address 256+128  0 length 16]
  25: Setup stub variables for higher prio area 0 read
  26: VP: Driver read is called with length of single page (8)
  27: VP: Driver read is called with the correct physical address [area 0 sub-area 2 drv 1]
  28: Setup stub for lower prio area 1 read
  29: VP: Driver read is called with length of single page (8)
  30: VP: Driver read is called with the correct physical address [area 1, sub-area 1 drv 1]
  31: VP: Driver Read APIs are called 4(2 for area 0, 2 for area 1) / 10 times ( 2 for area 0, 8 for area 1)

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.Compare.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_Wait_HighPrio_Failed</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>1595</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests two compare requests checking sequentiality and priority of jobs
  high prio is requested right after low prio,
  high prio job starts before low prio,
  then high prio job fails and low prio job starts.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare functions: [Area 1 logical address 0 length 12] &amp; [Area0 logical address 640 length 12]
  03: Call main function
  04: Set GetJob return to MEMIF_JOB_OK
  05: VP: Driver read is called with length of single page (4)
  06: VP: Driver read is called with the correct physical address
  07: Setup stub for area 1 read
  08: VP: Driver read is called with length of single page (4)
  09: VP: Driver read is called with the correct physical address
  10: Set Fls_Read return to E_NOT_OK
  11: VP: Driver Read APIs are called 5 times (2 for area 0, 3 for area 1)
  12: VP: Check Job result

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_Burst_1_Area</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>1716</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests the compare request with burst enabled on the the second and the third subareas 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare function: [Area 2 logical address 2040 length 4 + 4 + 3 * 16 + 8  bytes]
  03: Call main function
  04: VP: Driver read is called with length of single page (4)
  05: VP: Driver read is called with physical address starting 4608+120
      and increased by 4 after each successful request
  06: VP: Driver read is called with length of burst (16)
  07: VP: Driver read is called with physical address starting 1024
      and increased by 16 after each successful request
  08: VP: Driver read is called with the remaining length (12)
  09: VP: Driver read is called with physical address starting 1024 + 48(size read in burst mode on drv)
  10: VP: Driver Read APIs are called 2 / 4 times
  11: VP: Check Job result

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.Compare.Burst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_Burst_2_Areas_Preempted</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Compare/source/application/Tests.c</sourcefile>
      <sourceline>1830</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests the compare requests with burst enabled(multiple burst mode and page mode if needed)
  in case of one or multiple reads with different priorities checking sequentiality
  and priority handling.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Compare function [Area 2 logical address 2264 length 60 bytes]
  03: Call main function till job is finished
  04: VP: Driver read is called with length of burst (16)
  05: VP: Driver read is called with physical address starting 1024 + 216
          and increased by 16 after each successful request
  06: VP: Driver read is called with length of page (8)
  07: VP: Driver read is called with physical address starting 1024 + 216 + 32
          and increased by 8 after each successful request
  08: VP: Driver read is called with length of page (8)
  09: VP: Driver read is called with physical address starting 1280
          and increased by 8 after each successful request
  10: VP: Call Compare function: [area3 logical address 2432 length 20]
  11: VP: Driver read is called with length of burst (8)
  12: VP: Driver read is called with physical address starting 1408
          and increased by 8 after each successful request
  13: VP: Driver read is called with page length (4)
  14: VP: Driver read is called with physical address starting 1408
          and increased by 8 after each successful request 
  15: Reset internal variables for resuming area 2 read
  16: VP: Driver read is called with length of burst (8)
  17: VP: Driver read is called with physical address starting 1280 + 8 (previously read size)
          and increased by 8 after each successful request
  18: VP: Driver read is called with length of page (4)
  19: VP: Driver read is called with physical address starting 1280 + 16 (previously read size)
          and increased by 4 after each successful request
  20: VP: Driver Read API is called 9 times
  21: VP: Check Job result

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.PageBurst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.Compare.Burst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_2_Drvs_NotAvailable</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Fls_BlankCheck/source/application/custom_Fls_Test.c</sourcefile>
      <sourceline>20</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a blank check over a two drivers when at least one of them does not provide blank check api

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call BlankCheck function: [Area 2 SA0, logical address 3584 - 4 length 12 bytes]
         -Fls has no blank check, Fls_2_Vendor1 has blank check
  03: Call main function 3 times
  04: VP: Check that no blank check was triggered
  05: VP: Call BlankCheck function: [Area 1 SA0 logical address 1024 - 4 length 36 bytes] 
          -Fls has no blank check, Fls_1_Vendor1 has no blank check
  06: VP: Call BlankCheck function: [Area 3 SA1 logical address 5760 - 8 length 32 bytes]
          -Fls_3_Vendor1 has blank check Fls_1_Vendor1 has no blank check
  07: Call main function 3 times
  08: VP: Check that no blank check was triggered

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>495</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobInfo_Invalid_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobInfo/source/application/Tests.c</sourcefile>
      <sourceline>199</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests all invalid GetJobInfo requests :
    -  call GetJobInfo for uninitialized module 
    -  call GetJobInfo with invalid address area id

Test Object: 

Test Precondition: 

Test Execution: 
    01: Call MemAcc_GetJobInfo API with a valid address area id before module initialization
    02: VP: Check that module calls Det_ReportError for uninitialized module
    03: Initialize the used modules
    04: Call MemAcc_GetJobInfo function with an invalid address area id
    05: VP: Check that module calls Det_ReportError for invalid address area id
    06: Call MemAcc_GetJobInfo function with NULL_PTR
    07: VP: Check that module calls Det_ReportError for NULL_PTR

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00040</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00041</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00042</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobInfo_Erase_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobInfo/source/application/Tests.c</sourcefile>
      <sourceline>270</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetJobInfo API during an erase request while Burst mode is disabled in the following states :
    - Request is in waiting state and no processing has done yet
    - Request processing is failed 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function
  03: Call MemAcc_GetJobInfo API before any processing
  04: VP: Check that the returned job info match the expected values
  05: Call main function to process the first sector
  06: Init the return of Fls_GetJobResult to let it fail
  07: Call main function
  08: VP: Check that erase request failed 
  09: Reset Job info structure before the next call of GetJobInfo
  10: Call MemAcc_GetJobInfo API after the job is failed
  11: VP: Check that the returned job info match the expected values

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobInfo_Read_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobInfo/source/application/Tests.c</sourcefile>
      <sourceline>349</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetJobInfo API during read requests while burst is enabled in the following states :
    - after the first sub area is done  
    - after job is completely done and the second request is in progress 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call read function for the first request with the highest priority
  03: Call Main Function twice to process the first 64 bytes spanning over the first sub area
  04: Call MemAcc_GetJobInfo API after the processing of first sub area
  05: VP: Check that the returned job info match the expected values
  06: Call read function for the second request
  07: Call main function many times to make sure that the second request has been started processing
  08: VP: Check that read second request is in progress
  09: VP: Check that first read request is done successfully
  10: Reset Job info structure before the next call of GetJobInfo
  11: Call MemAcc_GetJobInfo API after the request is done
  12: VP: Check that the returned job info match the expected values
  13: Call main function many times to continue the second request processing
  14: VP: Check that second read request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.GetJobInfo.ActiveJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.GetJobInfo.InactiveJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobInfo_Write_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobInfo/source/application/Tests.c</sourcefile>
      <sourceline>445</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetJobInfo API during an write request while the burst is disabled in the following states :
    - job is waiting state where no processing is done yet 
    - job is waiting state after a few bytes have been processed after it is being preempted by higher
      priority job 
    - after job is done

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function
  03: Call MemAcc_GetJobInfo API while the job in pending state before any processing
  04: VP: Check that the returned job info match the expected values
  05: Call main function twice to process the first 8 bytes in address area 1 request
  06: VP: Driver write is called with length of single page (4)
  07: Call write function for higher priority job
  08: Initialize GetJobResult return value to simulate driver being busy for the low prio due to ongoing high prio
  09: Call main function to process the first 8 bytes in address area 2 request
  10: VP: Driver write is called with length of single page (8)
  11: Call MemAcc_GetJobInfo API while the job in pending state after the processing of the first 8 bytes
  12: VP: Check that the returned job info match the expected values
  13: Initialize GetJobResult return value to simulate driver being busy for the low prio due to ongoing high prio
  14: Call main function to process the remaining 8 bytes in address area 2 request
  15: Initialize GetJobResult return value to simulate driver being busy for the low prio due to ongoing high prio
  16: Call main function to process the remaining 4 bytes in address area 1 request
  17: Reset Job info structure before the next call of GetJobInfo
  18: Call MemAcc_GetJobInfo API after the job is done
  19: VP: Check that the returned job info match the expected values
  20: VP: Check that write request done

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.GetJobInfo.InactiveJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobInfo_Compare_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobInfo/source/application/Tests.c</sourcefile>
      <sourceline>567</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetJobInfo API during compare requests while burst is enabled in the following states :
    - after the first sub area is done  
    - after job is completely done and the second request is in progress 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call compare function for the first request with the highest priority
  03: Call Main Function twice to process the first 64 bytes spanning over the first sub area
  04: Call MemAcc_GetJobInfo API after the processing of first sub area
  05: VP: Check that the returned job info match the expected values
  06: Call compare function for the second request
  07: Call main function many times to make sure that the second request has been started processing
  08: VP: Check that compare second request is in progress
  09: VP: Check that first compare request is done successfully
  10: Reset Job info structure before the next call of GetJobInfo
  11: Call MemAcc_GetJobInfo API after the request is done
  12: VP: Check that the returned job info match the expected values
  13: Call main function many times to continue the second request processing
  14: VP: Check that second compare request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetJobInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.GetJobInfo.ActiveJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.GetJobInfo.InactiveJob</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobResult_Invalid_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobResult/source/application/Tests.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests all invalid GetJobResult requests :
    -  call GetJobResult for uninitialized module 
    -  call GetJobResult with invalid address area id

Test Object: 

Test Precondition: 

Test Execution: 
    01. Call MemAcc_GetJobResult API with a valid address area id before module initialization
    02. VP: Check that module calls Det_ReportError for uninitialized module
    03. Initialize the used modules
    04. Call MemAcc_GetJobResult function with an invalid address area id
    05. VP: Check that module calls Det_ReportError for invalid address area id

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00034</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobResult_Init</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobResult/source/application/Tests.c</sourcefile>
      <sourceline>105</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests GetJobResult after module initialization and after a new request

Test Object: 

Test Precondition: 

Test Execution: 
    01: Initialize the used modules
    02: VP: job result is set to MEMACC_MEM_OK
    03: Call erase function: [Area 0 SA0 logical address 0 length 256 bytes]
    04: Set request return value to failed to indicate the failure of the driver request
    05: Call main function
    06: VP: request is failed
    07: Call erase function: [Area 0 SA0 logical address 0 length 256 bytes]
    08: VP: job result is set to MEMACC_MEM_OK
    09: Call main function till job is finished

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00112</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.GetJobResult.Init.NewRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobStatus_Invalid_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobStatus/source/application/Tests.c</sourcefile>
      <sourceline>49</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests all invalid GetJobStatus requests :
    -  call GetJobStatus for uninitialized module 
    -  call GetJobStatus with invalid address area id

Test Object: 

Test Precondition: 

Test Execution: 
    01. Call MemAcc_GetJobStatus API with a valid address area id before module initialization
    02. VP: Check that module calls Det_ReportError for uninitialized module
    03. Initialize the used modules
    04. Call MemAcc_GetJobStatus function with an invalid address area id
    05. VP: Check that module calls Det_ReportError for invalid address area id

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.GetJobStatus.InvalidAddressAreaId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00117</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobStatus_Failed_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobStatus/source/application/Tests.c</sourcefile>
      <sourceline>109</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetJobStatus after initialization and after job failure

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules
  02: VP: Check that job processing status is set to MEMACC_JOB_IDLE during initialization
  03: Call read function
  04: Call main function
  05: Init the return of Fls_1_Vendor1_GetJobResult to let it fail
  06: Call Main Function
  07: VP: Check that read request failed
  08: VP: Check that job status is idle

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00118</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetJobStatus_Pending_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetJobStatus/source/application/Tests.c</sourcefile>
      <sourceline>173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetJobStatus while job is pending

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules
  02: VP: Check that job processing status is set to MEMACC_JOB_IDLE during initialization
  03: Call read function
  04: VP: Check that job processing status is set to MEMACC_JOB_PENDING after request reception
  05: Call main function
  06: VP: Check that job processing status is MEMACC_JOB_PENDING after the processing of the first page
  07: Call main function
  08: VP: Check that read request is done
  09: VP: Check that job status is idle

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00020</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_GetMemoryInfo_Invalid_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetMemoryInfo/source/application/Tests.c</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests all invalid GetMemoryInfo requests :
    -  call MemAcc_GetMemoryInfo before module initialization
    -  call MemAcc_GetMemoryInfo with invalid address area id
    -  call MemAcc_GetMemoryInfo with NULL_PTR
    -  call MemAcc_GetMemoryInfo with invalid address offset

Test Object: 

Test Precondition: 

Test Execution: 
    01. Call MemAcc_GetMemoryInfo API with valid parameters before module initialization
    02. VP: Check that module calls Det_ReportError for uninitialized module
    03. Initialize the used modules
    04. Call MemAcc_GetMemoryInfo function with an invalid address area id 
    05. VP: Check that module calls Det_ReportError for invalid address area id
    06. Call MemAcc_GetMemoryInfo function with NULL_PTR 
    07. VP: Check that module calls Det_ReportError for NULL_PTR
    08. Call MemAcc_GetMemoryInfo function with an invalid address
    09. VP: Check that module calls Det_ReportError for invalid address

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00035</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00036</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.GetMemoryInfo.InvalidAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetMemoryInfo_Burst_Disabled_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetMemoryInfo/source/application/Tests.c</sourcefile>
      <sourceline>206</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests the MemAcc_GetMemoryInfo calls for an address area 1 where burst mode is disabled and the address as follow :
    - address span on the end of the first sub area 
    - address span on the end of the address area
  burst page/sector sizes will be filled with page/sector sizes

Test Object: 

Test Precondition: 

Test Execution: 
    01: Initialize the used modules
    02: Call GetMemoryInfo function
    03: VP: Check that the returned memory info match the expected values
    04: Call GetMemoryInfo function
    05: VP: Check that the returned memory info match the expected values

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemoryInfoType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetMemoryInfo_Burst_Enabled_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetMemoryInfo/source/application/Tests.c</sourcefile>
      <sourceline>266</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests the MemAcc_GetMemoryInfo call for an address area 2 where the address span over the first sub area on Fls_1_Vendor1 driver and burst mode is enabled
  The call is done for the beginning of address area 

Test Object: 

Test Precondition: 

Test Execution: 
  01. Initialize the used modules
  02. Call GetMemoryInfo function
  03. VP: Check that the returned memory info match the expected values

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemoryInfoType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_GetProcessedLength_Invalid_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetProcessedLength/source/application/Tests.c</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests all invalid GetProcessedLength requests :
    -  call GetProcessedLength for uninitialized module 
    -  call GetProcessedLength with invalid address area id

Test Object: 

Test Precondition: 

Test Execution: 
    01. Call MemAcc_GetProcessedLength API with a valid address area id before module initialization
        VP: Check that the returned processed length is 0
    02. VP: Check that module calls Det_ReportError for uninitialized module
    03. Initialize the used modules
    04. Call MemAcc_GetProcessedLength function with an invalid address area id
        VP: Check that the returned processed length is 0
    05. VP: Check that module calls Det_ReportError for invalid address area id
    06. VP: Det_ReportError API is called two times

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00038</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00039</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetProcessedLength_Erase_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetProcessedLength/source/application/Tests.c</sourcefile>
      <sourceline>135</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetProcessedLength API during an erase request in the following states :
    - before requesting an erase (address area is idle )
    - during job processing after each main function 
    - after job is done

Test Object: 

Test Precondition: 

Test Execution: 
  01. Initialize the used modules.
  02. Call MemAcc_GetProcessedLength API before any request
      VP: Check that the returned processed length is 0
  03. Call erase function
      VP: Check that the request is accepted
  04. Call main function
  05. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal erase burst size of address area 2
  06. Loop three times to process the remaining sectors in the erase request
  07. Call Main Function
  08. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal the expected value
  09. Call main function
  10. VP: Check that erase request is done and job status is idle 
  11. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal the expected value

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetProcessedLength_Read_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetProcessedLength/source/application/Tests.c</sourcefile>
      <sourceline>227</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests GetProcessedLength API during a read request that span in one sub area before it's end in the following states :
    - during job processing after each main function 
    - after job is done

Test Object: 

Test Precondition: 

Test Execution: 
  01. Initialize the used modules
  02. Call read function
  03. Call main function
  04. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal read burst size of address area 2
  05. Call Main Function
  06. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal the expected value
  07. Call main function
  08. VP: Check that read request is done and job status is idle 
  09. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal the expected value

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetProcessedLength_Compare_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetProcessedLength/source/application/Tests.c</sourcefile>
      <sourceline>307</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests GetProcessedLength API during a compare request that span in one sub area before it's end in the following states :
    - during job processing after each main function 
    - after job is done

Test Object: 

Test Precondition: 

Test Execution: 
  01. Initialize the used modules
  02. Call compare function
  03. Call main function
  04. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal read burst size of address area 2
  05. Call Main Function
  06. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal the expected value
  07. Call main function
  08. VP: Check that compare request is done and job status is idle 
  09. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal the expected value

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetProcessedLength_Write_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetProcessedLength/source/application/Tests.c</sourcefile>
      <sourceline>398</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetProcessedLength API during a write request that span in one sub area till it's end in the following states :
    - during job processing after each main function 
    - after job is done

Test Object: 

Test Precondition: 

Test Execution: 
  01. Initialize the used modules
  02. Call write function
  03. Call main function
  04. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal write burst size of address area 2
  05. Loop three times to process the remaining pages in the write request
  06. Call Main Function
  07. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal the expected value
  08. Call main function
  09. VP: Check that write request is done and job status is idle 
  10. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal the expected value

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetProcessedLength_Canceled_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetProcessedLength/source/application/Tests.c</sourcefile>
      <sourceline>483</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetProcessedLength API after the cancellation of a read request in the following states :
    - before job is canceled 
    - after job is canceled

Test Object: 

Test Precondition: 

Test Execution: 
  01. Initialize the used modules
  02. Call read function
  03. Call main function
  04. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal read burst size of address area 2
  05. Call Cancel function
  06. Call Main Function
  07. VP: Check that read request canceled
  08. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length is still the same as before

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetProcessedLength_Failed_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetProcessedLength/source/application/Tests.c</sourcefile>
      <sourceline>554</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetProcessedLength API after the failure of a read request in the following states :
    - before job is failed 
    - after job is failed

Test Object: 

Test Precondition: 

Test Execution: 
  01. Initialize the used modules
  02. Call read function
  03. Call main function
  04. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length equal read burst size of address area 2 
  05. Init the return of Fls_1_Vendor1_Read to let it fail
  06. Call Main Function
  07. VP: Check that read request failed
  08. Call MemAcc_GetProcessedLength API
      VP: Check that the returned processed length is still as before 

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetProcessedLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_GetVersionInfo_Valid_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetVersionInfo/source/application/Tests.c</sourcefile>
      <sourceline>38</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests MemAcc version information 

Test Object: 

Test Precondition: 

Test Execution: 
    01: Call MemAcc_GetVersionInfo function
    02: VP: Check the module version information

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.GetVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_GetVersionInfo_Invalid_TEST</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_GetVersionInfo/source/application/Tests.c</sourcefile>
      <sourceline>86</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests all invalid GetVersionInfo request :
    -  call GetVersionInfo with NULL_PTR 

Test Object: 

Test Precondition: 

Test Execution: 
    01: Call MemAcc_GetVersionInfo function with NULL_PTR
    02: VP: Check that module calls Det_ReportError for NULL_PTR

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00027</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_Mem_BlankCheck_Prio_Preemption</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Multi_Mem_Drv/source/application/Tests.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests blank check requests priority of jobs, high prio preempts low prio

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call MemAcc_BlankCheck function: [Area 0 logical address 496 length (16 SA0 + 24 SA1)]
  03: Set GetJob return to MEM_JOB_PENDING by blank check function via stub callout
  04: Call main function
  05: Set GetJob return to MEM_JOB_OK, so that next driver request can be triggered
  06: VP: Driver blank check is called with length of single page (8)
  07: VP: Driver blank check is called with the correct instance id (0)
  08: VP: Driver blank check is called with the correct physical address
  09: VP: Driver blank check is called with length of single page (8)
  10: VP: Driver blank check is called with the correct instance id (0)
  11: VP: Driver blank check is called with the correct physical address
  12: Call MemAcc_BlankCheck function [Area 2 SA0 logical address (3108 + 512 - 96) length 32 + 32 + 32 ]
  13: VP: Driver blank check is called with length of burst size (32)
  14: VP: Driver blank check is called with the correct physical address
  15: VP: Driver blank check is called with length of burst size 32)
  16: VP: Driver blank check is called with the correct instance id (0)
  17: VP: Driver blank check is called with the correct physical address
  18: VP: Driver blank check is called with length of single page (8)
  19: VP: Driver blank check is called with the correct instance id (0)
  20: VP: Driver blank check is called with the correct physical address
  21: Set Driver status to MEM_INCONSISTENT
  22: VP: Mem_1_Vend1_BlankCheck API is called 5 times (2 times for area 0, 3 times for area 2)
  23: VP: Mem_BlankCheck API is called 2 times for area 0
  24: VP: Check Job results

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.BlankCheck.Burst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Requests_2_Areas_2_Mem_Drvs_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Multi_Mem_Drv/source/application/Tests.c</sourcefile>
      <sourceline>214</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests read and write requests that spans over multiple sub areas handled by multiple drivers
  checking sequentiality and priority of jobs, high prio starts before low prio

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call read function: [Area 2 logical address 3108 + (512 -(32 + 8)) length (32 burst read size + 8 read size )SA0 + (16 burst read size + 8 read size)SA1 ]
  03: VP: Call write function: [Area 0 logical address 512 - (4 + 4) length (4 + 4)SA0 + (16 + 4)SA1]
  05: Call main function
  06: Set GetJob return to MEM_JOB_OK,
  07: VP: Driver read is called with the correct length (32/8)
  08: VP: Driver read check is called with the correct instance id (0)
  09: VP: Driver read is called with the correct physical address
  10: VP: Driver read is called with next target address
  11: VP: Driver write is called with length of single page (4)
  12: VP: Driver write check is called with the correct instance id (0)
  13: VP: Driver read is called with the correct physical address
  14: VP: Driver write is called with next source address
  15: VP: Driver read is called with the correct length (16/8)
  16: VP: Driver read check is called with the correct instance id (1)
  17: VP: Driver read is called with the correct physical address
  18: VP: Driver read is called with next target address
  19: VP: Driver read is called with length of single page (4)
  20: VP: Driver write check is called with the correct instance id (0)
  21: VP: Driver write is called with the correct physical address
  22: VP: Driver read is called with next source address
  23: VP: Mem_1_Vend1_Read API is called 4 times for addArea 2
  24: VP: Mem_Write API is called 2 times for addArea 0 SA0
  25: VP: Mem_1_Vend1_Write API is called 2 times for addArea 0 SA1
  26: VP: Check Job result

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_RequestLock_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>128</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid RequestLock requests regarding API return and Det error codes for : 
    - uninitialized module and valid parameters
    - uninitialized module and invalid address area, and invalid lock notification pointer

Test Object: 

Test Precondition: 

Test Execution: 
  01: VP: Call RequestLock function with valid parameters before MemAcc initialization
  02: Call main function few times
  03: VP: Area 0 is not locked
  04: VP: Det reported correctly for MemAcc RequestLock
  05: VP: Call RequestLock function with invalid area ID
  06: Call main function few times
  07: VP: Area 0 is not locked
  08: VP: Det reported correctly for MemAcc RequestLock
  09: VP: Call RequestLock function with invalid lock notification pointer
  10: VP: Call main function few times
  11: VP: Area 0 is not locked
  12: VP: Det reported correctly for MemAcc RequestLock

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00099</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_ReleaseLock_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>230</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid ReleaseLock requests regarding API return and Det error codes for : 
    - uninitialized module and valid parameters
    - uninitialized module and invalid address area

Test Object: 

Test Precondition: 

Test Execution: 
  01: VP: Call ReleaseLock function with valid parameters before MemAcc initialization
  02: Call main function few times
  03: VP: Det reported correctly for MemAcc ReleaseLock
  04: VP: Call ReleaseLock function with invalid area ID
  05: Call main function few times
  06: VP: Det reported correctly for MemAcc ReleaseLock

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_RequestLock_Pending_Area</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>306</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful RequestLock request for an address area that has a read request being processed
  It validates the following :
    - RequestLock preempts the current running job
    - lock notification is called after area lock
    - no driver calls if address area is locked
    - job continues after ReleaseLock
    - driver APIs are called with the right parameters (address, page size)
    - job status and result

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 0 SA0 logical address 1408 length 4 + 4 bytes]
  03: Call main function
  04: VP: Driver read is called with length of page size(4)
  05: VP: Driver read is called with physical address 2048
  06: Call RequestLock function to lock area 0
  07: Call main function
  08: VP: Lock notification is called and Area 0 is locked
  09: Call main function few times
  10: VP: Read request is pending
  11: Call ReleaseLock function to unlock area 0
  12: Call main function
  13: VP: Driver read is called with length of page size(4)
  14: VP: Driver read is called with physical address 2048 + 4
  15: VP: Check that Driver read is called 2 times
  16: VP: Read request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_RequestLock_Pending_Drv</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>407</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful RequestLock request for an address area that has a read request being processed and 
  driver is busy for a while
  It validates the following :
    - RequestLock waits till driver job end, then preempts the current running job
    - lock notification is called after area lock
    - no driver calls if address area is locked
    - job continues after ReleaseLock
    - driver APIs are called with the right parameters (address, page size)
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 0 SA0 logical address 1408, length 4 + 4 bytes]
  03: Call main function
  04: VP: Driver read is called with length of page size(4)
  05: VP: Driver read is called with physical address 2048
  06: Set Driver status to MEMIF_JOB_PENDING
  07: Call RequestLock function to lock area 0
  08: Call main function few times
  09: VP: Lock notification is not called
  10: Call ReleaseLock function to unlock area 0
  11: Call main function
  12: Call RequestLock function to lock area 0
  13: Call main function
  14: VP: Lock notification is not called
  15: Set Driver status to MEMIF_JOB_OK
  16: Call main function
  17: VP: Lock notification is called and Area 0 is locked
  18: Call main function few times
  19: VP: Request is pending
  20: Call ReleaseLock function to unlock area 0
  21: Call RequestLock function to lock area 0
  22: Call main function
  23: VP: Lock notification is called and Area 0 is locked
  24: Call ReleaseLock function to unlock area 0
  25: Call main function
  26: VP: Driver read is called with length of page size(4)
  27: VP: Driver read is called with physical address 2048 + 4
  28: Call main function
  29: VP: Check that Driver Erase is called 2 times
  30: VP: Read request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_RequestLock_Cancel</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>554</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful RequestLock request for an address area that has a write request being processed and 
  a cancel is requested for that write request 
  It validates the following :
    - cancel request is processed if area is already locked 
    - lock notification is called after area lock
    - no driver calls if address area is locked
    - job continues after ReleaseLock
    - driver APIs are called with the right parameters (address, page size)
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 0 SA0 logical address 1408 length 2 + 2 + 2 + 2 bytes]
  03: Call RequestLock function to lock area 0
  04: Call main function
  05: VP: Lock notification is called and Area 0 is locked
  06: Call main function few times
  07: VP: driver apis are not called
  08: Call Cancel function
  09: Call main function
  10: VP: write request is canceled
  11: Call ReleaseLock function to unlock area 0

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_RequestLock_Job_End</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>639</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful RequestLock request for an address area that has a request being processed, and
  request is completed at the moment of lock request
  It validates the following :
    - RequestLock locks the area 
    - lock notification is called after area lock
    - driver APIs are called with the right parameters (address, page size)
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 0 SA0 logical address 1408 length 4 bytes]
  03: Call main function
  04: VP: Driver read is called with length of page size(4)
  05: VP: Driver read is called with physical address 2048
  06: Set Driver status to MEMIF_JOB_PENDING
  07: Call RequestLock function to lock area 0
  08: Call main function
  09: VP: Lock notification is not called
  10: Set Driver status to MEMIF_JOB_OK
  11: Call main function
  12: VP: Read request is done successfully
  13: VP: Lock notification is called and Area 0 is locked
  14: Call main function few times
  15: Call ReleaseLock function to unlock area 0
  16: Call Read function: [Area 0 SA0 logical address 1408 length 4bytes]
  17: Call main function
  18: VP: Driver read is called with length of page size(4)
  19: VP: Driver read is called with physical address 2048
  20: Call RequestLock function to lock area 0
  21: Set Driver status to MEMIF_JOB_FAILED
  22: Call main function
  23: VP: Lock notification is called and Area 0 is locked
  24: VP: Read request is failed
  25: Call main function few times
  26: Call ReleaseLock function to unlock area 0
  27: VP: Call BlankCheck function: [A2 SA1 logical address 3584 length 4 bytes]
  28: Call main function
  29: VP: Driver BlankCheck is called with length of page size(4)
  30: VP: Driver BlankCheck is called with physical address 2048
  31: Call RequestLock function to lock area 2
  32: Set Driver status to MEMIF_BLOCK_INCONSISTENT
  33: Call main function
  34: VP: Lock notification is called and Area 2 is locked
  35: VP: BlankCheck request is failed
  36: Call main function few times
  37: Call ReleaseLock function to unlock area 2

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_RequestLock_Queued_Job</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>815</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful RequestLock request for an address area while an erase is requested during the lock
  It validates the following :
    - RequestLock locks the idle area
    - lock notification is called after area lock
    - request during the lock is queued
    - queued job is processed after ReleaseLock
    - driver APIs are called with the right parameters (address, page size)
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call RequestLock function to lock area 0
  03: Call main function
  04: VP: Lock notification is called and Area 0 is locked
  05: Call Erase function: [Area 0 SA0 logical address 1408 length 256 bytes]
  06: VP: Another Erase request for Area 0 is rejected
  07: Call main function few times
  08: VP: Driver Erase is not
  09: Call ReleaseLock function to unlock area 0
  10: Call main function
  11: VP: Driver erase is called with length of sector size(256)
  12: VP: Driver erase is called with physical address 2048
  13: Call main function
  14: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.RequestLock.RequestLockedArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_RequestLock_Retry_Job</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>911</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful RequestLock request for an address area during the retry of failed driver write job 
  It validates the following :
    - RequestLock doesn't affect the internal module states 
    - RequestLock preempts the current running job
    - lock notification is called after area lock
    - no driver calls if address area is locked
    - job continues after ReleaseLock
    - driver APIs are called with the right parameters (address, page size)
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 1 SA0 logical address 1408 length 2 + 2 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with physical address 2048
  06: Set Driver status to MEMIF_JOB_FAILED
  07: Call main function
  08: VP: Driver write is called with length of page size(2)
  09: VP: Driver write is called with physical address 3072
  10: Call RequestLock function to lock area 1
  11: Call main function
  12: VP: Lock notification is called and Area 1 is locked
  13: Call main function few times
  14: VP: Request is pending
  15: Call ReleaseLock function to unlock area 1
  16: Set Driver status to MEMIF_JOB_OK
  17: Call main function
  18: VP: Driver write is called with length of page size(2)
  19: VP: Driver erase is called with physical address 3072
      and increased by 2 after each successful request
  20: VP: Check that Driver Write is called 4 times [1 fail + 1 retry + 2 successes]
  21: VP: Read request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_RequestLock_2_Areas</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>1036</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful RequestLock requests for two address areas.
  It validates the following :
    - RequestLock doesn't affect the internal module states 
    - RequestLock preempts the current running job
    - lock notification is called after area lock
    - no driver calls if address area is locked
    - job continues after ReleaseLock
    - driver APIs are called with the right parameters (address, page size)
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 0 SA0 logical address 1408 length 24 bytes]
  03: Call Read function: [Area 1 SA1 logical address 1024 length 256 bytes]
  04: Call main function
  05: VP: Driver read is called with length of page size(4)
  06: VP: Driver erase is called with physical address 2048
  07: VP: Driver erase is called with length of sector size(128)
  08: VP: Driver erase is called with physical address 0
  09: Call RequestLock function to lock area 1
  10: Call main function
  11: VP: Driver read is called with length of page size(4)
  12: VP: Driver read is called with physical address 2048 + 2
  13: VP: Lock notification is called and Area 1 is locked
  14: Call main function few times
  15: VP: Driver read is called with length of page size(4)
  16: VP: Driver erase is called with physical address starting 2048 4 
      and increased by 4 after each successful request
  17: Call RequestLock function to lock area 0
  18: Call main function
  19: VP: Lock notification is called and Area 0 is locked
  20: Call main function few times
  21: VP: Requests are pending
  22: Call ReleaseLock function to unlock area 0
  23: Call main function
  24: VP: Driver read is called with length of page size(4)
  25: VP: Driver erase is called with physical address 2048 + (4 * 5)
  26: Call ReleaseLock function to unlock area 1
  27: Call main function
  28: VP: Driver erase is called with length of sector size(128)
  29: VP: Driver erase is called with physical address 2048 + 128
  30: Call main function
  31: VP: Check that Driver Read is called 6 times
  32: VP: Check that Driver Erase is called 2 times
  33: VP: Requests are done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Lock_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_RequestLock/source/application/Tests.c</sourcefile>
      <sourceline>1201</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid RequestLock and ReleaseLock requests regarding API return and Det error codes for
    - invalid address area, 
    - invalid lock notification pointer,  
    - invalid address area state

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call RequestLock function with invalid area ID
  03: Call main function few times
  04: VP: Lock notification is not called
  05: VP: Det reported correctly for MemAcc RequestLock
  06: VP: Call Erase function with invalid lock notification pointer
  07: Call main function few times
  08: VP: Lock notification is not called
  09: VP: Det reported correctly for MemAcc RequestLock
  10: Call RequestLock function with valid args to lock area 0
  11: Call RequestLock function with valid args to the locked area 0
  12: Call main function
  13: VP: Lock notification is called and Area 0 is locked
  14: VP: Call ReleaseLock function with invalid area ID
  15: VP: Det reported correctly for MemAcc ReleaseLock
  16: Call ReleaseLock function to unlock area 0
  17: Call ReleaseLock function to unlock area 0 which is already unlocked

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00071</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00072</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_GetMemoryInfo_Mem_Burst_Disabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Single_Mem_Drv/source/application/Tests.c</sourcefile>
      <sourceline>147</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests the MemAcc_GetMemoryInfo calls for an address area 1 where burst mode is disabled and the addresses as follow :
    - address span on the end of the first sub area 
    - address span on the end of the address area
  burst page/sector sizes will be filled with page/sector sizes

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules
  02: Call GetMemoryInfo function using an address located at the end of the first sub area
  03: VP: Check that the returned memory info match the expected values
  04: Call GetMemoryInfo function using an address located at the end of the second sub area
  05: VP: Check that the returned memory info match the expected values

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Types.MemAcc_MemoryInfoType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>494</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Compare_1_Area_2_SubAreas_1_MemDrv</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_Single_Mem_Drv/source/application/Tests.c</sourcefile>
      <sourceline>205</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests GetProcessedLength with a compare request that spans over multiple sub area.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call compare function
  03: Call main function
  04: VP: Driver read is called with length of single page (8)
  05: VP: Driver read is called with the correct instance id (0)
  06: VP: Driver read is called with the correct physical address
  07: VP: Driver read is called with length of single page (8)
  08: VP: Driver read is called with the correct instance id (0)
  09: VP: Driver read is called with the correct physical address
  10: VP: Check that the returned processed length equal to the expected value
  11: VP: Driver Read API is called 4 times
  12: VP: Check that the returned processed length equal to requested length (32)
  13: VP: Check that compare request done and job status is idle

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Compare.JobResult.Match</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_VarWrite_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_VariableWrite/source/application/Tests.c</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful write requests that spans over a single sub area while variable write is enabled, when
    - request length is a length between write size and write burst size
  It validates the following :
    - addresses translation during Write
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result
    - entire job length is used even if higher than write page size and lower than burst write size

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 2 SA1 logical address 3584 length 100  bytes]
  03: Call main function to trigger the driver write
  04: VP(MemAcc.EB.VariableWrite.Functionality): Driver write is called with length of the job received(100)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 1024
  07: VP: Driver write is called with the right source address
  08: VP(MemAcc.EB.VariableWrite.Functionality): Driver Write API is called 1 times
  09: Check Write data
  10: Call main function to complete the job
  11: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.VariableWrite.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_VarWrite_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_VariableWrite/source/application/Tests.c</sourcefile>
      <sourceline>195</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful write requests that spans over a single sub area while variable write is enabled, when
    - request length is equal with write burst size + 5 x write size
  It validates the following :
    - addresses translation during Write
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result
    - write job is split in 2 driver write jobs, one of burst write size and one equal with 5 x Write Size.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 2 SA1 logical address 3584 length 138  bytes]
  03: Call main function to trigger first part of the write job
  04. VP: Driver write is called with length of the BurstSize)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 1024
  07: VP: Driver write is called with the right source address
  08: Call main function to trigger second batch of the write job
  09: VP(MemAcc.EB.VariableWrite.Functionality): Driver write is called with length Total Write Job minus the BurstSize
  10: VP: Driver write is called with the right instance id
  11: VP: Driver write is called with physical address starting 1024+128
  12: VP: Driver write is called with the right source address
  13: VP: Driver Write API is called 2 time
  14: Check Write data
  15: VP: Call main function to finalize the write job.
  16: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.VariableWrite.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_VarWrite_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_VariableWrite/source/application/Tests.c</sourcefile>
      <sourceline>293</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests a successful write requests that spans over a single sub area while variable write is enabled, when 
    - write job length is equal with the entire subarea size minus one write size
  It validates the following :
    - addresses translation during Write 
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - write job is split in multiple driver jobs, by burst size and the last job the remaining size lower than burst size

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 2 SA1 logical address 3584 length 1022  bytes]
  03: Call main function to complete first driver job
  04: VP: Driver write is called with Burst Size
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 1024 
  07: VP: Driver write is called with the right source address
  08: Call main function to complete the next driver job
  09: VP: Driver write is called with Burst Size
  10: VP: Driver write is called with the right instance id
  11: VP: Driver write is called with correct physical address
  12: VP: Driver write is called with the right source address
  13: Call main function to complete the next driver job
  14: VP: Driver write is called with Burst Size
  15: VP: Driver write is called with the right instance id
  16: VP: Driver write is called with correct physical address
  17: VP: Driver write is called with the right source address
  18: Call main function to complete the next driver job
  19: VP: Driver write is called with Burst Size
  20: VP: Driver write is called with the right instance id
  21: VP: Driver write is called with correct physical address
  22: VP: Driver write is called with the right source address
  23: Call main function to complete the next driver job
  24: VP: Driver write is called with Burst Size
  25: VP: Driver write is called with the right instance id
  26: VP: Driver write is called with correct physical address
  27: VP: Driver write is called with the right source address
  28: Call main function to complete the next driver job
  29: VP: Driver write is called with Burst Size
  30: VP: Driver write is called with the right instance id
  31: VP: Driver write is called with correct physical address
  32: VP: Driver write is called with the right source address
  33: Call main function to complete the next driver job
  34: VP: Driver write is called with Burst Size
  35: VP: Driver write is called with the right instance id
  36: VP: Driver write is called with correct physical address
  37: VP: Driver write is called with the right source address
  38: Call main function to complete the next driver job
  39: VP(MemAcc.EB.VariableWrite.Functionality): Driver write is called with remaining length of the job
  40: VP: Driver write is called with the right instance id
  41: VP: Driver write is called with correct physical address
  42: VP: Driver write is called with the right source address
  43: VP: Driver Write API is called 8 times
  44: Check Write data
  45: VP: Request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.VariableWrite.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_VarWrite_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Conformance/IN/MemAcc_ConTest_VariableWrite/source/application/Tests.c</sourcefile>
      <sourceline>480</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests a successful write request that spans over a two sub areas while variable write is enabled for the second area, when
    - write job over the first subarea spans 2 write sizes
    - write job over the second subarea spans one write burst size and multiple write sizes
  It validates the following :
    - addresses translation during Write
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result
    - Length used per subarea : 2 write sizes in the first subarea, and on the second
      area one write burst size and the remaining length which is greater than a write size
      and lower than  write burst size.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 2 SA0 logical address 3580 length 150  bytes]
  03: Call main function to trigger the driver write
  04: VP: Driver write is called with length of the job ExpectedWriteSizeDriver0(2 bytes)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 5628
  07: VP: Driver write is called with the right source address
  08: Call main function to trigger the driver write
  09: VP: Driver write is called with length of the job ExpectedWriteSizeDriver0(2 bytes)
  10: VP: Driver write is called with the right instance id
  11: VP: Driver write is called with physical address starting 5630
  12: VP: Driver write is called with the right source address
  13: Call main function to trigger the driver write
  14: VP: Driver write is called with length of the ExpectedWriteBurstSizeDriver2(128 bytes)
  15: VP: Driver write is called with the right instance id
  16: VP: Driver write is called with physical address starting 1024
  17: VP: Driver write is called with the right source address
  18: Call main function to trigger the driver write
  19: VP(MemAcc.EB.VariableWrite.Functionality): Driver write is called with the remaining length(18 bytes))
  20: VP: Driver write is called with the right instance id
  21: VP: Driver write is called with physical address starting 1152
  22: VP: Driver write is called with the right source address
  23: VP: Driver Write API is called 2 times
  24: VP(MemAcc.EB.VariableWrite.Functionality): Driver Write API is called 2 times
  25: VP: Check Write data
  26: Call main function to complete the job
  27: VP: Request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.VariableWrite.Functionality</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_BlankCheck/source/application/Tests.c</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid blank check requests regarding API return and Det error codes for
  uninitialized module and valid parameters
  uninitialized module and invalid address area, invalid length, invalid address, invalid address area state

Test Object: 

Test Precondition: 

Test Execution: 
  01: VP: Call BlankCheck function with valid parameters [ area 3 SA0, logical address 5120, length 8 bytes]
  02: Call main function few times
  03: VP: Driver BlankCheck API is not called
  04: VP: Det reported correctly for MemAcc BlankCheck
  05: VP: Call BlankCheck function with invalid area ID
  06: Call main function few times
  07: VP: Driver BlankCheck API is not called
  08: VP: Det reported correctly for MemAcc BlankCheck
  09: VP: Call BlankCheck function with invalid length(0)
  10: Call main function few times
  11: VP: Driver BlankCheck API is not called
  12: VP: Det reported correctly for MemAcc BlankCheck
  13: VP: Call BlankCheck function with invalid address(too big)
  14: VP: Call main function few times
  15: VP: Driver BlankCheck API is not called
  16: VP: Det reported correctly for MemAcc BlankCheck

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00062</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_1_Drv_Available</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_BlankCheck/source/application/Tests.c</sourcefile>
      <sourceline>229</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a blank check over a single driver which provides blank check api
  in case of driver available and driver busy
  It validates the following :
  - addresses translation for multiple drivers 
  - MemAcc calls the right driver API
  - driver APIs are called with the right parameters (destination and length)
  - job status and result 
  - BlankCheck availability [ 1 driver, 2 subareas]

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call BlankCheck function: [A2 SA1 logical address (3584 + 1024 - 8) length 4 + 4 + 4 + 4  bytes]
  03: Call main function
  04: VP: Driver is called with length of single page (4)
  05: VP: Driver BlankCheck is called with the right instance id
  06: VP: Driver blank check is called with physical address starting 2048 - 8
          and increased by 4 after each successful request
  07: VP: Driver is called with length of single page (4)
  08: VP: Driver BlankCheck is called with the right instance id
  09: VP: Driver blank check is called with physical address starting 2048
          and increased by 4 after each successful request
  10: VP: Driver blank check API is called 4 times
  11: Reset stub variables
  12: VP: Call BlankCheck function: [A2 SA1 logical address (3584 + 1024 - 8) length 4 + 4 + 4 + 4  bytes]
  13: Set Driver status to PENDING
  14: Call main function 3 times
  15: VP: Check that no blank check was triggered
  16: Set Driver status to OK
  17: Call main function till job is finished
  18: VP: Driver is called with length of single page (4)
  19: VP: Driver BlankCheck is called with the right instance id
  20: VP: Driver blank check is called with physical address starting 2048 - 8
          and increased by 4 after each successful request
  21: Set Driver status to PENDING for two cycles
  22: Set Driver status to OK
  23: VP: Driver is called with length of single page (4)
  24: VP: Driver BlankCheck is called with the right instance id
  25: VP: Driver blank check is called with physical address starting 2048
          and increased by 4 after each successful request
  26: VP: Driver blank check API is called 4 times

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Dsn.Interfaces.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>495</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.BlankCheck.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_2_Drvs_Available</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_BlankCheck/source/application/Tests.c</sourcefile>
      <sourceline>411</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a blank check over for a request over two drivers which provide blank check api
  while the burst is enabled on the second and the third subareas 
  It validates the following :
  - addresses translation for multiple drivers 
  - MemAcc calls the right driver API
  - driver APIs are called with the right parameters (destination and length)
  - job status and result 
  - BlankCheck availability [ 2 driver, 2 subareas]
  - BlankCheck uses read burst size if the remaining length &gt;= read burst size
  - BlankCheck uses the total remaining length if the remaining length &lt; read burst size

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call BlankCheck function: [A3 SA0 logical address 5120 length 512 + 128 bytes]
  03: Call main function
  04: VP: Driver is called with length of single page (4)
  05: VP: Driver BlankCheck is called with the right instance id
  06: VP: Driver blank check is called with physical address starting 2560
                    and increased by 4 after each successful request
  07: VP: Driver is called with length of burst size (32)
  08: VP: Driver BlankCheck is called with the right instance id
  09: VP: Driver blank check is called with physical address starting at 0
          and increased by 32 after each successful request
  10: VP: Driver is called with length of burst size (8)
  11: VP: Driver BlankCheck is called with the right instance id
  12: VP: Driver blank check is called with physical address starting at 512
  10: VP: Driver is called with length of remaining size (4)
  11: VP: Driver BlankCheck is called with the right instance id
  12: VP: Driver blank check is called with physical address starting at 512 + 8
  13: VP: Driver blank check API is called 128 + 16 times

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.BlankCheck.Burst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_Prio_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_BlankCheck/source/application/Tests.c</sourcefile>
      <sourceline>536</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests blank check requests priority of jobs, high prio starts before low prio.
  It validates the following :
  - addresses translation for multiple drivers 
  - MemAcc calls the right driver API
  - driver APIs are called with the right parameters (destination and length)
  - job status and result 
  - sequentiality and priority of jobs

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call BlankCheck functions: [Area 2 SA0 logical address 5120 length 32] &amp; [Area 3 SA1 logical address 3584 length 24]
  03: Set GetJob return to PENDING by blank check function via stub callout
  04: Call main function
  05: Set GetJob return to OK, so that next driver request can be triggered
  06: VP: Driver blank check is called with length of single page (4)
  07: VP: Driver BlankCheck is called with the right instance id
  08: VP: Driver blank check is called with physical address starting at 2560
          and increased by 4 after each successful request
  09: VP: Driver blank check is called with length of single page (4)
  10: VP: Driver BlankCheck is called with the right instance id
  11: VP: Driver blank check is called with physical address starting at 1024
          and increased by 4 after each successful request
  12: VP: Driver blank check APIs are called 14 times (6 times for area 3, 8 times for area 2)

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.BlankCheck.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_Prio_Preemption</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_BlankCheck/source/application/Tests.c</sourcefile>
      <sourceline>645</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests blank check requests priority of jobs, high prio preempts low prio.
  It validates the following :
  - addresses translation for multiple drivers 
  - MemAcc calls the right driver API
  - driver APIs are called with the right parameters (destination and length)
  - job status and result 
  - sequentiality and priority of jobs

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call BlankCheck function [Area 2 SA0 logical address 5120 length 32]
  03: Set GetJob return to PENDING by blank check function via stub callout
  04: Call main function
  05: Set GetJob return to OK, so that next driver request can be triggered
  06: VP: Driver blank check is called with length of single page (4)
  07: VP: Driver BlankCheck is called with the right instance id
  08: VP: Driver blank check is called with physical address starting at 1024
                 and increased by 4 after each successful request
  09: VP: Driver blank check is called with length of single page (4)
  10: VP: Driver BlankCheck is called with the right instance id
  11: VP: Driver blank check is called with physical address starting at 1024
          and increased by 4 after each successful request
  12: VP: Call BlankCheck function [Area 3 SA1 logical address 3584 length 24]
  13: VP: Driver blank check is called with length of single page (4)
  14: VP: Driver BlankCheck is called with the right instance id
  15: VP: Driver blank check is called with physical address starting at 2560
          and increased by 4 after each successful request
  16: VP: Driver blank check is called with length of single page (4)
  17: VP: Driver BlankCheck is called with the right instance id
  18: VP: Driver blank check is called with physical address starting at 1024
  19: VP: Driver blank check APIs are called 14 times (6 times for area 3, 8 times for area 2)

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_CheckFailed</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_BlankCheck/source/application/Tests.c</sourcefile>
      <sourceline>782</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a blank check in case of check failure at driver level
  - driver returns inconsistent
  - driver job is failed

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call BlankCheck function: [A2 SA1 logical address (3584 + 1024 - 8) length 4 + 4 + 4 + 4  bytes]
  03: Call main function
  04: VP: Driver is called with length of single page (4)
  05: VP: Driver BlankCheck is called with the right instance id
  06: VP: Driver blank check is called with physical address starting 2048 - 8
          and increased by 4 after each successful request
  07: VP: Driver is called with length of single page (4)
  08: VP: Driver BlankCheck is called with the right instance id
  09: VP: Driver blank check is called with physical address starting 2048
          and increased by 4 after each successful request
  10: Set Driver status to INCONSISTENT
  11: VP: Driver blank check API is called 3 times
  12: VP: Check Job result
  13: Reset stub variables
  14: VP: Call BlankCheck function: [A2 SA1 logical address (3584 + 1024 - 8) length 4 + 4 + 4 + 4  bytes]
  15: Call main function
  16: VP: Driver is called with length of single page (4)
  17: VP: Driver BlankCheck is called with the right instance id
  18: VP: Driver blank check is called with physical address starting 2048 - 8
  19: Set Driver status to FAILED
  20: VP: Driver blank check API is called 4 times
  21: VP: Check Job result

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.Inconsistent.BlankCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_1_Drv_Failed_DrvRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_BlankCheck/source/application/Tests.c</sourcefile>
      <sourceline>922</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a blank check over a single driver which provides blank check api
  in case of driver request returns E_NOT_OK

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call BlankCheck function: [A2 SA1 logical address (3584 + 1024 - 8) length 4 + 4 + 4 + 4  bytes]
  03: Set request return value to failed to indicate the failure of the driver request
  04: Call main function
  05: VP: Driver is called with length of single page (4)
  06: VP: Driver BlankCheck is called with the right instance id
  07: VP: Driver blank check is called with physical address starting 2048 - 8
  08: VP: Driver blank check API is called 1 time
  09: VP: Request is failed
  10: Reset stub variables
  11: VP: Call BlankCheck function: [A2 SA1 logical address (3584 + 1024 - 8) length 4 + 4 + 4 + 4  bytes]
  12: Call main function
  13: VP: Driver is called with length of single page (4)
  14: VP: Driver BlankCheck is called with the right instance id
  15: VP: Driver blank check is called with physical address starting 2048 - 8
          and increased by 4 after each successful request
  16: VP: Driver is called with length of single page (4)
  17: VP: Driver BlankCheck is called with the right instance id
  18: VP: Driver blank check is called with physical address starting 2048
          and increased by 4 after each successful request
  19: Set request return value to failed to indicate the failure of the driver request
  20: VP: Driver blank check API is called 4 times
  21: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.EB.MemoryAccess.BlankCheck.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_BlankCheck_InvalidRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_BlankCheck/source/application/Tests.c</sourcefile>
      <sourceline>1057</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests invalid blank check requests regarding API return and Det error codes for
  invalid address area, invalid length, invalid address, invalid address area state

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call BlankCheck function with invalid area ID
  03: Call main function few times
  04: VP: Driver BlankCheck API is not called
  05: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_PARAM_ADDRESS_AREA_ID
  06: VP: Call BlankCheck function with invalid length(0)
  07: Call main function few times
  08: VP: Driver BlankCheck API is not called
  09: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_PARAM_ADDRESS_LENGTH
  10: VP: Call BlankCheck function with invalid length(too big)
  11: Call main function few times
  12: VP: Driver BlankCheck API is not called
  13: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_PARAM_ADDRESS_LENGTH
  14: VP: Call BlankCheck function with invalid length(over area)
  15: Call main function few times
  16: VP: Driver BlankCheck API is not called
  17: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_PARAM_ADDRESS_LENGTH
  18: VP: Call BlankCheck function with invalid address(too big)
  19: VP: Call main function few times
  20: VP: Driver BlankCheck API is not called
  21: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_PARAM_ADDRESS_LENGTH
  22: VP: Call BlankCheck function with invalid address(too small)
  23: Call main function few times
  24: VP: Driver BlankCheck API is not called
  25: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_PARAM_ADDRESS_LENGTH
  26: VP: Call BlankCheck function with unaligned start address
  27: Call main function few times
  28: VP: Driver BlankCheck API is not called
  29: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_PARAM_ADDRESS_LENGTH
  30: VP: Call BlankCheck function with unaligned end address
  31: Call main function few times
  32: VP: Driver BlankCheck API is not called
  33: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_PARAM_ADDRESS_LENGTH

  34: VP: Call BlankCheck function with valid params, [A3 SA0 logical address (5120) length 4 + 4 bytes]
  35: VP: Call BlankCheck function with valid params, for pending area, [A3 SA1 logical address (5632) length 4 + 4 bytes]
  36: VP: Det reported correctly for MemAcc BlankCheck - MEMACC_E_BUSY
  37: Call main function
  38: VP: Driver BlankCheck  is called with length of single page (4)
  39: VP: Driver BlankCheck is called with the right instance id
  40: VP: Driver BlankCheck is called with physical address starting 2560
          and increased by 4 after each successful request
  41: VP: Driver BlankCheck API is called only for first BlankCheck

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.MultipleRequestsForSameAreaReturnCode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Request.InvalidParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00065</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>90</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid erase requests regarding API return and Det error codes for : 
    - uninitialized module and valid parameters
    - uninitialized module and invalid address area, invalid length, invalid address

Test Object: 

Test Precondition: 

Test Execution: 
  01: VP: Call Erase function with valid parameters before MemAcc initialization
  02: Call main function few times
  03: VP: Driver Erase API is not called
  04: VP: Det reported correctly for MemAcc Erase
  05: VP: Call Erase function with invalid area ID
  06: Call main function few times
  07: VP: Driver Erase API is not called
  08: VP: Det reported correctly for MemAcc Erase
  09: VP: Call Erase function with invalid length(0)
  10: Call main function few times
  11: VP: Driver Erase API is not called
  12: VP: Det reported correctly for MemAcc Erase
  13: VP: Call Erase function with invalid length(too big)
  14: VP: Call main function few times
  15: VP: Driver Erase API is not called
  16: VP: Det reported correctly for MemAcc Erase
  17: VP: Call Erase function with invalid address (too big)
  18: VP: Call main function few times
  19: VP: Driver Erase API is not called
  20: VP: Det reported correctly for MemAcc Erase
  21: VP: Call Erase function with invalid address(too small)
  22: VP: Call main function few times
  23: VP: Driver Erase API is not called
  24: VP: Det reported correctly for MemAcc Erase

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00053</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>258</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful erase request that spans over a single sub area while the driver is busy
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (address, sector size)
    - no driver calls if the driver is busy
    - driver being busy doesn't affect the internal MemAcc states
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 0 logical address 1408 + 256 length 256 + 256 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(256)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 2048 + 256 
      and increased by 256 after each successful request
  07: VP: Driver Erase API is called 2 times
  08: VP: Request is done successfully
  09: Call erase function: [Area 0 logical address 1408 + 512 length 256 + 256 bytes]
  10: Call main function
  11: VP: Driver erase is called with length of sector size(256)
  12: VP: Driver erase is called with the right instance id
  13: VP: Driver erase is called with physical address starting 2048 + 512
  14: VP: Check that Driver Erase is called just once
  15: Set Driver status to busy
  16: Call main function 3 times
  17: VP: Check that Driver Erase is called just once
  18: Set Driver status to ok
  19: Call main function
  20: VP: Driver erase is called with length of sector size(256)
  21: VP: Driver erase is called with the right instance id
  22: VP: Driver erase is called with physical address starting 2048 + 512 + 256
  23: VP: Check that Driver Erase is called 2 times
  24: Call main function to process result from driver
  25: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Erase.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_1_Drv</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>401</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests an erase request that spans over multiple sub area, while the driver is busy during the processing of the second sub area.
  It validates the following :
    - addresses translation for multiple sub area request 
    - driver APIs are called with the right parameters (address, sector size)
    - no driver calls if the driver is busy
    - driver being busy doesn't affect the internal MemAcc states
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 0 logical address 1408 + 768 length 256 + 128 + 128 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(256)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 2048 + 768 
      and increased by 256 after each successful request
  07: VP: Driver erase is called with length of sector size(128)
  08: VP: Driver erase is called with the right instance id
  09: VP: Driver erase is called with physical address starting 4608
      and increased by 128 after each successful request
  10: Set Driver status to busy
  11: Set Driver status to available
  12: VP: Driver Erase API is called 2 times only
  13: VP: Driver erase is called with length of sector size(128)
  14: VP: Driver erase is called with the right instance id
  09: VP: Driver erase is called with physical address starting 4608
      and increased by 128 after each successful request
  16: VP: Driver Erase API is called 3 times
  17: VP: Request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Erase.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_2_Drvs</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>526</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests an erase request that spans over multiple sub areas handled by multiple drivers
  It validates the following :
    - addresses translation for multiple drivers 
    - MemAcc calls the right driver API
    - driver APIs are called with the right parameters (address, sector size)
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 1 logical address 768 length 256 + 128 + 128 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(256)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 3072 + 768 
      and increased by 256 after each successful request
  07: VP: Driver erase is called with length of sector size(128)
  08: VP: Driver erase is called with the right instance id
  09: VP: Driver erase is called with physical address starting 0 
      and increased by 128 after each successful request
  10: VP: Driver Erase API is called 1 time
  11: VP: Driver Vendor1 Erase API is called 2 times
  12: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Erase.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>627</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful erase requests that spans over a single sub area while burst is enabled, when 
    - request length is burst size multiple 
    - request length is less than burst size 
  It validates the following :
    - addresses translation during burst 
    - driver APIs are called with the right parameters (address, sector size)
    - job status and result 
    - sector burst size is used only if the remaining length is &gt;= burst size 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 2 logical address 3584 length 512 + 512 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of burst sector size(512)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 1024 
      and increased by 512 after each successful request
  07: VP: Driver Erase API is called 2 times
  08: VP: Request is done successfully
  09: Call erase function: [Area 2 logical address 3840 length 256 bytes]
  10: Call main function
  11: VP: Driver erase is called with length of sector size(256)
  12: VP: Driver erase is called with the right instance id
  13: VP: Driver erase is called with the correct physical address (1024 + 256)
  14: VP: Driver Erase API is called 1 time
  15: Call main function
  16: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_1_Drv_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>742</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests an erase request that spans over multiple sub area on the same driver while burst is enabled
  with fallback to sector size for the end of erase due to requested size not being a multiple of burst size
  It validates the following :
    - addresses translation during burst 
    - driver APIs are called with the right parameters (address, sector size)
    - job status and result 
    - sector burst size is used only if the remaining length is &gt;= burst size 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 2 logical address 3584 + 256 length 512 + 256 + 256 + 128 bytes]
  03: Call main function
  04: VP: Driver erase is called with the right length
    Sector size (256) is used if the remaining size is less than burst size (512)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 1024 + 256 
      and increased by 512/256 after each successful request
  07: VP: Driver erase is called with length of burst sector size(256)
  08: VP: Driver erase is called with the right instance id
  09: VP: Driver erase is called with the right physical address (2048)
  10: VP: Driver erase is called with length of sector size(128)
  11: VP: Driver erase is called with the right instance id
  12: VP: Driver erase is called with the right physical address (2048 + 256)
  13: VP: Driver Erase API is called 4 times
  14: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_2_SubAreas_2_Drv_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>860</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests an Erase request that spans over multiple sub areas handled by multiple drivers while burst is enabled on the 
  second subarea and disable for the the first one 
  It validates the following :
    - addresses translation during burst is enabled
    - driver APIs are called with the right parameters (address, sector size)
    - job status and result 
    - sector burst size is used only if the remaining length is &gt;= burst size and burst is enabled
    - no driver calls if the driver is busy

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 2 logical address 3072 + 256 length 128 + 128 + 512 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(128)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 5120 + 256 
      and increased by 128 after each successful request
  07: VP: Driver erase is called with length of burst sector size(512)
  08: VP: Driver erase is called with the right instance id
  09: VP: Driver erase is called with the right physical address (1024)
  10: Set Driver status to busy
  11: Set Driver status to available
  12: VP: Driver Erase API is called 1 time only
  13: VP: Driver erase is called with length of sector size(256)
  14: VP: Driver erase is called with the right instance id
  15: VP: Driver erase is called with the right physical address (1024 + 512)
  16: VP: Driver Erase API is called 2 times for each of the used drivers
  17: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>986</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed erase request that spans over a single sub area after retry 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (address, sector size)
    - job status and result 
    - retry is performed up to configured number for each driver request

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 0 SA2 logical address 2944 length 64 + 64 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(64)
  05: VP: Driver erase is called with physical address starting 640
  06: VP: Driver erase is called with the right instance id
  07: Set Driver status to failed to indicate failure of driver job
  08: Set Driver status back to ok to indicate success of driver job after two retries
  09: Call main function
  10: VP: Driver erase is called with length of sector size(64)
  11: VP: Driver erase is called with physical address starting 640 + 64
    and increased by 64 after each successful request
  12: VP: Driver erase is called with the right instance id
  13: Set Driver status to failed,to indicate the failure of the driver job
  14: VP: Request is in progress
  15: Call main function
  16: VP: Driver Erase API is called 7 times [ 1 + 2 retries + 1 + 3 retries ]
  17: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_NoRetry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>1104</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed erase request that spans over a single sub area while the number of retries equals zero
  It validates the following :
    - driver APIs are called with the right parameters (address, sector size)
    - job status and result 
    - no retry is done, if the configured number of retries is zero 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 0, SA0 logical address 1408 length 256 + 256 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(256)
  06: VP: Driver erase is called with the right instance id
  05: VP: Driver erase is called with physical address starting 2048
  07: Set Driver status to failed to indicate the failure of the driver job
  08: Call main function
  09: VP: Request is failed
  10: Call main function few times
  11: VP: Driver Erase API is called 1 time
  12: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Erase.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_2_Drvs_Successful_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>1192</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful retry of an erase request that spans over multiple drivers while the driver is busy
  during retry 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (address, sector size)
    - job status and result 
    - driver being busy doesn't affect the retry behavior 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 1 logical address 768 length 256 + 128 + 128 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(256)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 3072 + 768
  07: Call main function
  08: VP: Driver erase is called with length of sector size(128)
  09: VP: Driver erase is called with the right instance id
  10: VP: Driver erase is called with physical address starting 0
  11: Set Driver status to failed, to indicate the failure of the driver job
  12: Set Driver status to busy to indicate that the driver isn't available
  13: Call main function few times
  14: Set Driver status to ok, to indicate the success of the driver job
  15: Call main function
  16: VP: Driver Erase API is called 1 time
  17: VP: Driver Vendor1 Erase API is called 2 times
  18: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Erase</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Successful_Max_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>1307</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful retry of an erase request that spans over a single sub area while the configured retries is the 
  maximum (255) 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - maximum configurable number of retries is considered correctly
    - job end callback is called correctly

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 3 SA0 logical address 5120 length 128 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(128)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 2560
  07: Set Driver status to failed, to indicate the failure of the driver job
  08: Call main function
  09: VP: Driver erase is called with length of sector size(128)
  10: VP: Driver erase is called with the right instance id
  11: VP: Driver erase is called with physical address starting 2560
  12: VP: Request is in progress
  13: VP: address area callback isn't called yet
  14: Set Driver status to ok, to indicate the success of the driver job
  15: Call main function
  16: VP: Driver Erase API is called 256 times [1 + 255 retries]
  17: VP: Request is done successfully
  18: VP: address area callback is called correctly

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_Max_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>1417</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed retry of an erase request that spans over a single sub area while the configured retries is the 
  maximum (255) 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - job is considered as failed as soon as the maximally configured number of retries fail
    - job end callback is called correctly

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 3 SA0 logical address 5120 length 128 bytes]
  03: Call main function
  04: VP: Driver erase is called with length of sector size(128)
  05: VP: Driver erase is called with the right instance id
  06: VP: Driver erase is called with physical address starting 5120
  07: Set Driver status to failed, to indicate the failure of the driver job
  08: Call main function
  09: VP: Driver erase is called with length of sector size(128)
  10: VP: Driver erase is called with the right instance id
  11: VP: Driver erase is called with physical address starting 5120
  12: VP: Request is in progress
  13: VP: address area callback isn't called yet
  14: Call main function
  15: VP: Driver Erase API is called 256 times [1 + 255 retries]
  16: VP: Request is failed
  17: VP: address area callback is called correctly

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00015</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_1_Area_1_SubArea_Failed_DrvRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>1524</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed Erase requests that spans over a single sub area, when the operation returns E_NOT_OK,
  while the retry is enabled
  It validates the following :
    - addresses translation
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Erase function: [Area 0 SA2 logical address 5120 length 256 + 256 bytes]
  03: Set request return value to failed to indicate the failure of the driver request
  04: Call main function
  05: VP: Driver Erase is called with length of sector size(128)
  06: VP: Driver Erase is called with physical address starting 2560
  07: VP: Driver Erase is called with the right instance id
  08: VP: Request is failed
  09: Call Erase function: [Area 0 SA2 logical address 5120 length 512 bytes]
  10: Set request return value back to successful
  11: Call main function
  12: VP: Driver Erase is called with length of sector size(128)
  13: VP: Driver Erase is called with physical address starting 2560
            and increased by 128 after each successful request
  14: VP: Driver Erase is called with the right instance id
  15: Set request return value to failed to indicate the failure of the driver request
  16: VP: Driver Erase API is called 3 times
  17: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Erase.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_2_Areas_1_Drv_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>1632</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests Erase requests that spans over single sub area handled by one driver
  checking sequentiality and priority of jobs, high prio starts before low prio  
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (address, sector size)
    - sequentiality and priority of jobs
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase requests: [Area 1 SA1 logical address 1024 length 128 + 128 bytes],[Area 0 SA2 logical address 2944 length 64 + 64 bytes]
  03: Set GetJob return to MEMIF_JOB_PENDING by erase function via stub callout
  04: Call main function
  05: Set GetJob return to MEMIF_JOB_OK,
  06: VP: Driver erase is called with length of sector size(64)
  07: VP: Driver erase is called with the right instance id
  08: VP: Driver erase is called with physical address starting 640 
          and increased by 64 after each successful request
  09: Set GetJob return to MEMIF_JOB_OK,
  11: VP: Driver erase is called with length of sector size(128)
  12: VP: Driver erase is called with the right instance id
  13: VP: Driver erase is called with physical address starting 0 
          and increased by 128 after each successful request
  14: VP: Driver Erase API is called 4 times
  15: VP: High prio request is done successfully
  16: VP: Low prio request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Erase.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Prioritization.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_2_Areas_1_Drv_Preempted</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>1747</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests erase requests that spans over single sub area handled by one driver
  checking sequentiality and priority of jobs, high prio erase interrupts low prio erase only after current sector operation finishes
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (address, sector size)
    - sequentiality and priority of jobs
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call erase function: [Area 2 SA1 logical address 3584 length 512 + 512 bytes]
  03: Set GetJob return to PENDING by erase function via stub callout
  04: Call main function
  05: VP: Driver erase is called with length of burst sector size(512)
  06: VP: Driver erase is called with the right instance id
  07: VP: Driver erase is called with physical address starting 1024
  08: Call erase function: [Area 3 SA0 logical address 5120 length 256 + 256 bytes]
  09: VP: Driver Erase API is called 1 time
  10: Set GetJob return to OK to indicate the success of low prio job
  11: VP: Driver erase is called with length of burst sector size(512)
  12: VP: Driver erase is called with the right instance id
  13: VP: Driver erase is called with physical address starting 2560 
          and increased by 512 after each successful request
  14: Set GetJob return to OK to indicate the success of high prio job
  15: VP: Driver erase is called with length of burst sector size(256)
  16: VP: Driver erase is called with the right instance id
  17: VP: Driver erase is called with physical address starting 1024 + 256
  18: Set GetJob return to OK to indicate the success of low prio job
  19: VP: Driver Erase API is called 4 times
  20: VP: High prio request is done successfully
  21: VP: Low prio request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Erase.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Prioritization.SectorBurst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Erase_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Erase/source/application/Tests.c</sourcefile>
      <sourceline>1882</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid erase requests regarding API return and Det error codes for
    - invalid address area, 
    - invalid length, 
    - invalid start address, 
    - invalid address area state

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Erase function with invalid area ID
  03: Call main function few times
  04: VP: Driver Erase API is not called
  05: VP: Det reported correctly for MemAcc Erase
  06: VP: Call Erase function with invalid length(0)
  07: Call main function few times
  08: VP: Driver Erase API is not called
  09: VP: Det reported correctly for MemAcc Erase
  10: VP: Call Erase function with invalid length(too big)
  11: Call main function few times
  12: VP: Driver Erase API is not called
  13: VP: Det reported correctly for MemAcc Erase
  14: VP: Call Erase function with invalid length(over area)
  15: Call main function few times
  16: VP: Driver Erase API is not called
  17: VP: Det reported correctly for MemAcc Erase
  18: VP: Call Erase function with invalid address(too big)
  19: VP: Call main function few times
  20: VP: Driver Erase API is not called
  21: VP: Det reported correctly for MemAcc Erase
  22: VP: Call Erase function with invalid address(too small)
  23: Call main function few times
  24: VP: Driver Erase API is not called
  25: VP: Det reported correctly for MemAcc Erase
  26: VP: Call Erase function with unaligned start address
  27: Call main function few times
  28: VP: Driver Erase API is not called
  29: VP: Det reported correctly for MemAcc Erase
  30: VP: Call Erase function with unaligned end address
  31: Call main function few times
  32: VP: Driver Erase API is not called
  33: VP: Det reported correctly for MemAcc Erase
  34: VP: Call Erase function again with valid params
  35: VP: Call Erase function again with valid params
  36: VP: Det reported correctly for MemAcc Erase
  37: VP: Call Erase function again with valid params for a different subarea
  38: VP: Det reported correctly for MemAcc Erase
  39: VP: Driver Erase API is called only for first erase
  40: VP: Driver Erase is called with length of sector size (256)
  41: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.MultipleRequestsForSameAreaReturnCode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Request.InvalidParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>604</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_Mixed_APIs_Prio_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Mixed_APIs_Prio/source/application/Tests.c</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Test prioritization of jobs for 2 Address Areas of different priorities.
  The Read Job for the low priority address area is requested before the Write job
  for the high priority address area.
  The test case verifies that the Write job of the higher priority Address Area will be executed first even if triggered second.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read request [low prio][Area 1 SA0 logical address 1024 - ( 4 ) length 4 + (2*2) bytes]
  03: Call Write request [high prio][Area 2 SA0 logical address 3072 + (128 * 4) - 6 length (2*3)+(8) bytes]
  04: Set GetJob return to PENDING by Write function via stub callout
  05: Call main function
  06: Set GetJob return to JOB OK,
  07: VP: Checks that Driver Write corresponding to the High Prio Area [Area 2]
          is called with length of page size(2)
  08: VP: Checks that Driver Write corresponding to the High Prio Area [Area 2]
          is called with the right instance id
  09: VP: Checks that Driver Write corresponding to the High Prio Area [Area 2]
          is called with physical address starting 5632-6
          and increased by 2 after each successful request
  10: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1] API is not called
  11: VP: Checks that Driver Write corresponding to the High Prio Area [Area 2]
          is called with length of page size(8)
  12: VP: Checks that Driver Write corresponding to the High Prio Area [Area 2]
          is called with the right instance id
  13: VP: Checks that Driver Write corresponding to the High Prio Area [Area 2]
          is called with physical address starting 1024
  14: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with length of page size(4)
  15: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1] check
          is called with the correct instance id
  16: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with physical address starting 4096 - 4
  17: Set GetJob return to JOB OK, to finish high prio request
  18: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with length of page size(2)
  19: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1] check
          is called with the correct instance id
  20: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with physical address starting 0, and increased by 2 after each successful request
  21: VP: Check Drivers APIs number of calls
  22: VP: Check Write data
  23: VP: Check Read data
  24: VP: High prio request is done successfully
  25: VP: Low prio request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>605</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Mixed_APIs_Prio_Wait_Failed</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Mixed_APIs_Prio/source/application/Tests.c</sourcefile>
      <sourceline>286</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Test prioritization of jobs for 2 Address Areas of different priorities.
  The Read Job for the high priority address area is requested before the Erase job
  for the low priority address area,The Read job of the high priority address area
  is failed before it is done.
  The test case verifies that the Erase job of the low priority Address Area will be executed second
  after The Read job of the high priority address area failure.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Erase request [high prio][Area 2 SA0 logical address 3072 + (128 * 3) length (3*128)+256 bytes]
  03: Call Read request [low prio][Area 1 SA0 logical address 1024 - ( 4 ) length 4 + (2*2) bytes]
  04: Set GetJob return to PENDING by Erase function via stub callout
  05: Call main function
  06: Set GetJob return to JOB OK,
  07: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with length of sector size(128)
  08: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with the right instance id
  09: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with physical address starting 5120 + 128, and increased by 128 after each successful request
  10: Set Driver status to failed to indicate failure of driver job
  11: VP: Checks that Driver Read API is not called
  12: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with length of page size(4)
  13: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1] check
          is called with the correct instance id
  14: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with physical address starting 4096 - 4
  15: Set GetJob return to JOB OK, to finish high prio request
  16: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with length of page size(2)
  17: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1] check
          is called with the correct instance id
  18: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with physical address starting 0, and increased by 2 after each successful request
  19: VP: Check Drivers APIs number of calls
  20: VP: Check Read data
  21: VP: High prio request is failed
  22: VP: Low prio request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Prioritization.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>606</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Mixed_APIs_Prio_Mid_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Mixed_APIs_Prio/source/application/Tests.c</sourcefile>
      <sourceline>454</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Test prioritization of jobs for 2 Address Areas of different priorities.
  The Write Job for the low priority address area is requested during the processing of the Erase job
  for the high priority address area.
  The test case verifies that the Write job of the low priority Address Area will be blocked till
  the Erase job of the high priority address area is done.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Write request [high prio][Area 2 SA0 logical address 3072 length 512 + 256 bytes]
  03: Set GetJob return to PENDING by Erase function via stub callout
  04: Call main function
  05: Set GetJob return to Fls_JOB_OK, so that next driver request can be triggered
  06: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with length of sector size (128)
  07: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with the right instance id
  08: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with physical address starting 5120, and increased by 128 after each successful request
  09: Call Read request [low prio][Area 1 SA0 logical address 1024 - ( 2 ) length 2 + 4 + 4 bytes]
  10: VP: Driver Write API is not called
  11: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with length of sector size(256)
  12: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with the right instance id
  13: VP: Checks that Driver Erase corresponding to the High Prio Area [Area 2]
          is called with physical address starting 1024
  14: VP: Checks that Driver Write corresponding to the Low Prio Area [Area 1]
          is called with length of page size(2)
  15: VP: Checks that Driver Write corresponding to the Low Prio Area [Area 1]
          is called with the correct instance id
  16: VP: Checks that Driver Write corresponding to the Low Prio Area [Area 1]
          is called with physical address starting 4096 - 2
  17: VP: Checks that Driver Write corresponding to the Low Prio Area [Area 1]
          is called with length of page size(4)
  18: VP: Checks that Driver Write corresponding to the Low Prio Area [Area 1]
          is called with the correct instance id
  19: VP: Checks that Driver Write corresponding to the Low Prio Area [Area 1]
          is called with physical address 0
  20: VP: Check Drivers APIs number of calls
  21: VP: Check Write data
  22: VP: High prio request is done successfully
  23: VP: Low prio request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.Sector</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Prioritization.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>607</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Mixed_APIs_Prio_Mid_Preempted</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Mixed_APIs_Prio/source/application/Tests.c</sourcefile>
      <sourceline>630</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Test prioritization of jobs for 2 Address Areas of different priorities.
  The BlankCheck Job for the high priority address area is requested during
  the processing of the Read job for the low priority address area,
  the BlankCheck job of the high priority address area is canceled before it is done.
  The test case verifies that the Read job of the low priority Address Area will be preempted till
  the BlankCheck job of the high priority address area is canceled.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read request [low prio][Area 2 SA2 logical address 4608 length 8 * 8 bytes]
  03: Call main function
  04: Set GetJob return to Fls_JOB_OK, so that next driver request can be triggered
  05: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 2]
          is called with length of page size(8)
  06: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 2]
          is called with the right instance id
  07: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 2]
          is called with physical address starting 256
          and increased by 8 after each successful request
  08: 08: Call BlankCheck request [high prio][Area 3 SA0 logical address 5120 length 4 * 32 + 4  bytes]
  09: Set GetJob return to PENDING by BankCheck function via stub callout
  10: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 2] is called 4 times
  11: VP: Checks that Driver BlankCheck corresponding to the High Prio Area [Area 3]
          is called with length of burst size(32)
  12: VP: Checks that Driver BlankCheck corresponding to the High Prio Area [Area 3]
          is called with the right instance id
  13: VP: Checks that Driver BlankCheck corresponding to the High Prio Area [Area 3]
          is called with physical address starting 0, and increased by 32 after each successful request
  14: Cancel Area 3 request
  15: VP: no further calls to Driver Read
  16: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 2]
          is called with length of page size(8)
  17: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 2]
          is called with the right instance id
  18: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 2]
          is called with physical address starting 256 + (4 * 8), and increased by 8 after each successful request
  19: VP: Check Drivers APIs number of calls
  20: VP: Check Read data
  21: VP: High prio request is canceled
  22: VP: Low prio request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>608</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Mixed_APIs_Prio_Preempted_Failed</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Mixed_APIs_Prio/source/application/Tests.c</sourcefile>
      <sourceline>793</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Test prioritization of jobs for 2 Address Areas of different priorities.
  The Read Job for the high priority address area is requested before the Compare job
  for the low priority address area, both jobs start in different drivers and at some point both
  need the same driver, the Compare job of the high priority address area is failed before it is done.
  The test case verifies that the Read job of the low priority Address Area will be blocked till
  the Compare job of the high priority address area is failed.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read request [high prio][Area 3 SA1 logical address 5248+( 4*16 )-16 length 8+8 + 4 + 4 bytes]
  03: Call Compare request [low prio][Area 1 SA0  logical address 1024-8 length 4+4+2+2+2 bytes]
  04: Call main function
  05: Set GetJob return to Fls_JOB_OK, so that next driver request can be triggered
  06: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with length of page size(8)
  07: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with the right instance id
  08: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with physical address starting 3072-16
          and increased by 8 after each successful request
  09: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with length of page size(4)
  10: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with the right instance id
  11: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with physical address starting 4096 - 8, and increased by 4 after each successful request
  12: Set GetJob return to PENDING by Read function via stub callout
  13: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with length of page size(4)
  14: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3] check
          is called with the correct instance id
  15: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with physical address starting 1152, and increased by 4 after each successful request
  16: Set Driver status to failed to indicate the failure of the driver job
  17: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with length of page size(2)
  18: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1] check
          is called with the correct instance id
  19: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with physical address starting 0, and increased by 2 after each successful request
  20: VP: Check Drivers APIs number of calls
  21: VP: High prio request is failed
  22: VP: Low prio request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>609</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Mixed_APIs_Prio_Diff_Drvs</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Mixed_APIs_Prio/source/application/Tests.c</sourcefile>
      <sourceline>974</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Test prioritization of jobs for 2 Address Areas of different priorities and use of different drivers.
  The Read Job for the low priority address area is requested before the Compare job
  for the high priority address area, both jobs start together on different drivers,
  the Read job of the low priority address area is failed before it is done.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read request [low prio][Area 1 SA0 logical address 5248 length 4 + 4 bytes]
  03: Call Compare request [high prio][Area 3 SA1  logical address 1024 length 8 + 8 + 8 bytes]
  04: Call main function
  05: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with length of page size(8)
  06: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with the right instance id
  07: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with physical address starting 2560
          and increased by 8 after each successful request
  08: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with length of page size(4)
  09: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with the right instance id
  10: VP: Checks that Driver Read corresponding to the Low Prio Area [Area 1]
          is called with physical address starting 3072 , and increased by 4 after each successful request
  11: Set GetJob return to unsupported return value
  12: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with length of page size(8)
  13: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3] check
          is called with the correct instance id
  14: VP: Checks that Driver Read corresponding to the High Prio Area [Area 3]
          is called with physical address starting 2560, and increased by 8 after each successful request
  15: VP: Check Drivers APIs number of calls
  16: VP: High prio request is done successfully
  17: VP: Low prio request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>610</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_Read_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid read requests regarding API return and Det error codes for : 
    - uninitialized module and valid parameters
    - uninitialized module and invalid address area, invalid length, invalid address, and NULL_PTR

Test Object: 

Test Precondition: 

Test Execution: 
  01: VP: Call Read function with valid parameters before MemAcc initialization
  02: Call main function few times
  03: VP: Driver Read API is not called
  04: VP: Det reported correctly for MemAcc Read
  05: VP: Call Read function with invalid area ID
  06: Call main function few times
  07: VP: Driver Read API is not called
  08: VP: Det reported correctly for MemAcc Read
  09: VP: Call Read function with invalid length(0)
  10: Call main function few times
  11: VP: Driver Read API is not called
  12: VP: Det reported correctly for MemAcc Read
  13: VP: Call Read function with invalid length(too big)
  14: VP: Call main function few times
  15: VP: Driver Read API is not called
  16: VP: Det reported correctly for MemAcc Read
  17: VP: Call Read function with invalid address (too big)
  18: VP: Call main function few times
  19: VP: Driver Read API is not called
  20: VP: Det reported correctly for MemAcc Read
  21: VP: Call Read function with invalid address(too small)
  22: VP: Call main function few times
  23: VP: Driver Read API is not called
  24: VP: Det reported correctly for MemAcc Read
  25: VP: Call Read function with NULL_PTR
  26: VP: Call main function few times
  27: VP: Driver Read API is not called
  28: VP: Det reported correctly for MemAcc Read

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00043</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>611</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_1_Area_1_SubArea</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>311</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful read request that spans over a single sub area while the driver is busy
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (destination and source addresses, length)
    - no driver calls if the driver is busy
    - driver being busy doesn't affect the internal MemAcc states
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 0 SA0 logical address 1408 + 1024 - 8 length 4 + 4  bytes]
  03: Call main function
  04: VP: Driver Read is called with length of page size(4)
  05: VP: Driver Read is called with the right instance id
  06: VP: Driver Read is called with physical address starting 2048 + 1024 - 8 
          and increased by 4 after each successful request
  07: VP: Driver Read is called with the right destination address
  08: VP: Driver Read API is called 2 times
  09: VP: Check Read data
  10: VP: Request is done successfully
  11: Call Read function: [Area 0 SA0 logical address 1408 length 4 + 4 bytes]
  12: Call main function
  13: VP: Driver Read is called with length of page size(4)
  14: VP: Driver Read is called with the right instance id
  15: VP: Driver Read is called with physical address starting 2048
  16: VP: Driver Read is called with the right destination address
  17: Set Driver status to busy
  18: Call main function 3 times
  19: VP: Check that Driver Read is called just once
  20: Set Driver status to ok
  21: Call main function
  22: VP: Driver Read is called with length of page size(4)
  23: VP: Driver Read is called with the right instance id
  24: VP: Driver Read is called with physical address starting 2048 + 4
  25: VP: Driver Read is called with the right destination address
  26: VP: Check that Driver Read is called 2 times
  27: VP: Check Read data
  28: Call main function to process result from driver
  29: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Read.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>612</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_1_Drv</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>470</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests a read request that spans over multiple sub area, while the driver is busy during the processing of the second sub area.
  It validates the following :
    - addresses translation for multiple sub area request 
    - driver APIs are called with the right parameters (destination and source addresses, length)
    - no driver calls if the driver is busy
    - driver being busy doesn't affect the internal MemAcc states
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 0 SA0 logical address 1408 + 1024 - 4 length 4 + 4 + 4 bytes]
  03: Call main function
  04: VP: Driver Read is called with length of page size(4)
  05: VP: Driver Read is called with the right instance id
  06: VP: Driver Read is called with physical address starting 3070 
          and increased by 4 after each successful request
  07: VP: Driver Read is called with the right destination address
  08: VP: Driver Read is called with length of page size(4)
  09: VP: Driver Read is called with the right instance id
  10: VP: Driver Read is called with physical address starting 4608
          and increased by 4 after each successful request
  11: VP: Driver Read is called with the right destination address
  12: Set Driver status to busy
  13: Set Driver status to available
  14: VP: Driver Read API is called 2 times only
  15: VP: Driver Read is called with length of page size(4)
  16: VP: Driver Read is called with the right instance id
  18: VP: Driver Read is called with the right destination address
  19: VP: Driver Read API is called 3 times
  20: VP: Check Read data
  21: VP: Request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Read.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>613</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_1_Area_2_Drvs</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>607</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a read request that spans over multiple sub areas handled by multiple drivers
  It validates the following :
    - addresses translation for multiple drivers 
    - MemAcc calls the right driver API
    - driver APIs are called with the right parameters (destination and source addresses, length)
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 1 logical address 1020 length 4 + 2 + 2 bytes]
  03: Call main function
  04: VP: Driver Read is called with length of page size(4)
  05: VP: Driver Read is called with the right instance id
  06: VP: Driver Read is called with physical address starting 4096 - 4
  07: VP: Driver Read is called with the right destination address
  08: VP: Driver Read is called with length of page size(2)
  09: VP: Driver Read is called with the right instance id
  10: VP: Driver Read is called with physical address starting 0 
          and increased by 2 after each successful request
  11: VP: Driver Read is called with the right destination address
  12: VP: Driver Read API is called 1 time
  13: VP: Driver Vendor1 Read API is called 2 times
  14: VP: Check Read data
  15: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Read.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Read</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>614</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>719</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful read requests that spans over a single sub area while burst is enabled, when 
    - request length is burst size multiple 
    - request length is less than burst size 
  It validates the following :
    - addresses translation during burst 
    - driver APIs are called with the right parameters (destination and source addresses, length)
    - job status and result 
    - page burst size is used only if the remaining length is &gt;= read burst size 
    - the total remaining length is used if it is less than read burst size  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 2 SA1 logical address 3584 length 16 + 16  bytes]
  03: Call main function
  04: VP: Driver Read is called with length of burst page size(16)
  05: VP: Driver Read is called with the right instance id
  06: VP: Driver Read is called with physical address starting 1024 
          and increased by 16 after each successful request
  07: VP: Driver Read is called with the right destination address
  08: VP: Driver Read API is called 2 times
  09: VP: Check Read data
  10: VP: Request is done successfully
  11: Call Read function: [Area 2 logical address 3584 + 256 length 12 bytes]
  12: Call main function
  13: VP: Driver Read is called with length of (12)
  14: VP: Driver Read is called with the right instance id
  15: VP: Driver Read is called with the correct physical address (1024 + 256)
  16: VP: Driver Read is called with the right destination address
  17: VP: Driver Read API is called 1 time
  18: VP: Check Read data
  19: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>615</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_1_Drv_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>856</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a read request that spans over multiple sub area on the same driver while burst is enabled
  with fallback to read page size for the end of read due to not multiple of burst size
  It validates the following :
    - addresses translation during burst 
    - driver APIs are called with the right parameters (destination and source addresses, length)
    - job status and result 
    - page burst size is used only if the remaining length is &gt;= burst size 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 2 SA1 + SA2 logical address 4608 - 20, length 16 + 4 + 8 + 4 bytes]
  03: Call main function
  05: VP: Driver Read is called with the right instance id
  06: VP: Driver Read is called with physical address starting 2048 - 20 
          and increased by 16/4 after each successful request
  07: VP: Driver Read is called with the right destination address
  08: VP: Driver Read is called with length of burst page size(8)
  09: VP: Driver Read is called with the right instance id
  10: VP: Driver Read is called with the right physical address(2048)
  11: VP: Driver Read is called with the right destination address
  12: VP: Driver Read is called with length of page size(4)
  13: VP: Driver Read is called with the right instance id
  14: VP: Driver Read is called with the right physical address (2048 + 8)
  15: VP: Driver Read is called with the right destination address
  16: VP: Driver Read API is called 4 times
  17: VP: Check Read data
  18: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>616</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_1_Area_2_SubAreas_2_Drv_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>991</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests Read request that spans over multiple sub areas handled by multiple drivers while burst is enabled on the 
  second subarea and disabled for the the first one 
  It validates the following :
    - addresses translation during burst is enabled
    - driver APIs are called with the right parameters (destination and source addresses, length)
    - job status and result 
    - read burst size is used only if the remaining length is &gt;= burst size and burst is enabled 
    - no driver calls if the driver is busy

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 2 SA0 + SA1 logical address 3584 - 8 length 4 + 4 + 16 + 4 bytes]
  03: Call main function
  04: VP: Driver Read is called with length of page size(4)
  05: VP: Driver Read is called with the right instance id
  06: VP: Driver Read is called with physical address starting 5632 - 8 
          and increased by 4 after each successful request
  07: VP: Driver Read is called with the right destination address
  08: VP: Driver Read is called with length of burst page size(16)
  09: VP: Driver Read is called with the right instance id
  10: VP: Driver Read is called with the right physical address (1024)
  11: VP: Driver Read is called with the right destination address
  12: Set Driver status to busy
  13: Set Driver status to available
  14: VP: Driver Read API is called 1 time only
  15: VP: Driver Read is called with length of page size(4)
  16: VP: Driver Read is called with the right instance id
  17: VP: Driver Read is called with the right physical address (1024 + 16)
  18: VP: Driver Read is called with the right destination address
  19: VP: Driver Read API is called 2 times
  20: VP: Check Read data
  21: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Read</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>617</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Failed_Job</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>1132</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed read request that spans over a single sub area
  It validates the following :
    - driver APIs are called with the right parameters (destination and source addresses, length)
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 0, SA0 logical address 1408 length 4 + 4 bytes]
  03: Call main function
  04: VP: Driver Read is called with length of page size(4)
  05: VP: Driver Read is called with physical address starting 2048
  06: VP: Driver Read is called with the right instance id
  07: VP: Driver Read is called with the right destination address
  08: Set Driver status to failed to indicate the failure of the driver job
  09: Call main function
  10: VP: Request is failed
  11: Call main function few times
  12: VP: Driver Read API is called 1 time
  13: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Read.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>618</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_1_Area_1_SubArea_Failed_DrvRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>1223</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests a failed read request that spans over a single sub area, in case of first or consecutive(last) driver request failure
  It validates the following :
    - addresses translation
    - driver APIs are called with the right parameters (destination and source addresses, length)
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 0 SA2 logical address 2944 length 8 + 8 bytes]
  03: Set request return value to failed to indicate the failure of the driver request
  04: Call main function
  05: VP: Driver Read is called with length of page size(8)
  06: VP: Driver Read is called with physical address starting 640
  07: VP: Driver Read is called with the right instance id
  08: VP: Driver Read is called with the right destination address
  09: VP: Request is failed
  10: Call Read function: [Area 0 SA2 logical address 2944 length 32 bytes]
  11: Set request return value back to successful
  12: Call main function
  13: VP: Driver Read is called with length of page size(8)
  14: VP: Driver Read is called with physical address starting 640 
        and increase by 8 after each successful request
  15: VP: Driver Read is called with the right instance id
  16: VP: Driver Read is called with the right destination address
  17: Set request return value to failed to indicate the failure of the driver request
  18: VP: Driver Read API is called 5 times
  19: VP: Request is failed

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Read.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>619</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_2_Areas_1_Drv_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>1337</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests Read requests that spans over single sub area handled by one driver
  checking sequentiality and priority of jobs, high prio starts before low prio  
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (address, page size)
    - sequentiality and priority of jobs
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read requests: [Area 1 SA1 logical address 1024 length 2 + 2 bytes],[Area 0 SA2 logical address 2944 length 8 + 8 bytes]
  03: Set GetJob return to PENDING by read function via stub callout
  04: Call main function
  05: Set GetJob return to JOB OK,
  06: VP: Driver Read is called with length of page size(8)
  07: VP: Driver Read is called with the right instance id
  08: VP: Driver Read is called with physical address starting 640 
          and increased by 8 after each successful request
  09: VP: Driver Read is called with the right destination address
  10: Set GetJob return to JOB OK, to finish high prio request
  11: VP: Driver Read is called with length of page size(2)
  12: VP: Driver Read is called with the right instance id
  13: VP: Driver Read is called with physical address starting 0 
          and increased by 2 after each successful request
  14: VP: Driver Read is called with the right destination address
  15: VP: Driver Read API is called 4 times
  16: VP: Check Read data
  17: VP: High prio request is done successfully
  18: VP: Low prio request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Read.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Prioritization.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>620</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_2_Areas_1_Drv_Preempted</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>1465</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests read requests that spans over single sub area handled by one driver
  checking sequentiality and priority of jobs, high prio read interrupts low prio read only after current page burst operation finishes
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (address, page size)
    - sequentiality and priority of jobs
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call Read function: [Area 2 SA1 logical address 3584 length 16 + 16 bytes]
  03: Set GetJob return to PENDING by read function via stub callout
  04: Call main function
  05: VP: Driver Read is called with length of burst page size(16)
  06: VP: Driver Read is called with the right instance id
  07: VP: Driver Read is called with physical address starting 1024 
          and increased by 16 after each successful request
  08: VP: Driver Read is called with the right destination address
  09: Call Read function: [Area 3 SA0 logical address 5120 length 8 + 8 bytes]
  10: VP: Driver Read API is called 1 time
  11: Set GetJob return to OK to indicate the success of low prio job
  12: VP: Driver Read is called with length of burst page size(8)
  13: VP: Driver Read is called with the right instance id
  14: VP: Driver Read is called with physical address starting 2560
          and increased by 8 after each successful request
  15: VP: Driver Read is called with the right destination address
  16: Set GetJob return to OK to indicate the success of high prio job
  17: VP: Driver Read is called with length of burst page size(16)
  18: VP: Driver Read is called with the right instance id
  19: VP: Driver Read is called with physical address starting 1024 + 16
  20: VP: Driver Read is called with the right destination address
  21: Set GetJob return to OK to indicate the success of low prio job
  22: VP: Driver Read API is called 4 times
  23: VP: Check Read data
  24: VP: High prio request is done successfully
  25: VP: Low prio request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Read.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Prioritization.PageBurst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>621</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Read_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Read/source/application/Tests.c</sourcefile>
      <sourceline>1626</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid read requests regarding API return and Det error codes for
    - invalid address area, 
    - invalid length, 
    - invalid start address, 
    - invalid address area state
    - NULL_PTR

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Read function with invalid area ID
  03: Call main function few times
  04: VP: Driver Read API is not called
  05: VP: Det reported correctly for MemAcc Read
  06: VP: Call Read function with invalid length(0)
  07: Call main function few times
  08: VP: Driver Read API is not called
  09: VP: Det reported correctly for MemAcc Read
  10: VP: Call Read function with invalid length(too big)
  11: Call main function few times
  12: VP: Driver Read API is not called
  13: VP: Det reported correctly for MemAcc Read
  14: VP: Call Read function with invalid length(over area)
  15: Call main function few times
  16: VP: Driver Read API is not called
  17: VP: Det reported correctly for MemAcc Read
  18: VP: Call Read function with invalid address(too big)
  19: VP: Call main function few times
  20: VP: Driver Read API is not called
  21: VP: Det reported correctly for MemAcc Read
  22: VP: Call Read function with invalid address(too small)
  23: Call main function few times
  24: VP: Driver Read API is not called
  25: VP: Det reported correctly for MemAcc Read
  26: VP: Call Read function with NULL_PTR
  27: Call main function few times
  28: VP: Driver Read API is not called
  29: VP: Det reported correctly for MemAcc Read
  30: VP: Call Read function with unaligned start
  31: Call main function few times
  32: VP: Driver Read API is not called
  33: VP: Det reported correctly for MemAcc Read
  34: VP: Call Read function with unaligned end
  35: Call main function few times
  36: VP: Driver Read API is not called
  37: VP: Det reported correctly for MemAcc Read
  38: VP: Call Read function with valid params
      [MemAccConf_MemAccAddressAreaConfiguration_MemAccAddressAreaConfiguration_0 logical address 1408 length 2 bytes]
  39: VP: Call Read function again with valid params
  40: VP: Det reported correctly for MemAcc Read
  41: VP: Call Read function again with valid params for a different sub area
  42: VP: Det reported correctly for MemAcc Read
  43: VP: Driver Read API is called only for first read
  44: VP: Driver Read is called with length of page size (2)
  45: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.MultipleRequestsForSameAreaReturnCode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Request.InvalidParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00044</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00045</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>622</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_MEMACC_ConTest_Write_Uninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid write requests regarding API return and Det error codes for : 
    - uninitialized module and valid parameters
    - uninitialized module and invalid address area, invalid length, invalid address, and NULL_PTR

Test Object: 

Test Precondition: 

Test Execution: 
  01: VP: Call Write function with valid parameters before MemAcc initialization
  02: Call main function few times
  03: VP: Driver Write API is not called
  04: VP: Det reported correctly for MemAcc Write
  05: VP: Call Write function with invalid area ID
  06: Call main function few times
  07: VP: Driver Write API is not called
  08: VP: Det reported correctly for MemAcc Write
  09: VP: Call Write function with invalid length(0)
  10: Call main function few times
  11: VP: Driver Write API is not called
  12: VP: Det reported correctly for MemAcc Write
  13: VP: Call Write function with invalid length(too big)
  14: VP: Call main function few times
  15: VP: Driver Write API is not called
  16: VP: Det reported correctly for MemAcc Write
  17: VP: Call Write function with invalid address (too big)
  18: VP: Call main function few times
  19: VP: Driver Write API is not called
  20: VP: Det reported correctly for MemAcc Write
  21: VP: Call Write function with invalid address(too small)
  22: VP: Call main function few times
  23: VP: Driver Write API is not called
  24: VP: Det reported correctly for MemAcc Write
  25: VP: Call Write function with NULL_PTR
  26: VP: Call main function few times
  27: VP: Driver Write API is not called
  28: VP: Det reported correctly for MemAcc Write

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>623</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>301</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful write request that spans over a single sub area while the driver is busy
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (target and source addresses, length)
    - no driver calls if the driver is busy
    - driver being busy doesn't affect the internal MemAcc states
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 0 SA0 logical address 1408 + 1024 - 4 length 2 + 2 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 2048 + 1024 - 4 
          and increased by 2 after each successful request
  07: VP: Driver write is called with the right source address
  08: VP: Driver Write API is called 2 times
  09: VP: Check Write data
  10: VP: Request is done successfully
  11: Call write function: [Area 0 SA0 logical address 1408 length 2 + 2 bytes]
  12: Call main function
  13: VP: Driver write is called with length of page size(2)
  14: VP: Driver write is called with the right instance id
  15: VP: Driver write is called with physical address starting 2048
  16: VP: Driver write is called with the right source address
  17: Set Driver status to busy
  18: Call main function 3 times
  19: VP: Check that Driver Write is called just once
  20: Set Driver status to ok
  21: Call main function
  22: VP: Driver write is called with length of page size(2)
  23: VP: Driver write is called with the right instance id
  24: VP: Driver write is called with physical address starting 2048 + 2
  25: VP: Driver write is called with the right source address
  26: VP: Check that Driver Write is called 2 times
  27: VP: Check Write data
  28: Call main function to process result from driver
  29: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>624</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_1_Drv</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>457</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests a write request that spans over multiple sub area, while the driver is busy during the processing of the second sub area.
  It validates the following :
    - addresses translation for multiple sub area request 
    - driver APIs are called with the right parameters (target and source addresses, length)
    - no driver calls if the driver is busy
    - driver being busy doesn't affect the internal MemAcc states
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 0 SA0 logical address 1408 + 1024 - 2 length 2 + 2 + 2 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 3070 
          and increased by 2 after each successful request
  07: VP: Driver write is called with the right source address
  08: VP: Driver write is called with length of page size(2)
  09: VP: Driver write is called with the right instance id
  10: VP: Driver write is called with physical address starting 4608
          and increased by 2 after each successful request
  11: VP: Driver write is called with the right source address
  12: Set Driver status to busy
  13: Set Driver status to available
  14: VP: Driver Write API is called 2 times only
  15: VP: Driver write is called with length of page size(2)
  16: VP: Driver write is called with the right instance id
  18: VP: Driver write is called with the right source address
  19: VP: Driver Write API is called 3 times
  20: VP: Check Write data
  21: VP: Request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>625</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_2_Drvs</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>594</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a write request that spans over multiple sub areas handled by multiple drivers
  It validates the following :
    - addresses translation for multiple drivers 
    - MemAcc calls the right driver API
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 1 logical address 1022 length 2 + 4 + 4 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 4096 - 2
  07: VP: Driver write is called with the right source address
  08: VP: Driver write is called with length of page size(4)
  09: VP: Driver write is called with the right instance id
  10: VP: Driver write is called with physical address starting 0 
          and increased by 4 after each successful request
  11: VP: Driver write is called with the right source address
  12: VP: Driver Write API is called 1 time
  13: VP: Driver Vendor1 Write API is called 2 times
  14: VP: Check Write data
  15: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>626</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>704</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful write requests that spans over a single sub area while burst is enabled, when 
    - request length is burst size multiple 
    - request length is less than burst size 
  It validates the following :
    - addresses translation during burst 
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - page burst size is used only if the remaining length is &gt;= burst size 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 2 SA1 logical address 3584 length 8 + 8  bytes]
  03: Call main function
  04: VP: Driver write is called with length of burst page size(8)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 1024 
          and increased by 8 after each successful request
  07: VP: Driver write is called with the right source address
  08: VP: Driver Write API is called 2 times
  09: VP: Check Write data
  10: VP: Request is done successfully
  11: Call write function: [Area 2 logical address 3584 + 256 length 2 bytes]
  12: Call main function
  13: VP: Driver write is called with length of page size(2)
  14: VP: Driver write is called with the right instance id
  15: VP: Driver write is called with the correct physical address (1024 + 256)
  16: VP: Driver write is called with the right source address
  17: VP: Driver Write API is called 1 time
  18: VP: Check Write data
  19: Call main function
  20: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>627</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_1_Drv_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>833</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a write request that spans over multiple sub area on the same driver while burst is enabled
  with fallback to write page size for the end of write due to not multiple of burst size
  It validates the following :
    - addresses translation during burst 
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - page burst size is used only if the remaining length is &gt;= burst size 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 2 SA1 + SA2 logical address 4096 - 10, length 8 + 2 + 4 + 2 bytes]
  03: Call main function
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 2048 - 10 
          and increased by 8/2 after each successful request
  07: VP: Driver write is called with the right source address
  08: VP: Driver write is called with length of burst page size(4)
  09: VP: Driver write is called with the right instance id
  10: VP: Driver write is called with the right physical address (2048 + 10)
  11: VP: Driver write is called with the right source address
  12: VP: Driver write is called with length of page size(2)
  13: VP: Driver write is called with the right instance id
  14: VP: Driver write is called with the right physical address (2048 + 10 + 4)
  15: VP: Driver write is called with the right source address
  16: VP: Driver Write API is called 4 times
  17: VP: Check Write data
  18: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>628</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_2_SubAreas_2_Drv_Burst</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>968</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests Write request that spans over multiple sub areas handled by multiple drivers while burst is enabled on the 
  second subarea and disable for the the first one 
  It validates the following :
    - addresses translation during burst is enabled
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - write burst size is used only if the remaining length is &gt;= burst size and burst is enabled 
    - no driver calls if the driver is busy

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 2 SA0 + SA1 logical address 3584 - 4 length 2 + 2 + 8 + 2 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 5632 - 4 
          and increased by 2 after each successful request
  07: VP: Driver write is called with the right source address
  08: VP: Driver write is called with length of burst page size(8)
  09: VP: Driver write is called with the right instance id
  10: VP: Driver write is called with the right physical address (1024)
  11: VP: Driver write is called with the right source address
  12: Set Driver status to busy
  13: Set Driver status to available
  14: VP: Driver Write API is called 1 time only
  15: VP: Driver write is called with length of page size(2)
  16: VP: Driver write is called with the right instance id
  17: VP: Driver write is called with the right physical address (1024 + 8)
  18: VP: Driver write is called with the right source address
  19: VP: Driver Write API is called 2 times
  20: VP: Check Write data
  21: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>629</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>1110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed write request that spans over a single sub area after retry 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - the internal retry states are independent for each driver request

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 0 SA2 logical address 2944 length 4 + 4 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(4)
  05: VP: Driver write is called with physical address starting 640
  06: VP: Driver write is called with the right instance id
  07: VP: Driver write is called with the right source address
  08: Set Driver status to failed to indicate failure of driver job
  09: Set Driver status back to ok to indicate success of driver job after one cycle of retry
  10: Call main function
  11: VP: Driver write is called with length of page size(4)
  12: VP: Driver write is called with physical address starting 640 + 4
  13: VP: Driver write is called with the right instance id
  14: VP: Driver write is called with the right source address
  15: Set Driver status to failed,to indicate the failure of the driver job
  16: Call main function
  17: VP: Driver Write API is called 5 times [ 1 + 1 retry + 1 + 2 retries ]
  18: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>630</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_NoRetry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>1231</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed write request that spans over a single sub area while the number of reties equal zero
  It validates the following :
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - no retry is done, if the number of retries is zero 

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 0, SA0 logical address 1408 length 2 + 2 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with physical address starting 2048
  06: VP: Driver write is called with the right instance id
  07: VP: Driver write is called with the right source address
  08: Set Driver status to failed to indicate the failure of the driver job
  09: Call main function
  10: VP: Request is failed
  11: Call main function few times
  12: VP: Driver Write API is called 1 time
  13: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>631</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_2_Drvs_Successful_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>1322</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful retry of an write request that spans over multiple drivers while the driver is busy
  during retry 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - driver being busy doesn't affect the retry behavior, only successfully requested operations are considered
    - retries are considered for each used driver independently

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 1 SA0 + SA1 logical address 1024 - 2 length 2 + 4 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 4096 - 2
  07: VP: Driver write is called with the right source address
  08: Call main function
  09: VP: Driver write is called with length of page size(4)
  10: VP: Driver write is called with the right instance id
  11: VP: Driver write is called with physical address starting 0
  12: VP: Driver write is called with the right source address
  13: Set Driver status to failed, to indicate the failure of the driver job
  14: Set Driver status to busy to indicate that the driver isn't available
  15: Call main function few times
  16: Set Driver status to ok, to indicate the success of the driver job
  17: Call main function
  18: VP: Driver Write API is called 1 time
  19: VP: Driver Vendor1 Write API is called 2 times
  20: VP: Check Write data
  21: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.CrossDeviceBoundaryOperation.Write</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>632</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Successful_Max_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>1451</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a successful retry of an write request that spans over a single sub area while the configured retries is the 
  maximum (255) 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - maximum configurable number of retries is considered correctly

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 3 SA0 logical address 5120 length 2 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 2560
  07: VP: Driver write is called with the right source address
  08: Set Driver status to failed, to indicate the failure of the driver job
  09: Call main function
  10: VP: Driver write is called with length of page size(2)
  11: VP: Driver write is called with the right instance id
  12: VP: Driver write is called with physical address starting 2560
  13: VP: Driver write is called with the right source address
  14: VP: Request is in progress
  15: Set Driver status to ok, to indicate the success of the driver job
  16: Call main function
  17: VP: Driver Write API is called 256 times [1 + 255 retries]
  18: VP: Check Write data
  19: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>633</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_Max_Retry</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>1566</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed retry of an write request that spans over a single sub area while the configured retries is the 
  maximum (255) 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - job is considered as failed as soon as the maximally configured number of retries fail

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 3 SA0 logical address 5120 length 2 bytes]
  03: Call main function
  04: VP: Driver write is called with length of page size(2)
  05: VP: Driver write is called with the right instance id
  06: VP: Driver write is called with physical address starting 5120
  07: VP: Driver write is called with the right source address
  08: Set Driver status to failed, to indicate the failure of the driver job
  09: Call main function
  10: VP: Driver write is called with length of page size(2)
  11: VP: Driver write is called with the right instance id
  12: VP: Driver write is called with physical address starting 5120
  13: VP: Driver write is called with the right source address
  14: VP: Request is in progress
  15: Call main function
  16: VP: Driver Write API is called 256 times [1 + 255 retries]
  17: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>634</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_1_Area_1_SubArea_Failed_DrvRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>1671</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests a failed write request that spans over a single sub area after retry 
  It validates the following :
    - addresses translation during the retry
    - driver APIs are called with the right parameters (target and source addresses, length)
    - job status and result 
    - the internal retry states are independent for each driver request

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 0 SA2 logical address 2944 length 4 + 4 bytes]
  03: Set request return value to failed to indicate the failure of the driver request
  04: Call main function
  05: VP: Driver write is called with length of page size(4)
  06: VP: Driver write is called with physical address starting 640
  07: VP: Driver write is called with the right instance id
  08: VP: Driver write is called with the right source address
  09: VP: Request is failed
  10: Call write function: [Area 0 SA2 logical address 2944 length 16 bytes]
  11: Set request return value back to successful
  12: Call main function
  13: VP: Driver write is called with length of page size(4)
  14: VP: Driver write is called with physical address starting 640 
        and increase by 4 after each successful request
  15: VP: Driver write is called with the right instance id
  16: VP: Driver write is called with the right source address
  17: Set request return value to failed to indicate the failure of the driver request
  18: VP: Driver Write API is called 5 times
  19: VP: Request is failed

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00119</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>635</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_2_Areas_1_Drv_Wait</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>1786</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests Read requests that spans over single sub area handled by one driver
  checking sequentiality and priority of jobs, high prio starts before low prio  
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (address, page size)
    - sequentiality and priority of jobs
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write requests: [Area 1 SA1 logical address 1024 length 2 + 2 bytes],[Area 0 SA2 logical address 2944 length 8 + 8 bytes]
  03: Set GetJob return to PENDING by write function via stub callout
  04: Call main function
  05: Set GetJob return to JOB OK,
  06: VP: Driver write is called with length of page size(8)
  07: VP: Driver write is called with the right instance id
  08: VP: Driver write is called with physical address starting 640 
          and increased by 8 after each successful request
  09: VP: Driver write is called with the right source address
  10: Set GetJob return to JOB OK,
  11: VP: Driver write is called with length of page size(2)
  12: VP: Driver write is called with the right instance id
  13: VP: Driver write is called with physical address starting 0 
          and increased by 2 after each successful request
  14: VP: Driver write is called with the right source address
  15: VP: Driver Read API is called 4 times
  16: VP: Check Read data
  17: VP: High prio request is done successfully
  18: VP: Low prio request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.MemoryAccess.Write.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Prioritization.Page</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>636</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_2_Areas_1_Drv_Preempted</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>1913</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
  Tests write requests that spans over single sub area handled by one driver
  checking sequentiality and priority of jobs, high prio write interrupts low prio write only after current page operation finishes
  It validates the following :
    - addresses translation for single sub area 
    - driver APIs are called with the right parameters (address, page size)
    - sequentiality and priority of jobs
    - job status and result  

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: Call write function: [Area 2 SA1 logical address 3584 length 8 + 8 bytes]
  03: Set GetJob return to PENDING by write function via stub callout
  04: Call main function
  05: VP: Driver write is called with length of burst page size(8)
  06: VP: Driver write is called with the right instance id
  07: VP: Driver write is called with physical address starting 1024 
          and increased by 8 after each successful request
  08: VP: Driver write is called with the right source address
  09: Call write function: [Area 3 SA0 logical address 5120 length 4 + 4 bytes]
  10: VP: Driver Read API is called 1 time
  11: Set GetJob return to OK to indicate the success of low prio job
  12: VP: Driver write is called with length of burst page size(4)
  13: VP: Driver write is called with the right instance id
  14: VP: Driver write is called with physical address starting 2560
          and increased by 4 after each successful request
  15: VP: Driver write is called with the right source address
  16: Set GetJob return to OK to indicate the success of high prio job
  17: VP: Driver write is called with length of burst page size(8)
  18: VP: Driver write is called with the right instance id
  19: VP: Driver write is called with physical address starting 1024 + 8
  20: VP: Driver write is called with the right source address
  21: Set GetJob return to OK to indicate the success of low prio job
  22: VP: Driver Read API is called 4 times
  23: VP: Check Read data
  24: VP: High prio request is done successfully
  25: VP: Low prio request is done successfully

Test Input: 

Test Output: 
</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Prioritization.PageBurst</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>637</internalId></specobject>
    <specobject>
      <id>TS_MEMACC_ConTest_Write_Invalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_MemAcc)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_MemAcc/test/ts5/Include/MemAcc_ConTest_Write/source/application/Tests.c</sourcefile>
      <sourceline>2067</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Tests invalid write requests regarding API return and Det error codes for
    - invalid address area, 
    - invalid length, 
    - invalid start address, 
    - invalid address area state
    - NULL_PTR

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the used modules.
  02: VP: Call Write function with invalid area ID
  03: Call main function few times
  04: VP: Driver Write API is not called
  05: VP: Det reported correctly for MemAcc Write
  06: VP: Call Write function with invalid length(0)
  07: Call main function few times
  08: VP: Driver Write API is not called
  09: VP: Det reported correctly for MemAcc Write
  10: VP: Call Write function with invalid length(too big)
  11: Call main function few times
  12: VP: Driver Write API is not called
  13: VP: Det reported correctly for MemAcc Write
  14: VP: Call Write function with invalid length(over area)
  15: Call main function few times
  16: VP: Driver Write API is not called
  17: VP: Det reported correctly for MemAcc Write
  18: VP: Call Write function with invalid address(too big)
  19: VP: Call main function few times
  20: VP: Driver Write API is not called
  21: VP: Det reported correctly for MemAcc Write
  22: VP: Call Write function with invalid address(too small)
  23: Call main function few times
  24: VP: Driver Write API is not called
  25: VP: Det reported correctly for MemAcc Write
  26: VP: Call Write function with NULL_PTR
  27: Call main function few times
  28: VP: Driver Write API is not called
  29: VP: Det reported correctly for MemAcc Write
  30: VP: Call Write function with unaligned start address
  31: Call main function few times
  32: VP: Driver Write API is not called
  33: VP: Det reported correctly for MemAcc Write
  34: VP: Call Write function with unaligned end address
  35: Call main function few times
  36: VP: Driver Write API is not called
  37: VP: Det reported correctly for MemAcc Write
  38: VP: Call Write function with valid params
      [MemAccConf_MemAccAddressAreaConfiguration_MemAccAddressAreaConfiguration_0 logical address 1408 length 2 bytes]
  39: VP: Call Write function again with valid params
  40: VP: Det reported correctly for MemAcc Write
  41: VP: Call Write function again with valid params for a different sub area
  42: VP: Det reported correctly for MemAcc Write
  43: VP: Driver Write API is called only for first write
  44: VP: Driver Write is called with length of page size (2)
  45: VP: Request is done successfully

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>MemAcc.Request.MultipleRequestsForSameAreaReturnCode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>MemAcc.Request.InvalidParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00049</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00050</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>MemAcc.SWS_MemAcc_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>638</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
