<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_FOCom_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/ReqM2_Native/asc_FOCom_requirements_FOCom.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/ReqM2_Native/asc_FOCom_requirements_TL_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/common_req/FOCom_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/ReqM2_OldCImporter/reqm_TCS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 22:04:33 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_FOCom_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/ReqM2_Native/asc_FOCom_requirements_FOCom.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/ReqM2_Native/asc_FOCom_requirements_TL_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/common_req/FOCom_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/ReqM2_OldCImporter/reqm_TCS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/2018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>feavc</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swpad</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swts</regex>
      <regex>pdoc</regex>       <!-- since 10/2018: introduced for updated tracing model-->
      <regex>dev</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swadvc</regex>     <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swuvc</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/2020: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>
      <regex>doc</regex>

      <!-- legacy items -->
      <regex>req</regex>        <!-- deprecated 10/2017: old swrs type -->
      <regex>dsn</regex>        <!-- deprecated 10/2017: old swdd -->
      <regex>src</regex>        <!-- deprecated 10/2017: old impl type -->
      <regex>tcs</regex>        <!-- deprecated 10/2017: replaced by swintts and swuts -->
      <regex>dsn_arch</regex>   <!-- deprecated 10/2017: old swad type -->
      <regex>man</regex>
      <regex>tso</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='req') and (../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.rejected</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.count</name>
      <description>Requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='req') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='req') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.req.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[((../@doctype='req') or (../@doctype='swrs')) and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dsn.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[((../@doctype='swdd') or (../@doctype='dsn')) and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.doctypes</name>
      <description>Requirements can be covered only by req, dsn_arch, dev, lim, dsn, src, tcs, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='req')]</applyto>
          <condition>(./needscoverage/needsobj="req" or ./needscoverage/needsobj="dsn_arch" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swad, dev, lim, swurs, swdd, src, swuts, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dsn.needscoverage.doctypes</name>
      <description>Design elements can only be covered by dsn, src, tcs, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dsn')]</applyto>
          <condition>(./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>
    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.tcs.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.src.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='src')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="tsc" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes") )</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="dsn_arch" or ./fulfilledby/ffbObj/ffbType="dsn_arch" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>



    <rule>
      <name>ERR.dsn_arch.needscoverage.doctypes</name>
      <description>Architectural design objects can only be covered by dsn_arch, dsn, src, tcs, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dsn_arch')]</applyto>
          <condition>(./needscoverage/needsobj="dsn_arch" or ./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, req, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
         </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.tcs.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>
  </rules>
    <oreqmRules>
          <rule>
            <name>WRN.tsc.needscoverage.count</name>
            <description>Violated if there are more than 10 tsc specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='tcs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='tsc'])) &gt; 10]/furtherinfo</applyto>
                    <regex>tsc.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.req.needscoverage.count</name>
            <description>Violated if there are more than 10 req specobjects covering one specobject and no appropriate information is provided in furtherinfo, refinement on req to req are excluded. Refinements of requirements Req to Req and Req to Fea are excluded from this rule since this is tracing on the same level. The justification in furtherinfo must contain the rule name.</description>
           <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(../@doctype != 'req') and (../@doctype != 'fea') and ((count(./needscoverage/needscov[needsobj='req']/coveredby/linkedfrom)) &gt; 10)]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='req'])) &gt; 10]/furtherinfo</applyto>
                    <regex>req.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
     </rule>

        <rule>
            <name>WRN.src.needscoverage.count</name>
            <description>Violated if there are more than 10 src specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='src']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.dsn.needscoverage.count</name>
            <description>Violated if there are more than 10 dsn specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='dsn']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.dsn_arch.needscoverage.count</name>
            <description>Violated if there are more than 10 dsn_arch specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='dsn_arch']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn_arch'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn_arch.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="swurs">

<!-- ========================= FOCom Interfaces Start =================================== -->

  <specobject>
    <id>FOCom.EB.ServiceDefinition.Init</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_Init
      Syntax: void FOCom_Init(const FOCom_ConfigType* ConfigPtr)
      Service ID [hex]: 0x01
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): ConfigPtr : Pointer to the FOCom module's configuration data.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service shall initialize internal data structures of the module.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.Deinit</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_DeInit
      Syntax: void FOCom_DeInit()
      Service ID [hex]: 0x02
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service shall put the module back into an uninitialized state.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.VersionInfo</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_GetVersionInfo
      Syntax: void FOCom_GetVersionInfo(Std_VersionInfoType* VersionInfoPtr)
      Service ID [hex]: 0x03
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None
      Parameters (inout): None
      Parameters (out): VersionInfoPtr : Pointer to where to store the version information of the module.
      Return value: None
      Description: This service shall return the version information of this module.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.Transmit</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_Transmit
      Syntax: Std_ReturnType FOCom_Transmit (
        PduIdType TxPduId,
        uint8 *BufferPtr,
        uint16 BufferSize
        )
      Service ID [hex]: 0x04
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non-reentrant for the same PduId.
      Parameters (in): TxPduId : Identification of the I-PDU to be transmitted.
                       BufferSize : Size of the buffer.
      Parameters (inout): BufferPtr : Pointer to the buffer provided by upper layer. The same buffer pointer shall be passed to the lower layer transmit call.
      Parameters (out):   None
      Return value: Std_ReturnType E_OK: Transmit request is accepted.
                    E_NOT_OK: Transmit request is not accepted.
      Description: This service shall request transmission of an I-PDU from upper layer (Safety RTE) to lower layer (FOCan).
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.001</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.TxConfirmation</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name:  FOCom_FOCanTxConfirmation
      Syntax:  void FOCom_FOCanTxConfirmation (
        PduIdType TxPduId,
        Std_ReturnType Result
        )
      Service ID [hex]: 0x05
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non-reentrant for the same PduId.
      Parameters (in): TxPduId : Identification of the I-PDU.
                       Result : Result of transmission. E_OK: I-PDU was transmitted successfully, else transmission failed
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service shall report the result of transmission result of the specified I-PDU and hand result over to the Safety RTE.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.001</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.TxConfirmationCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: &lt;FOComUser_CbkTxConfirmation&gt;
      Syntax: void &lt;FOComUser_CbkTxConfirmation&gt; (
        PduIdType TxPduId,
        Std_ReturnType Result
        )
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non-reentrant for the same PduId.
      Parameters (in): TxPduId : Identification of the I-PDU.
                       Result : Result of transmission. E_OK: I-PDU was transmitted successfully, else transmission failed
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service is called after an I-PDU has been transmitted via FOCan.
      Available via: Rte_Cbk.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.001</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.RxIndication</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_FOCanRxIndication
      Syntax: void FOCom_FOCanRxIndication (
        PduIdType RxPduId,
        uint8 *BufferPtr,
        uint16 BufferLength
        )
      Service ID [hex]: 0x06
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non-reentrant for the same PduId.
      Parameters (in): RxPduId : Identification of the I-PDU.
                       BufferLength : Length of the received I-PDU.
      Parameters (inout): BufferPtr  : Pointer to a buffer containing the received I-PDU.
      Parameters (out): None
      Return value: None
      Description: Receives I-PDU from lower layer, verify its correctness and hand it over to the upper layer.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.002</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.RxIndicationCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: &lt;FOComUser_CbkRxIndication&gt;
      Syntax: void &lt;FOComUser_CbkRxIndication&gt; (
        PduIdType PduId,
        uint8 *BufferPtr,
        uint16 BufferLength
        )
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non-reentrant for the same PduId.
      Parameters (in): PduId : Identification of the I-PDU.
                       BufferPtr : Pointer to the buffer holding the I-PDU data.
                       BufferLength : Length of the I-PDU.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service is called after an I-PDU has been received via FOCan.
      Available via: Rte_Cbk.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.002</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.Satellite_InstallSecOCKey</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_Satellite_InstallSecOCKey
      Syntax: void FOCom_Satellite_InstallSecOCKey ()
      Service ID [hex]: 0x07
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service shall hand over the SecOC secure key from the non fail operational to the fail operational partition.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.ReceiveSecOCKey</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_ReceiveSecOCKey
      Syntax: void FOCom_ReceiveSecOCKey ()
      Service ID [hex]: 0x08
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service shall copy the SecOC secure key from the satellite's data area to FOCom module's data area.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.FOCom_Satellite_MainFunction</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_Satellite_MainFunction
      Syntax: void FOCom_Satellite_MainFunction ()
      Service ID [hex]: 0x09
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service shall inquire the SOK-FM module for the current freshness value and, if changed, transfers it to the FOCom.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.ReceiveFreshnessValue</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_ReceiveFreshnessValue
      Syntax: void FOCom_ReceiveFreshnessValue (
        uint64 FreshnessValue
        )
      Service ID [hex]: 0x0A
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): FreshnessValue : Freshness value received from non fail operational partition.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service shall copy the received freshness value to to FOCom module's data area.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TestMain</srcid><srcstatus/><internalId>116</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ServiceDefinition.IsFreshnessValueOk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      Service name: FOCom_IsFreshnessValueOk
      Syntax: Std_ReturnType FOCom_IsFreshnessValueOk ()
      Service ID [hex]: 0x0B
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in): None.
      Parameters (inout): None
      Parameters (out): None
      Return value: Std_ReturnType E_OK: Freshness value calculation works as expected.
                    E_NOT_OK: Freshness value calculation does not works as expected.
      Description: This service shall tell the caller if the freshness value calculation works as expected.
      Available via: FOCom.h
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>12</internalId></specobject>

<!-- ========================= FOCom Interfaces End ===================================== -->

<!-- ================== FOCom Init/De-Init Functionality Start ========================== -->
  <specobject>
    <id>FOCom.EB.Init.InitInternalDataStructures</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Init() service shall initialize the FOCom module when it is called from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06001_Init_PartitionCall</srcid><srcstatus/><internalId>142</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Init.InvalidInitCall</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Init() service shall not initialize the FOCom module when it is called from a different partition than the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06001_Init_PartitionCall</srcid><srcstatus/><internalId>142</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Init.InvalidInitCall.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Init() service is called from a different partition than the configured fail operational partition and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06001_Init_PartitionCall</srcid><srcstatus/><internalId>142</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Init.InvalidInitCall.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Init() service is called from a different partition than the configured fail operational partition and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>16</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Deinit.DeinitInternalDataStructures</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Deinit() service shall de-initialize the FOCom module when it is called from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>17</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Deinit.InvalidDeinitcall</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Deinit() service shall not de-initialize the FOCom module when it is called from a different partition than the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>18</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Deinit.InvalidDeinitCall.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Deinit() service is called from a different partition than the configured fail operational partition and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>19</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Deinit.InvalidDeinitCall.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Deinit() service is called from a different partition than the configured fail operational partition and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>20</internalId></specobject>

  <specobject>
    <id>FOCom.EB.GetVersionInfo.ReturnVersionInfo</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Deinit() service shall return the version information of the FOCom module when it is called from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02006_GetVersionInfo</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_06005_VersionInfo_PartitionCall</srcid><srcstatus/><internalId>146</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

  <specobject>
    <id>FOCom.EB.GetVersionInfo.InvalidGetVersionInfoCall</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Deinit() service shall not return the version information of the FOCom module when it is called from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06005_VersionInfo_PartitionCall</srcid><srcstatus/><internalId>146</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

  <specobject>
    <id>FOCom.EB.GetVersionInfo.InvalidGetVersionInfo.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_GetVersionInfo() service is called from a different partition than the configured fail operational partition and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06005_VersionInfo_PartitionCall</srcid><srcstatus/><internalId>146</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

  <specobject>
    <id>FOCom.EB.GetVersionInfo.InvalidGetVersionInfo.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_GetVersionInfo() service is called from a different partition than the configured fail operational partition and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>24</internalId></specobject>

<!-- TODO
- To be refined correctly.
-->
  <specobject>
    <id>FOCom.EB.PublishedInformation</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom module shall publish the standardized common parameters within the header file of the module.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02007_PublishedInformation</srcid><srcstatus/><internalId>125</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

<!-- ================== FOCom Init/De-Init Functionality End ============================ -->

<!-- ================= FOCom Satellite Functionality Start =============================== -->

<!-- TODO
- CSM API to be added.
-->
  <specobject>
    <id>FOCom.EB.Satellite.GetSecureKey</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Satellite_InstallSecOCKey shall call the &lt;CSM API&gt; to get the secure key from CSM module.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.005</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Satellite.StoreSecureKey</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Satellite_InstallSecOCKey shall store the secure key received from CSM module in FOCom satellite module's data area.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.005</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Satellite.CallReceiveSecOCKey</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      After storing the secure key in its data area, FOCom_Satellite_InstallSecOCKey shall call SchM client/server API(synchronously)
      to the fail operational partition to invoke the FOCom_ReceiveSecOCKey() function.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.005</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Satellite.OverwriteArbitraryData</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Satellite_InstallSecOCKey shall overwrite the FOCom satellite module's data area with arbitrary data after the SchM client/server API call return.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.005</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

  <specobject>
    <id>FOCom.EB.ReceiveSecOCKey.CopySecureKey</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_ReceiveSecOCKey() is invoked, then the function shall copy the secure key from FOCom satellite's data area to FOCom module's data area.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.005</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Satellite.MainFunction.GetTxFreshness</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Satellite_MainFunction shall call the SecOC_GetTxFreshness() function to get the current freshness value.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.006</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Satellite.MainFunction.CallReceiveFreshnessValue</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the current freshness value is changed from its last invocation, FOCom_Satellite_MainFunction shall call
      SchM sender/receiver API to send the latest freshness value to the FOCom_ReceiveFreshnessValue() function.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.006</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Satellite.MainFunction.CopyFreshnessValue</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_ReceiveFreshnessValue() is invoked, function shall copy the received freshness value.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.006</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

<!-- ================= FOCom Satellite Functionality End   =============================== -->

<!-- ================= FOCom Transmit Functionality Start =============================== -->
  <specobject>
    <id>FOCom.EB.Transmit.ValidPartitionCall</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit() service shall perform the transmit operation for the outgoing I-PDU when it is called from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06002_Transmit_PartitionCall</srcid><srcstatus/><internalId>143</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InvalidPartitionCall</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit() service shall not perform any transmit operation for the outgoing I-PDU when it is called from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06002_Transmit_PartitionCall</srcid><srcstatus/><internalId>143</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InvalidPartitionCall.RetVal</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called from a different partition than the configured fail operational partition,
      then the service shall return E_NOT_OK to the caller.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06002_Transmit_PartitionCall</srcid><srcstatus/><internalId>143</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InvalidPartitionCall.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called from a different partition than the configured fail operational partition and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06002_Transmit_PartitionCall</srcid><srcstatus/><internalId>143</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InvalidPartitionCall.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called from a different partition than the configured fail operational partition and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>38</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidInitState</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit() service shall not perform any transmit operation for the outgoing I-PDU when FOCom module initialization status is not FOCOM_EB_INIT.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02003_Transmit_IPDU_InvalidInitState</srcid><srcstatus/><internalId>120</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidInitState.RetVal</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called when FOCom module initialization status is not FOCOM_EB_INIT,
      then the service shall return E_NOT_OK to the caller.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02003_Transmit_IPDU_InvalidInitState</srcid><srcstatus/><internalId>120</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidInitState.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called when FOCom module initialization status is not FOCOM_EB_INIT and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02003_Transmit_IPDU_InvalidInitState</srcid><srcstatus/><internalId>120</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidInitState.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called when FOCom module initialization status is not FOCOM_EB_INIT and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>42</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.ValidTxPduId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit() service shall perform the transmit operation for the outgoing I-PDU when it is called with a valid PDU ID.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02001_Transmit_AuthenticIPDU</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_02002_Transmit_SecureIPDU</srcid><srcstatus/><internalId>119</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidTxPduId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit() service shall not perform the transmit operation for the outgoing I-PDU when it is called with a invalid PDU ID.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02004_Transmit_IPDU_InvalidTxPduId</srcid><srcstatus/><internalId>121</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidTxPduId.RetVal</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called with a invalid PDU ID, then the service shall return E_NOT_OK to the caller.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02004_Transmit_IPDU_InvalidTxPduId</srcid><srcstatus/><internalId>121</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidTxPduId.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called with a invalid PDU ID and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02004_Transmit_IPDU_InvalidTxPduId</srcid><srcstatus/><internalId>121</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidTxPduId.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called with a invalid PDU ID and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>47</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.ValidBufferPtr</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit() service shall perform the transmit operation for the outgoing I-PDU when it is called with a valid buffer pointer.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02001_Transmit_AuthenticIPDU</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_02002_Transmit_SecureIPDU</srcid><srcstatus/><internalId>119</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidBufferPtr</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit() service shall perform the transmit operation for the outgoing I-PDU when it is called with a invalid buffer pointer.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02005_Transmit_IPDU_InvalidBufferPtr</srcid><srcstatus/><internalId>122</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidBufferPtr.RetVal</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called with a invalid buffer pointer, then the service shall return E_NOT_OK to the caller.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02005_Transmit_IPDU_InvalidBufferPtr</srcid><srcstatus/><internalId>122</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidBufferPtr.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called with a invalid buffer pointer and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02005_Transmit_IPDU_InvalidBufferPtr</srcid><srcstatus/><internalId>122</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.InValidBufferPtr.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_Transmit() service is called with a invalid buffer pointer and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>52</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.ValidInitState</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit() service shall perform the transmit operation for the outgoing I-PDU when FOCom module initialization status is FOCOM_EB_INIT.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02001_Transmit_AuthenticIPDU</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_02002_Transmit_SecureIPDU</srcid><srcstatus/><internalId>119</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit shall append the SecOC protocol information to the authentic I-PDU to be transmitted if the I-PDU is configured to be secured.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02002_Transmit_SecureIPDU</srcid><srcstatus/><internalId>119</internalId></linkedfrom></coveredby></needscov>
      <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</srcid><srcstatus/><internalId>55</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.GenerateMAC</srcid><srcstatus/><internalId>63</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.003</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit shall construct the secured I-PDU by concatenating the authentic I-PDU, freshness value (up to SecOCFreshnessValueTruncLength)
      and MAC (up to SecOCAuthInfoTruncLength) in the given order.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncMAC</srcid><srcstatus/><internalId>56</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncMAC.UseMSBBits</srcid><srcstatus/><internalId>57</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncFreshnessValue</srcid><srcstatus/><internalId>58</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncFreshnessValue.UseLSBBits</srcid><srcstatus/><internalId>59</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.MACByteOrder</srcid><srcstatus/><internalId>60</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.FreshnessValueByteOrder</srcid><srcstatus/><internalId>61</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.ExcludeFreshnessValue</srcid><srcstatus/><internalId>62</internalId></linkedfrom></coveredby></needscov>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncMAC</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit shall truncate the MAC down to the number of bits specified by configuration parameter SecOCAuthInfoTruncLength.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncMAC.UseMSBBits</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      While using SecOCAuthInfoTruncLength length, FOCom_Transmit shall truncate down to the most significant bits
      of the resulting MAC generated by the authentication algorithm.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncFreshnessValue</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the configured parameter SecOCFreshnessValueTruncLength value is less than the configured SecOCFreshnessValueLength value,
      then FOCom_Transmit shall truncate the freshness value down to the number of bits specified by configuration parameter SecOCFreshnessValueTruncLength.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncFreshnessValue.UseLSBBits</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      While using SecOCFreshnessValueTruncLength length, FOCom_Transmit shall truncate down to the least significant bits
      of the SecOCFreshnessValueLength.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.MACByteOrder</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit shall encode the MAC which is transmitted in big endian byte order.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.FreshnessValueByteOrder</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit shall encode the freshness value which is transmitted in big endian byte order.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.ExcludeFreshnessValue</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the configuration parameter SecOCFreshnessValueTruncLength is configured to 0, then freshness value shall not be included in construction of the secured I-PDU.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.GenerateMAC</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the authentic I-PDU to be transmitted is configured to be secured, then FOCom_Transmit shall call FOCrypto_CalcMAC() for MAC generation.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>137</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.Transmit.SecuredIpdu</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

<!-- TODO
- requirement about passed parameters to use for calling FOCrypto_CalcMAC.
-->

  <specobject>
    <id>FOCom.EB.Transmit.AuthenticIpdu</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the authentic I-PDU to be transmitted is not configured to be secured,
      then FOCom_Transmit shall route the authentic I-PDU to the lower layer FOCan without adding any SecOC protocol information.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02001_Transmit_AuthenticIPDU</srcid><srcstatus/><internalId>117</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.003</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

  <specobject>
    <id>FOCom.EB.Transmit.CallCanTransmit</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_Transmit shall call FOCan_Transmit() to transfer the I-PDU.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02001_Transmit_AuthenticIPDU</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_02002_Transmit_SecureIPDU</srcid><srcstatus/><internalId>119</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.001</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

<!-- TODO
- requirement about passed parameters to use for calling FOCan_Transmit.
-->

<!-- ================= FOCom Transmit Functionality End ================================= -->

<!-- ==================FOCom Tx Confirmation Start ====================================== -->

  <specobject>
    <id>FOCom.EB.TxConfirmation.CallCbk</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanTxConfirmation function shall call the corresponding &lt;FOComUser_FOComCbkTxConfirmation&gt;() and pass the parameters
      it received from lower layer module FOCan when it is called with valid parameters and from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>swurs</needsobj><objcovstatus>partially</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.TxConfirmation.InvalidPartitionCall</srcid><srcstatus/><internalId>67</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InvalidPartitionCall.CallUserCallback</srcid><srcstatus>source not covered.</srcstatus><internalId>69</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.ValidInitState</srcid><srcstatus/><internalId>70</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidInitState</srcid><srcstatus/><internalId>71</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidInitState.CallDET</srcid><srcstatus/><internalId>72</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidInitState.CallUserCallback</srcid><srcstatus>source not covered.</srcstatus><internalId>73</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.ValidPduId</srcid><srcstatus/><internalId>74</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidPduId</srcid><srcstatus/><internalId>75</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidPduId.CallDET</srcid><srcstatus/><internalId>76</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidPduId.CallUserCallback</srcid><srcstatus>source not covered.</srcstatus><internalId>77</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidFnPtr</srcid><srcstatus/><internalId>78</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidFnPtr.CallDET</srcid><srcstatus/><internalId>79</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.TxConfirmation.InValidFnPtr.CallUserCallback</srcid><srcstatus>source not covered.</srcstatus><internalId>80</internalId></linkedfrom></coveredby></needscov>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02008_TxConfirmation_InvokeUserCallback</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_06003_TxConfirmation_PartitionCall</srcid><srcstatus/><internalId>144</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>partially</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.007</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linkerror</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror>source not covered.</linkerror><internalId>111</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>partially</covstatus><internalId>66</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InvalidPartitionCall</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanTxConfirmation function shall not call the corresponding &lt;FOComUser_FOComCbkTxConfirmation&gt;() and pass the parameters
      it received from lower layer module FOCan when it is called from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.TxConfirmation.InvalidPartitionCall.CallDET</srcid><srcstatus/><internalId>68</internalId></linkedfrom></coveredby></needscov>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06003_TxConfirmation_PartitionCall</srcid><srcstatus/><internalId>144</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InvalidPartitionCall.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanTxConfirmation() service is called from a different partition than the configured fail operational partition and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06003_TxConfirmation_PartitionCall</srcid><srcstatus/><internalId>144</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.InvalidPartitionCall</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InvalidPartitionCall.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanTxConfirmation() service is called from a different partition than the configured fail operational partition and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linkerror</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror>source not covered.</linkerror><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>69</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.ValidInitState</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanTxConfirmation function shall call the corresponding &lt;FOComUser_FOComCbkTxConfirmation&gt;() when FOCom module's
      initialization status is FOCOM_EB_INIT.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02008_TxConfirmation_InvokeUserCallback</srcid><srcstatus/><internalId>126</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidInitState</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanTxConfirmation function shall not call the corresponding &lt;FOComUser_FOComCbkTxConfirmation&gt;() when FOCom module's
      initialization status is not FOCOM_EB_INIT.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02011_TxConfirmation_InValidInitState</srcid><srcstatus/><internalId>129</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidInitState.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanTxConfirmation() service is called when FOCom module's initialization status is not FOCOM_EB_INIT and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02011_TxConfirmation_InValidInitState</srcid><srcstatus/><internalId>129</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidInitState.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanTxConfirmation() service is called when FOCom module's initialization status is not FOCOM_EB_INIT and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linkerror</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror>source not covered.</linkerror><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>73</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.ValidPduId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanTxConfirmation function shall call the corresponding &lt;FOComUser_FOComCbkTxConfirmation&gt;() when it is called with a valid PDU ID.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02008_TxConfirmation_InvokeUserCallback</srcid><srcstatus/><internalId>126</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidPduId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanTxConfirmation function shall not call the corresponding &lt;FOComUser_FOComCbkTxConfirmation&gt;() when it is called with a invalid PDU ID.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02009_TxConfirmation_InValidTxPduId</srcid><srcstatus/><internalId>127</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidPduId.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanTxConfirmation() service is called when it is called with a invalid PDU ID and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02009_TxConfirmation_InValidTxPduId</srcid><srcstatus/><internalId>127</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidPduId.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanTxConfirmation() service is called when it is called with a invalid PDU ID and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linkerror</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror>source not covered.</linkerror><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>77</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidFnPtr</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanTxConfirmation function shall not call the corresponding &lt;FOComUser_FOComCbkTxConfirmation&gt;() if the corresponding function callback pointer is invalid.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02010_TxConfirmation_InValidFnPtr</srcid><srcstatus/><internalId>128</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidFnPtr.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanTxConfirmation() service is called when the corresponding function callback pointer is invalid and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_02010_TxConfirmation_InValidFnPtr</srcid><srcstatus/><internalId>128</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.InValidFnPtr.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanTxConfirmation() service is called when the corresponding function callback pointer is invalid and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linkerror</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror>source not covered.</linkerror><internalId>66</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>80</internalId></specobject>

  <specobject>
    <id>FOCom.EB.TxConfirmation.ValidPuduId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanTxConfirmation function shall call the corresponding &lt;FOComUser_FOComCbkTxConfirmation&gt;() when it is called with a valid PDU ID.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>81</internalId></specobject>
<!-- ==================FOCom Tx Confirmation End ======================================== -->

<!-- ==================FOCom Receive Functionality Start================================= -->

  <specobject>
    <id>FOCom.EB.RxIndication.ValidPartitionCall</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanRxIndication service shall perform the receive operation for the incoming I-PDU when it is called from the same partition as the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06004_Receive_PartitionCall</srcid><srcstatus/><internalId>145</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.001</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InvalidPartitionCall</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanRxIndication service shall not perform the receive operation for the incoming I-PDU when it is called from a different partition than the configured
      fail operational partition.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06004_Receive_PartitionCall</srcid><srcstatus/><internalId>145</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InvalidPartitionCall.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanRxIndication() service is called from a different partition than the configured fail operational partition and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_06004_Receive_PartitionCall</srcid><srcstatus/><internalId>145</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InvalidPartitionCall.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanRxIndication() service is called from a different partition than the configured fail operational partition and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>85</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.ValidInitState</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanRxIndication service shall perform the receive operation for the incoming I-PDU when FOCOm module's initialization state is FOCOM_EB_INIT.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03001_Receive_AuthenticIPDU</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_03002_Receive_SecureIPDU</srcid><srcstatus/><internalId>131</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.001</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidInitState</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanRxIndication service shall not perform the receive operation for the incoming I-PDU when FOCOm module's initialization state is not FOCOM_EB_INIT.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03005_Receive_InvalidInitState</srcid><srcstatus/><internalId>134</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidInitState.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanRxIndication() service is called when FOCOm module's initialization state is not FOCOM_EB_INIT and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03005_Receive_InvalidInitState</srcid><srcstatus/><internalId>134</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidInitState.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanRxIndication() service is called when FOCOm module's initialization state is not FOCOM_EB_INIT and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>89</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.ValidRxPduId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanRxIndication service shall perform the receive operation for the incoming I-PDU when it is called with a valid PDU ID.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03001_Receive_AuthenticIPDU</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_03002_Receive_SecureIPDU</srcid><srcstatus/><internalId>131</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidRxPduId</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanRxIndication service shall not perform the receive operation for the incoming I-PDU when it is called with a invalid PDU ID.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03006_Receive_InvalidRxPduId</srcid><srcstatus/><internalId>135</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidRxPduId.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanRxIndication() service is called with a invalid PDU ID and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03006_Receive_InvalidRxPduId</srcid><srcstatus/><internalId>135</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidRxPduId.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanRxIndication() service is called with a invalid PDU ID and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>93</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.ValidBufferPtr</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanRxIndication() service shall perform the receive operation for the incoming I-PDU when it is called with a valid buffer pointer.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03001_Receive_AuthenticIPDU</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_03002_Receive_SecureIPDU</srcid><srcstatus/><internalId>131</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidBufferPtr</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_FOCanRxIndication() service shall not perform the receive operation for the incoming I-PDU when it is called with a invalid buffer pointer.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03007_Receive_InvalidRxDataBufferPtr</srcid><srcstatus/><internalId>136</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidBufferPtr.CallDET</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanRxIndication() service is called with a invalid buffer pointer and development error detection is enabled,
      then the service shall call Det_ReportError() to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03007_Receive_InvalidRxDataBufferPtr</srcid><srcstatus/><internalId>136</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.InValidBufferPtr.CallUserCallback</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When FOCom_FOCanRxIndication() service is called with a invalid buffer pointer and user defined error callback is enabled,
      then the service shall call the configured user defined callback function to report the error.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
    <containerCovstatus>uncovered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>97</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.AuthenticIpdu</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the received I-PDU is configured not to be secured, then FOCom_RxIndication function shall call the corresponding &lt;FOComUser_FOComCbkRxIndication&gt; function
      without performing any SecOC protocol verification.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03001_Receive_AuthenticIPDU</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_03002_Receive_SecureIPDU</srcid><srcstatus/><internalId>131</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.004</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.SecuredIpdu.VerifyFV</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_RxIndication function shall verify the freshness value of the received I-PDU by comparing it against the current freshness value.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03003_Receive_Invalid_FreshnessValue</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_03003_Receive_Invalid_TruncFreshnessValue</srcid><srcstatus/><internalId>140</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.004</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.SecuredIpdu.VerifyFV.TruncBits</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the configured parameter SecOCFreshnessValueTruncLength value is less than the configured SecOCFreshnessValueLength value,
      then FOCom_RxIndication shall only verify the least significant number of bits specified by configuration parameter SecOCFreshnessValueTruncLength.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03003_Receive_Invalid_FreshnessValue</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_03003_Receive_Invalid_TruncFreshnessValue</srcid><srcstatus/><internalId>140</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.004</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      FOCom_RxIndication function shall verify the SecOC MAC of the received I-PDU by calling the function FOCrypto_CalcMAC() if required by the configuration.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03004_Receive_Invalid_MAC</srcid><srcstatus/><internalId>133</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.004</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

<!-- TODO
- requirement about passed parameters to use for calling FOCrypto_CalcMAC.
-->

<!-- TODO
- requirement about how to verify MAC.
-->

  <specobject>
    <id>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.FailedCheck</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the SecOC MAC verification of the received I-PDU fails, then the received I-PDU shall be discarded.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03004_Receive_Invalid_MAC</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_03004_Receive_Invalid_TruncMAC</srcid><srcstatus/><internalId>141</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.004</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

<!-- TODO
- requirement about error counter and how to pass it to upper layer.
-->

  <specobject>
    <id>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.PassedCheck</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      If the SecOC MAC verification of the received I-PDU succeed, then FOCom_RxIndication function shall call the corresponding &lt;FOComUser_FOComCbkRxIndication&gt; function.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03002_Receive_SecureIPDU_TruncFvAndMac</srcid><srcstatus/><internalId>139</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.002</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      <provcov>
        <linksto>FOCom.top.004</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

  <specobject>
    <id>FOCom.EB.RxIndication.CallCbk.PassedParameters</id>
    <status>approved</status>
    <source>EB</source>
    <version>1</version>
    <description>
      When calling the corresponding &lt;FOComUser_FOComCbkRxIndication&gt;() function, FOCom_RxIndication function shall pass the parameters it received from lower layer.
    </description>
    <comment>
    </comment>
    <needscoverage>
      <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCOM_CON_03001_Receive_AuthenticIPDU</srcid><srcstatus/><internalId>130</internalId></linkedfrom><linkedfrom><srcid>TS_FOCOM_CON_03002_Receive_SecureIPDU</srcid><srcstatus/><internalId>131</internalId></linkedfrom></coveredby></needscov>
    <containerCovstatus>covered</containerCovstatus></needscoverage>
    <providescoverage>
      <provcov>
        <linksto>FOCom.top.002</linksto>
        <dstversion>1</dstversion>
      <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
    </providescoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

<!-- ==================FOCom Receive Functionality End ================================== -->

</specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>FOCom.top.001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The FOCom module shall transmit fixed size I-PDU from upper layer Safety RTE to lower layer FOCan.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.ServiceDefinition.Transmit</srcid><srcstatus/><internalId>3</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.ServiceDefinition.TxConfirmation</srcid><srcstatus/><internalId>4</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.ServiceDefinition.TxConfirmationCallback</srcid><srcstatus/><internalId>5</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.CallCanTransmit</srcid><srcstatus/><internalId>65</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.ValidPartitionCall</srcid><srcstatus/><internalId>82</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.ValidInitState</srcid><srcstatus/><internalId>86</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>FOCom.top.002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The FOCom module shall receive fixed size I-PDU from lower layer FOCan to upper layer Safety RTE.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.ServiceDefinition.RxIndication</srcid><srcstatus/><internalId>6</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.ServiceDefinition.RxIndicationCallback</srcid><srcstatus/><internalId>7</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.PassedCheck</srcid><srcstatus/><internalId>103</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.CallCbk.PassedParameters</srcid><srcstatus/><internalId>104</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

    <specobject>
      <id>FOCom.top.003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The FOCom module shall append SecOC protocol information to an I-PDU to be transmitted if required by the configuration.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.Transmit.SecuredIpdu</srcid><srcstatus/><internalId>54</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Transmit.AuthenticIpdu</srcid><srcstatus/><internalId>64</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>FOCom.top.004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The FOCom module shall verify the SecOC protocol information from a received I-PDU if required by the configuration.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.RxIndication.AuthenticIpdu</srcid><srcstatus/><internalId>98</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.SecuredIpdu.VerifyFV</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.SecuredIpdu.VerifyFV.TruncBits</srcid><srcstatus/><internalId>100</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.FailedCheck</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.PassedCheck</srcid><srcstatus/><internalId>103</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>FOCom.top.005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The FOCom module shall get the SecOC secure key from a non fail operational partition and store it securely in RAM.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.Satellite.GetSecureKey</srcid><srcstatus/><internalId>26</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Satellite.StoreSecureKey</srcid><srcstatus/><internalId>27</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Satellite.CallReceiveSecOCKey</srcid><srcstatus/><internalId>28</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Satellite.OverwriteArbitraryData</srcid><srcstatus/><internalId>29</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.ReceiveSecOCKey.CopySecureKey</srcid><srcstatus/><internalId>30</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>FOCom.top.006</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The FOCom module shall get the SecOC freshness value on ECU startup and every time it change from the freshness manager operating on a non fail operational partition.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.Satellite.MainFunction.GetTxFreshness</srcid><srcstatus/><internalId>31</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Satellite.MainFunction.CallReceiveFreshnessValue</srcid><srcstatus/><internalId>32</internalId></linkedfrom><linkedfrom><srcid>FOCom.EB.Satellite.MainFunction.CopyFreshnessValue</srcid><srcstatus/><internalId>33</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>FOCom.top.007</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The FOCom module shall indicate the upper layer (Safety RTE) once an I-PDU transmission confirmation is received from the lower layer (FOCan).
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby><linkedfrom><srcid>FOCom.EB.TxConfirmation.CallCbk</srcid><srcstatus>source not covered.</srcstatus><internalId>66</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>uncovered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>FOCom.top.008</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The FOCom module shall map the serialized signal group to be transmitted or received in a way that there is a 1:1 mapping to the transmitted or received I-PDU.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>uncovered</objcovstatus><coveredby/></needscov>
      <containerCovstatus>uncovered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>uncovered</covstatus><internalId>112</internalId></specobject>

  </specobjects>
    <specobjects doctype="req">

    <specobject>
      <id>FOCom.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_FOCom_VerifyCodeStub</srcid><srcstatus/><internalId>114</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_FOCom_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/build/reqm/common_req/FOCom_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(FOCom.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_FOCOM_COM_02_HandleIdGeneratorCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Compile/IN/FOCom_ComTest_02_HandleIdGeneratorCheck/source/application/Test.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test checks that running the handle ID wizard creates a valid configuration out of invalid
  IDs with respect to configuration parameters PduRSourcePduHandleId, PduRDestPduHandleId and
  PduRRoutingPathGroupId.
  The handle IDs are checked for being zero-based and dense for each adjacent ASR module by the
  generator.
  This test also verifies the correct generation of the symbolic name values.

Test Object: None.
Test Precondition: 
      Configured Tp and non-TP singlecast and multicast routing path from the same       source module.

Test Execution: 
    The C-code is not part of this test.
    The handle ID wizard is started by command line via the Merged_Makefile.mak.
    The module configuration generator generates file PduR_SymbolicNames_PBcfg.h
    which is compared to the reference.

Test Input: 
     Usage of a common ASR configuration having all adjacent ASR modules configured.
     Configuration holds wrongly assigned handle IDs (non zero-based or non-dense or non-unique)
     and group IDs. Here, all are set to -1.

Test Output: None.&lt;/pre&gt;</description>
    <violations><ruleid>ERR.tcs.providescoverage.doctypes</ruleid></violations><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TestMain</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Compile/IN/FOCom_Compile_VerifyStubs/source/application/Application.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies all FOCom module APIs.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation of FOCom using configuration specified in test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.Init</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.Deinit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.VersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>2</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.TxConfirmationCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.RxIndicationCallback</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.Satellite_InstallSecOCKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.ReceiveSecOCKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.FOCom_Satellite_MainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ServiceDefinition.ReceiveFreshnessValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_FOCOM_CON_02001_Transmit_AuthenticIPDU</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>138</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies the FOCom support for transmitting an Authentic I-PDU.

  Requirement verification scenario:
  [FOCom.EB.Transmit.ValidInitState]
  This test verifies that the I-PDU is only transferred to lower layer when the module is in a valid initialized state.
  
  [FOCom.EB.Transmit.ValidTxPduId]
  This test verifies that the I-PDU is only transferred to lower layer when FOCom_Transmit() is called with a valid Tx PDU ID.

  [FOCom.EB.Transmit.ValidBufferPtr]
  This test verifies that the I-PDU is only transferred to lower layer when FOCom_Transmit() is called with a valid data buffer pointer.

  [FOCom.EB.Transmit.AuthenticIpdu]
  This test verifies that in case of authentic I-PDU transfer no SecOC related information is appended with the payload.

  [FOCom.EB.Transmit.CallCanTransmit]
  This test verifies that in case of authentic I-PDU transfer the lower layer API is called by FOCom_Transmit(). 
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 
  FOCom module is initialized.
  FOCom module configuration contains at-least 1 authentic I-PDU for transmission and is used in test.

Test Execution: 
  00: Reset all global variables and flush the trace buffer.
  01: Initialize FOCom module with a valid configuration.
  02: VP: (FOCom.EB.Transmit.ValidInitState)
          Verify that FOCom module state is FOCOM_EB_INIT.
          It is implicitly verified that only in FOCOM_EB_INIT state the PDU is routed successfully
          by verifying the return value of FOCom_Transmit() call in Step 04.
  03: Call FOCom_Transmit() with valid TxPduId, valid PDU data buffer pointer and PDU length.
  04: VP: (FOCom.EB.Transmit.ValidTxPduId)
          (FOCom.EB.Transmit.ValidBufferPtr)
          FOCom_Transmit() is called successfully with return value E_OK. It is implicitly verified that FOCom_Transmit()
          is called with a valid Tx PDU ID and valid data buffer pointer with the return value E_OK.
  05: VP: (FOCom.EB.Transmit.AuthenticIpdu)
          (FOCom.EB.Transmit.CallCanTransmit)
          FOCan_Transmit() is called with converted TxPduId,
          the same pointer to buffer(as passed with FOCom_Transmit call) and the same buffer length.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Transmit.ValidInitState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.ValidTxPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.ValidBufferPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.AuthenticIpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.CallCanTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02012_Transmit_SecureIPDU_NoFVReceived</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>230</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that the FOCom_transmit call is rejected if it is invoked before receiving a valid
  freshness value for the freshness value instance to which the tx pdu belongs.
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 
  FOCom module is initialized.
  No FV is received from non-FO partition.
  FOCom module configuration contains at-least 1 secured I-PDU for transmission and is used in test.
  

Test Execution: 
  01: Initialize FOCom module with a valid configuration.
  03: Call FOCom_Transmit() with valid TxPduId, valid Pdu data buffer pointer and Pdu length.
  04: VP: FOCom_Transmit() is called rejected.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
    <violations><ruleid>ERR.tcs.providescoverage.doctypes</ruleid></violations><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02002_Transmit_SecureIPDU</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>284</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies the FOCom support for transmitting a secured I-PDU.
  Requirement verification scenario:
  [FOCom.EB.Transmit.ValidInitState]
  This test verifies that the I-PDU is only transferred to lower layer when the module is in a valid initialized state.
  
  [FOCom.EB.Transmit.ValidTxPduId]
  This test verifies that the I-PDU is only transferred to lower layer when FOCom_Transmit() is called with a valid Tx PDU ID.

  [FOCom.EB.Transmit.ValidBufferPtr]
  This test verifies that the I-PDU is only transferred to lower layer when FOCom_Transmit() is called with a valid data buffer pointer.

  [FOCom.EB.Transmit.SecuredIpdu]
  This test verifies that in case of secured I-PDU transfer, SecOC related information as per configuration is appended to the payload.

  [FOCom.EB.Transmit.CallCanTransmit]
  This test verifies that in case of secured I-PDU transfer the lower layer API is called by FOCom_Transmit().
&lt;/para&gt;
&lt;para&gt;
  This test is permuted to the following scenarios:
  Permutation                                                      p0    p1    p2    p3
  Freshness Value Length(both complete and truncated FV in bits)   1     64    44    40
  Truncated Authenticator Length(in bits)                          1     64    27    24
  Secure Header Length(in bytes)                                   0     4     1     2
  Authentic I-PDU length(in bytes)                                 1     44    23    24
  Secured I-PDU length(in bytes)                                   2     64    33    34
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 
  FOCom module is initialized.
  A valid freshness value is available for transmit usage.
  A valid session(security) key is available for transmit usage.
  FOCom module configuration contains at-least 1 secured I-PDU for transmission and is used in test.
  

Test Execution: 
  00: Flush the trace buffer, call FOCom_Satellite_MainFunction()
  to get a valid freshness value and call FOCom_Satellite_InstallSecOCKey() to get a valid session key.
  01: Initialize FOCom module with a valid configuration.
  02: VP: (FOCom.EB.Transmit.ValidInitState)
          Verify that FOCom module state is FOCOM_EB_INIT.
          It is implicitly verified that only in FOCOM_EB_INIT state the PDU is routed successfully
          by verifying the return value of FOCom_Transmit() call in Step 04.
  03: Call FOCom_Transmit() with valid TxPduId, valid Pdu data buffer pointer and Pdu length.
  04: VP: (FOCom.EB.Transmit.ValidTxPduId)
          (FOCom.EB.Transmit.ValidBufferPtr)
          FOCom_Transmit() is called successfully with return value E_OK. It is implicitly verified that FOCom_Transmit()
          is called with a valid Tx PDU ID and valid data buffer pointer with the return value.
  05: VP: (FOCom.EB.Transmit.SecuredIpdu)
          (FOCom.EB.Transmit.CallCanTransmit)
          FOCan_Transmit() is called with converted TxPduId and the passed buffer contains
          the correct authentication information.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Transmit.ValidInitState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.ValidTxPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.ValidBufferPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.CallCanTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02003_Transmit_IPDU_InvalidInitState</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>402</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_Transmit() rejects the transmit call when FOCom module is not in valid state.

  Requirement verification scenario:
  [FOCom.EB.Transmit.InValidInitState]
  This test verifies that the I-PDU transmit call is rejected when the module is in a invalid state.
  
  [FOCom.EB.Transmit.InValidInitState.RetVal]
  This test verifies that the I-PDU transmit call return E_NOT_OK when the module is in a invalid state.

  [FOCom.EB.Transmit.InValidInitState.CallDET]
  This test verifies that the I-PDU transmit call invokes DET(if enabled )when the module is in a invalid state.

  [FOCom.EB.Transmit.InValidInitState.CallUserCallback]
  This test verifies that the I-PDU transmit call invokes user configured callback function(if enabled )when the module is in a invalid state.
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 
  FOCom module is not initialized.
  FOCom module configuration contains at-least 1 I-PDU for transmission and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Flush the trace buffer and set the module init status to FOCOM_EB_UNINIT.
  01: Call FOCom_Transmit() with valid TxPduId, valid PDU data buffer pointer and PDU length.
  02: VP: (FOCom.EB.Transmit.InValidInitState.RetVal)
          FOCom_Transmit() call returns value E_NOT_OK.
  03: VP: (FOCom.EB.Transmit.InValidInitState.CallDET)
          (FOCom.EB.Transmit.InValidInitState.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  04: VP: (FOCom.EB.Transmit.InValidInitState)
           It is verified that in uninitialized state the PDU is not routed.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidInitState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidInitState.RetVal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidInitState.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02004_Transmit_IPDU_InvalidTxPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>482</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_Transmit() rejects the transmit call when it is called with a invalid(out of range) Tx PDU ID.

  Requirement verification scenario:
  [FOCom.EB.Transmit.InValidTxPduId]
  This test verifies that the I-PDU transmit call is rejected when it is called with a invalid(out of range) Tx PDU ID.
  
  [FOCom.EB.Transmit.InValidTxPduId.RetVal]
  This test verifies that the I-PDU transmit call return E_NOT_OK when it is called with a invalid(out of range) Tx PDU ID.

  [FOCom.EB.Transmit.InValidTxPduId.CallDET]
  This test verifies that the I-PDU transmit call invokes DET(if enabled )when it is called with a invalid(out of range) Tx PDU ID.

  [FOCom.EB.Transmit.InValidTxPduId.CallUserCallback]
  This test verifies that the I-PDU transmit call invokes user configured callback function(if enabled )when it is called with a invalid(out of range) Tx PDU ID.
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 
  FOCom module is not initialized.
  FOCom module configuration contains at-least 1 I-PDU for transmission and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Reset all global variables and flush the trace buffer.
  01: Initialize the FOCom module by calling FOCom_Init().
  02: Call FOCom_Transmit() with invalid TxPduId, valid PDU data buffer pointer and PDU length.
  03: VP: (FOCom.EB.Transmit.InValidTxPduId.RetVal)
          FOCom_Transmit() call returns value E_NOT_OK.
  04: VP: (FOCom.EB.Transmit.InValidTxPduId.CallDET)
          (FOCom.EB.Transmit.InValidTxPduId.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  05: VP: (FOCom.EB.Transmit.InValidInitState)
          It is verified that when called with invalid PDU ID, the PDU is not routed.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidTxPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidTxPduId.RetVal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidTxPduId.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02005_Transmit_IPDU_InvalidBufferPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>566</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_Transmit() rejects the transmit call when it is called with a invalid data buffer pointer.

  Requirement verification scenario:
  [FOCom.EB.Transmit.InValidBufferPtr]
  This test verifies that the I-PDU transmit call is rejected when it is called with a invalid data buffer pointer.
  
  [FOCom.EB.Transmit.InValidBufferPtr.RetVal]
  This test verifies that the I-PDU transmit call return E_NOT_OK when it is called with a invalid data buffer pointer.

  [FOCom.EB.Transmit.InValidBufferPtr.CallDET]
  This test verifies that the I-PDU transmit call invokes DET(if enabled )when it is called with a invalid data buffer pointer.

  [FOCom.EB.Transmit.InValidBufferPtr.CallUserCallback]
  This test verifies that the I-PDU transmit call invokes user configured callback function(if enabled )when it is called with a invalid data buffer pointer.
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 
  FOCom module is not initialized.
  FOCom module configuration contains at-least 1 I-PDU for transmission and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Reset all global variables and flush the trace buffer.
  01: Initialize the FOCom module by calling FOCom_Init().
  02: Call FOCom_Transmit() with valid TxPduId, valid PDU data buffer pointer and PDU length.
  03: VP: (FOCom.EB.Transmit.InValidBufferPtr.RetVal)
          FOCom_Transmit() call returns value E_NOT_OK.
  04: VP: (FOCom.EB.Transmit.InValidBufferPtr.CallDET)
          (FOCom.EB.Transmit.InValidBufferPtr.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  05: VP: (FOCom.EB.Transmit.InValidBufferPtr)
          It is verified that when called with invalid data buffer pointer, the PDU is not routed.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidBufferPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidBufferPtr.RetVal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InValidBufferPtr.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02013_Transmit_IPDU_InvalidBufferSize</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>650</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_Transmit() rejects the transmit call when it is called with a invalid data buffer size.
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 
  FOCom module is not initialized.
  FOCom module configuration contains at-least 1 I-PDU for transmission and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Reset all global variables and flush the trace buffer.
  01: Initialize the FOCom module by calling FOCom_Init().
  02: Call FOCom_Transmit() with valid TxPduId, valid PDU data buffer pointer and invalid buffer size.
  03: VP: FOCom_Transmit() call returns value E_NOT_OK.
  04: VP: It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  05: VP: It is verified that when called with invalid data buffer pointer, the PDU is not routed.

Test Input: None.
Test Output: None.</description>
    <violations><ruleid>ERR.tcs.providescoverage.doctypes</ruleid></violations><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02006_GetVersionInfo</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>714</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the function FOCom_GetVersionInfo returns the version information
  of this module in the passed argument *versionInfo.
  The version information includes: Module Id, Vendor Id, Vendor specific version numbers.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
 - FOComVersionInfoApi is enabled
 - Macros FOCom_VENDOR_ID,.. are defined properly

Test Execution: 
  01: FOCom_GetVersionInfo() is called with valid versionInfo pointer
  02: VP: (FOCom.EB.GetVersionInfo.ReturnVersionInfo)
     FOCom_VENDOR_ID, FOCom_MODULE_ID, FOCom_SW_MAJOR_VERSION, FOCom_SW_MINOR_VERSION and FOCom_SW_PATCH_VERSION
     are returned by versionInfo.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.GetVersionInfo.ReturnVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02007_PublishedInformation</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>764</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test shall check the correct definition of the common published information
  provided in the module header file.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 
1. macro definition FOCom_VENDOR_ID
2. macro definition FOCom_MODULE_ID
3. macro definition FOCom_AR_RELEASE_MAJOR_VERSION
4. macro definition FOCom_AR_RELEASE_MINOR_VERSION
5. macro definition FOCom_AR_RELEASE_REVISION_VERSION
6. macro definition FOCom_SW_MAJOR_VERSION
7. macro definition FOCom_SW_MINOR_VERSION
8. macro definition FOCom_SW_PATCH_VERSION
9. macro definition FOCom_INSTANCE_ID

Test Output: 
Test Pass Criteria:
1. FOCom_VENDOR_ID shall be defined
   with the value globally provided by the tooling
   environment
2. FOCom_MODULE_ID shall be defined with 49
3. FOCom_AR_RELEASE_MAJOR_VERSION shall be defined
   with the value specified in config.mk
4. FOCom_AR_RELEASE_MINOR_VERSION shall be defined
   with the value specified in config.mk
5. FOCom_AR_RELEASE_REVISION_VERSION shall be defined
   with the value specified in config.mk
6. FOCom_SW_MAJOR_VERSION shall be defined
   with the value specified in config.mk
7. FOCom_SW_MINOR_VERSION shall be defined
    with the value specified in config.mk
8. FOCom_SW_PATCH_VERSION shall be defined
    with the value specified in config.mk
9. FOCom_INSTANCE_ID shall be defined with 0U
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.PublishedInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02008_TxConfirmation_InvokeUserCallback</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>866</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the user configured Tx confirmation callback function is called when FOCom_FOCanTxConfirmation() is called.

  Requirement verification scenario:
  [FOCom.EB.TxConfirmation.CallCbk]
&lt;/para&gt;

Test Object: 
  FOCom_FOCanTxConfirmation()

Test Precondition: 
  FOCom module is initialized.
  FOCom module configuration contains at-least 1 I-PDU for transmission and is used in test.

Test Execution: 
  01: VP: (FOCom.EB.TxConfirmation.ValidInitState)
      It is verified that the module is correct init state. It is implicitly verified that only in valid init state
      Tx confirmation call invoke the user callback function which is verified in step 03
  02: Call FOCom_FOCanTxConfirmation()
  03: VP: (FOCom.EB.TxConfirmation.CallCbk)
          (FOCom.EB.TxConfirmation.ValidPduId)
      FOCom_DummyCbkTxConfirmation callback is called. It is implicitly verified that only when FOCom_FOCanTxConfirmation() is called
      with a valid PDU ID then the user callback function is invoked.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.ValidInitState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.ValidPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02009_TxConfirmation_InValidTxPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>917</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_FOCanTxConfirmation() rejects the transmit confirmation call when it is called with a invalid(out of range) Tx PDU ID.

  Requirement verification scenario:
  [FOCom.EB.TxConfirmation.InValidPduId]
  This test verifies that the I-PDU transmit confirmation call is rejected when it is called with a invalid(out of range) Tx PDU ID.

  [FOCom.EB.TxConfirmation.InValidPduId.CallDET]
  This test verifies that the I-PDU transmit confirmation call invokes DET(if enabled )when it is called with a invalid(out of range) Tx PDU ID.

  [FOCom.EB.TxConfirmation.InValidPduId.CallUserCallback]
  This test verifies that the I-PDU transmit confirmation call invokes user configured callback function(if enabled )when it is called with a invalid(out of range) Tx PDU ID.
&lt;/para&gt;

Test Object: 
  FOCom_FOCanTxConfirmation()

Test Precondition: 
  FOCom module is initialized.
  FOCom module configuration contains at-least 1 I-PDU for transmission and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Reset the callback counter test variable.
  01: Call FOCom_FOCanTxConfirmation() with invalid TxPduId and a transmit status.
  02: VP: (FOCom.EB.TxConfirmation.InValidPduId.CallDET)
          (FOCom.EB.TxConfirmation.InValidPduId.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  03: VP: (FOCom.EB.TxConfirmation.InValidPduId)
           It is verified that in uninitialized state the Tx confirmation user callback is not called.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.InValidPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.InValidPduId.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02010_TxConfirmation_InValidFnPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>980</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_FOCanTxConfirmation() rejects the transmit confirmation call when the configured user callback function pointer is invalid.

  Requirement verification scenario:
  [FOCom.EB.TxConfirmation.InValidFnPtr]
  This test verifies that the I-PDU transmit confirmation call is rejected when the configured user callback function pointer is invalid.

  [FOCom.EB.TxConfirmation.InValidFnPtr.CallDET]
  This test verifies that the I-PDU transmit confirmation call invokes DET(if enabled )when the configured user callback function pointer is invalid.

  [FOCom.EB.TxConfirmation.InValidFnPtr.CallUserCallback]
  This test verifies that the I-PDU transmit confirmation call invokes user configured callback function(if enabled )when the configured user callback function pointer is invalid.
&lt;/para&gt;

Test Object: 
  FOCom_FOCanTxConfirmation()

Test Precondition: 
  FOCom module is initialized.
  FOCom module configuration contains at-least 1 I-PDU for transmission and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Reset the callback counter test variable.
  01: Call FOCom_FOCanTxConfirmation() with valid TxPduId and a transmit status.
  02: VP: (FOCom.EB.TxConfirmation.InValidFnPtr.CallDET)
          (FOCom.EB.TxConfirmation.InValidFnPtr.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  03: VP: (FOCom.EB.TxConfirmation.InValidFnPtr)
           It is verified that when user callback function pointer is invalid, Tx confirmation user callback is not called.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.InValidFnPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.InValidFnPtr.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_02011_TxConfirmation_InValidInitState</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_02_Transmit/source/application/EbTest.c</sourcefile>
      <sourceline>1043</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_FOCanTxConfirmation() rejects the transmit confirmation call when FOCom module is not in valid state.

  Requirement verification scenario:
  [FOCom.EB.TxConfirmation.InValidInitState]
  This test verifies that the I-PDU transmit confirmation call is rejected when the module is in a invalid state.

  [FOCom.EB.TxConfirmation.InValidInitState.CallDET]
  This test verifies that the I-PDU transmit confirmation call invokes DET(if enabled )when the module is in a invalid state.

  [FOCom.EB.TxConfirmation.InValidInitState.CallUserCallback]
  This test verifies that the I-PDU transmit confirmation call invokes user configured callback function(if enabled )when the module is in a invalid state.
&lt;/para&gt;

Test Object: 
  FOCom_FOCanTxConfirmation()

Test Precondition: 
  FOCom module is not initialized.
  FOCom module configuration contains at-least 1 I-PDU for transmission and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Reset the callback counter test variable and set the FOCom module initialization status to FOCOM_EB_UNINIT.
  01: Call FOCom_FOCanTxConfirmation() with valid TxPduId and a transmit status.
  02: VP: (FOCom.EB.TxConfirmation.InValidInitState.CallDET)
          (FOCom.EB.TxConfirmation.InValidInitState.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  03: VP: (FOCom.EB.TxConfirmation.InValidInitState)
           It is verified that in uninitialized state the Tx confirmation user callback is not called.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.InValidInitState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.InValidInitState.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_FOCOM_CON_03001_Receive_AuthenticIPDU</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_03_Receive/source/application/EbTest.c</sourcefile>
      <sourceline>155</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOCom_FOCanRxIndication() route a received authentic I-PDU from lower layer to upper layer.
  Requirement verification scenario:
  [FOCom.EB.RxIndication.ValidInitState]
  This test verifies that the I-PDU is only transferred to upper layer when the module is in a valid initialized state.
  
  [FOCom.EB.RxIndication.ValidRxPduId]
  This test verifies that the I-PDU is only transferred to upper layer when FOCom_FOCanRxIndication() is called with a valid Rx PDU ID.

  [FOCom.EB.RxIndication.ValidBufferPtr]
  This test verifies that the I-PDU is only transferred to upper layer when FOCom_FOCanRxIndication() is called with a valid data buffer pointer.

  [FOCom.EB.RxIndication.AuthenticIpdu]
  This test verifies that in case of authentic I-PDU transfer no SecOC related information is verified.

  [FOCom.EB.RxIndication.CallCbk.PassedParameters]
  This test verifies that in case of authentic I-PDU transfer, the upper layer function is called.
&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  The FOCom has been initialized.
  FOCom module configuration contains at-least 1 authentic I-PDU for reception and is used in test.

Test Execution: 
  01: Initialize FOCom module by calling FOCom_Init() function.
  02: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
  03: VP: (FOCom.EB.RxIndication.ValidInitState)
          (FOCom.EB.RxIndication.ValidRxPduId)
          (FOCom.EB.RxIndication.ValidBufferPtr)
          (FOCom.EB.RxIndication.AuthenticIpdu)
          (FOCom.EB.RxIndication.CallCbk.PassedParameters)
      RxIndication callback function FOCom_DummyCbkRxIndication() is called with converted PduId and
          the same pointer to buffer and same size. 
          It is implicitly verified that only when module is in a valid init state and when
          called with a valid Rx PDU ID and valid data buffer pointer then PDU is routed to upper layer.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.ValidInitState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.ValidRxPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.ValidBufferPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.AuthenticIpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.CallCbk.PassedParameters</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_03002_Receive_SecureIPDU</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_03_Receive/source/application/EbTest.c</sourcefile>
      <sourceline>231</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOCom_FOCanRxIndication() route a received secured I-PDU from lower layer to upper layer.
  Requirement verification scenario:
  [FOCom.EB.RxIndication.ValidInitState]
  This test verifies that the I-PDU is only transferred to upper layer when the module is in a valid initialized state.
  
  [FOCom.EB.RxIndication.ValidRxPduId]
  This test verifies that the I-PDU is only transferred to upper layer when FOCom_FOCanRxIndication() is called with a valid Rx PDU ID.

  [FOCom.EB.RxIndication.ValidBufferPtr]
  This test verifies that the I-PDU is only transferred to upper layer when FOCom_FOCanRxIndication() is called with a valid data buffer pointer.

  [FOCom.EB.RxIndication.CallCbk.PassedParameters]
  This test verifies that in case of secured I-PDU transfer, the upper layer function is called.
&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  The FOCom has been initialized.
  A valid freshness value is available for receive usage.
  A valid session(security) key is available for receive usage.
  FOCom module configuration contains at-least 1 secured I-PDU for reception and is used in test.

Test Execution: 
  01: Initialize FOCom module by calling FOCom_Init() function.
  02: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
  03: VP: (FOCom.EB.RxIndication.ValidInitState)
          (FOCom.EB.RxIndication.ValidRxPduId)
          (FOCom.EB.RxIndication.ValidBufferPtr)
          (FOCom.EB.RxIndication.CallCbk.PassedParameters)
      RxIndication callback function FOCom_DummyCbkRxIndication() is called with converted PduId and
          the same pointer to buffer and same size. 
          It is implicitly verified that only when module is in a valid init state and when
          called with a valid Rx PDU ID and valid data buffer pointer then PDU is routed to upper layer.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.ValidInitState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.ValidRxPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.ValidBufferPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.AuthenticIpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.CallCbk.PassedParameters</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_03003_Receive_Invalid_FreshnessValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_03_Receive/source/application/EbTest.c</sourcefile>
      <sourceline>320</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that when a secured I-PDU is received from the lower layer, then
  freshness value comparison shall be performed.
&lt;/para&gt;
&lt;para&gt;
  This test is permuted to the following scenarios:
  Permutation                                                      p0    p1    p2    p3
  Freshness Value Length(both complete and truncated FV in bits)   1     64    44    40
  Truncated Authenticator Length(in bits)                          1     64    27    24
  Secure Header Length(in bytes)                                   0     4     1     2
  Authentic I-PDU length(in bytes)                                 1     44    23    24
  Secured I-PDU length(in bytes)                                   2     64    33    34
&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  The FOCom has been initialized.
  A valid freshness value is available for receive usage.
  A valid session(security) key is available for receive usage.
  FOCom module configuration contains at-least 1 secured I-PDU for reception and is used in test.

Test Execution: 
  00: Reset stubs, flush the trace buffer and initialize FOCom module by calling FOCom_Init() function.
  01: Enable stub to create a freshness value error, install a secure key and get current freshness value. 
  02: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
  03: VP: (FOCom.EB.RxIndication.SecuredIpdu.VerifyFV)
          (FOCom.EB.RxIndication.SecuredIpdu.VerifyFV.TruncBits)
      It is verified that if freshness value check is failed then the PDU is discarded.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.SecuredIpdu.VerifyFV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.SecuredIpdu.VerifyFV.TruncBits</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_03004_Receive_Invalid_MAC</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_03_Receive/source/application/EbTest.c</sourcefile>
      <sourceline>393</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that when a secured I-PDU is received from the lower layer, then
  MAC comparison shall be performed.
&lt;/para&gt;
&lt;para&gt;
  This test is permuted to the following scenarios:
  Permutation                                                      p0    p1    p2    p3
  Freshness Value Length(both complete and truncated FV in bits)   1     64    44    40
  Truncated Authenticator Length(in bits)                          1     64    27    24
  Secure Header Length(in bytes)                                   0     4     1     2
  Authentic I-PDU length(in bytes)                                 1     44    23    24
  Secured I-PDU length(in bytes)                                   2     64    33    34
&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  The FOCom has been initialized.
  A valid freshness value is available for receive usage.
  A valid session(security) key is available for receive usage.
  FOCom module configuration contains at-least 1 secured I-PDU for reception and is used in test.

Test Execution: 
  00: Reset stubs, flush the trace buffer and initialize FOCom module by calling FOCom_Init() function.
  01: Enable stub to create a MAC error, install a secure key and get current freshness value. 
  02: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
  03: VP: (FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC)
          (FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.FailedCheck)
      It is verified that if MAC check is failed then the PDU is discarded.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.FailedCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_03005_Receive_InvalidInitState</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_03_Receive/source/application/EbTest.c</sourcefile>
      <sourceline>476</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_FOCanRxIndication() rejects the receive call when FOCom module is not in valid state.

  Requirement verification scenario:
  [FOCom.EB.RxIndication.InValidInitState]
  This test verifies that the I-PDU receive call is rejected when the module is in a invalid state.

  [FOCom.EB.RxIndication.InValidInitState.CallDET]
  This test verifies that the I-PDU receive call invokes DET(if enabled )when the module is in a invalid state.

  [FOCom.EB.RxIndication.InValidInitState.CallUserCallback]
  This test verifies that the I-PDU receive call invokes user configured callback function(if enabled )when the module is in a invalid state.
&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  FOCom module is not initialized.
  FOCom module configuration contains at-least 1 I-PDU for reception and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Flush the trace buffer and set the module init status to FOCOM_EB_UNINIT.
  01: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
  02: VP: (FOCom.EB.RxIndication.InValidInitState.CallDET)
          (FOCom.EB.RxIndication.InValidInitState.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  03: VP: (FOCom.EB.RxIndication.InValidInitState)
      It is verified that in invalid init state, then the PDU is discarded.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.InValidInitState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.InValidInitState.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_03006_Receive_InvalidRxPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_03_Receive/source/application/EbTest.c</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_FOCanRxIndication() rejects the receive call when it is called with a invalid Rx PDU ID.

  Requirement verification scenario:
  [FOCom.EB.RxIndication.InValidRxPduId]
  This test verifies that the I-PDU receive call is rejected when it is called with a invalid Rx PDU ID.

  [FOCom.EB.RxIndication.InValidRxPduId.CallDET]
  This test verifies that the I-PDU receive call invokes DET(if enabled )when it is called with a invalid Rx PDU ID.

  [FOCom.EB.RxIndication.InValidRxPduId.CallUserCallback]
  This test verifies that the I-PDU receive call invokes user configured callback function(if enabled )when it is called with a invalid Rx PDU ID.
&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  FOCom module is initialized.
  FOCom module configuration contains at-least 1 I-PDU for reception and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Reset the variables, flush the trace buffer and init the FOCom module.
  01: Call FOCom_FOCanRxIndication() with invalid Rx PduId and valid Pdu buffer pointer and size.
  02: VP: (FOCom.EB.RxIndication.InValidRxPduId.CallDET)
          (FOCom.EB.RxIndication.InValidRxPduId.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  03: VP: (FOCom.EB.RxIndication.InValidRxPduId)
      It is verified that in invalid init state, then the PDU is discarded.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.InValidRxPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.InValidRxPduId.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_03007_Receive_InvalidRxDataBufferPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_03_Receive/source/application/EbTest.c</sourcefile>
      <sourceline>611</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test case verifies that FOCom_FOCanRxIndication() rejects the receive call when it is called with a invalid Rx PDU data buffer pointer.

  Requirement verification scenario:
  [FOCom.EB.RxIndication.InValidBufferPtr]
  This test verifies that the I-PDU receive call is rejected when it is called with a invalid Rx PDU data buffer pointer.

  [FOCom.EB.RxIndication.InValidBufferPtr.CallDET]
  This test verifies that the I-PDU receive call invokes DET(if enabled )when it is called with a invalid Rx PDU data buffer pointer.

  [FOCom.EB.RxIndication.InValidBufferPtr.CallUserCallback]
  This test verifies that the I-PDU receive call invokes user configured callback function(if enabled )when it is called with a invalid Rx PDU data buffer pointer.
&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  FOCom module is initialized.
  FOCom module configuration contains at-least 1 I-PDU for reception and is used in test.
  DET and User error callback are enabled.

Test Execution: 
  00: Reset the variables, flush the trace buffer and init the FOCom module.
  01: Call FOCom_FOCanRxIndication() with valid Rx PduId and invalid Pdu buffer pointer and valid size.
  02: VP: (FOCom.EB.RxIndication.InValidBufferPtr.CallDET)
          (FOCom.EB.RxIndication.InValidBufferPtr.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  03: VP: (FOCom.EB.RxIndication.InValidBufferPtr)
      It is verified that in invalid init state, then the PDU is discarded.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.InValidBufferPtr</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.InValidBufferPtr.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_FOCOM_CON_04001_Transmit_SecureIPDU_TruncFvAndMac</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_04_Transmit_TruncFvAndMac/source/application/EbTest.c</sourcefile>
      <sourceline>194</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that for the transmission of secured I-PDU, only truncated parts of freshness value and MAC
  are used as per the configuration.
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 

Test Execution: 
  01: Call FOCom_Transmit() with valid TxPduId and valid PduInfo.
  02: VP: FOCan_Transmit() is called with converted TxPduId and
          the same pointer to buffer.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncMAC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncMAC.UseMSBBits</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncFreshnessValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.TruncFreshnessValue.UseLSBBits</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.MACByteOrder</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.FreshnessValueByteOrder</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.ExcludeFreshnessValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.SecuredIpdu.ConstructSecuredIpdu.GenerateMAC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Satellite.GetSecureKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Satellite.StoreSecureKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Satellite.CallReceiveSecOCKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Satellite.OverwriteArbitraryData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.ReceiveSecOCKey.CopySecureKey</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Satellite.MainFunction.GetTxFreshness</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Satellite.MainFunction.CallReceiveFreshnessValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Satellite.MainFunction.CopyFreshnessValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_04002_Satellite_FO_Mode</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_04_Transmit_TruncFvAndMac/source/application/EbTest.c</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that in FO mode the FOCom_Satellite_MainFunction does not transfer any freshness values to
  the FO partition.
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 

Test Execution: 
  01: Set FOMM Mode to FOMM_MODE_FAILOP_SWC_EXEC_PREPARE
  02: Call FOCom_Satellite_MainFunction(.
  03: VP: No further functions are called. Ensured by trace check.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
    <violations><ruleid>ERR.tcs.providescoverage.doctypes</ruleid></violations><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_FOCOM_CON_03002_Receive_SecureIPDU_TruncFvAndMac</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_05_Receive_TruncFvAndMac/source/application/EbTest.c</sourcefile>
      <sourceline>213</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOComUser_CbkRxIndication has been invoked when
  FOCom_FOCanRxIndication is called.

  This test verifies that the called FOComHandleId of FOCom_FOCanRxIndication
  is converted to the target upper layer module when calling FOComUser_CbkRxIndication.

  This test verifies that the I-PDU content is not modified by FOCom module.

&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  The FOCom has been initialized.

Test Execution: 
  00: Initialize FOCom module by calling FOCom_Init() function.
  01: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
  02: VP: RxIndication callback function FOCom_DummyCbkRxIndication() is called with converted PduId and
          the same pointer to buffer and same size.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.PassedCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_03003_Receive_Invalid_TruncFreshnessValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_05_Receive_TruncFvAndMac/source/application/EbTest.c</sourcefile>
      <sourceline>292</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOComUser_CbkRxIndication has been invoked when
  FOCom_FOCanRxIndication is called.

  This test verifies that the called FOComHandleId of FOCom_FOCanRxIndication
  is converted to the target upper layer module when calling FOComUser_CbkRxIndication.

  This test verifies that the I-PDU content is not modified by FOCom module.

&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  The FOCom has been initialized.

Test Execution: 
  00: Initialize FOCom module by calling FOCom_Init() function.
  01: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
  02: VP: RxIndication callback function FOCom_DummyCbkRxIndication() is called with converted PduId and
          the same pointer to buffer and same size.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.SecuredIpdu.VerifyFV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.SecuredIpdu.VerifyFV.TruncBits</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_03004_Receive_Invalid_TruncMAC</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_05_Receive_TruncFvAndMac/source/application/EbTest.c</sourcefile>
      <sourceline>360</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOComUser_CbkRxIndication has been invoked when
  FOCom_FOCanRxIndication is called.

  This test verifies that the called FOComHandleId of FOCom_FOCanRxIndication
  is converted to the target upper layer module when calling FOComUser_CbkRxIndication.

  This test verifies that the I-PDU content is not modified by FOCom module.

&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  The FOCom has been initialized.

Test Execution: 
  00: Initialize FOCom module by calling FOCom_Init() function.
  01: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
  02: VP: RxIndication callback function FOCom_DummyCbkRxIndication() is called with converted PduId and
          the same pointer to buffer and same size.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.SecuredIpdu.VerifyMAC.FailedCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_FOCOM_CON_06001_Init_PartitionCall</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_06_MultiPartition/source/application/EbTest.c</sourcefile>
      <sourceline>78</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOCom module is initialized with FOCom_Init() only when it is called from the configured FO partition.
  Requirement verification scenario:

  [FOCom.EB.Init.InitInternalDataStructures]
  This test verifies that the FOCom_Init call initializes the module to FOCOM_EB_INIT state when it is called from the configured FO partition.
  
  [FOCom.EB.Init.InvalidInitCall]
  This test verifies that the FOCom_Init call does not initializes the module to FOCOM_EB_INIT when it is called from a different partition.

  [FOCom.EB.Init.InvalidInitCall.CallDET]
  This test verifies that the FOCom_Init call from a different partition invokes DET(if enabled).

  [FOCom.EB.Init.InvalidInitCall.CallUserCallback]
  This test verifies that the FOCom_Init call from a different partition invokes user configured callback function(if enabled ).
&lt;/para&gt;
&lt;para&gt;
  This test is permuted to the following cases:
  p0 : Call to GetApplicationID() returns the same application ID as configured in module configuration.
  p1 : Call to GetApplicationID() returns a different application ID than configured in module configuration
&lt;/para&gt;

Test Object: 
  FOCom_Init()

Test Precondition: 

Test Execution: 
  01: Call FOCom_Init() with a valid configuration.
In case of p0:
  02: VP: (FOCom.EB.Init.InitInternalDataStructures)
      FOCom module init status is FOCOM_EB_INIT.
In case of P1:
  03 : VP: (FOCom.EB.Init.InvalidInitCall)
       FOCom module init status is FOCOM_EB_UNINIT.
  04 : VP: (FOCom.EB.Init.InvalidInitCall.CallDET)
           (FOCom.EB.Init.InvalidInitCall.CallUserCallback)
       It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Init.InitInternalDataStructures</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Init.InvalidInitCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Init.InvalidInitCall.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_06002_Transmit_PartitionCall</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_06_MultiPartition/source/application/EbTest.c</sourcefile>
      <sourceline>164</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOCan_Transmit functionality is only performed when it is called from the configured FO partition.

  Requirement verification scenario:
  [FOCom.EB.Transmit.ValidPartitionCall]
  This test verifies that the I-PDU transmit call performs the routing operation when it is called from the configured FO partition.
  
  [FOCom.EB.Transmit.InvalidPartitionCall]
  This test verifies that the I-PDU transmit call return E_NOT_OK when it is called from a different partition.

  [FOCom.EB.Transmit.InvalidPartitionCall.RetVal]
  This test verifies that the I-PDU transmit call invokes DET(if enabled )when it is called from a different partition.

  [FOCom.EB.Transmit.InvalidPartitionCall.CallDET]
  This test verifies that the I-PDU transmit call invokes user configured callback function(if enabled )when it is called from a different partition.

  [FOCom.EB.Transmit.InvalidPartitionCall.CallUserCallback]
  This test verifies that the I-PDU transmit call invokes user configured callback function(if enabled )when it is called from a different partition.
&lt;/para&gt;
&lt;para&gt;
  This test is permuted to the following cases:
  p0 : Call to GetApplicationID() returns the same application ID as configured in module configuration.
  p1 : Call to GetApplicationID() returns a different application ID than configured in module configuration
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 

Test Execution: 
  00: Flush the trace buffer.
  01: Initialize the FOCom module by calling FOCom_Init().
  02: Call FOCom_Transmit() with invalid TxPduId, valid PDU data buffer pointer and PDU length.
In case of p0:
  03: VP: (FOCom.EB.Transmit.ValidPartitionCall)
      FOCom_Transmit() performs the routing operation.
In case of p1:
  04: VP: (FOCom.EB.Transmit.InvalidPartitionCall.RetVal)
          FOCom_Transmit() call returns value E_NOT_OK.
  05: VP: (FOCom.EB.Transmit.InvalidPartitionCall.CallDET)
          (FOCom.EB.Transmit.InvalidPartitionCall.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  06: VP: (FOCom.EB.Transmit.InvalidPartitionCall)
          It is verified that the PDU is not routed.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.Transmit.ValidPartitionCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InvalidPartitionCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InvalidPartitionCall.RetVal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.Transmit.InvalidPartitionCall.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_06003_TxConfirmation_PartitionCall</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_06_MultiPartition/source/application/EbTest.c</sourcefile>
      <sourceline>285</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOCom_FOCanTxConfirmation() functionality is only performed when it is called from the configured FO partition.

  Requirement verification scenario:
  [FOCom.EB.TxConfirmation.CallCbk]
  This test verifies that the FOCom_FOCanTxConfirmation() call performs the routing confirmation operation when it is called from the configured FO partition.
  
  [FOCom.EB.TxConfirmation.InvalidPartitionCall]
  This test verifies that the FOCom_FOCanTxConfirmation() rejects the call when it is called from a different partition.

  [FOCom.EB.TxConfirmation.InvalidPartitionCall.CallDET]
  This test verifies that the FOCom_FOCanTxConfirmation() call invokes user configured callback function(if enabled )when it is called from a different partition.

  [FOCom.EB.TxConfirmation.InvalidPartitionCall.CallUserCallback]
  This test verifies that the FOCom_FOCanTxConfirmation() call invokes user configured callback function(if enabled )when it is called from a different partition.
&lt;/para&gt;
&lt;para&gt;
  This test is permuted to the following cases:
  p0 : Call to GetApplicationID() returns the same application ID as configured in module configuration.
  p1 : Call to GetApplicationID() returns a different application ID than configured in module configuration
&lt;/para&gt;

Test Object: 
  FOCom_FOCanTxConfirmation()

Test Precondition: 

Test Execution: 
  01: Initialize the FOCom module by calling FOCom_Init().
  02: Call FOCom_FOCanTxConfirmation() with invalid TxPduId and Tx status.
In case of p0:
  03: VP: (FOCom.EB.TxConfirmation.CallCbk)
      FOCom_FOCanTxConfirmation() invokes the user callback function.
In case of p1:
  04: VP: (FOCom.EB.TxConfirmation.InvalidPartitionCall.CallDET)
          (FOCom.EB.TxConfirmation.InvalidPartitionCall.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  05: VP: (FOCom.EB.TxConfirmation.InvalidPartitionCall)
          It is verified that FOCom_FOCanTxConfirmation() does not invoke the user callback function.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.CallCbk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.InvalidPartitionCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.TxConfirmation.InvalidPartitionCall.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_06004_Receive_PartitionCall</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_06_MultiPartition/source/application/EbTest.c</sourcefile>
      <sourceline>378</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOCom_FOCanRxIndication() functionality is only performed when it is called from the configured FO partition.

  Requirement verification scenario:
  [FOCom.EB.RxIndication.ValidPartitionCall]
  This test verifies that the FOCom_FOCanRxIndication() call performs the routing operation when it is called from the configured FO partition.
  
  [FOCom.EB.RxIndication.InvalidPartitionCall]
  This test verifies that the FOCom_FOCanRxIndication() rejects the call when it is called from a different partition.

  [FOCom.EB.RxIndication.InvalidPartitionCall.CallDET]
  This test verifies that the FOCom_FOCanRxIndication() call invokes user configured callback function(if enabled )when it is called from a different partition.

  [FOCom.EB.RxIndication.InvalidPartitionCall.CallUserCallback]
  This test verifies that the FOCom_FOCanRxIndication() call invokes user configured callback function(if enabled )when it is called from a different partition.
&lt;/para&gt;
&lt;para&gt;
  This test is permuted to the following cases:
  p0 : Call to GetApplicationID() returns the same application ID as configured in module configuration.
  p1 : Call to GetApplicationID() returns a different application ID than configured in module configuration
&lt;/para&gt;

Test Object: 
  FOCom_FOCanRxIndication()

Test Precondition: 
  The FOCom has been initialized.

Test Execution: 
  01: Initialize FOCom module by calling FOCom_Init() function.
  02: Call FOCom_FOCanRxIndication() with valid PduId and valid Pdu buffer pointer and size.
In case of p0:
  03: VP: (FOCom.EB.RxIndication.ValidPartitionCall)
      RxIndication callback function FOCom_DummyCbkRxIndication() is called with converted PduId and
          the same pointer to buffer and same size. 
In case of p1:
  04: VP: (FOCom.EB.RxIndication.InvalidPartitionCall.CallDET)
          (FOCom.EB.RxIndication.InvalidPartitionCall.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  05: VP: (FOCom.EB.RxIndication.InvalidPartitionCall)
          It is verified that FOCom_FOCanRxIndication() does not invoke the user callback function.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.RxIndication.ValidPartitionCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.InvalidPartitionCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.RxIndication.InvalidPartitionCall.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_06005_VersionInfo_PartitionCall</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_06_MultiPartition/source/application/EbTest.c</sourcefile>
      <sourceline>490</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that FOCom_GetVersionInfo() returns the module's version info when it is called from the configured FO partition.

  Requirement verification scenario:

  [FOCom.EB.GetVersionInfo.ReturnVersionInfo]
  This test verifies that the FOCom_GetVersionInfo() call returns the module's version info when it is called from the configured FO partition.
  
  [FOCom.EB.GetVersionInfo.InvalidGetVersionInfoCall]
  This test verifies that the FOCom_GetVersionInfo() rejects the call when it is called from a different partition.

  [FOCom.EB.GetVersionInfo.InvalidGetVersionInfo.CallDET]
  This test verifies that the FOCom_GetVersionInfo() call invokes user configured callback function(if enabled )when it is called from a different partition.

  [FOCom.EB.GetVersionInfo.InvalidGetVersionInfo.CallUserCallback]
  This test verifies that the FOCom_GetVersionInfo() call invokes user configured callback function(if enabled )when it is called from a different partition.
&lt;/para&gt;
&lt;para&gt;
  This test is permuted to the following cases:
  p0 : Call to GetApplicationID() returns the same application ID as configured in module configuration.
  p1 : Call to GetApplicationID() returns a different application ID than configured in module configuration
&lt;/para&gt;

Test Object: 
  FOCom_GetVersionInfo()

Test Precondition: 
  The FOCom has been initialized.

Test Execution: 
  01: FOCom_GetVersionInfo() is called with valid versionInfo pointer
In case of p0:
  02: VP: (FOCom.EB.GetVersionInfo.ReturnVersionInfo)
     FOCom_VENDOR_ID, FOCom_MODULE_ID, FOCom_SW_MAJOR_VERSION, FOCom_SW_MINOR_VERSION and FOCom_SW_PATCH_VERSION
     are returned by versionInfo.
In case of p1:
  03: VP: (FOCom.EB.GetVersionInfo.InvalidGetVersionInfo.CallDET)
          (FOCom.EB.GetVersionInfo.InvalidGetVersionInfo.CallUserCallback)
          It is verified that DET and user error call back is called with module ID, instance ID, service ID and error code.
  04: VP: (FOCom.EB.GetVersionInfo.InvalidGetVersionInfoCall)
          It is verified that FOCom_GetVersionInfo() does not return module version information.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>FOCom.EB.GetVersionInfo.ReturnVersionInfo</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.GetVersionInfo.InvalidGetVersionInfoCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>FOCom.EB.GetVersionInfo.InvalidGetVersionInfo.CallDET</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_FOCOM_CON_07001_Transmit_FVCalculation</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_07_FVM/source/application/EbTest.c</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
    <violations><ruleid>ERR.tcs.providescoverage.doctypes</ruleid></violations><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    <specobject>
      <id>TS_FOCOM_CON_07002_Receive_FVCalculation_IncrementOffset</id>
      <status>approved</status>
      <source>EB test case specification (asc_FOCom)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_FOCom/test/ts5/Conformance/IN/FOCom_ConTest_07_FVM/source/application/EbTest.c</sourcefile>
      <sourceline>172</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
&lt;/para&gt;

Test Object: 
  FOCom_Transmit()

Test Precondition: 

Test Execution: 

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
    <violations><ruleid>ERR.tcs.providescoverage.doctypes</ruleid></violations><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
