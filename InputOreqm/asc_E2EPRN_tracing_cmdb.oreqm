<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_E2EPRN_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2EPRN_requirements_AUTOSAR_SWS_E2ETransformer_PRN.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2EPRN_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2EPRN_requirements_TL_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2E_requirements_E2EXf_Pxx_AUTOSAR_SWS_E2ETransformer_PXX.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2E_requirements_TL_ProfilesGeneral_TL_Requirements_General.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/common_req/E2EPRN_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_OldCImporter/reqm_TCS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 22:14:53 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_E2EPRN_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2EPRN_requirements_AUTOSAR_SWS_E2ETransformer_PRN.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2EPRN_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2EPRN_requirements_TL_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2E_requirements_E2EXf_Pxx_AUTOSAR_SWS_E2ETransformer_PXX.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_Native/asc_E2E_requirements_TL_ProfilesGeneral_TL_Requirements_General.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/common_req/E2EPRN_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/ReqM2_OldCImporter/reqm_TCS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/2018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>feavc</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swpad</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swts</regex>
      <regex>pdoc</regex>       <!-- since 10/2018: introduced for updated tracing model-->
      <regex>dev</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swadvc</regex>     <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swuvc</regex>      <!-- since 10/2018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/2020: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>
      <regex>doc</regex>

      <!-- legacy items -->
      <regex>req</regex>        <!-- deprecated 10/2017: old swrs type -->
      <regex>dsn</regex>        <!-- deprecated 10/2017: old swdd -->
      <regex>src</regex>        <!-- deprecated 10/2017: old impl type -->
      <regex>tcs</regex>        <!-- deprecated 10/2017: replaced by swintts and swuts -->
      <regex>dsn_arch</regex>   <!-- deprecated 10/2017: old swad type -->
      <regex>man</regex>
      <regex>tso</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='req') and (../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.rejected</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.count</name>
      <description>Requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='req') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='req') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.req.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[((../@doctype='req') or (../@doctype='swrs')) and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dsn.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[((../@doctype='swdd') or (../@doctype='dsn')) and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.req.needscoverage.doctypes</name>
      <description>Requirements can be covered only by req, dsn_arch, dev, lim, dsn, src, tcs, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='req')]</applyto>
          <condition>(./needscoverage/needsobj="req" or ./needscoverage/needsobj="dsn_arch" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swad, dev, lim, swurs, swdd, src, swuts, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dsn.needscoverage.doctypes</name>
      <description>Design elements can only be covered by dsn, src, tcs, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dsn')]</applyto>
          <condition>(./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>
    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.tcs.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.src.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='src')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="tsc" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes") )</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="dsn_arch" or ./fulfilledby/ffbObj/ffbType="dsn_arch" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>



    <rule>
      <name>ERR.dsn_arch.needscoverage.doctypes</name>
      <description>Architectural design objects can only be covered by dsn_arch, dsn, src, tcs, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dsn_arch')]</applyto>
          <condition>(./needscoverage/needsobj="dsn_arch" or ./needscoverage/needsobj="dsn" or ./needscoverage/needsobj="src" or ./needscoverage/needsobj="tcs" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, req, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
         </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.tcs.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>
  </rules>
    <oreqmRules>
          <rule>
            <name>WRN.tsc.needscoverage.count</name>
            <description>Violated if there are more than 10 tsc specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='tcs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='tsc'])) &gt; 10]/furtherinfo</applyto>
                    <regex>tsc.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.req.needscoverage.count</name>
            <description>Violated if there are more than 10 req specobjects covering one specobject and no appropriate information is provided in furtherinfo, refinement on req to req are excluded. Refinements of requirements Req to Req and Req to Fea are excluded from this rule since this is tracing on the same level. The justification in furtherinfo must contain the rule name.</description>
           <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(../@doctype != 'req') and (../@doctype != 'fea') and ((count(./needscoverage/needscov[needsobj='req']/coveredby/linkedfrom)) &gt; 10)]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='req'])) &gt; 10]/furtherinfo</applyto>
                    <regex>req.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
     </rule>

        <rule>
            <name>WRN.src.needscoverage.count</name>
            <description>Violated if there are more than 10 src specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='src']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.dsn.needscoverage.count</name>
            <description>Violated if there are more than 10 dsn specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='dsn']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>

        <rule>
            <name>WRN.dsn_arch.needscoverage.count</name>
            <description>Violated if there are more than 10 dsn_arch specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='dsn_arch']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
            <regexchecks>
                <regexcheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='dsn_arch'])) &gt; 10]/furtherinfo</applyto>
                    <regex>dsn_arch.needscoverage.count</regex>
                </regexcheck>
            </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="req">

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00102.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        In-place E2EXf_&lt;transformerId&gt; shall perform the following two precondition
        checks, without continuing further processing:
         1.  (buffer == NULL)
             ||
             (buffer != NULL &amp;&amp; inputBufferLength  &lt;
              EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
         2.  bufferLength == NULL.
        If any of above conditions is TRUE, then the function shall return
        E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
      </description>
      <comment>
        Incorporated Bugzilla RfC 75163:
        Rewrite '(buffer == NULL &amp;&amp; inputBufferLength != 0)' to '(buffer == NULL)'
        in point 1, see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07001_IOValidParamCheck</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00106.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        Out-of-place E2EXf_&lt;transformerId&gt; shall perform the
        following three precondition checks, without continuing further processing:
         1.  (inputBuffer == NULL)
             ||
             (inputBuffer != NULL &amp;&amp; inputBufferLength  &lt;
             EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
         2.  bufferLength == NULL
         3.  buffer == NULL
        If any of above conditions is TRUE, then the function shall return
        E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
      </description>
      <comment>
        Incorporated Bugzilla RfC 75163:
        Rewrite '(inputBuffer == NULL &amp;&amp; inputBufferLength != 0)' to '(inputBuffer == NULL)'
        in point 1, see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08001_IOValidParamCheck</srcid><srcstatus/><internalId>265</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00108.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If (EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), in-place
        E2EXf_&lt;transformerId&gt; shall copy the amount upperHeaderBitsToShift bits,
        in parameter buffer, with starting offset of BufferProperties.headerLength, in
        direction left by 'distance' of BufferProperties.headerLength. (RS_E2E_08538)
      </description>
      <rationale>
       This requirement is not applicable for profile RN.
      </rationale>
      <comment>
        Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
        SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
        Incorporated Bugzilla RfC 75163:
        Rewrite '(buffer != NULL &amp;&amp; EndToEndTransformationDescription.upperHeaderBitsToShift
        &gt; 0)' to '(EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00109.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If (EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), out-of-place
        E2EXf_&lt;transformerId&gt; shall copy the first upperHeaderBitsToShift bits from
        inputBuffer to buffer, and then copy the remaining part of inputBuffer (i.e. starting
        with offset upperHeaderBitsToShift) to parameter buffer starting with the destination
        offset of (upperHeaderBitsToShift+ BufferProperties.headerLength). (RS_E2E_08538)
      </description>
      <rationale>
       This requirement is not applicable for profile RN.
      </rationale>
      <comment>
        Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
        SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
        Incorporated Bugzilla RfC 75163:
        Rewrite '(inputBuffer != NULL &amp;&amp;
        EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)' to
        '(EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00115.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), out-of-place
        E2EXf_&lt;transformerId&gt; shall copy inputBuffer to buffer starting with the
        destination offset of BufferProperties.headerLength. (RS_E2E_08538)
      </description>
      <comment>
        Incorporated Bugzilla RfC 75163:
        Rewrite '(inputBuffer != NULL &amp;&amp;
        EndToEndTransformationDescription.upperHeaderBitsToShift == 0)' to
        '(EndToEndTransformationDescription.upperHeaderBitsToShift == 0)',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08002_CopyUpperHeader</srcid><srcstatus/><internalId>266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00111.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        E2EXf_&lt;transformerId&gt; shall set
        *bufferLength = inputBufferLength + BufferProperties.headerLength/8.
        (RS_E2E_08538)
      </description>
      <comment>
        Incorporated RfC 69897 'Inconsequent usage of bits and bytes for
        BufferProperties.headerLength'.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07003_BufLength</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08003_BufLength</srcid><srcstatus/><internalId>267</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00111</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00139.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For PXX = RN, the function E2EXf_&lt;transformerId&gt;
        shall perform a check of the *bufferLength (after the computation of *bufferLength):
        If (*bufferLength != config-&gt;DataLength / 8), then the function shall return
        immediately E_SAFETY_HARD_RUNTIMEERROR, i.e. without calling an E2E Library function.
        (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07004_BufLengthCheck</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08004_BufLengthCheck</srcid><srcstatus/><internalId>268</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00139</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00107.PRN</id>
      <status>approved</status> <!-- draft in R22-11 -->
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>2</version>
      <description>
        If DataTransformationStatusForwarding is set to noTransformerStatusForwarding and
        PXX is P01 ,P02 ,P04 ,P05 ,P06 ,P07 ,P08 ,P11 ,P22 or P44,
        the function E2EXf_&lt;transformerId&gt;() shall invoke E2E_PXXProtect(),
        passing to that function the appropriate Config and State structures
        (see [SWS_E2EXf_00125] and [SWS_E2EXf_00126]) that are associated with
        &lt;transformerId&gt;, as well as buffer and bufferLength (only for P04, P05, P06, P07,
        P08 ,P11 ,P22 and P44) that were updated in above requirements SWS_E2EXf_00108,
        SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.(RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07005_InvokeProtect</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08005_InvokeProtect</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_13000_FWCodeStatusCheck</srcid><srcstatus/><internalId>292</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_14000_FWCodeStatusCheck</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00107</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00018.PRN</id>
      <status>approved</status> <!-- draft in R22-11 -->
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>2</version>
      <description>
        In case E2E_PXXProtect() or E2E_PXXForward() returns E2E_E_OK, then
        E2EXf_&lt;transformerId&gt; shall return E_OK, otherwise E2EXf_&lt;transformerId&gt;
        shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07006_RetValProtect</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08006_RetValProtect</srcid><srcstatus/><internalId>270</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00018</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00105.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        In-place E2EXf_Inv_&lt;transformerId&gt; shall perform the
        following two precondition checks, without continuing further processing:
          1.  (buffer == NULL &amp;&amp; inputBufferLength != 0)
              ||
              (buffer != NULL &amp;&amp; inputBufferLength &lt; BufferProperties.headerLength/8u
               + EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
          2.  bufferLength == NULL.
        If any of above conditions is TRUE, then the function shall return
        E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07101_IOValidParamCheck</srcid><srcstatus/><internalId>256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00103.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        Out-of-place E2EXf_Inv_&lt;transformerId&gt; shall perform the
        following three precondition checks, without continuing further processing:
         1.  (inputBuffer == NULL &amp;&amp; inputBufferLength != 0)
             ||
             (inputBuffer != NULL &amp;&amp; inputBufferLength &lt;
             BufferProperties.headerLength/8u +
             EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
         2.  If (bufferLength == NULL)
         3.  If (buffer == NULL).
        If any of above conditions is TRUE, then the function shall return
        E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08101_IOValidParamCheck</srcid><srcstatus/><internalId>272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00103</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00140.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>2</version>
      <description>
        For PXX = 01 or 02 (i.e. for profile 1 and 2), the out-of-place function
        E2EXf_Inv_&lt;transformerId&gt; shall
         1.  if(inputBuffer == NULL and inputBufferLength == 0), then
              -  variable NewDataAvailable of state object of type
                 E2E_PXXCheckStateType (see [SWS_E2EXf_00125]) associated with
                 &lt;transformerId&gt; shall be set to FALSE
         2.  else if (inputBufferLength == config-&gt;DataLength / 8), then
              -  variable NewDataAvailable of state object of type
                 E2E_PXXCheckState Type (see [SWS_E2EXf_00125]) associated with
                 &lt;transformerId&gt; shall be set to TRUE.
         3   else return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08103_NewData</srcid><srcstatus/><internalId>274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00140</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00123.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For PXX = 01 or 02 (i.e. for profiles 1 and 2), the out-of-place function
        E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that
        function:
          -  config,
          -  state,
          -  Data
        Concerning pointer to data: if(inputBuffer == NULL and inputBufferLength == 0), then it
        shall pass a pointer to a 1-byte variable of E2E transformer, otherwise it shall pass
        inputBuffer.(RS_E2E_08538)
      </description>
      <comment>
        Incorporated RfC 70069
        'Incorrect specification of call of E2E_PXXCheck for profile RN ',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70069.
        For the case (inputBuffer == NULL and inputBufferLength == 0) it should be sufficient to
        have a valid pointer to data. From the dummy variable where it points to is never read. The
        size of the variable where it points to is considered as an implementation detail and thus
        not important for the fulfillment of this requirement.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08102_InvokeCheck</srcid><srcstatus/><internalId>273</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00123</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00141.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
          For PXX = RN (i.e. for profiles PRN), the in-place
        function E2EXf_Inv_&lt;transformerId&gt; shall
         1.  If(buffer == NULL and inputBufferLength == 0), then
              - variable NewDataAvailable of state object of type
                E2E_PXXCheckStateType (see [SWS_E2EXf_00125]) associated with
                &lt;transformerId&gt; shall be set to FALSE.
         2.  Else if (inputBufferLength == config-&gt;DataLength / 8), then
              - variable NewDataAvailable of state object of type      E2E_PXXCheckState
                Type (see [SWS_E2EXf_00125]) associated with &lt;transformerId&gt; shall be
                set to TRUE.
         3.  Else return E_SAFETY_HARD_RUNTIMEERROR.
        (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07103_NewData</srcid><srcstatus/><internalId>258</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00141</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00124.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For PXX = RN (i.e. for profiles RN), the in-place function
        E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that
        function:
          -  config,
          -  state,
          -  Data
        Concerning pointer to data: if(buffer == NULL and inputBufferLength == 0), then it shall
        pass a pointer to a 1-byte variable of E2E transformer, otherwise it shall pass buffer.
        (RS_E2E_08538)
      </description>
      <comment>
        Incorporated RfC 70069
          'Incorrect specification of call of E2E_PXXCheck for profile RN',
        see https://www.autosar.org/bugzilla/show_bug.cgi?id=70069.
        For the case (inputBuffer == NULL and inputBufferLength == 0) it should be sufficient to
        have a valid pointer to data. From the dummy variable where it points to is never read. The
        size of the variable where it points to is considered as an implementation detail and thus
        not important for the fulfillment of this requirement.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07102_InvokeCheck</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00142.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If configuration parameter profileBehavior is PRE_R4_2, then
        for PXX = RN, E2EXf_Inv_&lt;transformerId&gt;() shall set the variable
        MaxDeltaCounter of the state object to the value of variable MaxDeltaCounterInit of
        the corresponding configuration object. (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_09101_MaxDeltaCounterCheck</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_10101_MaxDeltaCounterCheck</srcid><srcstatus/><internalId>282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00142</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00104.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For PXX = 04, 05, 06: the function
        E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that function:
          -  config,
          -  state,
          -  data length: inputBufferLength
        pointer to data: inputBuffer (out-of-place version) or buffer (in-place
        version). (RS_E2E_08538)
      </description>
      <rationale>
       This requirement is not applicable for profile RN.
      </rationale>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00029.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        The function E2EXf_Inv_&lt;transformerId&gt; shall invoke
        E2E_PXXMapStatusToSM(), passing to that function the return value of E2E_PXXCheck
        and the profiles check Status (variable Status of state object of type
        E2E_PXXCheckStateType, see [SWS_E2EXf_00125]), to obtain the profile-
        independent check status. For P1/P2 mapping functions, there is an additional call
        parameter profileBehavior:
          -  if configuration parameter profileBehavior is R4_2, then E2E_PXXMapStatusToSM()
             shall be invoked with the call parameter profileBehavior = 1
          -  if configuration parameter profileBehavior is PRE_R4_2, then
             E2E_PXXMapStatusToSM()  shall be invoked with call parameter profileBehavior = 0
        (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07104_InvokeMapStatusToSM</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08104_InvokeMapStatusToSM</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_09102_ProfileBehaviorParameterCheck</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_10102_ProfileBehaviorParameterCheck</srcid><srcstatus/><internalId>283</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00029</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00028.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        The function E2EXf_Inv_&lt;transformerId&gt; shall invoke the
        E2E_SMCheck() function, passing to that function the configuration object of type
        E2E_SMConfigType (see [SWS_E2EXf_00126] and [SWS_E2EXf_00088]) and state
        object of type E2E_SMCheckStateType (see [SWS_E2EXf_00125]) that are
        associated with &lt;transformerId&gt;, plus the profile-independent check status that
        was computed by E2E_PXXMapStatusToSM() in SWS_E2EXf_00029. (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07105_InvokeSMCheck</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08105_InvokeSMCheck</srcid><srcstatus/><internalId>276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00028</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00027.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>2</version>
      <description>
        If E2E_SMCheck() returns E2E_E_OK and disableEndToEndStateMachine is FALSE, then:
          - the high nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt; shall be
            set to the low nibble of the state of the state machine (member SMState of object of
            type E2E_SMStateType that is associated with &lt;transformerId&gt;, see
            [SWS_E2EXf_00125]).
          - The low nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt;
            shall  be set to the low nibble of the profile-independent check status
            of type E2E_PCheckStatusType.
            If E2E_SMCheck() does not return E2E_E_OK, the return value shall be
            E_SAFETY_SOFT_RUNTIMEERROR. (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07106_SMCheckRetVal</srcid><srcstatus/><internalId>261</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08106_SMCheckRetVal</srcid><srcstatus/><internalId>277</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00027</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00112.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If (buffer != NULL &amp;&amp;
        EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), in-place
        E2EXf_Inv_&lt;transformerId&gt; shall copy the first upperHeaderBitsToShift
        bits, in parameter buffer, in direction right by 'distance' of
        BufferProperties.headerLength.(RS_E2E_08538)
      </description>
      <rationale>
        This requirement is not applicable for profile RN.
      </rationale>
      <comment>
      Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
      SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00112</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00113.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If (inputBuffer != NULL &amp;&amp;
        EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0),
        out-of-place E2EXf_Inv_&lt;transformerId&gt; shall copy the first
        upperHeaderBitsToShift bits from inputBuffer to buffer, and then copy the
        remaining part of inputBuffer skipping E2E header (i.e. starting with
        offset upperHeaderBitsToShift+BufferProperties.headerLength) to parameter
        buffer starting with the destination offset of
        (upperHeaderBitsToShift).(RS_E2E_08538)
      </description>
      <rationale>
        This requirement is not applicable for profile RN.
      </rationale>
      <comment>
        Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
        SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00116.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If (inputBuffer != NULL &amp;&amp;
        EndToEndTransformationDescription.upperHeaderBitsToShift == 0),
        out-of-place E2EXf_Inv_&lt;transformerId&gt; shall copy inputBuffer starting
        with the offset of BufferProperties.headerLength, to
        buffer.(RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08107_CopyUpperHeader</srcid><srcstatus/><internalId>278</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00114.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If inputBufferLength == 0, then E2EXf_Inv_&lt;transformerId&gt; shall set
        *bufferLength = 0, otherwise it shall set
        *bufferLength = inputBufferLength - BufferProperties.headerLength/8.
        (RS_E2E_08538)
      </description>
      <comment>
        Incorporated RfC 69897 'Inconsequent usage of bits and bytes for
        BufferProperties.headerLength' and
        RfC 69321 'Correction of calculation of bufferLength'.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07108_BufLength</srcid><srcstatus/><internalId>263</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08108_BufLength</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00167.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        In case of Client/Server-Communication on the server side, if the return value ret equals
        to E_SAFETY_*_ERR, the value shall be overwritten to E_E2E_HARD_SAFETY_ERR.
        (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.ClientServer</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00037.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>2</version>
      <description>
        Mandatory Interfaces
        API function         Description
        E2E_PRNCheck         Checks the Data received using the E2E profile RN. This includes CRC
                             calculation, handling of Counter and Data ID.
        E2E_PRNCheckInit     Initializes the check state
        E2E_PRNForward       Protects data which is forwarded by using the E2E profile RN. This includes
        (draft)              checksum calculation, handling of counter and Data ID. Detected Errors of
                             received message will be reconstruct on output data.
                             Tags: atp.Status=draft
        E2E_PRNMapStatusToSM The function maps the check status of Profile RN to a generic check
                             status, which can be used by E2E state machine check function. The E2E
                             Profile RN delivers a more fine-granular status, but this is not
                             relevant for the E2E state machine.
        E2E_PRNProtect       Protects the array/buffer to be transmitted using the E2E profile RN.
                             This includes checksum calculation, handling of counter and Data ID.
        E2E_PRNProtectInit   Initializes the protection state.
        E2E_SMCheck          Checks the communication channel. It determines if the data can be used
                             for safety-related application, based on history of checks performed by
                             a corresponding E2E_P0XCheck() function.
        E2E_SMCheckInit        Initializes the state machine.
        (RS_E2E_08538)
      </description>
      <comment>
        Only APIs of activated profiles are mandatory. APIs of deactivated profiles are optional.
        This applies to all profiles.
      </comment>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07005_InvokeProtect</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07102_InvokeCheck</srcid><srcstatus/><internalId>257</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07104_InvokeMapStatusToSM</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07105_InvokeSMCheck</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08005_InvokeProtect</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08102_InvokeCheck</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08104_InvokeMapStatusToSM</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08105_InvokeSMCheck</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_13000_FWCodeStatusCheck</srcid><srcstatus/><internalId>292</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_14000_FWCodeStatusCheck</srcid><srcstatus/><internalId>293</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_15000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_16000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>295</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00037</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.tsc.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_Xfrm_00108.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_TransformerGeneral.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        A transformer which is called with NULL_PTR as input data shall
        not change the output buffer unless the transformer invocation shall trigger an autonomous
        error reaction (see also [SWS_Rte_07420]).(SRS_Xfrm_00005)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07001_IOValidParamCheck</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07101_IOValidParamCheck</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08001_IOValidParamCheck</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08101_IOValidParamCheck</srcid><srcstatus/><internalId>272</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08103_NewData</srcid><srcstatus/><internalId>274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_Xfrm_00108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_Xfrm_00032.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_TransformerGeneral.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        -----------------------------------------------------------------------------
        Error Name                 | Error Code | Error Type | Description
        -----------------------------------------------------------------------------
        E_OK                       | 0x00       | -          | The communication is safe.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_REP         | 0x01       | Soft       | The data are valid according to
                                                               safety, although data with a re-
                                                               peated counter were received.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_SEQ         | 0x02       | Soft       | The data are valid according to
                                                               safety, although a counter jump
                                                               occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_ERR         | 0x03       | Soft       | The data are valid according to
                                                               safety, although the check itself
                                                               failed.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_NND         | 0x05       | Soft       | Communication is valid according to
                                                               safety, but no new data received.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_OK         | 0x20       | Soft       | No data are available since ini-
                                                               tialization of transformer.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_REP        | 0x21       | Soft       | No data are available since
                                                               initialization of transformer be-
                                                               cause a repeated counter was
                                                               received.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_SEQ        | 0x22       | Soft       | No data are available since ini-
                                                               tialization of transformer and a
                                                               counter jump occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_ERR        | 0x23       | Soft       | No data are available since ini-
                                                               tialization of transformer. There-
                                                               fore the check failed.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_NND        | 0x25       | Soft       | No data are available since
                                                               initialization of transformer.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_OK           | 0x30       | Soft       | Not enough data were received
                                                               to use them.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_REP          | 0x31       | Soft       | Not enough data were received
                                                               to use them but some with a re-
                                                               peated counter were received.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_SEQ          | 0x32       | Soft       | Not enough data were received
                                                               to use them, additionally a
                                                               counter jump occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_ERR          | 0x33       | Soft       | Not enough data were received
                                                               to use them, additionally a check
                                                               failed.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_NND          | 0x35       | Soft       | Not enough data were received to use
                                                               them, additionally no new data
                                                               received.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_OK        | 0x40       | Soft       | The data are invalid and cannot
                                                               be used.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_REP       | 0x41       | Soft       | The data are invalid and can-
                                                               not be used because a repeated
                                                               counter was received.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_SEQ       | 0x42       | Soft       | The data are invalid and cannot
                                                               be used due to a counter jump.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_ERR       | 0x43       | Soft       | The data are invalid and cannot
                                                               be used because a check failed.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_NND       | 0x45       | Soft       | Communication is invalid according to
                                                               safety and no new data received
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_OK           | 0x60       | Soft       | Communication is safe, Statemachine
                                                               is not active.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_REP          | 0x61       | Soft       | Data with a repeated counter were
                                                               received. E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_SEQ          | 0x62       | Soft       | A counter jump occurred.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_ERR          | 0x63       | Soft       | The data are invalid and cannot
                                                               be used because a check failed.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_NND          | 0x65       | Soft       | No new data available.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_DEC          | 0x66       | Soft       | Disabled E2E State machine and
                                                               disabled E2E check.
        -----------------------------------------------------------------------------
        E_SAFETY_SOFT_RUNTIMEERROR | 0x77       | Soft       | A runtime error occurred, safety
                                                               properties could not be checked
                                                               (state or status cannot be deter-
                                                               mined) but non-protected output
                                                               data could be produced nonethe-
                                                               less.
        -----------------------------------------------------------------------------
        E_E2E_HARD_SAFETY_ERR      | 0x8d       | Hard       | Not further specified E2E error
        -----------------------------------------------------------------------------
        E_SAFETY_HARD_RUNTIMEERROR | 0xFF       | Hard       | A runtime error occurred, safety
                                                               properties could not be checked
                                                               and NO output data could be pro-
                                                               duced.
        -----------------------------------------------------------------------------
      </description>
      <releases>
         <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
         <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_15000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_16000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>295</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
            <linksto>E2E.SWS_Xfrm_00032</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_Xfrm_00051.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_TransformerGeneral.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If a transformer returns a hard error, it shall leave the output buffer unchanged
        (SRS_Xfrm_00004)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07001_IOValidParamCheck</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07101_IOValidParamCheck</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08001_IOValidParamCheck</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08101_IOValidParamCheck</srcid><srcstatus/><internalId>272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_Xfrm_00051</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
      <id>E2EPRN.EB.SWS_E2EXf_00133.PRN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the E2E Transformer has not been correctly initialized (which means that
        E2EXf_[&lt;PartitionId&gt;]_PartitionInit() was not successfully
        called before), then all generated E2E
        Transformer APIs shall immediately return E_SAFETY_HARD_RUNTIMEERROR.
        (RS_E2E_08538)
      </description>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07000_NotInitialized</srcid><srcstatus/><internalId>248</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07100_NotInitialized</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08000_NotInitialized</srcid><srcstatus/><internalId>264</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08100_NotInitialized</srcid><srcstatus/><internalId>271</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.EB.SWS_E2EXf_00133</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

    <specobject>
      <id>E2EPRN.EB.Transformer.InPlace.NoCopying.PRN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If (buffer != NULL) &amp;&amp;
        (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), in-place
        E2EXf_&lt;transformerId&gt; shall keep buffer unchanged.
      </description>
      <comment>
        The setting upperHeaderBitsToShift == 0 implicits the use of ComXf
          which is applicable for profile PRN.
      </comment>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07002_CopyUpperHeader</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.EB.Transformer.InPlace.NoCopying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>E2EPRN.EB.InvTransformer.InPlace.NoCopying.PRN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If (buffer != NULL) &amp;&amp;
        (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), in-place
        E2EXf_Inv_&lt;transformerId&gt; shall keep buffer unchanged.
      </description>
      <comment>
        The setting upperHeaderBitsToShift == 0 implicits the use of ComXf
           which is applicable for profile PRN.
      </comment>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07107_CopyUpperHeader</srcid><srcstatus/><internalId>262</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.EB.InvTransformer.InPlace.NoCopying</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>E2EPRN.EB.SWS_E2EXf_00021.PRN</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EXf_[_&lt;PartitionId&gt;]_PartitionInit() function shall initialize
        all state structures managed by E2E transformer, calling the corresponding
        E2E_Init() method on each state variable.
      </description>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07005_InvokeProtect</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07102_InvokeCheck</srcid><srcstatus/><internalId>257</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07105_InvokeSMCheck</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08005_InvokeProtect</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08102_InvokeCheck</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08105_InvokeSMCheck</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_13000_FWCodeStatusCheck</srcid><srcstatus/><internalId>292</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.EB.SWS_E2EXf_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>E2EPRN.EB.Transformer.Server.ProtectStatePtrInputCheck.PRN</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In C/S communication, the E2EXf_&lt;transformerId&gt; on server-side shall perform the
        following additional precondition check, without continuing further processing:
        - ProtectStatePtr == NULL_PTR
        If the above condition is TRUE, then the function shall return
        E_SAFETY_HARD_RUNTIMEERROR.
      </description>
      <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <comment>
        Checking ProtectStatePtr for NULL_PTR is necessary as it is dereferenced
        and set by the RequestCounter of csTransactionHandlePtr-&gt;e2eCounter.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>E2E.EB.Transformer.Server.ProtectStatePtrInputCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>E2EPRN.EB.InvTransformer.Client.ProtectStatePtrInputCheck.PRN</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In C/S communication, the E2EXf_Inv_&lt;transformerId&gt; on client-side shall perform the
        following additional precondition check, without continuing further processing:
        - ProtectStatePtr == NULL_PTR
        If the above condition is TRUE, then the function shall return
        E_SAFETY_HARD_RUNTIMEERROR.
      </description>
      <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <comment>
        Checking ProtectStatePtr for NULL_PTR is necessary as it is dereferenced
        to setting the Counter member of CheckStatesPtr-&gt;PXXmCheckState.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>E2E.EB.InvTransformer.Client.ProtectStatePtrInputCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00047.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>2</version>
      <description>
        Imported Types
        Module    : Imported Type
        E2E       : E2E_PRNCheckStateType
                    E2E_PRNCheckStatusType
                    E2E_PRNConfigType
                    E2E_PRNProtectStateType
                    E2E_PRNReceiverStateType
                    E2E_PRNSenderStateType
                    E2E_PCheckStatusType
                    E2E_SMCheckStateType
                    E2E_SMConfigType
        Std_Types : Std_ExtractProtocolHeaderFieldsType
                    Std_MessageResultType
                    Std_MessageTypeType
                    Std_ReturnType
                    Std_TransformerForwardCode (draft)
                    Std_VersionInfoType
        (RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR 4.2.1</release>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07002_CopyUpperHeader</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_14000_FWCodeStatusCheck</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.ProfileTypes</srcid><srcstatus/><internalId>219</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00047</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00175.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        In case of Client/Server Communication on the client side, if the E2E_PXXCheck function
        returns a value different from E2E_P_OK, the status shall be set to E2E_P_ERR.
        (RS_E2E_08538)
      </description>
      <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00175</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00169.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If disableEndToEndStateMachine is to TRUE,
          - The high nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt; shall
            be set to 0x6.
          - The low nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt; shall
            be set to the low nibble of the profile-independent check status of type
            E2E_PCheckStatusType.(RS_E2E_08538)
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_15000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_16000_InvokeCheck_DisableE2ESM_TRUE</srcid><srcstatus/><internalId>295</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00173.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        In case of Client/Server Communication on the client side and Profile is P04, P05, P06, P07,
        P08, P11, P22 or P44, P04m, P07m, P08m, P44m state-&gt;Counter of
        E2EXf_Inv_&lt;transformerId&gt; shall be set to the requestCounter - 1.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <comment/>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.ClientServer</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00173</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00172.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        In case of Client/Server Communication on the client side and Profile is P01 or P02,
        state-&gt;LastValidCounter of E2EXf_Inv_&lt;transformerId&gt; shall be set to the
        requestCounter-1.(RS_E2E_08538)
      </description>
      <rationale>This requirement is not applicable for profile RN.</rationale>
      <comment/>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.ClientServer</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00203.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profile P04m, P07m, P08m and P44m both the in-place and the out-of-place
        E2EXf_Inv_&lt;transformerId&gt; on the server-side shall set the e2eCounter element
        of the csTransactionHandle to the value of the local variable receivedRequestCounter.
        (RS_E2E_08538)
      </description>
      <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <comment/>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00202.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profile P04m, P07m, P08m and P44m both the in-place and the out-of-place
        E2EXf_Inv_&lt;transformerId&gt; on the server-side shall set the e2eSourceId element
        of the csTransactionHandle to the value of the local variable sourceID.(RS_E2E_08538)
      </description>
      <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00201.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For PXX = P04m, P07m, P08m and P44m: the function E2EXf_Inv_&lt;transformerId&gt; on the
        server-side shall invoke E2E_PXXSinkCheck(), passing to that function:
          - config,
          - state,
          - the local variables messageType, messageResult, and the address of the local
            variable sourceID
          - data length:
            inputBufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
          - pointer to data:
            . inputBuffer + EndToEndTransformationDescription.upperHeaderBitsToShift
              (out-of-place version) or
            . buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
              (in-place version).(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00200.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For PXX = P04m, P07m, P08m and P44m: the function E2EXf_Inv_&lt;transformerId&gt; on the
        client-side shall invoke E2E_PXXSourceCheck(), passing to that function:
          - config,
          - state,
          - the local variables messageType, messageResult, and the local variable sourceID
          - data length:
                inputBufferLength – EndToEndTransformationDescription.upperHeaderBitsToShift
          - pointer to data:
              . inputBuffer + EndToEndTransformationDescription.upperHeaderBitsToShift (
                out-of-place version) or
              . buffer + EndToEndTransformationDescription.upperHeaderBitsToShift (
                in-place version).
        (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00199.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If extractProtocolHeaderFields() returns something different from E_OK,
        E2EXf_Inv_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00198.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_Inv_&lt;transformerId&gt;
        on the server-side shall call the extractProtocolHeaderFields() function passing the
        inputBuffer, the inputBufferLength, the address of local messageType variable, and the
        address of a local messageResult variable as parameters.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00197.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m the in-place E2EXf_Inv_&lt;transformerId&gt;
        on the server-side shall call the extractProtocolHeaderFields() function
        passing the buffer, the bufferLength, the address of local messageType variable,
        and the address of a local messageResult variable as parameters.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00197</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>175</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00196.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
        E2EXf_Inv_&lt;transformerId&gt; on the client-side shall set a local variable sourceID
        to the sourceID stored in the configuration.
        (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00194.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_Inv_&lt;transformerId&gt;
        on the client-side shall call the extractProtocolHeaderFields() function passing the
        inputBuffer, the inputBufferLength, the address of a local variable named messageType,
        and the address of a local variable named messageResult as parameters.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00193.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m the in-place E2EXf_Inv_&lt;transformerId&gt; on
        the client-side shall call the extractProtocolHeaderFields() function passing
        the buffer, the bufferLength, the address of local messageType variable, and
        the address of a local messageResult variable as parameters.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00192.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
        E2EXf_Inv_&lt;transformerId&gt; shall perform the following additional precondition checks,
        without continuing further processing:
          1. extractProtocolHeaderFields == NULL
          2. csTransactionHandle == NULL.
        If any of above conditions is TRUE, then the function shall return
        E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00192</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00191.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If DataTransformationStatusForwarding is set to transformerStatusForwarding and
        PXX = P04m, P07m, P08m or P44m: The function E2EXf_&lt;transformerId&gt;() shall invoke
        E2E_PXXForward(), passing to that function:
          - the appropriate Config structure (see [SWS_E2EXf_00125]),
          - the appropriate State structure (see [SWS_E2EXf_00126]),
          - the local variables sourceID, messageType, and messageResult
          - buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
          - bufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
        Hereby buffer and bufferLength were updated according to the above requirements
        SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00191</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00168.PRN</id>
      <status>approved</status> <!-- draft in R22-11 -->
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If DataTransformationStatusForwarding is set to transformerStatusForwarding and
        PXX is P01, P02, P04, P05, P06, P07, P08, P11, P22 or P44 the function
        E2EXf_&lt;transformerId&gt;() shall invoke E2E_PXXForward(), passing to that function
        the appropriate Config and State structures (see [SWS_E2EXf_00125] and
        [SWS_E2EXf_00126]) that are associated with &lt;transformerId&gt;, as well as buffer
        and bufferLength (only for P04, P05, P06, P07, P08, P11, P22 and P44)
        that were updated above in requirements SWS_E2EXf_00108, SWS_E2EXf_00109,
        SWS_E2EXf_00115, SWS_E2EXf_00111.
        In addition the E2E status shall be passed on to the E2E_PXXForward() function based on the
        parameter forwardedCode provided by the RTE. This parameter is associated with the optional
        IN parameter forwardedCode from Rte_Write (SWS_Rte_01071), Rte_Send (SWS_Rte_01072),
        Rte_IWrite (SWS_Rte_03744)and Rte_IWriteRef (SWS_Rte_05509). ). The forwardedCode must be
        mapped to the matching E2E status
        (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_13000_FWCodeStatusCheck</srcid><srcstatus/><internalId>292</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_14000_FWCodeStatusCheck</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00190.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If DataTransformationStatusForwarding is set to noTransformerStatusForwarding
        and PXX = P04m, P07m, P08m or P44m the function E2EXf_&lt;transformerId&gt;()
        shall invoke E2E_PXXProtect(), passing to that function:
          - the appropriate Config structure (see [SWS_E2EXf_00125]),
          - the appropriate State structure (see [SWS_E2EXf_00126]),
          - the local variables sourceID, messageType, and messageResult
          - buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
          - bufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
        Hereby buffer and bufferLength were updated according to the requirements
        SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.
        (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00166.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If E2E-Transformer is used in a Client-Server Communication and Profile is P01, P04, P04m,
        P05, P06, P07, P07m, P08, P08m, P11, P44 or P44m the sequence counter for protecting the
        response shall be set to requestCounter. (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.ClientServer</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00166</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00208.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        The function E2EXf_MapCodeToStatus shall return the values depending on the value of
        forwardedCode.(RS_E2E_08538)
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_14000_FWCodeStatusCheck</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00208</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00165.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If E2E-Transformer is used for a response in a Client-Server Communication and Profile is
        P02 or P22 the sequence counter used for protecting the response shall be set to
        requestCounter -1. (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable for profile RN.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00165</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00189.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
        E2EXf_&lt;transformerId&gt; on the server-side shall set a local variable named
        requestCounter to the value of the e2eCounter element of the csTransactionHandle.
        (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00188.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
        E2EXf_&lt;transformerId&gt; on the server-side shall set a local variable sourceID to the
        value of the e2eSourceId element of the csTransactionHandle. (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00188</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00187.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If extractProtocolHeaderFields() returns something different from E_OK,
        E2EXf_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00187</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00186.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_&lt;transformerId&gt;
        on the server-side shall call the extractProtocolHeaderFields() function passing the
        inputBuffer, the inputBufferLength, the address of local messageType variable,
        and the address of a local messageResult variable as parameters.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00185.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m the in-place E2EXf_&lt;transformerId&gt; on
        the server-side shall call the extractProtocolHeaderFields() function passing the buffer,
        the bufferLength, the address of local messageType variable, and the address of a local
        messageResult variable as parameters. (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00185</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00184.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
        E2EXf_&lt;transformerId&gt; on the client-side shall set a local variable sourceID
        to the sourceID stored in the configuration (see SWS_E2EXf_00126). (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00183.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If extractProtocolHeaderFields() returns something different from E_OK,
        E2EXf_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00181.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m the in-place E2EXf_&lt;transformerId&gt; on the
        client-side shall call the extractProtocolHeaderFields() function passing the buffer, the
        bufferLength, the address of local messageType variable, and the address of a local
        messageResult variable as parameters.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00181</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00182.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR 22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_&lt;transformerId&gt; on
        the client-side shall call the extractProtocolHeaderFields() function passing
        the inputBuffer, the inputBufferLength, the address of a local variable
        named messageType, and the address of a local variable named messageResult as
        parameters.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00171.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If E2EXf_&lt;transformerId&gt; is used in a Client-Server Communication on the client-side
        and Profile is P01, P04, P05, P06, P07, P08, P11 or P44, P04m, P07m, P08m, P44m
        state-&gt;Counter - 1 shall be stored as requestCounter to be accessed by the
        E2EXf_Inv_&lt;transformerId&gt; for checking the response. (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.ClientServer</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00171</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>195</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00170.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        If E2EXf_&lt;transformerId&gt; is used in a Client-Server Communication on the client-side
        and Profile is P02 or P22, state-&gt;Counter shall be stored to as requestCounter to be
        accessed by the E2EXf_Inv_&lt;transformerId&gt; for checking the response.(RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable for profile RN.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00170</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00180.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR 22-11</source>
      <version>1</version>
      <description>
        For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
        E2EXf_&lt;transformerId&gt; shall perform the following additional precondition checks,
        without continuing further processing:
          1. extractProtocolHeaderFields == NULL
          2. csTransactionHandle == NULL.
        If any of above conditions is TRUE, then the function shall return E_SAFETY_HARD_RUNTIMEERROR.
        (RS_E2E_08538)
      </description>
        <rationale>This requirement is not applicable as not supported in profile RN so far.</rationale>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00180</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>197</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00206.PRN</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        In case of Client/Server Communication on the client side
        and Profile is P01 or P02, the receivedRequestCounter shall be set to state-&gt;
        LastValidCounter of E2EXf_Inv_&lt;transformerId&gt;.(RS_E2E_08538)
      </description>
      <comment/>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.ClientServer</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

    <specobject>
      <id>E2EPRN.SWS_E2EXf_00207.PRN</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        In case of Client/Server Communication on the client side
        and Profile is P04, P05, P06, P07, P08, P11, P22, P44, P04m, P07m,
        P08m or P44m the receivedRequestCounter shall be set to state-&gt;Counter of
        E2EXf_Inv_&lt;transformerId&gt;.(RS_E2E_08538)
      </description>
      <rationale>
        This requirement is not applicable to E2EPRN.
      </rationale>
      <comment/>
      <releases>
        <release>AUTOSAR CP R22-11</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>E2E.SWS_E2EXf_00207</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

    <specobject>
      <id>E2EPRN.EB.Transformer.Init.SR</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In S/R communication each transformer can be initialized individually.
        API used is &lt;transformerId&gt;_Init().
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07005_InvokeProtect</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_07102_InvokeCheck</srcid><srcstatus/><internalId>257</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08005_InvokeProtect</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_08102_InvokeCheck</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_E2EXf_CON_13000_FWCodeStatusCheck</srcid><srcstatus/><internalId>292</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

    <specobject>
      <id>E2EPRN.EB.Transformer.Init.Client</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In C/S communication at client end both non-inverse transformer and
        inverse transformer shall be initialized at the time same.
        API used is &lt;non-inversetransformerId&gt;_&lt;inversetransformerId&gt;_Init().
      </description>
      <comment>
        This requirement is not applicable to PRN
      </comment>
      <providescoverage>
        <provcov>
          <linksto>E2E.EB.Transformer.Init.Client</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

  </specobjects>
    <specobjects doctype="req">

    <!--  GENERIC AUTOSAR REQUIREMENTS  -->

    <specobject>
      <id>EB_E2EPRN020115</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00115.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00115'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
       the following shall apply:
      </para>
      <para>
        E2E library files (i.e. E2E_*.*) shall not include any RTE files.
      </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_IncludeFiles</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00011.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00011'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>the following shall apply:</para>
      <para>
        The E2E Library shall report errors detected by library-internal mechanisms to callers of E2E
        functions through return value.
      </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNProtectInit_InvalidInput</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_13_PRNCheckInit_InvalidInput</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

  <!--  GENERIC SWS-CORRECTIONS  -->

    <specobject>
      <id>EB_E2EPRN020048</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00048
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00048'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        the following shall apply:
      </para>
      <para>
        applies,
        but the E2E library Profile RN shall be built of the following files:E2E_PRN.h and E2E_PRN.c
      </para>
      <para>
        Note:
        E2E.h (common header) is shared by all profiles and exists in a different module.
      </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_05_Files</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>


    <specobject>
      <id>EB_E2EPRN020047</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
    <description>     See AUTOSAR SWS, Design Item SWS_E2E_00047
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00047'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          The following error flags for errors shall be used E2E Library Profile RN.
          The functions E2E_PRNProtect() and E2E_PRNCheck() shall use these values as return value:
        </para>
        <itemizedlist>
          <listitem>
            <para>
              Type or error or status: <code>At least one pointer parameter is a NULL pointer</code>
            </para>
            <para>
              Relevance: <code>Production</code>
            </para>
            <para>
              Related code: <code>E2E_E_INPUTERR_NULL</code>
            </para>
            <para>
              Value [hex]: <code>0x13</code>
            </para>
          </listitem>
          <listitem>
            <para>
              Type or error or status: <code>At least one input parameter is erroneous, e.g. out of range</code>
            </para>
            <para>
              Relevance: <code>Production</code>
            </para>
            <para>
              Related code: <code>E2E_E_INPUTERR_WRONG</code>
            </para>
            <para>
              Value [hex]: <code>0x17</code>
            </para>
          </listitem>
          <listitem>
            <para>
              Type or error or status: <code>An internal library error has occurred (e.g. error detected by program flow monitoring, violated invariant or postcondition) </code>
            </para>
            <para>
              Relevance: <code>Production</code>
            </para>
            <para>
              Related code: <code>E2E_E_INTERR</code>
            </para>
            <para>
              Value [hex]: <code>0x19</code>
            </para>
          </listitem>
          <listitem>
            <para>
              Type or error or status: <code>Function completed successfully</code>
            </para>
            <para>
              Relevance: <code>N/A</code>
            </para>
            <para>
              Related code: <code>E2E_E_OK</code>
            </para>
            <para>
              Value [hex]: <code>0x00</code>
            </para>
          </listitem>
          <listitem>
            <para>
              Type or error or status: <code>Invalid value</code>
            </para>
            <para>
              Relevance: <code>Production</code>
            </para>
            <para>
              Related code: <code>E2E_E_INVALID</code>
            </para>
            <para>
              Value [hex]: <code>0xFF</code>
            </para>
          </listitem>
        </itemizedlist>
        <para>
          Note that the E2E Protection Wrapper (code examples) uses the same byte to store E2E and
          E2EPW errors.
          Therefore, some value ranges are reserved.
        </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNProtectInit_InvalidInput</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_13_PRNCheckInit_InvalidInput</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020037</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00037.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00037'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        the following shall apply:
      </para>
        The E2E library shall not have any configuration options.
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_03_NoConfigParams</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00033
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00033'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        the following shall apply:
      </para>
      <para>
        Only the module version identification and the vendor id shall be published
        as specified in the General Requirements on Basic Software Modules.
      </para>
      <para>
        That is, the following version numbers shall be defined in the header file:
        <itemizedlist>
          <listitem>
            E2EPRN_VENDOR_ID
          </listitem>
          <listitem>
            E2EPRN_MODULE_ID
          </listitem>
          <listitem>
            E2EPRN_SW_MAJOR_VERSION
          </listitem>
          <listitem>
            E2EPRN_SW_MINOR_VERSION
          </listitem>
          <listitem>
            E2EPRN_SW_PATCH_VERSION
          </listitem>
        </itemizedlist>
      </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PublishedInformation</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
       <provcov>
          <linksto>E2E.top.006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

  <!--  E2EPRN SWS-CORRECTIONS  -->

    <specobject>
      <id>EB_E2EPRN020018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR SWS, Design Item SWS_E2E_00018
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00018'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          The type <code>E2E_PRNConfigType</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Configuration of transmitted Data for E2E Profile PRN.</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Type</emphasis>
                </para>
                </th>
                <td>
                  <para>Structure</para>
                </td>
              </tr>
              <tr>
                <th rowspan="9"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Members</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>
                      uint16
                      CounterOffset
                    </code>
                  </para>
                </td>
                <td>
                  <para>Bit offset of Counter in MSB first order. In variants 1A and 1B, CounterOffset is 8. The offset shall be a multiplicity of 4.</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint16
                      CRCOffset
                    </code>
                  </para>
                </td>
                <td>
                  <para>Bit offset of CRC (i.e. since *Data) in MSB first order. In variants 1A and 1B, CRCOffset is 0. The offset shall be a multiplicity of 8.</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint16
                      DataID
                    </code>
                  </para>
                </td>
                <td>
                  <para>A unique identifier for protection against masquerading. Dataid is equivalent to Initialization constant  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint16
                      DataIDNibbleOffset
                    </code>
                  </para>
                </td>
                <td>
                  <para>Bit offset of the low nibble (Least Significant Bit) of the high byte of Data ID  from the beginning of the Byte-Array  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      E2E_PRNDataIDMode
                      DataIDMode
                    </code>
                  </para>
                </td>
                <td>
                  <para>Inclusion mode of ID in CRC computation (both bytes, alternating, or low byte only of ID included).</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint16
                      DataLength
                    </code>
                  </para>
                </td>
                <td>
                  <para>Length of data, in bits. The value shall be a multiplicity of 8 and shall be &lt;= 240 </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint8
                      MaxDeltaCounterInit
                    </code>
                  </para>
                </td>
                <td>
                  <para>Initial maximum allowed gap between two counter values of two consecutively received valid Data. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint8
                      MaxNoNewOrRepeatedData
                    </code>
                  </para>
                </td>
                <td>
                  <para>Maximum amount of missing or repeated Data which the receiver does not expect to exceed under normal communication conditions.</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint8
                      SyncCounterInit
                    </code>
                  </para>
                </td>
                <td>
                  <para>Number of Data required for validating the consistency of the counter that must be received with a valid counter after the detection of an unexpected behavior of a received counter. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Non-modifiable configuration of the data element sent over an RTE port,
                    for E2E profile PRN. The position of the counter and CRC is not configurable
                    in profile PRN.</para>
                </td>
              </tr>
        </table>
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_16_Struct</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020200</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR SWS, Design Item SWS_E2E_00200.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00200'])"/>
             </para>
          </listitem>
        </itemizedlist>
      </para>
       <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
          The enumerated values for <code>E2E_PRNDataIDMode</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>The values for the enumeration constants for E2E_PRNDataIDMode are specified as </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Type</emphasis>
                </para>
                </th>
                <td>
                  <para>enum</para>
                </td>
              </tr>
              <tr>
                <th rowspan="4"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Constants</emphasis>
                </para>
                </th>
                <td>
                  <para>E2E_PRN_DATAID_BOTH = 0x0</para>
                </td>
                <td>
                  <para>Two bytes are included in the CRC (double ID configuration) This is used in E2E variant 1A.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRN_DATAID_ALT = 0x1</para>
                </td>
                <td>
                  <para>One of the two bytes byte is included, alternating high and low byte, depending on parity of the counter
                  (alternating ID configuration).For an even counter, the low byte is included. For an odd counter,
                  the high byte is included. This is used in E2E variant 1B.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRN_DATAID_LOW = 0x2</para>
                </td>
                <td>
                  <para>Only the low byte is included, the high byte is never used.
                  This is applicable if the IDs in a particular system are 8 bits.</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRN_DATAID_NIBBLE = 0x3</para>
                </td>
                <td>
                  <para>The low byte is included in the implicit CRC calculation, the low nibble of the high byte is transmitted along
                  with the data (i.e. it is explicitly included), the high nibble of the high byte is not used. This is applicable for
                  the IDs up to 12 bits. This is used in E2E variant 1C.</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Result of the verification of the Data in E2E Profile RN, determined by the Check function. </para>
                </td>
              </tr>
        </table>
      </description>
      <comment>
        The E2E library Profile RN supports double ID configuration.
      </comment>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_03_TypeDataIDMode</srcid><srcstatus/><internalId>244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020022</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>        See AUTOSAR Design Item SWS_E2E_00022
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00022'])"/>
             </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          The type <code>E2E_PRNCheckStatusType</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Definition of E2E Profile RN receiver status type. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Type</emphasis>
                </para>
                </th>
                <td>
                  <para>enum</para>
                </td>
              </tr>
              <tr>
                <th rowspan="9"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Range</emphasis>
                </para>
                </th>
                <td>
                  <para>E2E_PRNSTATUS_OK = 0x0</para>
                </td>
                <td>
                  <para>
                    OK: The new data has been received according to communication medium,the CRC is
                    correct, the Counter is incremented by 1 with respect to the most recent Data
                    received with Status _INITIAL, _OK, or _OKSOMELOST.
                    This means that no Data has been lost since the last correct data reception.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRNSTATUS_NONEWDATA = 0x1</para>
                </td>
                <td>
                  <para>
                    Error: the Check function has been invoked but no new Data is not available
                    since the last call, according to communication medium (e.g. RTE, COM).
                    As a result, no E2E checks of Data have been consequently executed.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRNSTATUS_WRONGCRC = 0x2</para>
                </td>
                <td>
                  <para>
                    Error: The data has been received according to communication medium,
                    but 1 the CRC is incorrect or 2. the low nibble of the high byte of Data ID is
                    incorrect (applicable only for E2E Profile 1 with E2E_PRNDataIDMode
                    = E2E_PRN_DATAID_NIBBLE).
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRNSTATUS_SYNC = 0x3</para>
                </td>
                <td>
                  <para>
                    NOT VALID: The new data has been received after detection of an unexpected
                    behavior of counter. The data has a correct CRC and a counter within the
                    expected range with respect to the most recent Data received,
                    but the determined continuity check for the counter is not finalized yet.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRNSTATUS_INITIAL = 0x4</para>
                </td>
                <td>
                  <para>
                    Initial: The new data has been received according to communication medium,
                    the CRC is correct, but this is the first Data since the receiver's
                    initialization or reinitialization, so the Counter cannot be verified yet.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRNSTATUS_REPEATED = 0x8</para>
                </td>
                <td>
                  <para>
                    Error: The new data has been received according to communication medium,
                    the CRC is correct, but the Counter is identical to the most recent
                    Data received with Status _INITIAL, _OK, or _OKSOMELOST.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRNSTATUS_OKSOMELOST = 0x20</para>
                </td>
                <td>
                  <para>
                    OK: The new data has been received according to communication medium,
                    the CRC is correct, the Counter is incremented by DeltaCounter
                    (1 &lt; DeltaCounter &lt;=MaxDeltaCounter) with respect to the most recent
                    Data received with Status _INITIAL, _OK, or _OKSOMELOST.
                    This means that some Data in the sequence have been probably lost since
                    the last correct/initial reception, but this is within the configured
                    tolerance range.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRNSTATUS_WRONGSEQUENCE = 0x40</para>
                </td>
                <td>
                  <para>
                    Error: The new data has been received according to communication medium,
                    the CRC is correct, but the Counter Delta is too big
                    (DeltaCounter &gt; MaxDeltaCounter) with respect to the most recent Data received
                    with Status _INITIAL, _OK, or _OKSOMELOST. This means that too many Data in the
                    sequence have been probably lost since the last correct/initial reception.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>E2E_PRNSTATUS_DATAINVALID = 0x80</para>
                </td>
                <td>
                  <para>
                    Error:All bits in the received data except for byte 0 (CRC) are set to one.
                  </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>
                    Result of the verification of the Data in E2E Profile RN, determined by the
                    Check function.
                  </para>
                </td>
              </tr>
        </table>
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_15_PRNCheck_CheckEnum</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020020</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>        See AUTOSAR SWS, Design Item SWS_E2E_00020.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00020'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          The type <code>E2E_PRNProtectStateType</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>State of the sender for a Data protected with E2E Profile PRN. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Type</emphasis>
                </para>
                </th>
                <td>
                  <para>struct</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Members</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>
                      uint8
                      Counter
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    Counter to be used for protecting the next Data. The initial value is 0, which
                    means that the first Data will have the counter 0. After the protection by the
                    Counter, the Counter is incremented modulo 0xF. The value 0xF is skipped
                    (after 0xE the next is 0x0), as 0xF value represents the error value.
                    The four high bits are always 0.</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>State of the sender for a Data protected with E2E Profile RN. </para>
                </td>
              </tr>
        </table>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_03_TypeSenderState</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020021</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>        See AUTOSAR SWS, Design Item SWS_E2E_00021.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00021'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          The type <code>E2E_PRNCheckStateType</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Definition of E2E Profile PRN receiver state type. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Type</emphasis>
                </para>
                </th>
                <td>
                  <para>struct</para>
                </td>
              </tr>
              <tr>
                <th rowspan="8"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Members</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>
                      E2E_PRNCheckStatusType
                      Status
                    </code>
                  </para>
                </td>
                <td>
                  <para>Result of the verification of the Data, determined by the Check function. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint8
                      LastValidCounter
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    Counter value most recently received. If no data has been yet received, then the
                    value is 0x0. After each reception, the counter is updated with the value
                    received.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint8
                      MaxDeltaCounter
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    MaxDeltaCounter specifies the maximum allowed difference between two counter
                    values of consecutively received valid messages.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      boolean
                      WaitForFirstData
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    If true means that no correct data (with correct Data ID and CRC) has been yet
                    received after the receiver (re-)initialization.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      boolean
                      NewDataAvailable
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    Indicates to E2E Library that a new data is available for Library to be checked.
                    This attribute is set by the E2E Library caller, and not by the E2E Library.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint8
                      LostData
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    Number of data (messages) lost since reception of last valid one.This attribute
                    is set only if Status equals E2E_PRNSTATUS_OK or E2E_PRNSTATUS_OKSOMELOST.
                    For other values of Status, the value of LostData is undefined.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      E2E_PRNCheckStatusType
                      Status
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    Result of the verification of the Data, determined by the Check function.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                      uint8
                      SyncCounter
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    Number of Data required for validating the consistency of the counter that must
                    be received with a valid counter (i.e. counter within the allowed lock-in range)
                    after the detection of an unexpected behavior of a received counter.
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>
                       uint8
                       NoNewOrRepeatedDataCounter
                    </code>
                  </para>
                </td>
                <td>
                  <para>
                    Amount of consecutive reception cycles in which either (1) there was no new data,
                    or (2) when the data was repeated
                  </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>State of the receiver for a Data protected with E2E Profile RN. </para>
                </td>
              </tr>
        </table>
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_16_Struct</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

  <!-- E2E Profile RN routines -->
    <specobject>
      <id>EB_E2EPRN020166</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00166
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00166'])"/>
             </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
        P01 refers to PRN.
        The API <code>E2E_PRNProtect</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Protects the array/buffer to be transmitted using the E2E Profile RN. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Synopsis</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <funcsynopsis lang="C">
                    <funcprototype>
                      <funcdef>
                        <type>Std_ReturnType</type>
                        <function>E2E_PRNProtect</function>
                      </funcdef>
                      <paramdef>
                        <type>const E2E_PRNConfigType *</type>
                        <parameter>Config</parameter>
                      </paramdef>
                      <paramdef>
                        <type>E2E_PRNProtectStateType *</type>
                        <parameter>State</parameter>
                      </paramdef>
                      <paramdef>
                        <type>uint8 *</type>
                        <parameter>Data</parameter>
                      </paramdef>
                    </funcprototype>
                  </funcsynopsis>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Service ID</emphasis>
                </para>
                </th>
                <td>0x01</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Sync/Async</emphasis>
                </para>
                </th>
                <td>Synchronous</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Reentrancy</emphasis>
                </para>
                </th>
                <td>Reentrant</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (in)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>const * Config</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to static configuration. </para>
                </td>
              </tr>
              <tr>
                <th rowspan="2"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (in,out)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>State</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to port/data communication state. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>Data</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to Data to be transmitted.</para>
                </td>
              </tr>
              <!--Return Value row--><tr>
                <th rowspan="5"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Return Value</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Function execution success status </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_NULL</code>
                  </para>
                </td>
                <td>
                  <para>At least one pointer parameter is a NULL pointer. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_WRONG</code>
                  </para>
                </td>
                <td>
                  <para>At least one input parameter is erroneous. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INTERR</code>
                  </para>
                </td>
                <td>
                  <para>An internal error has occurred in the function (e.g. error detected by program flow monitoring, violated invariant or postcondition) </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_OK</code>
                  </para>
                </td>
                <td>
                  <para>Function completed successfully.</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>
                    Protects the array/buffer to be transmitted using the E2E Profile PRN.
                    This includes CRC calculation, handling of counter and Data ID.
                  </para>
                </td>
              </tr>
        </table>
       applies,
       but in contrast to SWS_E2E_00166, the first argument is a pointer to const:
    </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ComTest_01</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNProtect</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020385</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR SWS, Design Item SWS_E2E_00385.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00385'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
          The API <code>E2E_PRNProtectInit</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Initializes the protection state. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Synopsis</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <funcsynopsis lang="C">
                    <funcprototype>
                      <funcdef>
                        <type>Std_ReturnType</type>
                        <function>E2E_PRNProtectInit</function>
                      </funcdef>
                      <paramdef>
                        <type>E2E_PRNProtectStateType *</type>
                        <parameter>StatePtr</parameter>
                      </paramdef>
                    </funcprototype>
                  </funcsynopsis>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Service ID</emphasis>
                </para>
                </th>
                <td>0x1b</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Sync/Async</emphasis>
                </para>
                </th>
                <td>Synchronous</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Reentrancy</emphasis>
                </para>
                </th>
                <td>Reentrant</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (in)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>None</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to static configuration. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (inout)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>None</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to static configuration. </para>
                </td>
              </tr>
              <tr>
                <th rowspan="1"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (out)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>StatePtr</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to port/data communication state. </para>
                </td>
              </tr>
              <!--Return Value row--><tr>
                <th rowspan="3"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Return Value</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Std_ReturnType </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_NULL</code>
                  </para>
                </td>
                <td>
                  <para>null pointer passed </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_OK</code>
                  </para>
                </td>
                <td>
                  <para>The Function is Successfull</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Initializes the protection state.</para>
                  <para/>
                </td>
              </tr>
        </table>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ComTest_01</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNProtectInit_Ok</srcid><srcstatus/><internalId>223</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNProtectInit_InvalidInput</srcid><srcstatus/><internalId>224</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020386</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00386.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00386'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          In case State is NULL, E2E_PRNProtectInit shall return immediately with E2E_E_INPUTERR_NULL.
          Otherwise, it shall intialize the state structure, setting Counter to 0.
        </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNProtectInit_Ok</srcid><srcstatus/><internalId>223</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNProtectInit_InvalidInput</srcid><srcstatus/><internalId>224</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020588</id>
      <status>approved</status><!-- draft in ASR R22-11 -->
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00588
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00588'])"/>
             </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>The API <code>E2E_PRNForward</code> shall be specified as follows:</para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Forwards the array/buffer to be transmitted using the E2E Profile RN. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Synopsis</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <funcsynopsis lang="C">
                    <funcprototype>
                      <funcdef>
                        <type>Std_ReturnType</type>
                        <function>E2E_PRNForward</function>
                      </funcdef>
                      <paramdef>
                        <type>const E2E_PRNConfigType *</type>
                        <parameter>Config</parameter>
                      </paramdef>
                      <paramdef>
                        <type>E2E_PCheckStatusType</type>
                        <parameter>Checkstatus</parameter>
                      </paramdef>
                      <paramdef>
                        <type>E2E_PRNProtectStateType *</type>
                        <parameter>State</parameter>
                      </paramdef>
                      <paramdef>
                        <type>uint8 *</type>
                        <parameter>Data</parameter>
                      </paramdef>
                    </funcprototype>
                  </funcsynopsis>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Service ID</emphasis>
                </para>
                </th>
                <td>0x38</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Sync/Async</emphasis>
                </para>
                </th>
                <td>Synchronous</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Reentrancy</emphasis>
                </para>
                </th>
                <td>Reentrant</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (in)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>Config</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to static configuration. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>Checkstatus</code>
                  </para>
                </td>
                <td>
                  <para>E2E Status of the received message</para>
                </td>
              </tr>
              <tr>
                <th rowspan="2"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (inout)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>State</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to port/data communication state. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>Data</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to Data to be transmitted.</para>
                </td>
              </tr>
              <tr>
                <th rowspan="2"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (out)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>None</code>
                  </para>
                </td>
              </tr>
              <tr>
              <!--Return Value row-->
                <th rowspan="5"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Return Value</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Function execution success status </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>Std_ReturnType</code>
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_NULL</code>
                  </para>
                </td>
                <td>
                  <para>At least one pointer parameter is a NULL pointer. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_WRONG</code>
                  </para>
                </td>
                <td>
                  <para>At least one input parameter is erroneous. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INTERR</code>
                  </para>
                </td>
                <td>
                  <para>
                    An internal error has occurred in the function (e.g. error detected by
                    program flow monitoring, violated invariant or postcondition)
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_OK</code>
                  </para>
                </td>
                <td>
                  <para>Function completed successfully.</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>
                    Protects data which is forwarded by using the E2E profile RN.
                    This includes checksum calculation, handling of counter and Data ID.
                    Detected Errors of received message will be reconstruct on output data.
                  </para>
                </td>
              </tr>
        </table>
       applies,
       but in contrast to SWS_E2E_00588, the first argument is a pointer to const:
       P01 refers to PRN.
    </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_06_PRNForward_FS_Nonewdata</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020158</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>2</version>
      <description>      See AUTOSAR SWS, Design Item E2E0158
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00158'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          The API <code>E2E_PRNCheck</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Check the received Data using the E2E Profile PRN. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Synopsis</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <funcsynopsis lang="C">
                    <funcprototype>
                      <funcdef>
                        <type>Std_ReturnType</type>
                        <function>E2E_PRNCheck</function>
                      </funcdef>
                      <paramdef>
                        <type>const E2E_PRNConfigType *</type>
                        <parameter>Config</parameter>
                      </paramdef>
                      <paramdef>
                        <type>E2E_PRNCheckStateType *</type>
                        <parameter>State</parameter>
                      </paramdef>
                      <paramdef>
                        <type>const uint8 *</type>
                        <parameter>Data</parameter>
                      </paramdef>
                    </funcprototype>
                  </funcsynopsis>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Service ID</emphasis>
                </para>
                </th>
                <td>0x02</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Sync/Async</emphasis>
                </para>
                </th>
                <td colspan="2">Synchronous</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Reentrancy</emphasis>
                </para>
                </th>
                <td colspan="2">Reentrant</td>
              </tr>
              <tr>
                <th rowspan="2"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (in)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>Config</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to static configuration. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>Data</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to received Data.</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (inout)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>State</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to port/data communication state. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (out)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>None</code>
                  </para>
                </td>
              </tr>
              <!--Return Value row--><tr>
                <th rowspan="4"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Return Value</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Std_ReturnType</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_NULL</code>
                  </para>
                </td>
                <td>
                  <para>At least one pointer parameter is a NULL pointer. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_WRONG</code>
                  </para>
                </td>
                <td>
                  <para>At least one input parameter is erroneous. </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_INTERR</code>
                  </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_OK</code>
                  </para>
                </td>
                <td>
                  <para>Function completed successfully.</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>
                    Checks the Data received using the E2E Profile RN. This includes CRC calculation,
                    handling of Counter and Data ID.
                  </para>
                  <para/>
                </td>
              </tr>
        </table>
      applies,
      but in contrast to E2E0158, the first and third arguments are pointers to const:
      P01 refers to PRN.
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ComTest_01</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020390</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00390.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00390'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          The API <code>E2E_PRNCheckInit</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Initializes the check state. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Synopsis</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <funcsynopsis lang="C">
                    <funcprototype>
                      <funcdef>
                        <type>Std_ReturnType</type>
                        <function>E2E_PRNCheckInit</function>
                      </funcdef>
                      <paramdef>
                        <type>E2E_PRNCheckStateType *</type>
                        <parameter>State</parameter>
                      </paramdef>
                    </funcprototype>
                  </funcsynopsis>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Service ID</emphasis>
                </para>
                </th>
                <td>0x1c</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Sync/Async</emphasis>
                </para>
                </th>
                <td colspan="2">Synchronous</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Reentrancy</emphasis>
                </para>
                </th>
                <td colspan="2">Reentrant</td>
              </tr>
              <tr>
                <th rowspan="1"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (in)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>None</code>
                  </para>
                </td>
              </tr>
              <tr>
                <th rowspan="1"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (inout)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>None</code>
                  </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (out)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>State</code>
                  </para>
                </td>
                <td>
                  <para>Pointer to port/data communication state. </para>
                </td>
              </tr>
              <!--Return Value row--><tr>
                <th rowspan="3"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Return Value</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Std_ReturnType</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_INPUTERR_NULL</code>
                  </para>
                </td>
                <td>
                  <para>E2E_E_INPUTERR_NULL – null pointer passed</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_E_OK</code>
                  </para>
                </td>
                <td>
                  <para>The function completed Successfully</para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Initializes the check state.</para>
                  <para/>
                </td>
              </tr>
        </table>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ComTest_01</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_12_PRNCheckInit_Ok</srcid><srcstatus/><internalId>237</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_13_PRNCheckInit_InvalidInput</srcid><srcstatus/><internalId>238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020389</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00389.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00389'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        the following shall apply:
      </para>
      <para>
        P01 refers to PRN.
        In case State is NULL, E2E_PRNCheckInit shall return immediately with E2E_E_INPUTERR_NULL.
        Otherwise, it shall initialize the state structure, setting:</para>
       <para>
         1. LastValidCounter = 0 </para>
       <para>
         2. MaxDeltaCounter = 0 </para>
       <para>
         3. WaitForFirstData = TRUE </para>
       <para>
         4. NewDataAvailable = TRUE </para>
       <para>
         5. LostData = 0 </para>
       <para>
         6. Status = E2E_PRNSTATUS_NONEWDATA</para>
       <para>
         7. NoNewOrRepeatedDataCounter = 0 </para>
       <para>
         8. SyncCounter = 0.</para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_12_PRNCheckInit_Ok</srcid><srcstatus/><internalId>237</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_13_PRNCheckInit_InvalidInput</srcid><srcstatus/><internalId>238</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020382</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00382.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00382'])"/>
             </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          The API <code>E2E_PRNMapStatusToSM</code> shall be specified as follows:
        </para>
        <table border="1">
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Purpose</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>The function maps the check status of Profile RN to a generic check status. </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Synopsis</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <funcsynopsis lang="C">
                    <funcprototype>
                      <funcdef>
                        <type>E2E_PCheckStatusType</type>
                        <function>E2E_PRNMapStatusToSM</function>
                      </funcdef>
                      <paramdef>
                        <type>Std_ReturnType </type>
                        <parameter>CheckReturn</parameter>
                      </paramdef>
                      <paramdef>
                        <type>E2E_PRNCheckStatusType</type>
                        <parameter>Status</parameter>
                      </paramdef>
                      <paramdef>
                        <type>boolean</type>
                        <parameter>profileBehavior</parameter>
                      </paramdef>
                    </funcprototype>
                  </funcsynopsis>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Service ID</emphasis>
                </para>
                </th>
                <td>0x1d</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Sync/Async</emphasis>
                </para>
                </th>
                <td>Synchronous</td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Reentrancy</emphasis>
                </para>
                </th>
                <td>Reentrant</td>
              </tr>
              <tr>
                <th rowspan="3"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (in)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>CheckReturn</code>
                  </para>
                </td>
                <td>
                  <para>Return value of the E2E_PRNCheck function</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>Status</code>
                  </para>
                </td>
                <td>
                  <para>Status determined by E2E_PRNCheck function.</para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>profileBehavior</code>
                  </para>
                </td>
                <td>
                  <para>
                    FALSE: check has the legacy behavior, before R4.2 TRUE: check behaves like new
                    P4/P5/P6 profiles introduced in R4.2
                  </para>
                </td>
              </tr>
              <tr>
                <th rowspan="1"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (in,out)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>None</code>
                  </para>
                </td>
              </tr>
              <tr>
                <th rowspan="1"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Parameters (out)</emphasis>
                </para>
                </th>
                <td>
                  <para>
                    <code>None</code>
                  </para>
                </td>
              </tr>
              <!--Return Value row--><tr>
                <th rowspan="2"><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Return Value</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>Function execution success status </para>
                </td>
              </tr>
              <tr>
                <td>
                  <para>
                    <code>E2E_PCheckStatusType</code>
                  </para>
                </td>
                <td>
                  <para>
                    Profile-independent status of the reception on one single Data in one cycle.
                  </para>
                </td>
              </tr>
              <tr>
                <th><?dbfo bgcolor="#EBEBEB"?><?dbhtml bgcolor="#EBEBEB"?><para>
                  <emphasis role="bold">Description</emphasis>
                </para>
                </th>
                <td colspan="2">
                  <para>
                    The function maps the check status of Profile RN to a generic check status,
                    which can be used by E2E state machine check function. The E2E Profile RN
                    delivers a more fine-granular status, but this is not relevant for the E2E state
                    machine.
                  </para>
                </td>
              </tr>
        </table>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ComTest_01</srcid><srcstatus/><internalId>221</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020383</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00383
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00383'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
          If CheckReturn == E2E_E_OK and ProfileBehavior == TRUE, then the function
          E2E_PRNMapStatusToSM shall return the values depending on the value of Status:
        </para>
      applies,
      but if Status equals E2E_PRNSTATUS_NONEWDATA, then E2E_PRNMapStatusToSM() shall return
      E2E_P_NONEWDATA instead of E2E_P_REPEATED.
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_10_PRNMapStatusToSMProfileBehaviorTRUE</srcid><srcstatus/><internalId>235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020476</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00476
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00476'])"/>
             </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
          If CheckReturn == E2E_E_OK and ProfileBehavior == FALSE, then the function
          E2E_PRNMapStatusToSM shall return the values depending on the value of Status:
        </para>
      applies,
      but if Status equals E2E_PRNSTATUS_NONEWDATA, then E2E_PRNMapStatusToSM() shall return
      E2E_P_NONEWDATA instead of E2E_P_REPEATED .
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_11_PRNMapStatusToSMProfileBehaviorFALSE</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020384</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR SWS, Design Item SWS_E2E_00384
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibrary_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_SWS_E2E_00384'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
        <para>
          the following shall apply:
        </para>
        <para>
          If CheckReturn != E2E_E_OK, then the function E2E_PRNMapStatusToSM() shall return
          E2E_P_ERROR (regardless of value of Status).
        </para>
      </description>
      <releases>
        <release>AUTOSAR CP R22-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_10_PRNMapStatusToSMProfileBehaviorTRUE</srcid><srcstatus/><internalId>235</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_11_PRNMapStatusToSMProfileBehaviorFALSE</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

  <!-- E2E PRN Profile PRS Requirements -->

    <specobject>
      <id>ASR_E2EP04020218</id>
      <status>rejected</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00218.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00372'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
      </description>
      <comment>This requirement is informational only.</comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020075</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR PRS, Design Item PRS_E2E_00075
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00075'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
         <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          In E2E Profile RN, on the sender side, for the first transmission request of a data
          element the counter shall be initialized with 0 and shall be incremented by 1 for every
          subsequent send request (from sender SW-C). When the counter reaches the value 15 (0xF),
          then it shall restart with 0 for the next send request (i.e. value 0xF shall be skipped).
          All these actions shall be executed by E2E Library.
        </para>
      applies,
      but the E2E library Profile RN does not initialize the counter to 0, because the library
      E2E_PRNProtect() function cannot differentiate if a transmission is the first transmission.
      Note that the initialization of the counter to 0 for the first transmission shall be ensured
      by the caller of the E2E_PRNProtect() function.
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNProtect</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020076</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00076.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00076'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        The following shall apply:
      </para>
      <para>
        P01 refers to PRN.
        In E2E Profile RN, on the receiver side, by evaluating the counter of received data against
        the counter of previously received data, the following shall be detected:
      </para>
        <para>(1) no new data has arrived since last invocation of E2E library check function,</para>
        <para>(2) no new data has arrived since receiver start,</para>
        <para>(3) the data is repeated,</para>
        <para>(4) counter is incremented by one (i.e. no data lost),</para>
        <para>
          (5) counter is incremented more than by one, but still within allowed limits
          (i.e. some data lost),
        </para>
        <para>
          (6) counter is incremented more than allowed (i.e. too many data lost). All these actions
          shall be executed by E2E Library.
        </para>
      <para>
        Case 3 corresponds to the failed alive counter check, and case 6 correspond to failed
        sequence counter check. The above requirements are specified in more details by the UML
        diagrams in the following document sections.</para>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNCheckStatus_Ok</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>228</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNCheckStatus_WrongSequence</srcid><srcstatus/><internalId>229</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_05_PRNCheckStatus_Repeated</srcid><srcstatus/><internalId>230</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_06_PRNCheckStatus_Initial</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_07_PRNCheckStatus_NoNewData</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020163</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00163.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00163'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        the following shall apply:
      </para>
      <para>
        P01 refers to PRN.
        Both two bytes (double ID configuration) are included in the CRC, first low byte and then high byte (see variant 1A - E2E0227)
      </para>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020163.1</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020163.2</srcid><srcstatus/><internalId>100</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020163.3</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020163.4</srcid><srcstatus/><internalId>102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020163.1</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        EB_E2EPRN020163 applies for the first inclusion mode (double ID configuration).
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNProtect</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020163.2</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        EB_E2EPRN020163 applies for the second inclusion mode (alternating ID configuration).
      </description>
      <comment>
        The following shall applies:
        The E2E library Profile RN supports only double ID configuration mode.
      </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.SCrc</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020163.3</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        EB_E2EPRN020163 applies for the third inclusion mode (only low byte of Data ID).
      </description>
      <comment>
        The following shall applies:
        The E2E library Profile RN supports only double ID configuration mode
      </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNProtect</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020163.4</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>
        EB_E2EPRN020163 applies for the fourth inclusion mode (low nibble of high byte of Data ID
        is transmitted explicitly).
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNProtect</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020163</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020169</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>       See AUTOSAR PRS, Design Item PRS_E2E_00169.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00169'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        the following shall apply:
      </para>
      <para>
        P01 refers to PRN.
        In E2E Profile RN, the Data ID is transmitted implicitly. This means that Data ID is not
        transmitted together with the data, but it is included in the CRC calculation.
      </para>
      <para>
        In case of usage of E2E Library for protecting Data Elements, due to multiplicity of
        communication (1:1 or 1:N), a receiver of a data element will receive it only from one
        sender. In case of usage of E2E Library for protecting I-PDUs, due to the fact that each
        I-PDU has a unique Data ID, the receiver COM of an I-PDU will receive it from only from one
        sender COM. As a result, the receiver expects data with only one Data ID. The receiver uses
        the expected Data ID to calculate the CRC. If CRC matches, it means that the Data ID used by
        the sender and expected Data ID used by the receiver are the same.
      </para>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020306</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00306.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00306'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
        the following shall apply:
      </para>
      <para>
        P01 refers to PRN.
      </para>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020070</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
    <description>      See AUTOSAR PRS, Design Item PRS_E2E_00070.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00070'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
         <para>the following shall apply:</para>
        <para>
          P01 refers to PRN.
          CRC characteristics (based on J1850 SAE standard):
        <para>-	CRC result width: 8 bits.</para>
        <para>-	Polynomial: 1Dh (x^8 + x^4 + x^3 + x^2 + 1). </para>
        <para>-	Initial value: FFh. </para>
        <para>-	Input data reflected: No (no change of the bits order).</para>
        <para>-	Result data reflected: No (no change of the bits order).</para>
        <para>-	XOR value: FFh (= final inversion).</para>
        </para>
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020070.Lessthan8bytes</srcid><srcstatus/><internalId>106</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNProtect</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020070.Lessthan8bytes</id>
      <status>approved</status>
      <source>RT4_RNDS_A_20121_CAN%20Safety_v1.1%20.doc</source>
      <version>1</version>
    <description>
      <para>
        The CRC is calculated on 2 bytes Data ID and 7 bytes user data.
        Data ID                       User data
                                      7 bytes data from the data field in the frame
        “5 bits fixed at 0” and       - Excepting the byte of the CRC which is not
        “11 bits Frame ID”              included in the calculation, and;
                                      - The not declared bytes are to be fixed at 0.
      </para>
    </description>
    <comment>
    If the data length of the frame is less than 8bytes, in order to calculate CRC, complete the data with 0.
    </comment>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_LengthUpTo8BytesCRCCheck</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020190</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR PRS, Design Item PRS_E2E_00190
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00190'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>the following shall apply:</para>
      <para>
        P01 refers to PRN.
        E2E Profile RN shall use the Crc_CalculateCRC8 () function of the SWS CRC Library for
        calculating CRC CRCs.
      </para>
      <para>
        The Data ID itself is not transmitted in E2E Profile RN, but it is included in the CRC.
        This is called implicit transmission of Data ID (note: this is a different notion than
        implicit communication of data Elements through RTE).
      </para>
      <para>
        Note: The CRC used by E2E Profile RN is different than the CRCs used by FlexRay and CAN and
        is provided by different software modules (FlexRay and CAN CRCs are provided by hardware
        support in Communication Controllers, not by CRC library).
      </para>
      <para>
        The CRC calculation is illustrated by the following example (for standard variant 1A, and
        for a particular set of signals):
      </para>
      <para>In E2E Profile RN, the CRC is calculated over:</para>
        <para>
          1. First over the one or two bytes of the Data ID (depending on configuration) and then
        </para>
        <para>
          2. Then over all transmitted bytes of a safety-related complex data element/signal group
          (except the CRC byte).
        </para>
      </description>
      <comment>
        Set to DEVIATION because of:
        - Deviation [ASCE2E-34] The E2E library uses a Safety Crc module (SCrc) instead of the
        ASR Crc module
      </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.SCrc</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNProtect</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020195</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>      See AUTOSAR PRS, Design Item PRS_E2E_00195
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00195'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>the following shall apply:</para>
      <para>
        P01 refers to PRN.
        The function E2E_PRNProtect() shall write the Counter in Data, an finally compute the CRC
        over DataID and Data and write CRC in Data as specified in 
        <xref linkend="fig_E2E_PRNProtect"/> and <xref linkend="fig_E2E_CalculateCRC"/>.
        Then it shall increment the Counter (which will be used in the next invocation of
        E2E_PRNProtect()).
        <para>
          E2E_PRNProtect is visualized in <xref linkend="fig_E2E_PRNProtect"/>
        </para>
        <para>
          E2E_CalculateCRC is visualized in <xref linkend="fig_E2E_CalculateCRC"/>
        </para>
      </para>
      <figure id="fig_E2E_PRNProtect">
        <title>E2E_PRNProtect()</title>
        <inlinegraphic fileref="images/E2E_PRNProtect.png" width="90%"/>
      </figure>
      <figure id="fig_E2E_CalculateCRC">
        <title>E2E_CalculateCRC()</title>
        <inlinegraphic fileref="images/E2E_CalculateCRC.png" width="90%"/>
      </figure>
      </description>
      <comment>
        The following shall applies:
        The E2E library Profile RN supports only double ID configuration mode
      </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNProtect</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCRCCheck</srcid><srcstatus/><internalId>284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020608</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description> See AUTOSAR PRS, Design Item PRS_E2E_00608.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00608'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
        </para>
      </description>
      <comment>This is added in R21-11 </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNForward</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020609</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description> See AUTOSAR PRS, Design Item PRS_E2E_00609.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00609'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
        </para>
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PRNForward"/>
        </para>
        <figure id="fig_E2E_PRNForward">
          <title>E2E_PRNForward()</title>
          <inlinegraphic fileref="images/E2E_PRNForward.png" width="90%"/>
        </figure>
      </description>
      <comment>This is added in R21-11 </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020610</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description> See AUTOSAR PRS, Design Item PRS_E2E_00610.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00610'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
        </para>
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PRNForward"/>.
        </para>
        <figure id="fig_E2E_PRNForward_E2E_P_REPEATED">
          <title>E2E_PRNForward()</title>
          <inlinegraphic fileref="images/E2E_PRNForward.png" width="90%"/>
        </figure>
      </description>
      <comment>This is added in R21-11 </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNForward_WriteCounter_FS_Repeated</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020611</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description> See AUTOSAR PRS, Design Item PRS_E2E_00611.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00611'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
        </para>
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PRNForward"/>.
        </para>
        <figure id="fig_E2E_PRNForward_E2E_P_WRONGSEQUENCE">
          <title>E2E_PRNForward()</title>
          <inlinegraphic fileref="images/E2E_PRNForward.png" width="90%"/>
        </figure>
      </description>
      <comment>This is added in R21-11 </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNForward_WriteCounter_FS_WrongSeq</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020612</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description> See AUTOSAR PRS, Design Item PRS_E2E_00612.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00612'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
        <para>
          the following shall apply:
        </para>
        <para>
          P01 refers to PRN.
        </para>
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PRNForward"/>.
        </para>
        <figure id="fig_E2E_PRNForward_E2E_P_ERROR">
          <title>E2E_PRNForward()</title>
          <inlinegraphic fileref="images/E2E_PRNForward.png" width="90%"/>
        </figure>
      </description>
      <comment>This is added in R21-11 </comment>
      <releases>
        <release>AUTOSAR FO R22-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_05_PRNForward_WriteDataID_FS_Error</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020196</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00196.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00196'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>the following shall apply:</para>
      <para>
        P01 refers to PRN.
        In E2E Profile PRN, the E2E_PRNCheck() function shall perform the activities as
        specified in <xref linkend="fig_E2E_PRNCheck"/> and  <xref linkend="fig_E2E_CalculateCRC"/>
        of the ASR Specification with the following
        differences:
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_PRNCheck"/>
        </para>
        <para>
          The diagram is visualized in <xref linkend="fig_E2E_CalculateCRC"/>
        </para>
      </para>
      <figure id="fig_E2E_PRNCheck">
        <title>E2E_PRNCheck()</title>
        <inlinegraphic fileref="images/E2E_PRNCheck.png" width="90%"/>
      </figure>
      <figure id="fig_E2E_CalculateCRC_for_Check">
        <title>E2E_CalculateCRC()</title>
        <inlinegraphic fileref="images/E2E_CalculateCRC.png" width="90%"/>
      </figure>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNCheckStatus_Ok</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>228</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNCheckStatus_WrongSequence</srcid><srcstatus/><internalId>229</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_05_PRNCheckStatus_Repeated</srcid><srcstatus/><internalId>230</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_06_PRNCheckStatus_Initial</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_07_PRNCheckStatus_NoNewData</srcid><srcstatus/><internalId>232</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_08_PRNCheckStatus_Sync</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_09_PRNCheckStatus_WrongDataIDNibble</srcid><srcstatus/><internalId>234</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020298</srcid><srcstatus/><internalId>116</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020299</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020300</srcid><srcstatus/><internalId>118</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020301</srcid><srcstatus/><internalId>119</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020150</srcid><srcstatus/><internalId>120</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020151</srcid><srcstatus/><internalId>121</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020147</srcid><srcstatus/><internalId>122</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020148</srcid><srcstatus/><internalId>123</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020149</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020152</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020153</srcid><srcstatus/><internalId>127</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020012</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00012
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00012'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>the following shall apply:</para>
      <para>
        applies,
        but the library-internal mechanisms shall detect and report errors implemented according to
        the pre-defined E2E Profiles specified in this design document.
        P01 refers to PRN.
      </para>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNProtectInit_InvalidInput</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_13_PRNCheckInit_InvalidInput</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020298</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00298.
        <para>
          <itemizedlist>
            <listitem>
              <para>
                <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00298'])"/>
              </para>
            </listitem>
          </itemizedlist>
        </para>
          shall also apply for E2E_PRNCheck.
        <para>
          P01 refers to PRN.
          The E2E_PRNCheck() function shall
        </para>
        <itemizedlist>
          <listitem>
            <para>re-initialize SyncCounter with SyncCounterInit; and</para>
          </listitem>
          <listitem>
            <para>set Status to E2E_PRNSTATUS_SYNC;</para>
          </listitem>
        </itemizedlist>
        <para>
          if the following conditions are true:
        </para>
        <itemizedlist>
          <listitem>
            <para>the calculated DeltaCounter is within the parameters of 1 and MaxDeltaCounter
              (i.e. 1 &lt;= DeltaCounter &lt;= MaxDeltaCounter); and</para>
          </listitem>
          <listitem>
            <para>the value of the NoNewOrRepeatedDataCounter exceeds MaxNoNewOrRepeatedData.
              (i.e. State-&gt;NoNewOrRepeatedDataCounter &gt; Config-&gt;MaxNoNewOrRepeatedData)
            </para>
          </listitem>
        </itemizedlist>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_08_PRNCheckStatus_Sync</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020299</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00299.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00299'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      shall also apply for E2E_PRNCheck.
        <para>
          P01 refers to PRN.
          The E2E_PRNCheck() function shall
        </para>
        <itemizedlist>
          <listitem>
            <para>decrement SyncCounter by 1; and</para>
          </listitem>
          <listitem>
            <para>set Status to E2E_PRNSTATUS_SYNC</para>
          </listitem>
          <listitem>
            <para/>
          </listitem>
        </itemizedlist>
        <para>
          if the following conditions are true:
        </para>
        <itemizedlist>
          <listitem>
            <para>the calculated DeltaCounter is within the parameters of 1 and MaxDeltaCounter
              (i.e. 1 &lt;= DeltaCounter &lt;= MaxDeltaCounter); and</para>
          </listitem>
          <listitem>
            <para>the value of the NoNewOrRepeatedDataCounter is less than or equal to
              MaxNoNewOrRepeatedData
              (i.e. State-&gt;NoNewOrRepeatedDataCounter &lt;= Config-&gt;MaxNoNewOrRepeatedData);
              and</para>
          </listitem>
          <listitem>
            <para>the SyncCounter exceeds 0.</para>
          </listitem>
        </itemizedlist>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_08_PRNCheckStatus_Sync</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020300</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00300.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00300'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      shall also apply for E2E_PRNCheck.
        <para>
          P01 refers to PRN.
          The E2E_PRNCheck() function shall reset the NoNewOrRepeatedDataCounter to 0 if it returns
          one of the following status:
        </para>
        <itemizedlist>
          <listitem>
            <para>E2E_PRNSTATUS_OK; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_OKSOMELOST; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_SYNC; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_WRONGSEQUENCE</para>
          </listitem>
        </itemizedlist>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNCheckStatus_Ok</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>228</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNCheckStatus_WrongSequence</srcid><srcstatus/><internalId>229</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_08_PRNCheckStatus_Sync</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020301</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00301.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00301'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      shall also apply for E2E_PRNCheck.
      <para>
        P01 refers to PRN.
        The E2E_PRNCheck() function shall increment NoNewOrRepeatedDataCounter by 1
        if it returns the Status E2E_PRNSTATUS_NONEWDATA or E2E_PRNSTATUS_REPEATED
        up to the maximum value of Counter (i.e. 15 or 0xF).
      </para>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_05_PRNCheckStatus_Repeated</srcid><srcstatus/><internalId>230</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_07_PRNCheckStatus_NoNewData</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020150</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00150.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00150'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      shall also apply for E2E_PRNCheck.
        <para>
          P01 refers to PRN.
          The E2E_PRNCheck() function shall re-initialize MaxDeltaCounter with MaxDeltaCounterInit
          if it returns one of the following Status:
        </para>
        <itemizedlist>
          <listitem>
            <para>E2E_PRNSTATUS_OK; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_OKSOMELOST; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_INITIAL; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_SYNC; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_WRONGSEQUENCE on condition that SyncCounter exceeds 0
              (i.e. SyncCounter &gt; 0).</para>
          </listitem>
        </itemizedlist>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNCheckStatus_Ok</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>228</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNCheckStatus_WrongSequence</srcid><srcstatus/><internalId>229</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_06_PRNCheckStatus_Initial</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_08_PRNCheckStatus_Sync</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020151</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00151.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00151'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      shall also apply for E2E_PRNCheck.
        <para>
          P01 refers to PRN.
          The E2E_PRNCheck() function shall set LastValidCounter to Counter of Data if it returns
          one of the following Status:
        </para>
        <itemizedlist>
          <listitem>
            <para>E2E_PRNSTATUS_OK; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_OKSOMELOST; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_INITIAL; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_SYNC; or</para>
          </listitem>
          <listitem>
            <para>E2E_PRNSTATUS_WRONGSEQUENCE on condition that SyncCounter exceeds 0
              (i.e. SyncCounter &gt; 0).</para>
          </listitem>
        </itemizedlist>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNCheckStatus_Ok</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>228</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNCheckStatus_WrongSequence</srcid><srcstatus/><internalId>229</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_06_PRNCheckStatus_Initial</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_08_PRNCheckStatus_Sync</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020147</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00151.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00147'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      shall also apply for E2E_PRNCheck.
        <para>
          P01 refers to PRN.
          The E2E_PRNCheck() function shall set Status to E2E_PRNSTATUS_OK
          if the following conditions are true:
        </para>
        <itemizedlist>
          <listitem>
            <para>the calculated DeltaCounter equals 1; and</para>
          </listitem>
          <listitem>
            <para>the value of the NoNewOrRepeatedDataCounter is less than or equal to
              MaxNoNewOrRepeatedData
              (i.e. State-&gt;NoNewOrRepeatedDataCounter &lt;= Config-&gt;MaxNoNewOrRepeatedData);
              and</para>
          </listitem>
          <listitem>
            <para>the SyncCounter equals 0.</para>
          </listitem>
        </itemizedlist>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_08_PRNCheckStatus_Sync</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020148</id>
      <status>approved</status>
      <source>AUTOSAR_PRS_E2EProtocol.pdf, ASR R22-11</source>
      <version>1</version>
      <description>        See AUTOSAR PRS, Design Item PRS_E2E_00148.
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_PRS_E2EProtocol_ASR_R22-11.xml" xpointer="xpointer(//specobject[id='CREQ_ASR22-11_PRS_E2E_00148'])"/>
            </para>
          </listitem>
        </itemizedlist>
      </para>
      shall also apply for E2E_PRNCheck.
        <para>
          P01 refers to PRN.
          The E2E_PRNCheck() function shall set Status to E2E_PRNSTATUS_OKSOMELOST if the following
          conditions are true:
        </para>
        <itemizedlist>
          <listitem>
            <para>the calculated DeltaCounter is greater-than 1 but less-than or equal to
              MaxDeltaCounter (i.e. 1 &lt; DeltaCounter &lt;= MaxDeltaCounter); and</para>
          </listitem>
          <listitem>
            <para>the NoNewOrRepeatedDataCounter is less than or equal to MaxNoNewOrRepeatedData
              (i.e. State-&gt;NoNewOrRepeatedDataCounter &lt;= Config-&gt;MaxNoNewOrRepeatedData);
              and</para>
          </listitem>
          <listitem>
            <para>the SyncCounter equals 0.</para>
          </listitem>
        </itemizedlist>
      </description>
      <releases>
        <release>AUTOSAR FO R22-11</release>
        <release>AUTOSAR 4.1.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNCheckStatus_Ok</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_03_PRNCheckStatus_OkSomeLost</srcid><srcstatus/><internalId>228</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_06_PRNCheckStatus_Initial</srcid><srcstatus/><internalId>231</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020023</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        <para>
          The E2E library function E2EPRNCheck() shall return with
          the error E2E_E_INPUTERR_WRONG
          without any execution of library internals if one of the
          following config parameters is out of range (i.e. outside [0..15]):
          MaxDeltaCounterInit, MaxNoNewOrRepeatedData, MaxSyncCounterInit
        </para>
        <para>
          Note: The library function E2EPRNProtect() does not read
          any of the aforementioned parameters.
        </para>
      </description>
      <comment>
        This design item is used as an argumentation for a
        safety analysis of the generated E2EPW code in order
        make the E2EPW Check implementation easier.
        For example, the checker need not verify the value
        of the MaxDeltacounterInit value if it equals 255
        (in case this parameter should not be used at Tx side),
        because in this case the library always returns an
        error.
      </comment>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020149</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        <para>
          The E2E_PRNCheck() resp. E2E_PRNProtect() shall return with E2E_E_INPUTERR_WRONG if
          the used Data ID Inclusion Mode does not equal E2E_PRN_DATAID_BOTH,
          E2E_PRN_DATAID_LOW, or E2E_PRN_DATAID_NIBBLE.
        </para>
      </description>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020152</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        <para>
          The E2E_PRNCheck() resp. E2E_PRNProtect() shall return with E2E_E_INPUTERR_WRONG if
          the configured CRCOffset is greater than the DataLength.
        </para>
      </description>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020153</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        <para>
          The E2E_PRNCheck() resp. E2E_PRNProtect() shall return with E2E_E_INPUTERR_WRONG if
          the configured CounterOffset is greater than the DataLength.
        </para>
      </description>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</srcid><srcstatus/><internalId>225</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</srcid><srcstatus/><internalId>239</internalId></linkedfrom><linkedfrom><srcid>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020113</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR4.0 Rev 3</source>
      <version>1</version>
      <description>
        E2E_PXX.h shall exclusively include E2E.h.(SRS_E2E_08528)
        Design Item E2E0113
      <para>
       the following shall apply:
      </para>
      <para>
      applies,
        but E2E_PXX.h shall be replaced by E2E_PRN.h
        and E2E_PRN.h can also include MemMap.h.</para>
      </description>
      <releases>
         <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_IncludeFiles</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

    <specobject>
      <id>EB_E2EPRN020114</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_E2ELibrary.pdf, ASR4.0 Rev 3</source>
      <version>1</version>
    <description>
      Design Item E2E0114
      <para>
        <itemizedlist>
          <listitem>
            <para>
              <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="../../../../asc_E2ESEXfmgmt/doc/SwRS/customer_requirements/AUTOSAR_SWS_E2ELibraryASR421.xml" xpointer="xpointer(//specobject[id='CREQ_ASR421_SWS_E2E_00114'])"/>
             </para>
          </listitem>
        </itemizedlist>
      </para>
      <para>
       the following shall apply:
      </para>
      <para>
      Each E2E_PRN.c file shall exclusively include the corresponding E2E_PRN.h file.
      </para>
    </description>
      <comment>
        Set to DEVIATION because of:
        - Deviation [ASCE2E-34] The E2E library uses a Safety Crc module (SCrc) instead of the ASR Crc module
      </comment>
      <releases>
         <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.E2EPRN.SCrc</srcid><srcstatus/><internalId>217</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_ConTest_04_IncludeFiles</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>

  </specobjects>
    <specobjects doctype="req">

    <!--
        Top Level requirements motivated by the Product Description
    -->

    <specobject>
      <id>E2EPRN.top.001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPRN module shall implement a 4 bit sequence counter,
        explicitly sent in the message header.
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020166</srcid><srcstatus/><internalId>84</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020385</srcid><srcstatus/><internalId>85</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020588</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020158</srcid><srcstatus/><internalId>88</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020390</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020389</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020075</srcid><srcstatus/><internalId>96</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020076</srcid><srcstatus/><internalId>97</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020195</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020609</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020610</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020611</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020612</srcid><srcstatus/><internalId>113</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020196</srcid><srcstatus/><internalId>114</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

    <specobject>
      <id>E2EPRN.top.002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPRN module shall implement a data ID with a configurable
        behavior based on E2E_PRNDataIDMode used for CRC calculation.
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020166</srcid><srcstatus/><internalId>84</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020385</srcid><srcstatus/><internalId>85</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020588</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020158</srcid><srcstatus/><internalId>88</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020390</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020389</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020163</srcid><srcstatus/><internalId>98</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020169</srcid><srcstatus/><internalId>103</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020195</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020609</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020610</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020611</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020612</srcid><srcstatus/><internalId>113</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

    <specobject>
      <id>E2EPRN.top.003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPRN module shall implement a 8 bit CRC calculation based on
        CRC-8-SAE J1850.
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020166</srcid><srcstatus/><internalId>84</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020385</srcid><srcstatus/><internalId>85</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020588</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020158</srcid><srcstatus/><internalId>88</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020390</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020389</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020070</srcid><srcstatus/><internalId>105</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020190</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020195</srcid><srcstatus/><internalId>108</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020609</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020610</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020611</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020612</srcid><srcstatus/><internalId>113</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020196</srcid><srcstatus/><internalId>114</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

    <!--
        Top Level requirements motivated by module specific behavior
    -->

    <specobject>
      <id>E2EPRN.top.004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPRN module shall implement error indication and error states
        to indicate malfunction to the SWC.
      </description>
      <needscoverage>
        <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020011</srcid><srcstatus/><internalId>74</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020022</srcid><srcstatus/><internalId>81</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020158</srcid><srcstatus/><internalId>88</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020390</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020382</srcid><srcstatus/><internalId>91</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020383</srcid><srcstatus/><internalId>92</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020476</srcid><srcstatus/><internalId>93</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020384</srcid><srcstatus/><internalId>94</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020306</srcid><srcstatus/><internalId>104</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020612</srcid><srcstatus/><internalId>113</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020023</srcid><srcstatus/><internalId>124</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

    <specobject>
      <id>E2EPRN.top.005</id>
      <status>rejected</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The E2EPRN module shall support client-server communication via methods.
      </description>
      <comment>This requirement is not applicable.
        Methods for client-server communication are not supported.
      </comment>
      <providescoverage>
        <provcov>
          <linksto>E2E.top.011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

  </specobjects>
    <specobjects doctype="req">

      <specobject>
         <id>E2E.SWS_E2EXf_00102</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In-place E2EXf_&lt;transformerId&gt; shall perform the following
            two precondition checks, without continuing further processing:
             1.  (buffer == NULL)
                 ||
                 (buffer != NULL &amp;&amp; inputBufferLength &lt;
                  EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  bufferLength == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(buffer == NULL &amp;&amp; inputBufferLength != 0)' to '(buffer == NULL)'
            in point 1, see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00102.PRN</srcid><srcstatus/><internalId>0</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00106</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            Out-of-place E2EXf_&lt;transformerId&gt; shall perform the
            following three precondition checks, without continuing further processing:
             1.  (inputBuffer == NULL)
                 ||
                 (inputBuffer != NULL &amp;&amp; inputBufferLength &lt;
                 EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  bufferLength == NULL
             3.  buffer == NULL
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer == NULL &amp;&amp; inputBufferLength != 0)' to '(inputBuffer == NULL)'
            in point 1, see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00106.PRN</srcid><srcstatus/><internalId>1</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00108</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0),
            in-place E2EXf_&lt;transformerId&gt; shall copy the amount upper HeaderBitsToShiftbits,
            in parameter buffer, with starting offset of BufferProperties.headerLength,
            in direction left by "distance" of BufferProperties.headerLength.(RS_E2E_08538)
         </description>
         <comment>
            Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
            SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
            Incorporated Bugzilla RfC 75163:
            Rewrite '(buffer != NULL &amp;&amp; EndToEndTransformationDescription.upperHeaderBitsToShift
            &gt; 0)' to '(EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00108.PRN</srcid><srcstatus/><internalId>2</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00109</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), out-of-place
            E2EXf_&lt;transformerId&gt; shall copy the first upperHeaderBitsToShift bits from
            inputBuffer to buffer, and then copy the remaining part of inputBuffer (i.e. starting with
            offset upperHeaderBitsToShift) to parameter buffer starting with the destination offset
            of (upperHeaderBitsToShift+ BufferProperties.headerLength). (RS_E2E_08538)
         </description>
         <comment>
            Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
            SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)' to
            '(EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00109.PRN</srcid><srcstatus/><internalId>3</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00115</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), out-of-place
            E2EXf_&lt;transformerId&gt; shall copy inputBuffer to buffer starting with the
            destination offset of BufferProperties.headerLength. (RS_E2E_08538)
         </description>
         <comment>
            Incorporated Bugzilla RfC 75163:
            Rewrite '(inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift == 0)' to
            '(EndToEndTransformationDescription.upperHeaderBitsToShift == 0)',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=75163
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00115.PRN</srcid><srcstatus/><internalId>4</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00111</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            E2EXf_&lt;transformerId&gt; shall set
            *bufferLength = inputBufferLength + BufferProperties.headerLength/8.
            (RS_E2E_08538)
         </description>
         <comment>
            Incorporated RfC 69897 'Inconsequent usage of bits and bytes for
            BufferProperties.headerLength'.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00111.PRN</srcid><srcstatus/><internalId>5</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00139</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02, the function E2EXf_&lt;transformerId&gt; shall perform a check of
            the *bufferLength (after the computation of *bufferLength):
            If (*bufferLength != config-&gt;DataLength/8), then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR, i.e. without calling an E2E Library function.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00139.PRN</srcid><srcstatus/><internalId>6</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00107</id>
         <status>approved</status> <!-- draft in R22-11 -->
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            If DataTransformationStatusForwarding is set to no TransformerStatusForwarding and PXX
            is P01, P02, P04, P05, P06, P07, P08, P11, P22 or P44,
            The function E2EXf_&lt;transformerId&gt;() shall invoke
            E2E_PXXProtect(), passing to that function the appropriate Config and State
            structures (see [SWS_E2EXf_00125] and [SWS_E2EXf_00126]) that are associated
            with &lt;transformerId&gt;, as well as buffer and bufferLength
            (only for P04, P05, P06, P07, P08 ,P11 ,P22 and P44) that were updated in above
            requirements SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.
            (RS_E2E_08538)
         </description>
         <comment>
            ForwardStatus feature added in R22-11.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00107.PRN</srcid><srcstatus/><internalId>7</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00018</id>
         <status>approved</status> <!-- draft in R22-11 -->
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            In case E2E_PXXProtect() and E2E_PXXForward() returns E2E_E_OK, then E2EXf_&lt;transformerId&gt; shall
            return E_OK, otherwise E2EXf_&lt;transformerId&gt; shall return
            E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <comment>
            ForwardStatus feature added in R22-11.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00018.PRN</srcid><srcstatus/><internalId>8</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00105</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In-place E2EXf_Inv_&lt;transformerId&gt; shall perform the
            following two precondition checks, without continuing further processing:
             1.  (buffer == NULL &amp;&amp; inputBufferLength != 0)
                 ||
                 (buffer != NULL &amp;&amp; inputBufferLength &lt; BufferProperties.headerLength/8u +
                 EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  bufferLength == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00105.PRN</srcid><srcstatus/><internalId>9</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00103</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            Out-of-place E2EXf_Inv_&lt;transformerId&gt; shall perform the
            following three precondition checks, without continuing further processing:
             1.  (inputBuffer == NULL &amp;&amp; inputBufferLength != 0)
                 ||
                 (inputBuffer != NULL &amp;&amp; inputBufferLength &lt;
                 BufferProperties.headerLength/8u +
                 EndToEndTransformationDescription.upperHeaderBitsToShift/8u)
             2.  If (bufferLength == NULL)
             3.  If (buffer == NULL).
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00103.PRN</srcid><srcstatus/><internalId>10</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00140</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            For PXX = 01 or 02 (i.e. for profile 1 and 2), the out-of-place
            function E2EXf_Inv_&lt;transformerId&gt; shall
             1.  if(inputBuffer == NULL and inputBufferLength == 0), then
                 -  variable NewDataAvailable of state object of type
                    E2E_PXXCheckStateType (see [SWS_E2EXf_00125]) associated with
                    &lt;transformerId&gt; shall be set to FALSE
             2.  else if (inputBufferLength == config-&gt;DataLength/8), then
                 -  variable NewDataAvailable of state object of type
                    E2E_PXXCheckState Type (see [SWS_E2EXf_00125]) associated with
                    &lt;transformerId&gt; shall be set to TRUE.
             3.  else return E_SAFETY_HARD_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00140.PRN</srcid><srcstatus/><internalId>11</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00123</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the out-of-place function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that
            function:
              -  config,
              -  state,
              -  data
            Concerning pointer to data: if(inputBuffer == NULL and inputBufferLength == 0), then
            it shall pass a pointer to a 1-byte variable of E2E transformer, otherwise it shall pass
            inputBuffer.(RS_E2E_08538)
          </description>
          <comment>
            Incorporated RfC 70069
            'Incorrect specification of call of E2E_PXXCheck for profile 01 and 02',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=70069.
            For the case (inputBuffer == NULL and inputBufferLength == 0) it should be sufficient to
            have a valid pointer to data. From the dummy variable where it points to is never read. The
            size of the variable where it points to is considered as an implementation detail and thus
            not important for the fulfillment of this requirement.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00123.PRN</srcid><srcstatus/><internalId>12</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00141</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the in-place
            function E2EXf_Inv_&lt;transformerId&gt; shall
            1.  If(buffer == NULL and inputBufferLength == 0), then
                - variable NewDataAvailable of state object of type
                   E2E_PXXCheckStateType (see [SWS_E2EXf_00125]) associated with
                   &lt;transformerId&gt; shall be set to FALSE.
            2.  Else if (inputBufferLength == config-&gt;DataLength/8), then
                - variable NewDataAvailable of state object of type E2E_PXXCheckState
                  Type (see [SWS_E2EXf_00125]) associated with &lt;transformerId&gt; shall
                  be set to TRUE.
            3.  Else return E_SAFETY_HARD_RUNTIMEERROR.
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00141.PRN</srcid><srcstatus/><internalId>13</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00124</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 01 or 02 (i.e. for profiles 1 and 2), the in-place function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that
            function:
              -  Config,
              -  State,
              -  Data
            Concerning pointer to Data: if(buffer == NULL and inputBufferLength == 0), then it shall
            pass a pointer to a 1-byte variable of E2E transformer, otherwise it shall pass buffer.
            (RS_E2E_08538)
         </description>
         <comment>
            Incorporated RfC 70069
            'Incorrect specification of call of E2E_PXXCheck for profile 01 and 02',
            see https://www.autosar.org/bugzilla/show_bug.cgi?id=70069.
            For the case (inputBuffer == NULL and inputBufferLength == 0) it should be sufficient to
            have a valid pointer to data. From the dummy variable where it points to is never read. The
            size of the variable where it points to is considered as an implementation detail and thus
            not important for the fulfillment of this requirement.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00124.PRN</srcid><srcstatus/><internalId>14</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00142</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If configuration parameter profileBehavior is PRE_R4_2, then
            for PXX = 01 or 02, E2EXf_Inv_&lt;transformerId&gt;() shall set the variable
            MaxDeltaCounter of the state object to the value of variable MaxDeltaCounterInit of
            the corresponding configuration object. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00142.PRN</srcid><srcstatus/><internalId>15</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00104</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            For PXX = 04, 05, 06, 07, 11, 22: the function
            E2EXf_Inv_&lt;transformerId&gt; shall invoke E2E_PXXCheck(), passing to that function:
              -  config,
              -  state,
              -  data length: inputBufferLength
            pointer to data: inputBuffer (out-of-place version) or buffer (in-place
            version). (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00104.PRN</srcid><srcstatus/><internalId>16</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00029</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_Inv_&lt;transformerId&gt; shall invoke
            E2E_PXXMapStatusToSM(), passing to that function the return value of E2E_PXXCheck
            and the profiles check Status (variable Status of state object of type
            E2E_PXXCheckStateType, see [SWS_E2EXf_00125]), to obtain the profile-
            independent check status. For P1/P2 mapping functions, there is an additional call
            parameter profileBehavior:
            -  if configuration parameter profileBehavior is R4_2, then E2E_PXXMapStatusToSM()
               shall be invoked with the call parameter profileBehavior = 1
            -  if configuration parameter profileBehavior is PRE_R4_2, then
               E2E_PXXMapStatusToSM() shall be invoked with call parameter profileBehavior = 0
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00029.PRN</srcid><srcstatus/><internalId>17</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00028</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_Inv_&lt;transformerId&gt; shall invoke the
            E2E_SMCheck() function, passing to that function the configuration object of type
            E2E_SMConfigType (see [SWS_E2EXf_00126] and [SWS_E2EXf_00088])and state
            object of type E2E_SMCheckStateType (see [SWS_E2EXf_00125]) that are associated
            with &lt;transformerId&gt;, plus the profile-independent check status that was computed
            by E2E_PXXMapStatusToSM() in SWS_E2EXf_00029.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00028.PRN</srcid><srcstatus/><internalId>18</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00027</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            If E2E_SMCheck() returns E2E_E_OK and disableEndToEndStateMachine is FALSE, then:
            - the high nibble of the return
              of the function E2EXf_Inv_&lt;transformerId&gt; shall be set to the low nibble
              of the state of the state machine (member SMState of object of type
              E2E_SMStateType that is associated with &lt;transformerId&gt;, see
              [SWS_E2EXf_00125]).
            - The low nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt;
              shall  be set to the low nibble of the profile-independent check status
              of type E2E_PCheckStatusType.
              If E2E_SMCheck() does not return E2E_E_OK, the return value shall be
              E_SAFETY_SOFT_RUNTIMEERROR. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00027.PRN</srcid><srcstatus/><internalId>19</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00112</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (buffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0), in-place
            E2EXf_Inv_&lt;transformerId&gt; shall copy the first upperHeaderBitsToShift
            bits, in parameter buffer, in direction right by 'distance' of
            BufferProperties.headerLength.(RS_E2E_08538)
         </description>
         <comment>
            Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
            SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00112.PRN</srcid><srcstatus/><internalId>20</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00113</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0),
            out-of-place E2EXf_Inv_&lt;transformerId&gt; shall copy the first
            upperHeaderBitsToShift bits from inputBuffer to buffer, and then copy the
            remaining part of inputBuffer skipping E2E header (i.e. starting with
            offset upperHeaderBitsToShift+BufferProperties.headerLength) to parameter
            buffer starting with the destination offset of
            (upperHeaderBitsToShift).(RS_E2E_08538)
         </description>
         <comment>
            Note: EndToEndTransformationDescription.upperHeaderBitsToShift &gt; 0 refers to a
            SomeIpXf transformer above E2EXf (see also constr_3155 of System Template).
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00113.PRN</srcid><srcstatus/><internalId>21</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00116</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If (inputBuffer != NULL &amp;&amp;
            EndToEndTransformationDescription.upperHeaderBitsToShift == 0),
            out-of-place E2EXf_Inv_&lt;transformerId&gt; shall copy inputBuffer starting
            with the offset of BufferProperties.headerLength, to
            buffer.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00116.PRN</srcid><srcstatus/><internalId>22</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00169</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If disableEndToEndStateMachine is to TRUE,
            - The high nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt; shall
              be set to 0x6.
            - The low nibble of the return of the function E2EXf_Inv_&lt;transformerId&gt; shall
              be set to the low nibble of the profile-independent check status of type
              E2E_PCheckStatusType. (RS_E2E_08538)
         </description>
         <comment>
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00169.PRN</srcid><srcstatus/><internalId>37</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00114</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            If inputBufferLength == 0, then E2EXf_Inv_&lt;transformerId&gt; shall set
            *bufferLength = 0, otherwise it shall set
            *bufferLength = inputBufferLength - BufferProperties.headerLength/8.
            (RS_E2E_08538)
         </description>
         <comment>
            Incorporated RfC 69897 'Inconsequent usage of bits and bytes for
            BufferProperties.headerLength' and
            RfC 69321 'Correction of calculation of bufferLength'.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00114.PRN</srcid><srcstatus/><internalId>23</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00167</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server-Communication on the server side, if the return value ret equals
            to E_SAFETY_*_ERR, the value shall be overwritten to E_E2E_HARD_SAFETY_ERR.
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00167.PRN</srcid><srcstatus/><internalId>24</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00037</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, ASR R22-11</source>
         <version>2</version>
         <description>
            Mandatory Interfaces
            API function         Description
            E2E_P01Check           Checks the Data received using the E2E profile 1. This includes CRC
                                   calculation, handling of Counter and Data ID.
            E2E_P01CheckInit       Initializes the check state
            E2E_P01Forward (draft) Protects data which is forwarded by using the E2E profile 01.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P01MapStatusToSM   The function maps the check status of Profile 1 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 1 delivers a more fine-granular status, but this is not
                                   relevant for the E2E state machine.
            E2E_P01Protect         Protects the array/buffer to be transmitted using the E2E profile 1.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P01ProtectInit     Initializes the protection state.
            E2E_P02Check           Check the array/buffer using the E2E profile 2. This includes checksum
                                   calculation, handling of sequence counter and Data ID.
            E2E_P02CheckInit       Initializes the check state
            E2E_P02Forward (draft) Protects data which is forwarded by using the E2E profile 02.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P02MapStatusToSM   The function maps the check status of Profile 2 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 2 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P02Protect         Protects the array/buffer to be transmitted using the E2E profile 2.
                                   This includes checksum calculation, handling of sequence counter and
                                   Data ID.
            E2E_P02ProtectInit     Initializes the protection state.
            E2E_P04Check           Checks the Data received using the E2E profile 4. This includes CRC
                                   calculation, handling of Counter and Data ID.
            E2E_P04CheckInit       Initializes the check state
            E2E_P04Forward (draft) Protects data which is forwarded by using the E2E profile 04.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P04MapStatusToSM   The function maps the check status of Profile 4 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 4 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P04Protect         Protects the array/buffer to  be transmitted using the E2E profile 4.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P04ProtectInit     Initializes the protection state.
            E2E_P04mCheckInit      Initializes the check state
            E2E_P04mForward (draft)Protects data which is forwarded by using the E2E profile 04m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P04mMapStatusToSM  The function maps the check status of Profile 4m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 4m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P04mProtect        Protects the array/buffer to  be transmitted using the E2E profile 4.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P04mProtectInit    Initializes the protection state.
            E2E_P04mSinkCheck      Checks the Data received using the E2E profile 4m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
            E2E_P04mSourceCheck    Checks the Data received using the E2E profile 4m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
            E2E_P05Check           Checks the Data received using the E2E profile 5. This includes CRC
                                   calculation, handling of Counter. The function checks only one single
                                   data in one cycle, it does not determine/compute the accumulated state
                                   of the communication link.
            E2E_P05CheckInit       Initializes the check state
            E2E_P05Forward (draft) Protects data which is forwarded by using the E2E profile 05.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P05MapStatusToSM   The function maps the check status of Profile 5 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 5 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P05Protect         Protects the array/buffer to be transmitted using the E2E profile 5. This
                                   includes checksum calculation, handling of counter.
            E2E_P05ProtectInit     Initializes the protection state.
            E2E_P06Check           Checks the Data received using the E2E profile 6. This includes CRC
                                   calculation, handling of Counter. The function checks only one single
                                   data in one cycle, it does not determine/compute the accumulated state
                                   of the communication link.
            E2E_P06CheckInit       Initializes the check state
            E2E_P06Forward (draft) Protects data which is forwarded by using the E2E profile 06.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P06MapStatusToSM   The function maps the check status of Profile 6 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 6 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P06Protect         Protects the array/buffer to be transmitted using the E2E profile 6.
                                   This includes checksum calculation, handling of counter.
            E2E_P06ProtectInit     Initializes the protection state.
            E2E_P07Check           Checks the Data received using the E2E profile 7. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P07CheckInit       Initializes the check state
            E2E_P07Forward (draft) Protects data which is forwarded by using the E2E profile 07.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P07MapStatusToSM   The function maps the check status of Profile 7 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 7 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P07Protect         Protects the array/buffer to be transmitted using the E2E profile 7.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P07ProtectInit     Initializes the protection state.
            E2E_P07mCheckInit      Initializes the check state
            E2E_P07mForward (draft)Protects data which is forwarded by using the E2E profile 07m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P07mMapStatusToSM  The function maps the check status of Profile 7m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 7m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P07mProtect        Protects the array/buffer to  be transmitted using the E2E profile 7m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P07mProtectInit    Initializes the protection state.
            E2E_P07mSinkCheck      Checks the Data received using the E2E profile 7m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P07mSourceCheck    Checks the Data received using the E2E profile 7m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P07Check           Checks the Data received using the E2E profile 7. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P07CheckInit       Initializes the check state
            E2E_P07Forward (draft) Protects data which is forwarded by using the E2E profile 07.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P07MapStatusToSM   The function maps the check status of Profile 7 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 7 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P07Protect         Protects the array/buffer to be transmitted using the E2E profile 7.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P07ProtectInit     Initializes the protection state.
            E2E_P07mCheckInit      Initializes the check state
            E2E_P07mForward (draft)Protects data which is forwarded by using the E2E profile 07m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P07mMapStatusToSM  The function maps the check status of Profile 7m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 7m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P07mProtect        Protects the array/buffer to  be transmitted using the E2E profile 7m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P07mProtectInit    Initializes the protection state.
            E2E_P07mSinkCheck      Checks the Data received using the E2E profile 7m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P07mSourceCheck    Checks the Data received using the E2E profile 7m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P08Check           Checks the Data received using the E2E profile 8. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P08CheckInit       Initializes the check state
            E2E_P08Forward (draft) Protects data which is forwarded by using the E2E profile 08.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P08MapStatusToSM   The function maps the check status of Profile 8 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 8 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P08mCheckInit      Initializes the check state
            E2E_P08mForward (draft)Protects data which is forwarded by using the E2E profile 08m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P08mMapStatusToSM  The function maps the check status of Profile 8m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 8m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P08mProtect        Protects the array/buffer to  be transmitted using the E2E profile 8m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P08mProtectInit    Initializes the protection state.
            E2E_P08mSinkCheck      Checks the Data received using the E2E profile 8m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P08mSourceCheck    Checks the Data received using the E2E profile 8m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P08Check           Checks the Data received using the E2E profile 8. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P08CheckInit       Initializes the check state
            E2E_P08Forward (draft) Protects data which is forwarded by using the E2E profile 08.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P08MapStatusToSM   The function maps the check status of Profile 8 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 8 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P08Protect         Protects the array/buffer to be transmitted using the E2E profile 8.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P08ProtectInit     Initializes the protection state.
            E2E_P08mCheckInit      Initializes the check state
            E2E_P08mForward (draft)Protects data which is forwarded by using the E2E profile 08m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P08mMapStatusToSM  The function maps the check status of Profile 8m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 8m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P08mProtect        Protects the array/buffer to  be transmitted using the E2E profile 8m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P08mProtectInit    Initializes the protection state.
            E2E_P08mSinkCheck      Checks the Data received using the E2E profile 8m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P08mSourceCheck    Checks the Data received using the E2E profile 8m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P08Protect         Protects the array/buffer to be transmitted using the E2E profile 8.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P08ProtectInit     Initializes the protection state.
            E2E_P11Check           Checks the Data received using the E2E profile 11. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P11CheckInit       Initializes the check state
            E2E_P11Forward (draft) Protects data which is forwarded by using the E2E profile 11.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P11MapStatusToSM   The function maps the check status of Profile 11 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 11 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P11Protect         Protects the array/buffer to be transmitted using the E2E profile 11.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P11ProtectInit     Initializes the protection state.
            E2E_P22Check           Checks the Data received using the E2E profile 22. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P22CheckInit       Initializes the check state
            E2E_P22Forward (draft) Protects data which is forwarded by using the E2E profile 22.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P22MapStatusToSM   The function maps the check status of Profile 22 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 22 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P22Protect         Protects the array/buffer to be transmitted using the E2E profile 22.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P22ProtectInit     Initializes the protection state.
            E2E_P44Check           Checks the Data received using the E2E profile 44. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P44CheckInit       Initializes the check state
            E2E_P44Forward (draft) Protects data which is forwarded by using the E2E profile 44.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P44MapStatusToSM   The function maps the check status of Profile 44 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 44 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P44mCheckInit      Initializes the check state
            E2E_P44mForward (draft)Protects data which is forwarded by using the E2E profile 44m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P44mMapStatusToSM  The function maps the check status of Profile 44m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 44m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P44mProtect        Protects the array/buffer to  be transmitted using the E2E profile 44m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P44mProtectInit    Initializes the protection state.
            E2E_P44mSinkCheck      Checks the Data received using the E2E profile 44m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P44mSourceCheck    Checks the Data received using the E2E profile 44m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P44Check           Checks the Data received using the E2E profile 44. This includes CRC
                                   calculation, handling of Counter and Data ID. The function checks only
                                   one single data in one cycle, it does not determine/compute the
                                   accumulated state of the communication link.
            E2E_P44CheckInit       Initializes the check state
            E2E_P44Forward (draft) Protects data which is forwarded by using the E2E profile 44.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P44MapStatusToSM   The function maps the check status of Profile 44 to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 44 delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P44Protect         Protects the array/buffer to be transmitted using the E2E profile 44.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P44ProtectInit     Initializes the protection state.
            E2E_P44mCheckInit      Initializes the check state
            E2E_P44mForward (draft)Protects data which is forwarded by using the E2E profile 44m.
                                   This includes checksum calculation, handling of counter and Data ID.
                                   Detected Errors of received message will be reconstruct on output data.
            E2E_P44mMapStatusToSM  The function maps the check status of Profile 44m to a generic check
                                   status, which can be used by E2E state machine check function. The E2E
                                   Profile 44m delivers a more fine-granular status, but this is not relevant
                                   for the E2E state machine.
            E2E_P44mProtect        Protects the array/buffer to  be transmitted using the E2E profile 44m.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P44mProtectInit    Initializes the protection state.
            E2E_P44mSinkCheck      Checks the Data received using the E2E profile 44m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data sink
                                   (i.e., in case of C/S communication at the server)
            E2E_P44mSourceCheck    Checks the Data received using the E2E profile 44m.
                                   This includes CRC calculation, handling of Counter, Data ID,
                                   Message Type, Message Result, and Source ID.
                                   The function checks only one single data in one cycle, it does not
                                   determine/compute the accumulated state of the communication link.
                                   This function is intended for usage at the data source
                                   (i.e., in case of C/S communication at the client).
            E2E_P44Protect         Protects the array/buffer to be transmitted using the E2E profile 44.
                                   This includes checksum calculation, handling of counter and Data ID.
            E2E_P44ProtectInit     Initializes the protection state.
            E2E_SMCheck            Checks the communication channel. It determines if the data can
                                   be used for safety-related application, based on history of
                                   checks performed by a corresponding E2E_P0XCheck() function.
            E2E_SMCheckInit        Initializes the state machine.
            (RS_E2E_08538)
         </description>
         <comment>
            ForwardStatus feature added in R22-11.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00037.PRN</srcid><srcstatus/><internalId>25</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>

      <specobject>
         <id>E2E.SWS_Xfrm_00108</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_TransformerGeneral.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If (EndToEndTransformationDescription.upperHeaderBitsTo
            Shift &gt; 0), in-place E2EXf_&lt;transformerId&gt; shall copy the amount upper HeaderBits
            ToShiftbits, in parameter buffer, with starting offset of BufferProperties.headerLength,
            in direction left by "distance" of BufferProperties.headerLength.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_Xfrm_00108.PRN</srcid><srcstatus/><internalId>26</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
      
      <specobject>
         <id>E2E.SWS_Xfrm_00032</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_TransformerGeneral.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            A safety transformer shall return one of the errors shown in Table below
        -----------------------------------------------------------------------------
        Error Name                 | Error Code | Error Type | Description
        -----------------------------------------------------------------------------
        E_OK                       | 0x00       | -          | The communication is safe.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_REP         | 0x01       | Soft       | The data are valid according to
                                                               safety, although data with a re-
                                                               peated counter were received.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_SEQ         | 0x02       | Soft       | The data are valid according to
                                                               safety, although a counter jump
                                                               occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_ERR         | 0x03       | Soft       | The data are valid according to
                                                               safety, although the check itself
                                                               failed.
        -----------------------------------------------------------------------------
        E_SAFETY_VALID_NND         | 0x05       | Soft       | Communication is valid according to
                                                               safety, but no new data received.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_OK         | 0x20       | Soft       | No data are available since ini-
                                                               tialization of transformer.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_REP        | 0x21       | Soft       | No data are available since
                                                               initialization of transformer be-
                                                               cause a repeated counter was
                                                               received.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_SEQ        | 0x22       | Soft       | No data are available since ini-
                                                               tialization of transformer and a
                                                               counter jump occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_ERR        | 0x23       | Soft       | No data are available since ini-
                                                               tialization of transformer. There-
                                                               fore the check failed.
        -----------------------------------------------------------------------------
        E_SAFETY_NODATA_NND        | 0x25       | Soft       | No data are available since
                                                               initialization of transformer.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_OK           | 0x30       | Soft       | Not enough data were received
                                                               to use them.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_REP          | 0x31       | Soft       | Not enough data were received
                                                               to use them but some with a re-
                                                               peated counter were received.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_SEQ          | 0x32       | Soft       | Not enough data were received
                                                               to use them, additionally a
                                                               counter jump occurred.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_ERR          | 0x33       | Soft       | Not enough data were received
                                                               to use them, additionally a check
                                                               failed.
        -----------------------------------------------------------------------------
        E_SAFETY_INIT_NND          | 0x35       | Soft       | Not enough data were received to use
                                                               them, additionally no new data
                                                               received.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_OK        | 0x40       | Soft       | The data are invalid and cannot
                                                               be used.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_REP       | 0x41       | Soft       | The data are invalid and can-
                                                               not be used because a repeated
                                                               counter was received.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_SEQ       | 0x42       | Soft       | The data are invalid and cannot
                                                               be used due to a counter jump.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_ERR       | 0x43       | Soft       | The data are invalid and cannot
                                                               be used because a check failed.
        -----------------------------------------------------------------------------
        E_SAFETY_INVALID_NND       | 0x45       | Soft       | Communication is invalid according to
                                                               safety and no new data received
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_OK           | 0x60       | Soft       | Communication is safe, Statemachine
                                                               is not active.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_REP          | 0x61       | Soft       | Data with a repeated counter were
                                                               received. E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_SEQ          | 0x62       | Soft       | A counter jump occurred.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_ERR          | 0x63       | Soft       | The data are invalid and cannot
                                                               be used because a check failed.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_NND          | 0x65       | Soft       | No new data available.
                                                               E2EStateMachine disabled.
        -----------------------------------------------------------------------------
        E_SAFETY_NOSM_DEC          | 0x66       | Soft       | Disabled E2E State machine and
                                                               disabled E2E check.
        -----------------------------------------------------------------------------
        E_SAFETY_SOFT_RUNTIMEERROR | 0x77       | Soft       | A runtime error occurred, safety
                                                               properties could not be checked
                                                               (state or status cannot be deter-
                                                               mined) but non-protected output
                                                               data could be produced nonethe-
                                                               less.
        -----------------------------------------------------------------------------
        E_E2E_HARD_SAFETY_ERR      | 0x8d       | Hard       | Not further specified E2E error
        -----------------------------------------------------------------------------
        E_SAFETY_HARD_RUNTIMEERROR | 0xFF       | Hard       | A runtime error occurred, safety
                                                               properties could not be checked
                                                               and NO output data could be pro-
                                                               duced.
        -----------------------------------------------------------------------------
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_Xfrm_00032.PRN</srcid><srcstatus/><internalId>27</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>

      <specobject>
         <id>E2E.SWS_Xfrm_00051</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_TransformerGeneral.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If a transformer returns a hard error, it shall leave the output buffer unchanged
            (SRS_Xfrm_00004)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
            <release>AUTOSAR 4.2.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_Xfrm_00051.PRN</srcid><srcstatus/><internalId>28</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00047</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>2</version>
         <description>
            Imported Types
            Module:Imported Type
            E2E:
            E2E_P01CheckStateType
            E2E_P01CheckStatusType
            E2E_P01ConfigType
            E2E_P01DataIDMode
            E2E_P01ProtectStateType
            E2E_P02CheckStateType
            E2E_P02CheckStatusType
            E2E_P02ConfigType
            E2E_P02ProtectStateType
            E2E_P04CheckStateType
            E2E_P04CheckStatusType
            E2E_P04ConfigType
            E2E_P04ProtectStateType
            E2E_P04mCheckStateType
            E2E_P04mCheckStatusType
            E2E_P04mConfigType
            E2E_P04mProtectStateType
            E2E_P05CheckStateType
            E2E_P05CheckStatusType
            E2E_P05ConfigType
            E2E_P05ProtectStateType
            E2E_P06CheckStateType
            E2E_P06CheckStatusType
            E2E_P06ConfigType
            E2E_P06ProtectStateType
            E2E_P07CheckStatusType
            E2E_P07CheckStateType
            E2E_P07ConfigType
            E2E_P07ProtectStateType
            E2E_P07mCheckStateType
            E2E_P07mCheckStatusType
            E2E_P07mConfigType
            E2E_P07mProtectStateType
            E2E_P08CheckStateType
            E2E_P08CheckStatusType
            E2E_P08ConfigType
            E2E_P08ProtectStateType
            E2E_P08mCheckStateType
            E2E_P08mCheckStatusType
            E2E_P08mConfigType
            E2E_P08mProtectStateType
            E2E_P11CheckStatusType
            E2E_P11CheckStateType
            E2E_P11ConfigType
            E2E_P11DataIDMode
            E2E_P11ProtectStateType
            E2E_P22CheckStateType
            E2E_P22CheckStatusType
            E2E_P22ConfigType
            E2E_P22ProtectStateType
            E2E_P44CheckStateType
            E2E_P44CheckStatusType
            E2E_P44ConfigType
            E2E_P44ProtectStateType
            E2E_P44mCheckStateType
            E2E_P44mCheckStatusType
            E2E_P44mConfigType
            E2E_P44mProtectStateType
            E2E_PCheckStatusType
            E2E_SMCheckStateType
            E2E_SMConfigType
            E2E_SMStateType
            Std_Types:
            Std_ExtractProtocolHeaderFieldsType
            Std_MessageResultType
            Std_MessageTypeType
            Std_ReturnType
            Std_TransformerForwardCode (draft)
            Std_VersionInfoType
         </description>
         <comment>
            This requirement was adapted for profile E2EP07 and E2EP11 with SWS Release 4.3.0.
         </comment>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00047.PRN</srcid><srcstatus/><internalId>35</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00175</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side, if the
            E2E_PXXCheck function returns a value different from E2E_P_OK, the status shall be
            set to E2E_P_ERR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00175.PRN</srcid><srcstatus/><internalId>36</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00173</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and
            Profile is P04, P05, P06, P07, P08, P11, P22 or P44, P04m, P07m, P08m, P44m
            state-&gt;Counter of E2EXf_Inv_&lt;transformerId&gt; shall be set to the requestCounter - 1.
            (RS_E2E_08538)
         </description>
         <comment/>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00173.PRN</srcid><srcstatus/><internalId>38</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00172</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and Profile is P01 or P02,
            state-&gt;LastValidCounter of E2EXf_Inv_&lt;transformerId&gt; shall be set to the
            requestCounter-1.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00172.PRN</srcid><srcstatus/><internalId>39</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00203</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profile P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_Inv_&lt;transformerId&gt; on the server-side shall set the e2eCounter element
            of the csTransactionHandle to the value of the local variable receivedRequestCounter.
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00203.PRN</srcid><srcstatus/><internalId>40</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00202</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profile P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_Inv_&lt;transformerId&gt; on the server-side shall set the e2eSourceId element
            of the csTransactionHandle to the value of the local variable sourceID.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00202.PRN</srcid><srcstatus/><internalId>41</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00201</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For PXX = P04m, P07m, P08m and P44m: the function E2EXf_Inv_&lt;transformerId&gt; on the
            server-side shall invoke E2E_PXXSinkCheck(), passing to that function:
            - config,
            - state,
            - the local variables messageType, messageResult, and the address of the local variable
            sourceID
            - data length:
              inputBufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            - pointer to data:
              . inputBuffer + EndToEndTransformationDescription.upperHeaderBitsToShift
              (out-of-place version) or
              . buffer + EndToEndTransformationDescription.upperHeaderBitsToShift (in-place version).
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00201.PRN</srcid><srcstatus/><internalId>42</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00200</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For PXX = P04m, P07m, P08m and P44m: the function E2EXf_Inv_&lt;transformerId&gt; on
            the client-side shall invoke E2E_PXXSourceCheck(), passing to that function:
            - config,
            - state,
            - the local variables messageType, messageResult, and the local variable sourceID
            - data length:
              inputBufferLength – EndToEndTransformationDescription.upperHeaderBitsToShift
            - pointer to data:
                . inputBuffer + EndToEndTransformationDescription.upperHeaderBitsToShift
                  (out-of-place version) or
                . buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
                  (in-place version).
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00200.PRN</srcid><srcstatus/><internalId>43</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00199</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_Inv_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00199.PRN</srcid><srcstatus/><internalId>44</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00198</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_Inv_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields()
            function passing the inputBuffer, the inputBufferLength,
            the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00198.PRN</srcid><srcstatus/><internalId>45</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00197</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_Inv_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields() function
            passing the buffer, the bufferLength, the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00197.PRN</srcid><srcstatus/><internalId>46</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00196</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place
            and the out-of-place E2EXf_Inv_&lt;transformerId&gt; on the client-side shall
            set a local variable sourceID to the sourceID stored in the configuration
            (see SWS_E2EXf_00126).(RS_E2E_08538).
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00196.PRN</srcid><srcstatus/><internalId>47</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00194</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_Inv_&lt;transformerId&gt;
            on the client-side shall call the extractProtocolHeaderFields() function passing the
            inputBuffer, the inputBufferLength, the address of a local variable named messageType,
            and the address of a local variable named messageResult as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00194.PRN</srcid><srcstatus/><internalId>48</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00193</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_Inv_&lt;transformerId&gt; on
            the client-side shall call the extractProtocolHeaderFields() function passing
            the buffer, the bufferLength, the address of local messageType variable, and
            the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00193.PRN</srcid><srcstatus/><internalId>49</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00192</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_Inv_&lt;transformerId&gt; shall perform the following additional
            precondition checks, without continuing further processing:
            1. extractProtocolHeaderFields == NULL
            2. csTransactionHandle == NULL.
            If any of above conditions is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00192.PRN</srcid><srcstatus/><internalId>50</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00191</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If DataTransformationStatusForwarding is set to transformerStatusForwarding and
            PXX = P04m, P07m, P08m or P44m: The function E2EXf_&lt;transformerId&gt;()
            shall invoke E2E_PXXForward(), passing to that function:
             - the appropriate Config structure (see [SWS_E2EXf_00125]),
             - the appropriate State structure (see [SWS_E2EXf_00126]),
             - the local variables sourceID, messageType, and messageResult
             - buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
             - bufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            Hereby buffer and bufferLength were updated according to the above requirements
            SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00191.PRN</srcid><srcstatus/><internalId>51</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

      <specobject>
        <id>E2E.SWS_E2EXf_00168</id>
        <status>approved</status> <!-- draft in R22-11 -->
        <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
        <version>1</version>
        <description>
          If DataTransformationStatusForwarding is set to transformerStatusForwarding and
          PXX is P01, P02, P04, P05, P06, P07, P08, P11, P22 or P44 the function
          E2EXf_&lt;transformerId&gt;() shall invoke E2E_PXXForward(), passing to that function
          the appropriate Config and State structures (see [SWS_E2EXf_00125] and [SWS_E2EXf_00126])
          that are associated with &lt;transformerId&gt;, as well as buffer and bufferLength
          (only for P04, P05, P06, P07, P08, P11, P22 and P44) that were updated in requirements
          SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111.
          In addition the parameter ForwardStatus shall be passed to the E2E_PXXForward() function,
          which is provided by the RTE. This parameter is associated with the optional IN parameter
          ForwardStatus from Rte_Write (SWS_Rte_01071), Rte_Send (SWS_Rte_01072),
          Rte_IWrite (SWS_Rte_03744) and Rte_IWriteRef (SWS_Rte_05509)(RS_E2E_08538)
        </description>
        <releases>
          <release>AUTOSAR CP R22-11</release>
        </releases>
        <needscoverage>
          <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00168.PRN</srcid><srcstatus/><internalId>52</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00190</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If DataTransformationStatusForwarding is set to noTransformerStatusForwarding
            and PXX = P04m, P07m, P08m or P44m the function E2EXf_&lt;transformerId&gt;()
            shall invoke E2E_PXXProtect(), passing to that function:
             - the appropriate Config structure (see [SWS_E2EXf_00125]),
             - the appropriate State structure (see [SWS_E2EXf_00126]),
             - the local variables sourceID, messageType, and messageResult
             - buffer + EndToEndTransformationDescription.upperHeaderBitsToShift
             - bufferLength - EndToEndTransformationDescription.upperHeaderBitsToShift
            Hereby buffer and bufferLength were updated according to the requirements
            SWS_E2EXf_00108, SWS_E2EXf_00109, SWS_E2EXf_00115, SWS_E2EXf_00111. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00190.PRN</srcid><srcstatus/><internalId>53</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00166</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If E2E-Transformer is used in a Client-Server Communication and
            Profile is P01, P04, P04m, P05, P06, P07, P07m, P08, P08m, P11, P44 or P44m
            the sequence counter for protecting the response shall be set to requestCounter.
            (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00166.PRN</srcid><srcstatus/><internalId>54</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00208</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            The function E2EXf_MapCodeToStatus shall return the values depending on the value of
            forwardedCode.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00208.PRN</srcid><srcstatus/><internalId>55</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00165</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If E2E-Transformer is used for a response in a Client-Server Communication and
            Profile is P02 or P22 the sequence counter used for protecting the response shall
            be set to requestCounter -1. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00165.PRN</srcid><srcstatus/><internalId>56</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00189</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt; on the server-side shall
            set a local variable named requestCounter to the value of the e2eCounter element
            of the csTransactionHandle. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00189.PRN</srcid><srcstatus/><internalId>57</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00188</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt;
            on the server-side shall set a local variable sourceID to the value of the e2eSourceId
            element of the csTransactionHandle. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00188.PRN</srcid><srcstatus/><internalId>58</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00187</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00187.PRN</srcid><srcstatus/><internalId>59</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00186</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_&lt;transformerId&gt;
            on the server-side shall call the extractProtocolHeaderFields() function passing the
            inputBuffer, the inputBufferLength, the address of local messageType variable,
            and the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00186.PRN</srcid><srcstatus/><internalId>60</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

      <specobject>
        <id>E2E.SWS_E2EXf_00185</id>
        <status>approved</status>
        <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
        <version>1</version>
        <description>
           For profiles P04m, P07m, P08m and P44m the in-place E2EXf_&lt;transformerId&gt; on
           the server-side shall call the extractProtocolHeaderFields() function passing the buffer,
           the bufferLength, the address of local messageType variable, and the address of a local
           messageResult variable as parameters.
        </description>
        <releases>
           <release>AUTOSAR CP R22-11</release>
        </releases>
        <needscoverage>
           <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00185.PRN</srcid><srcstatus/><internalId>61</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00184</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and the out-of-place
            E2EXf_&lt;transformerId&gt; on the client-side shall set a local variable sourceID
            to the sourceID stored in the configuration (see SWS_E2EXf_00126).
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00184.PRN</srcid><srcstatus/><internalId>62</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00183</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If extractProtocolHeaderFields() returns something different from E_OK,
            E2EXf_&lt;transformerId&gt; shall return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00183.PRN</srcid><srcstatus/><internalId>63</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00181</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the in-place E2EXf_&lt;transformerId&gt;
            on the client-side shall call the extractProtocolHeaderFields() function passing
            the buffer, the bufferLength, the address of local messageType variable, and
            the address of a local messageResult variable as parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00181.PRN</srcid><srcstatus/><internalId>64</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00182</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m the out-of-place E2EXf_&lt;transformerId&gt; on
            the client-side shall call the extractProtocolHeaderFields() function passing
            the inputBuffer, the inputBufferLength, the address of a local variable
            named messageType, and the address of a local variable named messageResult as
            parameters.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00182.PRN</srcid><srcstatus/><internalId>65</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00171</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If E2EXf_&lt;transformerId&gt; is used in a Client-Server Communication on the client-side
            and Profile is P01, P04, P05, P06, P07, P08, P11 or P44, P04m, P07m, P08m, P44m
            state-&gt;Counter - 1 shall be stored as requestCounter to be accessed by the
            E2EXf_Inv_&lt;transformerId&gt; for checking the response. (RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00171.PRN</srcid><srcstatus/><internalId>66</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00170</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            If E2EXf_&lt;transformerId&gt; is used in a Client-Server Communication on the client-side
            and Profile is P02 or P22, state-&gt;Counter shall be stored to as requestCounter to be
            accessed by the E2EXf_Inv_&lt;transformerId&gt; for checking the response.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00170.PRN</srcid><srcstatus/><internalId>67</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00180</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            For profiles P04m, P07m, P08m and P44m both the in-place and
            the out-of-place E2EXf_&lt;transformerId&gt; shall perform the following
            additional precondition checks, without continuing further processing:
             1. extractProtocolHeaderFields == NULL
             2. csTransactionHandle == NULL.
            If any of above conditions is TRUE, then the function shall
            return E_SAFETY_HARD_RUNTIMEERROR.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00180.PRN</srcid><srcstatus/><internalId>68</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00206</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and Profile is P01 or P02,
            the receivedRequestCounter shall be set to state-&gt;LastValidCounter of
            E2EXf_Inv_&lt;transformerId&gt;.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00206.PRN</srcid><srcstatus/><internalId>69</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>

      <specobject>
         <id>E2E.SWS_E2EXf_00207</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_E2ETransformer.pdf, Release 22-11</source>
         <version>1</version>
         <description>
            In case of Client/Server Communication on the client side and Profile is P04, P05, P06,
            P07, P08, P11, P22, P44, P04m, P07m, P08m or P44m the receivedRequestCounter shall be
            set to state-&gt;Counter of E2EXf_Inv_&lt;transformerId&gt;.(RS_E2E_08538)
         </description>
         <releases>
            <release>AUTOSAR CP R22-11</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.SWS_E2EXf_00207.PRN</srcid><srcstatus/><internalId>70</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>

     <!--
         EB requirements valid for E2E profiles
     -->

      <specobject>
         <id>E2E.EB.SWS_E2EXf_00133</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If the E2E Transformer has not been correctly initialized (which means that
            E2EXf_[_&lt;PartitionId&gt;]_PartitionInit() was not successfully
            called before), then all generated E2E
            Transformer APIs shall immediately return E_SAFETY_HARD_RUNTIMEERROR.
         </description>
         <comment>
            This requirement replaces E2EXf.ASR421.SWS_E2EXf_00133.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.EB.SWS_E2EXf_00133.PRN</srcid><srcstatus/><internalId>29</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.InPlace.NoCopying</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If (buffer != NULL) &amp;&amp;
            (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), in-place
            E2EXf_&lt;transformerId&gt; shall keep buffer unchanged.
         </description>
         <comment>
            This requirement is based on requirement E2EXf.ASR421.SWS_E2EXf_00115
            but applied to in-place buffering for sake of completeness.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.EB.Transformer.InPlace.NoCopying.PRN</srcid><srcstatus/><internalId>30</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>

      <specobject>
         <id>E2E.EB.SWS_E2EXf_00021</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2EXf_[_&lt;PartitionId&gt;]_PartitionInit() function shall initialize
            all state structures managed by E2E transformer, calling the corresponding
            E2E_Init() method on each state variable.
         </description>
         <comment>
            This requirement replaces E2EXf.ASR421.SWS_E2EXf_00021
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.EB.SWS_E2EXf_00021.PRN</srcid><srcstatus/><internalId>32</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>

      <specobject>
         <id>E2E.EB.InvTransformer.InPlace.NoCopying</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            If (buffer != NULL) &amp;&amp;
            (EndToEndTransformationDescription.upperHeaderBitsToShift == 0), in-place
            E2EXf_Inv_&lt;transformerId&gt; shall keep buffer unchanged.
         </description>
         <comment>
            This requirement is based on requirement E2EXf.SWS_E2EXf_00116
            but applied to in-place buffering for sake of completeness.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.EB.InvTransformer.InPlace.NoCopying.PRN</srcid><srcstatus/><internalId>31</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.Server.ProtectStatePtrInputCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication, the E2EXf_&lt;transformerId&gt; on server-side shall perform the
            following additional precondition check, without continuing further processing:
            - ProtectStatePtr == NULL_PTR
            If the above condition is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.
         </description>
         <comment>
            Checking ProtectStatePtr for NULL_PTR is necessary as it is dereferenced
            and set by the RequestCounter of csTransactionHandlePtr-&gt;e2eCounter.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.EB.Transformer.Server.ProtectStatePtrInputCheck.PRN</srcid><srcstatus/><internalId>33</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>

      <specobject>
         <id>E2E.EB.InvTransformer.Client.ProtectStatePtrInputCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication, the E2EXf_Inv_&lt;transformerId&gt; on client-side shall perform the
            following additional precondition check, without continuing further processing:
            - ProtectStatePtr == NULL_PTR
            If the above condition is TRUE, then the function shall return
            E_SAFETY_HARD_RUNTIMEERROR.
         </description>
         <comment>
            Checking ProtectStatePtr for NULL_PTR is necessary as it is dereferenced
            to set the Counter member of CheckStatesPtr-&gt;PXXmCheckState.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.EB.InvTransformer.Client.ProtectStatePtrInputCheck.PRN</srcid><srcstatus/><internalId>34</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.Init</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In S/R communication each transformer can be initialized individually.
            While in C/S communication, at client end both non-inverse transformer and
            inverse transformer shall be initialized at the time same.
         </description>
         <comment>
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2E.EB.Transformer.Init.SR</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>E2E.EB.Transformer.Init.Client</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.Init.SR</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In S/R communication each transformer can be initialized individually.
            API used is &lt;transformerId&gt;_Init().
         </description>
         <comment>
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.EB.Transformer.Init.SR</srcid><srcstatus/><internalId>71</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
          <provcov>
            <linksto>E2E.EB.Transformer.Init</linksto>
            <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>

      <specobject>
         <id>E2E.EB.Transformer.Init.Client</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            In C/S communication at client end both non-inverse transformer and
            inverse transformer shall be initialized at the time same.
            API used is &lt;non-inversetransformerId&gt;_&lt;inversetransformerId&gt;_Init().
         </description>
         <comment>
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.EB.Transformer.Init.Client</srcid><srcstatus/><internalId>72</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
        <providescoverage>
          <provcov>
            <linksto>E2E.EB.Transformer.Init</linksto>
            <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>206</internalId></provcov>
        </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>

   </specobjects>
    <specobjects doctype="req">

    <!--
        Top Level requirements motivated by the Product Description
    -->

      <specobject>
         <id>E2E.top.001</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall implement a sequence counter mechanism
            to allow the protection and validation of communication data.
         </description>
         <comment>
            The modules E2EPxx contain the implementation of the sequence counter mechanism.
            The E2E module provides this generic requirement to have inter-module
            tracing unmodified with the removal or creation of new profiles.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.top.001</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>

      <specobject>
         <id>E2E.top.002</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall implement a data ID mechanism
            to allow the protection and validation of communication data.
         </description>
         <comment>
            The modules E2EPxx contain the implementation of the data ID mechanism.
            The E2E module provides this generic requirement to have inter-module
            tracing unmodified with the removal or creation of new profiles.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.top.002</srcid><srcstatus/><internalId>131</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>

      <specobject>
         <id>E2E.top.003</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall implement a Cyclic Redundancy Check mechanism
            to allow the protection and validation of communication data.
         </description>
         <comment>
            The modules E2EPxx contain the implementation of the Cyclic Redundancy
            Check mechanism.
            The E2E module provides this generic requirement to have inter-module
            tracing unmodified with the removal or creation of new profiles.
         </comment>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.top.003</srcid><srcstatus/><internalId>132</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>

      <!--
        Top Level requirements motivated by module specific behavior
    -->

      <specobject>
         <id>E2E.top.004</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall modularly structure static implementation files and data types.
         </description>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020115</srcid><srcstatus/><internalId>73</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020048</srcid><srcstatus/><internalId>75</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020037</srcid><srcstatus/><internalId>77</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020018</srcid><srcstatus/><internalId>79</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020200</srcid><srcstatus/><internalId>80</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020020</srcid><srcstatus/><internalId>82</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020021</srcid><srcstatus/><internalId>83</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020113</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020114</srcid><srcstatus/><internalId>129</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>

      <specobject>
         <id>E2E.top.005</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall check input parameter for validity.
         </description>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020047</srcid><srcstatus/><internalId>76</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020386</srcid><srcstatus/><internalId>86</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020389</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020608</srcid><srcstatus/><internalId>109</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020012</srcid><srcstatus/><internalId>115</internalId></linkedfrom><linkedfrom><srcid>EB_E2EPRN020023</srcid><srcstatus/><internalId>124</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>

      <specobject>
         <id>E2E.top.006</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall provide a mechanism to read the version number.
      </description>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_E2EPRN020033</srcid><srcstatus/><internalId>78</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>

      <specobject>
         <id>E2E.top.011</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
            The E2E module shall support client-server communication via methods for PXXm profiles.
         </description>
         <needscoverage>
            <needscov><needsobj>req</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>E2EPRN.top.005</srcid><srcstatus/><internalId>134</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>

   </specobjects>
    <specobjects doctype="req">

    <specobject>
      <id>E2EPRN.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>tcs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_E2EPRN_VerifyCodeStub</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.E2EPRN.SCrc</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>64</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
    <specobject>
      <id>dev.E2EPRN.ClientServer</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00166.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00171.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00173.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00172.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00206.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00167.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
    <specobject>
      <id>dev.E2EPRN.ProfileTypes</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/doc/public/changelog/Deviations.xml</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00047.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/build/reqm/common_req/E2EPRN_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(E2EPRN.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_ComTest_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Compile/IN/E2EPRN_ComTest_01/source/application/E2EPRN_ComTest_01.c</sourcefile>
      <sourceline>29</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
 &lt;para&gt;
 The End-to-End Communication Protection Library Module shall be translated.
 &lt;/para&gt;
 
Test Object: None.
Test Precondition: None.
Test Execution: 

 01: Call E2E_PRNProtect().
 02: VP(EB_E2EPRN020166):
 E2E_PRNProtect() shall be translated.
 03: Call E2E_PRNCheck().
 04: VP(EB_E2EPRN020158):
 E2E_PRNCheck() shall be translated.
 05: Call E2E_PRNProtectInit().
 06: VP(EB_E2EPRN020385):
 E2E_PRNProtectInit() shall be translated.
 07: Call E2E_PRNCheckInit().
 08: VP(EB_E2EPRN020390):
 E2E_PRNCheckInit() shall be translated.
 09: Call E2E_PRNMapStatusToSM().
 10: VP(EB_E2EPRN020382):
 E2E_PRNMapStatusToSM() shall be translated.
 11: Call E2E_PRNForward().
 12: VP(EB_E2EPRN020584):
 E2E_PRNForward() shall be translated.

 
Test Input: 
 
Test Output: 
 &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020166</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020158</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020385</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020390</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020382</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_ConTest_01_PRNProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_01_PRNProtect/source/application/E2EPRN_ConTest_01_PRNProtect.c</sourcefile>
      <sourceline>630</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 

  &lt;para&gt;
  The aspects stated below are done on valid input data only.

  1) (EB_E2EPRN020166,EB_E2EPRN020195)
    Test that E2E_PRNProtect()
    a) writes the Counter in the Data at the Counter position specified
       in the State data,
    b) writes DataID Nibble in Data (if E2E_PRN_DATAID_NIBBLE is used) at the Nibble
       position specified in the configuration data,
    c) computes the CRC over DataID (depending on DataID mode - see
       test aspects 5), 6), and 7)) and Data,
    d) writes the CRC in the Data at the CRC position provided in the configuration data, and
    e) increments the Counter in the State data.

  2) (EB_E2EPRN020075)
     Test that E2E_PRNProtect() increments the passed State Counter
     value by 1 up to 15, and then restarts with 0 again.

  3) (EB_E2EPRN020190)
     Test that E2E_PRNProtect() calls the SCrc_CalculateCRC8() function

  4) (EB_E2EPRN020070)
     Test that E2E_PRNProtect() uses CRC-8-SAE J1850 with 0 as start value and XOR value
     for the calculation of the CRC (That is,  SCrc_CalculateCRC8() is called
     with StartValue8=0).

  5) (EB_E2EPRN020163.1)
     Test that for DataId inclusion Mode E2E_PRN_DATAID_BOTH,
     first low byte and then high byte of the DataID are included in the CRC calculation
     step regarding the DataID.

  6) (EB_E2EPRN020163.3)
     Test that for DataID inclusion Mode E2E_PRN_DATAID_LOW,
     only low byte of the DataID is included in the CRC calculation
     step regarding the DataID.

  7) (EB_E2EPRN020163.4)
     Test that for DataID inclusion Mode E2E_PRN_DATAID_NIBBLE,
     the low Nibble of the high byte of the DataID
     is written to the Data (covered by CRC calculation when computing CRC over Data),
     and that first low byte of the DataID then value 0 is included
     in the CRC calculation step regarding the DataID.
  &lt;/para&gt;

  &lt;para&gt;
  Test strategies applied:
     Equivalence Class Partitioning:
       Test execution is done with a permutation of following parameters
          - E2E_PRNProtectStateType.Counter
          - E2E_PRNConfigType.CounterOffset
          - E2E_PRNConfigType.CRCOffset
          - E2E_PRNConfigType.DataIDNibbleOffset
          - E2E_PRNConfigType.DataIDMode
          - E2E_PRNConfigType.DataLength
          - E2E_PRNConfigType.DataID
        Note: The following parameters are not used at sender side and therefore not relevant:
           - MaxDeltaCounterInit
           - MaxNoNewOrRepeatedData
           - SyncCounterInit

     Pair wise tests: Tests are executed with a  combination of following parameters / values
          - DataIDMode
          - CRCOffset
          - CounterOffset
          - DataIDNibbleOffset (only relevant for E2E_PRN_DATAID_NIBBLE)

     Boundary Value Analysis in combination
     with test-case E2EPRN_ConTest_01_PRNProtect_InvalidInput (outside bound):
        DataIdMode: [E2E_PRN_DATAID_BOTH, E2E_PRN_DATAID_LOW, E2E_PRN_DATAID_NIBBLE]
        DataLength: MIN=2, MAX=30
        Counter: MIN=0, MAX=15; (First Byte, Last Byte, in between Data)
        DataId: MIN=0, MAX=0xFFFF (E2E_PRN_DATAID_BOTH)
                       MAX=0x0FFF (E2E_PRN_DATAID_NIBBLE)
                       MAX=0x00FF (E2E_PRN_DATAID_LOW)
        DataIDNibbleOffset: MIN=12, MAX=DataLength (low nibble and high nibble)
        CounterOffset: MIN=0, MAX=DataLength
        CRCOffset: MIN=0, MAX=DataLength
  &lt;/para&gt;


Test Object: None.
Test Precondition: None.
Test Execution: 

 010: Prepare CRC stub (SCrc_CalculateCRC8) to return the number of overall Stub calls
      XORed by 0xFF

For each stated TestDataBlock (InputTstCfg), execute the following steps:
 020: call the E2E_Protect function with following parameters:
      - Parameter Config points to following test-data
          Config.DataIDMode       = InputTstCfg.DataIDMode
          Config.DataID           = InputTstCfg.DataID
          Config.DataIDNibbleOffset = InputTstCfg.DataIDNibbleOffset
          Config.CRCOffset        = InputTstCfg.CRCOffset
          Config.CounterOffset    = InputTstCfg.CounterOffset
          Config.DataLength       = InputTstCfg.DataLength
          Config.TstData          = InputTstCfg.TstData
       - Parameter State points to following input data
          State.Counter           = InputTstCfg.Counter
       - Parameter Data points to valid input data
 030: VP (EB_E2EPRN020166):
     E2E_Protect function returns E2E_E_OK
 040: VP (EB_E2EPRN020075,EB_E2EPRN020166,EB_E2EPRN020195)
     State.Counter is updated as follows:
         If InputTstCfg.Counter==MAX(15) =&gt; State.Counter=0
         If InputTstCfg.Counter &lt; MAX(15) =&gt; State.Counter=InputTstCfg.Counter+1
 050: VP (EB_E2EPRN020166,EB_E2EPRN020195)
     TestData at position Config.CounterOffset (4 bits) equals InputTstCfg.Counter
 060: VP (EB_E2EPRN020166,EB_E2EPRN020163.4,EB_E2EPRN020195)
     If Config.DataIDMode=E2E_PRN_DATAID_NIBBLE =&gt;
       TestData at position Config.DataIDNibbleOffset (4 bits) equals
       the low Nibble of the high byte of Config.DataID
 070: VP (EB_E2EPRN020166,EB_E2EPRN020195)
     TestData at position Config.CRCOffset (8 bits) equals
     the number of overall calls to the SCrc_CalculateCRC8 CRC stub
 080: VP (EB_E2EPRN020166,EB_E2EPRN020190,EB_E2EPRN020070,EB_E2EPRN020163.1
          EB_E2EPRN020163.3,EB_E2EPRN020163.4,EB_E2EPRN020195)
      Number of SCrc_CalculateCRC8 CRC stub calls equals n where:
         IF Config.DataIDMode==E2E_PRN_DATAID_LOW
            and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=2 when datalength &gt;= 8 bytes, n=3 when datalength &lt; 8 bytes
         IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_LOW
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
         IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
            and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
         IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
           and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
         IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
           and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
         IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
 090: VP (EB_E2EPRN020195)
        No other data except CRC / Counter and DataId Nibble is modified in TestData
 100: VP (EB_E2EPRN020166,EB_E2EPRN020190,EB_E2EPRN020070,EB_E2EPRN020163.1
          EB_E2EPRN020163.3,EB_E2EPRN020163.4,EB_E2EPRN020195)
      1st call to SCrc_CalculateCRC8 CRC stub in this test iteration:
        - SCrc_DataPtr points to a value that equals the low byte of InputTstCfg.DataID
        - SCrc_Length equals 1
        - SCrc_StartValue8 equals 255
        - SCrc_IsFirstCall equals FALSE
 110: VP (EB_E2EPRN020166,EB_E2EPRN020190,EB_E2EPRN020070,EB_E2EPRN020163.1
          EB_E2EPRN020163.3,EB_E2EPRN020163.4,EB_E2EPRN020195)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on DataIdMode):
        If InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH:
         - SCrc_DataPtr points to a value that equals the high byte of InputTstCfg.DataID
         - SCrc_Length equals 1
         - SCrc_StartValue8 equals the SCrc return value from the previous stub call
           (number of overall SCrc stub calls XORed by 0xFFU)
         - SCrc_IsFirstCall equals FALSE
       If InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE:
         - SCrc_DataPtr points to a value 0
         - SCrc_Length equals 1
         - SCrc_StartValue8 equals the SCrc return value from the previous stub call
           (number of overall SCrc stub calls XORed by 0xFFU)
         - SCrc_IsFirstCall equals FALSE
 120: VP (EB_E2EPRN020166,EB_E2EPRN020190,EB_E2EPRN020070,EB_E2EPRN020163.1
          EB_E2EPRN020163.3,EB_E2EPRN020163.4,EB_E2EPRN020195)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
       if InputTstCfg.CRCOffset is first byte in TestData
          - SCrc_DataPtr points to 2nd byte of the data passed to E2E_Protect
          - SCrc_Length equals Config.DataLength-1
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls XORed by 0xFFU)
          - SCrc_IsFirstCall equals FALSE
       if InputTstCfg.CRCOffset is not first byte in TestData
          - SCrc_DataPtr points to 1st byte of the data passed to E2E_Protect
          - SCrc_Length equals Config.CRCOffset / 8 (excludes CRC value)
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls XORed by 0xFFU)
          - SCrc_IsFirstCall equals FALSE
 130: VP (EB_E2EPRN020166,EB_E2EPRN020190,EB_E2EPRN020070,EB_E2EPRN020163.1
          EB_E2EPRN020163.3,EB_E2EPRN020163.4,EB_E2EPRN020195)
      Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
       if InputTstCfg.CRCOffset is not first byte and not last byte
          - SCrc_DataPtr points to 1st byte after CRC byte in the TestData
          - SCrc_Length equals Config.DataLength-(Config.CRCOffset/8) (Data after CRC byte)
          - SCrc_StartValue8 equals the SCrc return value from the previous stub call
            (number of overall SCrc stub calls XORed by 0xFFU)
          - SCrc_IsFirstCall equals FALSE


Test Input: 

Note: MAX ... maximum possible counter value =  15

TestDataBlock 1 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_BOTH
  - CRC at first Byte
  - Counter at second Byte
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFF
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different size and values)

TestDataBlock 2 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_BOTH
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFF
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             16
InputTstCfg.CounterOffset:         28
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different size and values)

TestDataBlock 3 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_BOTH
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFF
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         52
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different values)



TestDataBlock 4 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC at first Byte
  - Counter at second Byte
  - DataID Nibble at bit position 12 (High Nibble)
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFF
InputTstCfg.DataIDNibbleOffset:    12
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different size and values)

TestDataBlock 5 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  - DataID Nibble at bit position 32  (Low Nibble)
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFF
InputTstCfg.DataIDNibbleOffset:    32
InputTstCfg.CRCOffset:             16
InputTstCfg.CounterOffset:         28
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                      { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different size and values)

TestDataBlock 6 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  - DataID Nibble at bit position 8 (Low Nibble)
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFF
InputTstCfg.DataIDNibbleOffset:    8
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         52
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different values)



TestDataBlock 7 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_LOW
  - CRC at first Byte
  - Counter at second Byte
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_LOW
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x00FF
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             0
InputTstCfg.CounterOffset:         8
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different size and values)

TestDataBlock 8 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_LOW
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_LOW
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x00FF
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             16
InputTstCfg.CounterOffset:         28
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different size and values)

TestDataBlock 9 test aspects:
=============================
  - DataIDMode E2E_PRN_DATAID_LOW
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
InputTstCfg.DataIDMode:            E2E_PRN_DATAID_LOW
InputTstCfg.DataID:                Different valid values from 0 to maximum 0x00FF
InputTstCfg.DataIDNibbleOffset:    0
InputTstCfg.CRCOffset:             56
InputTstCfg.CounterOffset:         52
InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
InputTstCfg.DataLength:            correct length of TstData
InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different values)


Test Output: 
  return value for all tests shall be E2E_E_OK
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020166</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020195</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_02_PRNProtectInit_Ok</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_01_PRNProtect/source/application/E2EPRN_ConTest_01_PRNProtect.c</sourcefile>
      <sourceline>1217</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

    Test that E2E_PRNProtectInit() initializes the state structure, setting Counter to 0.

  &lt;/para&gt;
  
Test Object: E2E_PRNProtectInit()
Test Precondition: None.
Test Execution: 

    01: Call E2E_PRNProtectInit() with valid parameter.
    02: VP(EB_E2EPRN020385,EB_E2EPRN020386):
        E2E_PRNProtectInit() returns E2E_E_OK.
        PRNCheckState.Counter is initialized with 0.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to E2E_E_OK status for E2E_PRNProtectInit() function)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020385</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_03_PRNProtectInit_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_01_PRNProtect/source/application/E2EPRN_ConTest_01_PRNProtect.c</sourcefile>
      <sourceline>1274</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

      Test that if E2E_PRNProtectInit() is called with StatePtr equal to NULL
      then E2E_PRNProtectInit() returns immediately with E2E_E_INPUTERR_NULL.

  &lt;/para&gt;
  
Test Object: E2E_PRNProtectInit()
Test Precondition: None.
Test Execution: 

    01: Call E2E_PRNProtectInit() with NULL parameter.
    02: VP(EB_E2EPRN020385,EB_E2EPRN020386,EB_E2EPRN020012,EB_E2EPRN020011,EB_E2EPRN020047):
        E2E_PRNProtectInit() returns E2E_E_INPUTERR_NULL.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to E2E_E_INPUTERR_NULL status for E2E_PRNProtectInit() function)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020385</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_04_PRNProtect_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_01_PRNProtect/source/application/E2EPRN_ConTest_01_PRNProtect.c</sourcefile>
      <sourceline>1335</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

    1) Check that the E2E-library function E2E_PRNProtect()
       returns the error codes E2E_E_INPUTERR_NULL if:
    - NULL_PTR is passed for configuration data / state data / data to be protected

    2) Check that the E2E-library function E2E_PRNProtect()
       returns the error codes E2E_E_INPUTERR_WRONG if:
    - Unsupported Data ID Inclusion Mode does not equal E2E_PRN_DATAID_ALT
    - invalid counter values in state data (maximum value exceeded)
    - invalid data length (not a multiple of 8, maximum value exceeded, value smaller than 16)
    - invalid crc offsets (greater than data length, )
    - invalid counter offset (greater than data length, )
    - invalid DataIDNibbleOffset in case of DataID mode not equal to E2E_PRN_DATAID_NIBBLE (!=0)
    - invalid DataId value in case of DataID mode E2E_PRN_DATAID_NIBBLE (value exceeds 12 bit limit)

    See also in the SWS section 7.2.1 Error classification
    (End-to-End Communication Protection Library V1.0.0 R4.0 Rev 1).

&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 
    The input/output parameter(s) shall hold the following
    value(s) for calling E2E_PRNProtect():
    01: set configuration to NULL
    02: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_NULL
    03: set sender state to NULL
    04: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_NULL
    05: set data to NULL
    06: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_NULL
    07: set all input parameters (configuration, sender state
        and data) to NULL
    08: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_NULL
    09: set all input parameters in RAM (sender state and data)
        to NULL
    10: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_NULL
    11: exceed maximum allowed State.Counter
    12: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    13: call with a data length which is not a multiple of 8
    14: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    15: call with a data length exceeding the maximum number of
        specified bits
    16: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    17: call with a data length smaller than 16 bits
    18: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    19: call with a crc offset greater than the configured data length
    20: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047,EB_E2EPRN020153)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    21: call with a counter offset greater than the configured data length
    22: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047,EB_E2EPRN020152)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    23: call with data id mode E2E_PRN_DATAID_ALT
    24 VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047,EB_E2EPRN020149)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    27: call with data id mode E2E_PRN_DATAID_BOTH and DataIDNibbleOffset != 0
    28 VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    29: call with data id mode E2E_PRN_DATAID_ALT and DataIDNibbleOffset != 0
    30 VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    31: call with data id mode E2E_PRN_DATAID_LOW and DataIDNibbleOffset != 0
    32 VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    33: call with data id mode E2E_PRN_DATAID_NIBBLE and DataID &gt;
        12bit value (0x1000U)
    34 VP (EB_E2EPRN020306)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    35: call with data id mode E2E_PRN_DATAID_NIBBLE and DataID &gt;
        12bit value (0xFFFFU)
    36 VP (EB_E2EPRN020306)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    37: call with data id mode E2E_PRN_DATAID_LOW and DataID &gt;
        8bit value (0x0100U)
    38 VP (EB_E2EPRN020169)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    39: call with data id mode E2E_PRN_DATAID_LOW and DataID &gt;
        8bit value (0xFFFFU)
    40 VP (EB_E2EPRN020169)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    41: call with data id mode E2E_PRN_DATAID_NIBBLE and a too high DataIdNibbleOffset)
        (i.e. Config-&gt;DataIDNibbleOffset + 4U) &gt; Config-&gt;DataLength)
    42: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020166,EB_E2EPRN020047)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG


Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020166</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020149</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020306</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_ConTest_01_PRNCheck_AllStates_DataIDModes</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>1607</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

    A) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_NONEWDATA with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    B) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_INITIAL with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    C) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_WRONGCRC with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    D) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_OK with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    E) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_REPEATED with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    F) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_WRONGSEQUENCE with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    G) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_OKSOMELOST with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    H) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_NONEWDATA with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    I) Test the correct behavior of the E2E-library
       for the function E2E_PRNCheck() by the path leading to
       E2E_PRNSTATUS_DATAINVALID with respect
       to different configurations of the DataIDMode and
       CRC / Counter / DataIDNibble offset values.

    Note:
      Additional test-cases do exist for some Status values
      which are either not tested here
      (e.g. TS_E2EPRN_ConTest_02_PRNCheckStatus_Sync)
      or have special test aspects which do not match
      with the Test Strategies applied here
      (e.g. additional parameters for Boundary Value analysis
      as it is the case for reaching Status E2E_PRNSTATUS_OKSOMELOST).

  &lt;/para&gt;

  &lt;para&gt;
  Test strategies applied:
     Equivalence Class Partitioning:
       Test execution is done with a permutation of following parameters
          - E2E_PRNProtectStateType.Counter
          - E2E_PRNConfigType.CounterOffset
          - E2E_PRNConfigType.CRCOffset
          - E2E_PRNConfigType.DataIDNibbleOffset
          - E2E_PRNConfigType.DataIDMode
          - E2E_PRNConfigType.DataLength
          - E2E_PRNConfigType.DataID
          - E2E_PRNConfigType.MaxDeltaCounterInit
          - E2E_PRNConfigType.MaxNoNewOrRepeatedData
          - E2E_PRNConfigType.SyncCounterInit

     Pair wise tests: Tests are executed with a  combination of following parameters / values
          - DataIDMode
          - CRCOffset
          - CounterOffset
          - DataIDNibbleOffset (only relevant for E2E_PRN_DATAID_NIBBLE)
          - MaxDeltaCounterInit
          - MaxNoNewOrRepeatedData
          - SyncCounterInit

     Boundary Value Analysis in combination
     with test-case E2EPRN_ConTest_01_PRNProtect_InvalidInput (outside bound):
        DataIdMode: [E2E_PRN_DATAID_BOTH, E2E_PRN_DATAID_LOW, E2E_PRN_DATAID_NIBBLE]
        DataLength: MIN=2, MAX=30
        Counter: MIN=0, MAX=15; (First Byte, Last Byte, in between Data)
        DataId: MIN=0, MAX=0xFFFF (E2E_PRN_DATAID_BOTH)
                       MAX=0x0FFF (E2E_PRN_DATAID_NIBBLE)
                       MAX=0x00FF (E2E_PRN_DATAID_LOW)
        DataIDNibbleOffset: MIN=12, MAX=DataLength (low nibble and high nibble)
        CounterOffset: MIN=0, MAX=DataLength
        CRCOffset: MIN=0, MAX=DataLength
        MaxDeltaCounterInit: MIN=0, MAX=15
        MaxNoNewOrRepeatedData: MIN=0, MAX=15
        SyncCounterInit: MIN=0, MAX=15
  &lt;/para&gt;


Test Object: None.
Test Precondition: None.
Test Execution: 

Execute the following steps several times with InputDataXX from input:
   01: Call E2E_PRNCheck() with
       - the E2E_PRNConfig stated in InputDataXX
       - the E2E_PRNCheckState stated in InputDataXX
       - the data VDxx stated in InputDataXX
   02: VP (see VPs of E2ETEST_GenericTest.xx)
       E2E_PRNCheck() returns the value stated in OutputDataXX
       E2E_PRNCheckState values are equal to values stated in OutputDataXX

   Additionally, the following VPs are checked within E2ETEST_GenericTest()
      E2ETEST_GenericTest.01: VP (EB_E2EPRN020196)
          The return value of E2E_PRNCheck()
          shall be equal to the value specified in OutputDataXX
      E2ETEST_GenericTest.02: VP (EB_E2EPRN020196)
          State-&gt;Status shall be equal to the value specified in OutputDataXX
      E2ETEST_GenericTest.03: VP (EB_E2EPRN020196)
          State-&gt;LastValidCounter shall hold the value specified in OutputDataXX
      E2ETEST_GenericTest.04: VP (EB_E2EPRN020196)
          The State-&gt;MaxDeltaCounter shall hold the value specified in OutputDataXX
      E2ETEST_GenericTest.05: VP (EB_E2EPRN020196)
          State-&gt;WaitForFirstData shall be equal to the value specified in OutputDataXX
      E2ETEST_GenericTest.06: VP (EB_E2EPRN020196)
          State-&gt;NewDataAvailable shall be equal to the value specified in OutputDataXX
      E2ETEST_GenericTest.07: VP (EB_E2EPRN020196)
          State-&gt;LostData shall be equal to the value specified in OutputDataXX
      E2ETEST_GenericTest.08: VP (EB_E2EPRN020196)
          State-&gt;NoNewOrRepeatedDataCounter
          shall be equal to the value specified in OutputDataXX
      E2ETEST_GenericTest.09: VP (EB_E2EPRN020196)
          State-&gt;SyncCounter
          shall be equal to the value specified in OutputDataXX
      E2ETEST_GenericTest.10: VP (EB_E2EPRN020196,EB_E2EPRN020190,EB_E2EPRN020163)
        Number of SCrc_CalculateCRC8 CRC stub calls equals n where:
         IF E2E_PRN_DATAID_LOW is configured in InputDataXX
            and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=2 when datalength &gt;= 8 bytes, n=3 when datalength &lt; 8 bytes
         IF E2E_PRN_DATAID_LOW is configured in InputDataXX
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
         IF E2E_PRN_DATAID_BOTH is configured in InputDataXX
            and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
         IF E2E_PRN_DATAID_BOTH is configured in InputDataXX
           and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
         IF E2E_PRN_DATAID_NIBBLE is configured in InputDataXX
           and InputTstCfg.CRCOffset is first or last byte in TestData
            =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
         IF E2E_PRN_DATAID_NIBBLE is configured in InputDataXX
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
            =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes

  The following VPs are checked within the SCrc_CalculateCRC8 stub
   (test aspect related to call of CalculateCRC8):
    EBTEST_CalculateCRC8_Callout.01: VP (EB_E2EPRN020163,EB_E2EPRN020070,EB_E2EPRN020070)
            1st call to SCrc stub regarding DataId:
            - SCrc_DataPtr points to a value that equals the low byte of the configured DataId
            - SCrc_Length equals 1
            - SCrc_StartValue8 equals 255
            - SCrc_IsFirstCall equals FALSE
    EBTEST_CalculateCRC8_Callout.02: VP (EB_E2EPRN020163,EB_E2EPRN020070,EB_E2EPRN020070)
            Next call (2nd call) to SCrc stub regarding DataId (depends on data-id mode):
              If DataIdMode equals E2E_PRN_DATAID_BOTH:
               - SCrc_DataPtr points to a value that equals the high byte of the configured DataId
               - SCrc_Length equals 1
               - SCrc_StartValue8 equals the SCrc return value from the previous stub call
                 (number of overall SCrc stub calls XORed by 0xFFU)
               - SCrc_IsFirstCall equals FALSE
              If DataIdMode equals E2E_PRN_DATAID_NIBBLE:
               - SCrc_DataPtr points to a value 0
               - SCrc_Length equals 1
               - SCrc_StartValue8 equals the SCrc return value from the previous stub call
                 (number of overall SCrc stub calls XORed by 0xFFU)
               - SCrc_IsFirstCall equals FALSE
    EBTEST_CalculateCRC8_Callout.03: VP (EB_E2EPRN020163,EB_E2EPRN020070,EB_E2EPRN020070)
            Next call (2nd or 3rd call) to SCrc stub regarding Data (depends on CRCOffsetByte):
            if CRCOffsetByte equals 0:
              - SCrc_DataPtr points to 2nd byte of the data passed to E2E_Protect
              - SCrc_Length equals the data length of complete array - 1 (excluding CRC)
              - SCrc_StartValue8 equals the SCrc return value from the previous stub call
                (number of overall SCrc stub calls XORed by 0xFFU)
              - SCrc_IsFirstCall equals FALSE
            if CRCOffsetByte does not equal 0:
              - SCrc_DataPtr points to 1st byte of the data passed to E2E_Protect
              - SCrc_Length equals \a CRCOffsetByte
              - SCrc_StartValue8 equals the SCrc return value from the previous stub call
                (number of overall SCrc stub calls XORed by 0xFFU)
              - SCrc_IsFirstCall equals FALSE
    EBTEST_CalculateCRC8_Callout.04: VP (EB_E2EPRN020163,EB_E2EPRN020070,EB_E2EPRN020070)
            Next call (3rd or 4th call) to SCrc stub regarding Data (depends on CRCOffsetByte):
            if CRCOffsetByte does not equal 0 and does not equal last byte in data array:
              - SCrc_DataPtr points to 1st byte after CRC byte of the data passed to E2E_Protect
              - SCrc_Length equals Array size of complete data minus \a CRCOffsetByte
              - SCrc_StartValue8 equals the SCrc return value from the previous stub call
                (number of overall SCrc stub calls XORed by 0xFFU)
              - SCrc_IsFirstCall equals FALSE
    EBTEST_CalculateCRC8_Callout.05:
            For last CalculateCRC8 call in a sequence:
                return the CRC value stated in InputDataXX
                (XORed by final XOR value = 0x00)
            else:
                return the number of overall SCrc stub calls XORed by 0xFFU


Test aspects of individual InputDataXX/OutputDataXX (Note X ... any stand for any digit):
    DataX00: VP (EB_E2EPRN020190,EB_E2EPRN020076)
          See Test aspect A)
    DataX01: VP (EB_E2EPRN020190,EB_E2EPRN020076)
          I) See Test aspect B)
    DataX02: VP (EB_E2EPRN020190)
          See Test aspect C)
    DataX03: VP (EB_E2EPRN020190,EB_E2EPRN020076)
          See Test aspect D)
    DataX04: VP (EB_E2EPRN020190)
          See Test aspect E)
    DataX05: VP (EB_E2EPRN020190)
          See Test aspect F)
    DataX06: VP (EB_E2EPRN020190)
          See Test aspect G)
    DataX07: Exists only for sake of sanity check.
    DataX08: VP (EB_E2EPRN020190)
          See Test aspect H)
    DataX09: VP (EB_E2EPRN020190)
          See Test aspect I) with correct CRC (DataInvalid shall be returned too)
    DataX10: VP (EB_E2EPRN020190)
          See Test aspect I) with incorrect CRC

  - Test Data Variation regarding DataIDModes:
    Data0XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.1)
          Tests that all Status values are set by the library for following configuration:
          DataIDMode = E2E_PRN_DATAID_BOTH
          CRC byte is placed in first byte of serialized data
          CRCOffset = 0, CounterOffset = 8
    Data1XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.1)
          Tests the correct behavior of library where
          DataIDMode = E2E_PRN_DATAID_BOTH
          CRC byte is placed in a byte in-between the serialized data
          CRCOffset = 16, CounterOffset = 28
    Data2XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.1, EB_E2EPRN020163.2)
          Tests that all Status values are set by the library for following configuration:
          DataIDMode = E2E_PRN_DATAID_BOTH
          CRC byte is placed in last byte of serialized data
          CRCOffset = 56, CounterOffset = 52
    Data3XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.3)
          Tests that all Status values are set by the library for following configuration:
          DataIDMode = E2E_PRN_DATAID_NIBBLE
          CRC byte is placed in first byte of serialized data
          CRCOffset = 0, CounterOffset = 8, DataIDNibble = 12
    Data4XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.3)
          Tests the correct behavior of library where
          DataIDMode = E2E_PRN_DATAID_NIBBLE
          CRC byte is placed in a byte in-between the serialized data
          CRCOffset = 16, CounterOffset = 28, DataIDNibble = 24
    Data5XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.3)
          Tests that all Status values are set by the library for following configuration:
          DataIDMode = E2E_PRN_DATAID_NIBBLE
          CRC byte is placed in last byte of serialized data
          CRCOffset = 56, CounterOffset = 52, DataIDNibble = 40
    Data6XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.4)
          Tests that all Status values are set by the library for following configuration:
          DataIDMode = E2E_PRN_DATAID_LOW
          CRC byte is placed in first byte of serialized data
          CRCOffset = 0, CounterOffset = 8, DataIDNibble = 12
    Data7XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.4)
          Tests the correct behavior of library where
          DataIDMode = E2E_PRN_DATAID_LOW
          CRC byte is placed in a byte in-between the serialized data
          CRCOffset = 16, CounterOffset = 28, DataIDNibble = 24
    Data8XX: VP (EB_E2EPRN020190,EB_E2EPRN020163.4)
          Tests that all Status values are set by the library for following configuration:
          DataIDMode = E2E_PRN_DATAID_LOW
          CRC byte is placed in last byte of serialized data
          CRCOffset = 56, CounterOffset = 52, DataIDNibble = 40

Used Test Strategies:
- Pair wise tests
  with respect to following sets:
  1) possible Status values set by E2E library: E2E_PRNSTATUS_NONEWDATA,
                                                E2E_PRNSTATUS_INITIAL,
                                                E2E_PRNSTATUS_WRONGCRC,
                                                E2E_PRNSTATUS_OK,
                                                E2E_PRNSTATUS_REPEATED,
                                                E2E_PRNSTATUS_WRONGSEQUENCE,
                                                E2E_PRNSTATUS_OKSOMELOST,
                                                E2E_PRNSTATUS_NONEWDATA,
                                                E2E_PRNSTATUS_DATAINVALID
     See Test Aspects A)-I)
  2) Configuration variation with respect to different DataID Modes:
     See Description of Test Data Variation Data0XX ... Data8XX
- Boundary Value Analysis
  (Either usage of all possible values or min / intermediate /max value for individual parameters)
- Equivalence Class Partitioning
  (Testing each DataIDMode)


Test Input: 

 InputDataXXX:

  CounterOffset                      MaxDeltaCounterInit                   NoNewOrRepeatedDataCounter+
       |                                  |  MaxNoNewOrRepeatedData                      LostData+   | +SyncCounter
       |  +CRCOffset                      |   | SyncCounterInit             NewDataAvailable+    |   | | data+
       |  | DataID                        |   |   |                    WaitForFirstData+    |    |   | |     |returned
       |  |  | DataIDNibbleOffset         |   |   |                 MaxDeltaCounter+   |    |    |   | |     |  CRC+
       |  |  | |                          |   |   |             LastValidCounter+  |   |    |    |   | |     |     |
       |  |  | |       DataIDMode         |   |   |        Status               |  |   |    |    |   | |     |     |
000:{ 8U, 0U,0U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD400,0x00}
001:{ 8U, 0U,1U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD401,0x11}
002:{ 8U, 0U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD401,0xFF}
003:{ 8U, 0U,3U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD401,0x11}
004:{ 8U, 0U,4U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD401,0x11}
005:{ 8U, 0U,5U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD403,0x33}
006:{ 8U, 0U,6U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD403,0x33}
007:{ 8U, 0U,7U, 0U,E2E_PRN_DATAID_BOTH,  1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD404,0x44}
008:{ 8U, 0U,8U, 0U,E2E_PRN_DATAID_BOTH,  1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD405,0x55}
009:{ 8U, 0U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD406,0x66}
010:{ 8U, 0U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD406,0xFF}

100:{28U,16U,0U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD500,0x00}
101:{28U,16U,1U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD501,0x11}
102:{28U,16U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD501,0xFF}
103:{28U,16U,3U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD501,0x11}
104:{28U,16U,4U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD501,0x11}
105:{28U,16U,5U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD503,0x33}
106:{28U,16U,6U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD503,0x33}
107:{28U,16U,7U, 0U,E2E_PRN_DATAID_BOTH,  1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD504,0x44}
108:{28U,16U,8U, 0U,E2E_PRN_DATAID_BOTH,  1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD505,0x55}
109:{28U,16U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD506,0x66}
110:{28U,16U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD506,0xFF}

200:{52U,56U,0U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD600,0x00}
201:{52U,56U,1U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD601,0x11}
202:{52U,56U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD601,0xFF}
203:{52U,56U,3U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD601,0x11}
204:{52U,56U,4U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD601,0x11}
205:{52U,56U,5U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD603,0x33}
206:{52U,56U,6U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD603,0x33}
207:{52U,56U,7U, 0U,E2E_PRN_DATAID_BOTH,  1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD604,0x44}
208:{52U,56U,8U, 0U,E2E_PRN_DATAID_BOTH,  1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD605,0x55}
209:{52U,56U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD606,0x66}
210:{52U,56U,2U, 0U,E2E_PRN_DATAID_BOTH,  0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD606,0xFF}

300:{ 8U, 0U,0U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD400,0x00}
301:{ 8U, 0U,1U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD401,0x11}
302:{ 8U, 0U,2U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD401,0xFF}
303:{ 8U, 0U,3U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD401,0x11}
304:{ 8U, 0U,4U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD401,0x11}
305:{ 8U, 0U,5U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD403,0x33}
306:{ 8U, 0U,6U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD403,0x33}
307:{ 8U, 0U,7U,12U,E2E_PRN_DATAID_NIBBLE,1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD404,0x44}
308:{ 8U, 0U,8U,12U,E2E_PRN_DATAID_NIBBLE,1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD405,0x55}
309:{ 8U, 0U,2U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD406,0x66}
310:{ 8U, 0U,2U,12U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD406,0xFF}

400:{28U,16U,0U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD500,0x00}
401:{28U,16U,1U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD501,0x11}
402:{28U,16U,2U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD501,0xFF}
403:{28U,16U,3U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD501,0x11}
404:{28U,16U,4U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD501,0x11}
405:{28U,16U,5U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD503,0x33}
406:{28U,16U,6U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD503,0x33}
407:{28U,16U,7U,24U,E2E_PRN_DATAID_NIBBLE,1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD504,0x44}
408:{28U,16U,8U,24U,E2E_PRN_DATAID_NIBBLE,1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD505,0x55}
409:{28U,16U,2U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD506,0x66}
410:{28U,16U,2U,24U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD506,0xFF}

500:{52U,56U,0U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD600,0x00}
501:{52U,56U,1U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD601,0x11}
502:{52U,56U,2U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD601,0xFF}
503:{52U,56U,3U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD601,0x11}
504:{52U,56U,4U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD601,0x11}
505:{52U,56U,5U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD603,0x33}
506:{52U,56U,6U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD603,0x33}
507:{52U,56U,7U,40U,E2E_PRN_DATAID_NIBBLE,1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD604,0x44}
508:{52U,56U,8U,40U,E2E_PRN_DATAID_NIBBLE,1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD605,0x55}
509:{52U,56U,2U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD606,0x66}
510:{52U,56U,2U,40U,E2E_PRN_DATAID_NIBBLE,0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD606,0xFF}

600:{ 8U, 0U,0U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD400,0x00}
601:{ 8U, 0U,1U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD401,0x11}
602:{ 8U, 0U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD401,0xFF}
603:{ 8U, 0U,3U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD401,0x11}
604:{ 8U, 0U,4U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD401,0x11}
605:{ 8U, 0U,5U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD403,0x33}
606:{ 8U, 0U,6U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD403,0x33}
607:{ 8U, 0U,7U, 0U,E2E_PRN_DATAID_LOW,   1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD404,0x44}
608:{ 8U, 0U,8U, 0U,E2E_PRN_DATAID_LOW,   1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD405,0x55}
609:{ 8U, 0U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD406,0x67}
610:{ 8U, 0U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD406,0xFF}

700:{28U,16U,0U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD500,0x00}
701:{28U,16U,1U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD501,0x11}
702:{28U,16U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD501,0xFF}
703:{28U,16U,3U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD501,0x11}
704:{28U,16U,4U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD501,0x11}
705:{28U,16U,5U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD503,0x33}
706:{28U,16U,6U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD503,0x33}
707:{28U,16U,7U, 0U,E2E_PRN_DATAID_LOW,   1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD504,0x44}
708:{28U,16U,8U, 0U,E2E_PRN_DATAID_LOW,   1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD505,0x55}
709:{28U,16U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD506,0x67}
710:{28U,16U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD506,0xFF}

800:{52U,56U,0U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_INITIAL,  0U, 0U,FALSE,FALSE,0U,0U,0U},VD600,0x00}
801:{52U,56U,1U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD601,0x11}
802:{52U,56U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,TRUE, TRUE, 0U,0U,0U},VD601,0xFF}
803:{52U,56U,3U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U, 0U,FALSE,TRUE, 0U,0U,0U},VD601,0x11}
804:{52U,56U,4U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD601,0x11}
805:{52U,56U,5U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 0U,FALSE,TRUE, 0U,0U,0U},VD603,0x33}
806:{52U,56U,6U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 4U,FALSE,TRUE, 1U,0U,0U},VD603,0x33}
807:{52U,56U,7U, 0U,E2E_PRN_DATAID_LOW,   1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD604,0x44}
808:{52U,56U,8U, 0U,E2E_PRN_DATAID_LOW,   1U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,1U, 1U,FALSE,TRUE, 2U,0U,0U},VD605,0x55}
809:{52U,56U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD606,0x67}
810:{52U,56U,2U, 0U,E2E_PRN_DATAID_LOW,   0U,15U,0U},{E2E_PRNSTATUS_NONEWDATA,0U,15U,FALSE,TRUE, 0U,0U,0U},VD606,0xFF}


with:

 Test data for CRC byte 0, Counter low nibble byte 1, DataIDNibble high nibble byte 1:
       CRC-+      +-Counter and DataIDNibble
           |      |      +-Data----------------------------------------------------------------+
VD400: {0x00U, 0x00U, 0x00U}
VD401: {0x11U, 0x01U, 0x10U, 0x11U, 0x12U, 0x13U, 0x14U, 0x15U, 0x16U}
VD402: {0x22U, 0x02U, 0x20U, 0x21U, 0x22U, 0x23U, 0x24U, 0x25U, 0x26U, 0x27U, 0x28U, 0x29U, 0x2AU,
                                                                              0x2BU, 0x2CU, 0x2DU}
VD403: {0x33U, 0x03U, 0x30U, 0x31U, 0x32U, 0x33U, 0x34U, 0x35U, 0x36U, 0x37U, 0x38U, 0x39U, 0x3AU,
                                                                0x3BU, 0x3CU, 0x3DU, 0x3EU, 0x3FU}
VD404: {0x44U, 0x04U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U, 0x47U, 0x48U, 0x49U, 0x4AU,
                                                                0x4BU, 0x4CU, 0x4DU, 0x4EU, 0x4FU}
VD405: {0x55U, 0x0FU, 0x50U}  contains a wrong counter value
VD406: {0x66U, 0xFFU, 0xFFU}  data and counter contains only set bits


 Test data for CRC byte 2, Counter high nibble byte 3, DataIDNibble low nibble byte 3:
                    CRC-+      +-Counter and DataIDNibble
          +-Data--+     |      |      +-Data----------------------------------------------------+
VD500: {0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U}
VD501: {0x10U, 0x11U, 0x11U, 0x10U, 0x12U, 0x13U, 0x14U, 0x15U, 0x16U}
VD502: {0x20U, 0x21U, 0x22U, 0x20U, 0x22U, 0x23U, 0x24U, 0x25U, 0x26U, 0x27U, 0x28U, 0x29U, 0x2AU,
                                                                              0x2BU, 0x2CU, 0x2DU}
VD503: {0x30U, 0x31U, 0x33U, 0x30U, 0x32U, 0x33U, 0x34U, 0x35U, 0x36U, 0x37U, 0x38U, 0x39U, 0x3AU,
                                                                0x3BU, 0x3CU, 0x3DU, 0x3EU, 0x3FU}
VD504: {0x40U, 0x41U, 0x44U, 0x40U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U, 0x47U, 0x48U, 0x49U, 0x4AU,
                                                                0x4BU, 0x4CU, 0x4DU, 0x4EU, 0x4FU}
VD505: {0x50U, 0x00U, 0x55U, 0xF0U, 0x00U, 0x00U, 0x00U, 0x00U}  contains a wrong counter value
VD506: {0xFFU, 0xFFU, 0x66U, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU}  data and counter contains only set bits


 Test data for CRC byte 7, Counter high nibble byte 6, DataIDNibble low nibble byte 5:
                                             Counter+  CRC-+
                                  DataIDNibble+     |      |
          +-Data---------------------+        |     |      |     +-Data----------------+
VD600: {0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U, 0x00U}
VD601: {0x15U, 0x14U, 0x10U, 0x11U, 0x12U, 0x10U, 0x1AU, 0x11U, 0x16U}
VD602: {0x25U, 0x24U, 0x20U, 0x21U, 0x22U, 0x20U, 0x2AU, 0x22U, 0x26U, 0x27U, 0x28U, 0x29U, 0x2AU,
                                                                              0x2BU, 0x2CU, 0x2DU}
VD603: {0x35U, 0x34U, 0x30U, 0x31U, 0x32U, 0x30U, 0x3AU, 0x33U, 0x36U, 0x37U, 0x38U, 0x39U, 0x3AU,
                                                                0x3BU, 0x3CU, 0x3DU, 0x3EU, 0x3FU}
VD604: {0x45U, 0x44U, 0x40U, 0x41U, 0x42U, 0x40U, 0x4AU, 0x44U, 0x46U, 0x47U, 0x48U, 0x49U, 0x4AU,
                                                                0x4BU, 0x4CU, 0x4DU, 0x4EU, 0x4FU}
VD605: {0x00U, 0x00U, 0x50U, 0x00U, 0x00U, 0x00U, 0xFAU, 0x55U}  contains a wrong counter value
VD606: {0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0xFFU, 0x66U}  data and counter contains only set bits


Test Output: 

OutputDataXXX:
                                         NewDataAvailable+       +LostData
                                    WaitForFirstData+      |       |   +NoNewOrRepeatedDataCounter
                                 MaxDeltaCounter+   |      |       |   |   +SyncCounter
                             stValidCounter+    |   |      |       |   |   |     +retVal
                    +-Status-+             |    |   |      |       |   |   |     |             invokeCRC+
000: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
001: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
002: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
003: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
004: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
005: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
006: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
007: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
008: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
009: {{E2E_PRNSTATUS_OKSOMELOST,       15U, 0U, FALSE, TRUE,   14U,0U, 0U}, E2E_E_OK,             TRUE  },
010: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },

100: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
101: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
102: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
103: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
104: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
105: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
106: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
107: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
108: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
109: {{E2E_PRNSTATUS_OKSOMELOST,       15U, 0U, FALSE, TRUE,   14U,0U, 0U}, E2E_E_OK,             TRUE  },
110: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },

200: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
201: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
202: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
203: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
204: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
205: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
206: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
207: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
208: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
209: {{E2E_PRNSTATUS_OKSOMELOST,       15U, 0U, FALSE, TRUE,   14U, 0U, 0U}, E2E_E_OK,            TRUE  },
210: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },

300: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
301: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
302: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
303: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
304: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
305: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
306: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
307: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
308: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
309: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
310: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
400: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
401: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
402: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
403: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
404: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
405: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
406: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
407: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
408: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
409: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
410: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },

500: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
501: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
502: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
503: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
504: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
505: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
506: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
507: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
508: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
509: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
510: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },

600: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
601: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
602: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
603: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
604: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
605: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
606: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
607: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
608: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
609: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
610: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },

700: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
701: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
702: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
703: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
704: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
705: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
706: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
707: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
708: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE },
709: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE },
710: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE },

800: {{E2E_PRNSTATUS_NONEWDATA,        0U,  1U, FALSE, FALSE,  0U, 1U, 0U}, E2E_E_OK,             FALSE },
801: {{E2E_PRNSTATUS_INITIAL,          1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
802: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U, TRUE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
803: {{E2E_PRNSTATUS_OK,               1U,  0U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
804: {{E2E_PRNSTATUS_REPEATED,         1U,  1U, FALSE, TRUE,   0U, 1U, 0U}, E2E_E_OK,             TRUE  },
805: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  1U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
806: {{E2E_PRNSTATUS_OKSOMELOST,       3U,  0U, FALSE, TRUE,   1U, 0U, 0U}, E2E_E_OK,             TRUE  },
807: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
808: {{E2E_PRNSTATUS_WRONGSEQUENCE,    1U,  2U, FALSE, TRUE,   2U, 0U, 0U}, E2E_E_OK,             TRUE  },
809: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
810: {{E2E_PRNSTATUS_WRONGCRC,         0U, 15U, FALSE, TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },


&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020070.Lessthan8bytes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        
        <provcov>
          <linksto>EB_E2EPRN020190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_02_PRNCheckStatus_Ok</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>2248</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

    This test shall check the behavior of the E2E-library
    for the function E2E_PRNCheck() by the path leading to
    State-&gt;Status E2E_PRNSTATUS_OK.

    In detail:
     Test that if
       - DeltaCounter equals 1 (difference between data counter and LastValidCounter), AND
       - the value of the NoNewOrRepeatedDataCounter is less than
         or equal to MaxNoNewOrRepeatedData, AND
       - the SyncCounter equals 0
     THEN
       - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_OK

&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Execute the following steps several times with InputDataXX from input:
   01: Call E2E_PRNCheck() with
       - the E2E_PRNConfig stated in InputDataXX
       - the E2E_PRNCheckState stated in InputDataXX
       - the data VDxx stated in InputDataXX
   02: VP (see VPs of E2ETEST_GenericTest.xx)
       E2E_PRNCheck() returns the value stated in OutputDataXX
       E2E_PRNCheckState values are equal to values stated in OutputDataXX

   The following VPs are checked within the SCrc_CalculateCRC8 stub
   (see TS_E2EPRN_ConTest_02_PRNCheck_DataIdMode):
      - EB_E2EPRN020163 (test aspect related to call of SCrc_CalculateCRC8() only)
      - EB_E2EPRN020070,EB_E2EPRN020070
      - EB_E2EPRN020190

Test aspects of individual InputDataXX/OutputDataXX:
   Data00..Data19: VP (EB_E2EPRN020148,EB_E2EPRN020076,EB_E2EPRN020196)
           Test that if
             - DeltaCounter equals 1 (difference between data counter and LastValidCounter), AND
             - the value of the NoNewOrRepeatedDataCounter is less than
               or equal to MaxNoNewOrRepeatedData, AND
             - the SyncCounter equals 0
           THEN
             - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_OK
           FOR
             - all possible values of: LastValidCounter
             - all possible values of: NoNewOrRepeatedDataCounter
             - MaxNoNewOrRepeatedData set to 15
             - different values of initial Status values
               (  OK           ,
                  OKSOMELOST   ,
                  NONEWDATA    ,
                  WRONGCRC     ,
                  SYNC         ,
                  INITIAL      ,
                  REPEATED     ,
                  WRONGSEQUENCE)
   Data00..Data19: VP (EB_E2EPRN020196)
           Test that LostData is set to 0 (status OK is returned)
   Data00..Data19: VP (EB_E2EPRN020150)
           Test that
           - MaxDeltaCounter is set to MaxDeltaCounterInit
           FOR
           - all possible values of MaxDeltaCounterInit.
   Data00..Data19: VP (EB_E2EPRN020151)
           Test that
           - LastValidCounter is set to the Counter of the data
           FOR
           - all possible counter values.
   Data00..Data19: VP (EB_E2EPRN020300)
           Test that
           - NoNewOrRepeatedDataCounter is set to 0 (status OKSOMELOST is returned)
           FOR
           - all possible values of NoNewOrRepeatedDataCounter

Used Test Strategies:
- Pair wise tests
  (Different values among different E2E_PRNCheckState parameters)
- Boundary Value Analysis
  (Either usage of all possible values or min / intermediate /max value for individual parameters)
- Equivalence Class Partitioning
  (Testing only transitions to Rx status E2E_PRNSTATUS_OK)


Test Input: 

InputDataXX:

CounterOffset                   MaxDeltaCounterInit                      NoNewOrRepeatedDataCounter+
     |                               |  MaxNoNewOrRepeatedData                         LostData+   |  +SyncCounter
     |  +CRCOffset                   |   | SyncCounterInit                NewDataAvailable+    |   |  | data+
     |  | DataID                     |   |   |                       WaitForFirstData+    |    |   |  |     |returned
     |  |  | DataIDNibbleOffset      |   |   |                    MaxDeltaCounter+   |    |    |   |  |     |  CRC+
     |  |  | |                       |   |   |                LastValidCounter+  |   |    |    |   |  |     |     |
     |  |  | |       DataIDMode      |   |   |        Status                  |  |   |    |    |   |  |     |     |
00:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 2U,15U,3U},{E2E_PRNSTATUS_OK           , 0U,2U,FALSE,TRUE,0U, 0U,0U},VD000,0x00U}
01:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 3U,15U,3U},{E2E_PRNSTATUS_OKSOMELOST   , 1U,2U,FALSE,TRUE,0U, 1U,0U},VD001,0x01U}
02:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 4U,15U,3U},{E2E_PRNSTATUS_NONEWDATA    , 2U,2U,FALSE,TRUE,0U, 2U,0U},VD002,0x02U}
03:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 5U,15U,3U},{E2E_PRNSTATUS_WRONGCRC     , 3U,2U,FALSE,TRUE,0U, 3U,0U},VD003,0x03U}
04:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 6U,15U,3U},{E2E_PRNSTATUS_SYNC         , 4U,2U,FALSE,TRUE,0U, 4U,0U},VD004,0x04U}
05:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 7U,15U,3U},{E2E_PRNSTATUS_INITIAL      , 5U,2U,FALSE,TRUE,0U, 5U,0U},VD005,0x05U}
06:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 8U,15U,3U},{E2E_PRNSTATUS_REPEATED     , 6U,2U,FALSE,TRUE,0U, 6U,0U},VD006,0x06U}
07:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 9U,15U,3U},{E2E_PRNSTATUS_WRONGSEQUENCE, 7U,2U,FALSE,TRUE,0U, 7U,0U},VD007,0x07U}
08:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH,10U,15U,3U},{E2E_PRNSTATUS_OK           , 8U,2U,FALSE,TRUE,0U, 8U,0U},VD008,0x08U}
09:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH,11U,15U,3U},{E2E_PRNSTATUS_OKSOMELOST   , 9U,2U,FALSE,TRUE,0U, 9U,0U},VD009,0x09U}
10:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH,12U,15U,3U},{E2E_PRNSTATUS_NONEWDATA    ,10U,2U,FALSE,TRUE,0U,10U,0U},VD010,0x10U}
11:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH,13U,15U,3U},{E2E_PRNSTATUS_WRONGCRC     ,11U,2U,FALSE,TRUE,0U,11U,0U},VD011,0x11U}
12:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH,14U,15U,3U},{E2E_PRNSTATUS_SYNC         ,12U,2U,FALSE,TRUE,0U,12U,0U},VD012,0x12U}
13:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH,15U,15U,3U},{E2E_PRNSTATUS_SYNC         ,12U,2U,FALSE,TRUE,0U,12U,0U},VD012,0x12U}
14:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 0U,15U,3U},{E2E_PRNSTATUS_INITIAL      ,13U,2U,FALSE,TRUE,0U,13U,0U},VD013,0x13U}
15:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 0U,15U,3U},{E2E_PRNSTATUS_REPEATED     ,14U,2U,FALSE,TRUE,0U,14U,0U},VD014,0x14U}
16:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 0U,15U,3U},{E2E_PRNSTATUS_WRONGSEQUENCE, 0U,2U,FALSE,TRUE,0U, 0U,0U},VD000,0x00U}
17:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 0U,15U,3U},{E2E_PRNSTATUS_OK           , 1U,2U,FALSE,TRUE,0U, 1U,0U},VD001,0x01U}
18:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 0U,15U,3U},{E2E_PRNSTATUS_OKSOMELOST   , 2U,2U,FALSE,TRUE,0U, 2U,0U},VD002,0x02U}
19:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 0U,15U,3U},{E2E_PRNSTATUS_NONEWDATA    , 3U,2U,FALSE,TRUE,0U, 3U,0U},VD003,0x03U}
20:{{8U,0U,1,0U,E2E_PRN_DATAID_BOTH, 0U,15U,3U},{E2E_PRNSTATUS_WRONGCRC     , 4U,2U,FALSE,TRUE,0U, 4U,0U},VD004,0x04U}



For input data VDxx, see TS_E2EPRN_ConTest_02_PRNCheckStatus_Repeated.



Test Output: 

OutputDataXX:
00: {E2E_PRNSTATUS_OK         ,    1U, 2U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
01: {E2E_PRNSTATUS_OK         ,    2U, 3U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
02: {E2E_PRNSTATUS_OK         ,    3U, 4U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
03: {E2E_PRNSTATUS_OK         ,    4U, 5U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
04: {E2E_PRNSTATUS_OK         ,    5U, 6U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
05: {E2E_PRNSTATUS_OK         ,    6U, 7U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
06: {E2E_PRNSTATUS_OK         ,    7U, 8U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
07: {E2E_PRNSTATUS_OK         ,    8U, 9U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
08: {E2E_PRNSTATUS_OK         ,    9U,10U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
09: {E2E_PRNSTATUS_OK         ,   10U,11U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
10: {E2E_PRNSTATUS_OK         ,   11U,12U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
11: {E2E_PRNSTATUS_OK         ,   12U,13U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
12: {E2E_PRNSTATUS_OK         ,   13U,14U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
13: {E2E_PRNSTATUS_OK         ,   14U,15U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
14: {E2E_PRNSTATUS_OK         ,   15U, 0U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
15: {E2E_PRNSTATUS_OK         ,    0U, 0U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
16: {E2E_PRNSTATUS_OK         ,    1U, 0U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
17: {E2E_PRNSTATUS_OK         ,    2U, 0U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
18: {E2E_PRNSTATUS_OK         ,    3U, 0U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
19: {E2E_PRNSTATUS_OK         ,    4U, 0U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
20: {E2E_PRNSTATUS_OK         ,    5U, 0U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},


&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_03_PRNCheckStatus_OkSomeLost</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>2504</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

    This test shall check the behavior of the E2E-library for the function E2E_PRNCheck()
    by the path leading to State-&gt;Status E2E_PRNSTATUS_OKSOMELOST.

    In detail:
     Test that if
       - the calculated DeltaCounter is greater-than 1 but less-than or equal to MaxDeltaCounter, AND
       - NoNewOrRepeatedDataCounter is less than or equal to MaxNoNewOrRepeatedData, AND
       - the SyncCounter equals 0
     THEN
       - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_OKSOMELOST

&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 

Execute the following steps several times with InputDataXX from input:
   01: Call E2E_PRNCheck() with
       - the E2E_PRNConfig stated in InputDataXX
       - the E2E_PRNCheckState stated in InputDataXX
       - the data VDxx stated in InputDataXX
   02: VP (see VPs of E2ETEST_GenericTest.xx)
       E2E_PRNCheck() returns the value stated in OutputDataXX
       E2E_PRNCheckState values are equal to values stated in OutputDataXX

   The following VPs are checked within the SCrc_CalculateCRC8 stub
   (see TS_E2EPRN_ConTest_02_PRNCheck_DataIdMode):
      - EB_E2EPRN020163 (test aspect related to call of SCrc_CalculateCRC8() only)
      - EB_E2EPRN020070,EB_E2EPRN020070
      - EB_E2EPRN020190

Test aspects of individual InputDataXX/OutputDataXX:

   Data00..Data19: VP (EB_E2EPRN020148,EB_E2EPRN020076,EB_E2EPRN020196)
           Test that if
             - calculated DeltaCounter is greater-than 1 but less-than or equal MaxDeltaCounter, AND
             - NoNewOrRepeatedDataCounter is less than or equal to MaxNoNewOrRepeatedData, AND
             - the SyncCounter equals 0
           THEN
             - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_OKSOMELOST
           FOR
             - all possible values of: DeltaCounter / MaxDeltaCounter
             - all possible values of: NoNewOrRepeatedDataCounter
             - all possible values of: MaxNoNewOrRepeatedData
             - different values of initial Status values
               (  OK           ,
                  OKSOMELOST   ,
                  NONEWDATA    ,
                  WRONGCRC     ,
                  SYNC         ,
                  INITIAL      ,
                  REPEATED     ,
                  WRONGSEQUENCE)
   Data00..Data19: VP (EB_E2EPRN020196)
           Test that LostData is set to (DeltaCounter - 1) (status OKSOMELOST is returned)
   Data00..Data19: VP (EB_E2EPRN020196,EB_E2EPRN020150)
           Test that
           - MaxDeltaCounter is set to MaxDeltaCounterInit
           FOR
           - all possible values of MaxDeltaCounterInit.
   Data00..Data19: VP (EB_E2EPRN020196,EB_E2EPRN020151)
           Test that
           - LastValidCounter is set to the Counter of the data
           FOR
           - all possible counter values.
   Data00..Data19: VP (EB_E2EPRN020196,EB_E2EPRN020300)
           Test that
           - NoNewOrRepeatedDataCounter is set to 0 (status OKSOMELOST is returned)
           FOR
           - all possible values of NoNewOrRepeatedDataCounter

Used Test Strategies:
- Pair wise tests
  (Different values among different E2E_PRNCheckState parameters)
- Boundary Value Analysis
  (Either usage of all possible values or min / intermediate /max value for individual parameters)
- Equivalence Class Partitioning
  (Testing only transitions to Rx status E2E_PRNSTATUS_OKSOMELOST)


Test Input: 

InputDataXX:

CounterOffset                   MaxDeltaCounterInit                    NoNewOrRepeatedDataCounter+
     |                               | MaxNoNewOrRepeatedData                        LostData+   |  +SyncCounter
     |  +CRCOffset                   |  | SyncCounterInit               NewDataAvailable+    |   |  | data+
     |  | DataID                     |  |  |                       WaitForFirstData+    |    |   |  |     |returned
     |  |  | DataIDNibbleOffset      |  |  |                    MaxDeltaCounter+   |    |    |   |  |     |  CRC+
     |  |  | |                       |  |  |                LastValidCounter+  |   |    |    |   |  |     |     |
     |  |  | |       DataIDMode      |  |  |        Status                  |  |   |    |    |   |  |     |     |
00:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2  1, 3},{E2E_PRNSTATUS_OK           , 0U, 2U,FALSE,TRUE,0U, 1U,0U},VD001,0x01U}
01:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 3, 2, 7},{E2E_PRNSTATUS_OKSOMELOST   , 1U, 3U,FALSE,TRUE,1U, 2U,0U},VD003,0x03U}
02:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 4, 3,10},{E2E_PRNSTATUS_NONEWDATA    , 2U, 4U,FALSE,TRUE,1U, 3U,0U},VD005,0x05U}
03:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 5, 4,13},{E2E_PRNSTATUS_WRONGCRC     , 3U, 5U,FALSE,TRUE,1U, 4U,0U},VD007,0x07U}
04:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 6, 5, 4},{E2E_PRNSTATUS_SYNC         , 4U, 6U,FALSE,TRUE,1U, 5U,0U},VD009,0x09U}
05:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 7, 6, 9},{E2E_PRNSTATUS_INITIAL      , 5U, 7U,FALSE,TRUE,1U, 6U,0U},VD011,0x11U}
06:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 8, 7, 3},{E2E_PRNSTATUS_REPEATED     , 6U, 8U,FALSE,TRUE,1U, 7U,0U},VD013,0x13U}
07:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 9, 8,10},{E2E_PRNSTATUS_WRONGSEQUENCE, 7U, 9U,FALSE,TRUE,1U, 8U,0U},VD014,0x14U}
08:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,10, 9,11},{E2E_PRNSTATUS_OK           , 8U,10U,FALSE,TRUE,1U, 9U,0U},VD001,0x01U}
09:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,11,10,12},{E2E_PRNSTATUS_OKSOMELOST   , 9U,11U,FALSE,TRUE,1U,10U,0U},VD003,0x03U}
10:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,12,11,14},{E2E_PRNSTATUS_NONEWDATA    ,10U,12U,FALSE,TRUE,1U,11U,0U},VD005,0x05U}
11:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,13,12, 0},{E2E_PRNSTATUS_WRONGCRC     ,11U,13U,FALSE,TRUE,1U,12U,0U},VD007,0x07U}
12:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,14,13, 1},{E2E_PRNSTATUS_SYNC         ,12U,14U,FALSE,TRUE,1U,13U,0U},VD009,0x09U}
13:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2,14, 2},{E2E_PRNSTATUS_INITIAL      ,13U,14U,FALSE,TRUE,1U,14U,0U},VD011,0x11U}
14:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2, 0, 3},{E2E_PRNSTATUS_REPEATED     ,12U, 2U,FALSE,TRUE,1U, 0U,0U},VD013,0x13U}
15:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2, 1, 4},{E2E_PRNSTATUS_WRONGSEQUENCE,13U, 2U,FALSE,TRUE,1U, 0U,0U},VD014,0x14U}
16:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2, 2, 5},{E2E_PRNSTATUS_OK           , 0U, 2U,FALSE,TRUE,1U, 0U,0U},VD001,0x01U}
17:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2, 3, 6},{E2E_PRNSTATUS_OKSOMELOST   , 2U, 2U,FALSE,TRUE,1U, 0U,0U},VD003,0x03U}
18:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2, 4, 7},{E2E_PRNSTATUS_NONEWDATA    , 4U, 2U,FALSE,TRUE,1U, 0U,0U},VD005,0x05U}
19:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2, 5, 8},{E2E_PRNSTATUS_WRONGCRC     , 6U, 2U,FALSE,TRUE,1U, 0U,0U},VD007,0x07U}

For input data VDxx, see TS_E2EPRN_ConTest_02_PRNCheckStatus_Repeated.


Test Output: 

OutputDataXX:
00: {{E2E_PRNSTATUS_OKSOMELOST,    2U, 2U,FALSE, TRUE, 1U, 0U, 0U}, E2E_E_OK,  TRUE},
01: {{E2E_PRNSTATUS_OKSOMELOST,    4U, 3U,FALSE, TRUE, 2U, 0U, 0U}, E2E_E_OK,  TRUE},
02: {{E2E_PRNSTATUS_OKSOMELOST,    6U, 4U,FALSE, TRUE, 3U, 0U, 0U}, E2E_E_OK,  TRUE},
03: {{E2E_PRNSTATUS_OKSOMELOST,    8U, 5U,FALSE, TRUE, 4U, 0U, 0U}, E2E_E_OK,  TRUE},
04: {{E2E_PRNSTATUS_OKSOMELOST,   10U, 6U,FALSE, TRUE, 5U, 0U, 0U}, E2E_E_OK,  TRUE},
05: {{E2E_PRNSTATUS_OKSOMELOST,   12U, 7U,FALSE, TRUE, 6U, 0U, 0U}, E2E_E_OK,  TRUE},
06: {{E2E_PRNSTATUS_OKSOMELOST,   14U, 8U,FALSE, TRUE, 7U, 0U, 0U}, E2E_E_OK,  TRUE},
07: {{E2E_PRNSTATUS_OKSOMELOST,    0U, 9U,FALSE, TRUE, 7U, 0U, 0U}, E2E_E_OK,  TRUE},
08: {{E2E_PRNSTATUS_OKSOMELOST,    2U,10U,FALSE, TRUE, 8U, 0U, 0U}, E2E_E_OK,  TRUE},
09: {{E2E_PRNSTATUS_OKSOMELOST,    4U,11U,FALSE, TRUE, 9U, 0U, 0U}, E2E_E_OK,  TRUE},
10: {{E2E_PRNSTATUS_OKSOMELOST,    6U,12U,FALSE, TRUE,10U, 0U, 0U}, E2E_E_OK,  TRUE},
11: {{E2E_PRNSTATUS_OKSOMELOST,    8U,13U,FALSE, TRUE,11U, 0U, 0U}, E2E_E_OK,  TRUE},
12: {{E2E_PRNSTATUS_OKSOMELOST,   10U,14U,FALSE, TRUE,12U, 0U, 0U}, E2E_E_OK,  TRUE},
13: {{E2E_PRNSTATUS_OKSOMELOST,   12U, 2U,FALSE, TRUE,13U, 0U, 0U}, E2E_E_OK,  TRUE},
14: {{E2E_PRNSTATUS_OKSOMELOST,   14U, 2U,FALSE, TRUE, 1U, 0U, 0U}, E2E_E_OK,  TRUE},
15: {{E2E_PRNSTATUS_OKSOMELOST,    0U, 2U,FALSE, TRUE, 1U, 0U, 0U}, E2E_E_OK,  TRUE},
16: {{E2E_PRNSTATUS_OKSOMELOST,    2U, 2U,FALSE, TRUE, 1U, 0U, 0U}, E2E_E_OK,  TRUE},
17: {{E2E_PRNSTATUS_OKSOMELOST,    4U, 2U,FALSE, TRUE, 1U, 0U, 0U}, E2E_E_OK,  TRUE},
18: {{E2E_PRNSTATUS_OKSOMELOST,    6U, 2U,FALSE, TRUE, 1U, 0U, 0U}, E2E_E_OK,  TRUE},
19: {{E2E_PRNSTATUS_OKSOMELOST,    8U, 2U,FALSE, TRUE, 1U, 0U, 0U}, E2E_E_OK,  TRUE},

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_04_PRNCheckStatus_WrongSequence</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>2749</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check the behavior of the E2E-library
    for the function E2E_PRNCheck() by the path leading to
    E2E_PRNSTATUS_WRONGSEQUENCE that the values
    SyncCounter, MaxDeltaCounter, LastValidCounter, and NoNewOrRepeatedDataCounter
    are correctly set based on the configuration of SyncCounterInit.

    In detail:
       Test that if
         - DeltaCounter (difference between data counter and LastValidCounter)
           exceeds the value of MaxDeltaCounter (incremented by 1)
       THEN
         - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_WRONGSEQUENCE
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Successful execution of TS_E2EPRN_ConTest_02_PRNCheck_AllStates.


Test Execution: 

Execute the following steps several times with InputDataXX from input:
   01: Call E2E_PRNCheck() with
       - the E2E_PRNConfig stated in InputDataXX
       - the E2E_PRNCheckState stated in InputDataXX
       - the data VDxx stated in InputDataXX
   02: VP (see VPs of E2ETEST_GenericTest.xx)
       E2E_PRNCheck() returns the value stated in OutputDataXX
       E2E_PRNCheckState values are equal to values stated in OutputDataXX

   The following VPs are checked within the SCrc_CalculateCRC8 stub
   (see TS_E2EPRN_ConTest_02_PRNCheck_DataIdMode):
      - EB_E2EPRN020163 (test aspect related to call of SCrc_CalculateCRC8() only)
      - EB_E2EPRN020070,EB_E2EPRN020070
      - EB_E2EPRN020190

Test aspects of individual InputDataXX/OutputDataXX:

   Data00..Data05: VP (EB_E2EPRN020076,EB_E2EPRN020196)
           Test that if
             - DeltaCounter (difference between data counter and LastValidCounter)
               exceeds the value of MaxDeltaCounter (incremented by 1)
           THEN
             - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_WRONGSEQUENCE
           FOR
             - boundary values of DeltaCounter values (1, 8 ,14)
           INDEPENDENT of
             - parameters LastValidCounter, NoNewOrRepeatedDataCounter, SyncCounter,
                          MaxNoNewOrRepeatedData, SyncCounterInit

   Data00..Data05: VP (EB_E2EPRN020196)
           Test that
           - MaxDeltaCounter is incremented by 1 up to 14 (13 in this test-case)
           FOR
           - initial boundary values (0, 3, 13
             (NOTE: with 14, WRONGSEQUENCE will never be returned =&gt; not applicable here)

   Data00..Data02: VP (EB_E2EPRN020150)
          Test that if
             - SyncCounter / SyncCounterInit equals 0
          THEN
             - MaxDeltaCounter is NOT re-initialized to MaxDeltaCounterInit
               (but incremented by 1)
   Data03..Data05: VP (EB_E2EPRN020150)
          Test that if
             - SyncCounter / SyncCounterInit exceeds 0
               (SyncCounter is always set to SyncCounter in case of WRONGSEQUENCE)
          THEN
             - MaxDeltaCounter is re-initialized to MaxDeltaCounterInit

   Data00..Data02: VP (EB_E2EPRN020151)
          Test that if
             - SyncCounter / SyncCounterInit equals 0
          THEN
             - LastValidCounter is NOT set to Counter of Data
   Data03..Data05: VP (EB_E2EPRN020151)
          Test that if
             - SyncCounter / SyncCounterInit exceeds 0
               (SyncCounter is always set to SyncCounter in case of WRONGSEQUENCE)
          THEN
             - LastValidCounter is set to Counter of Data

   Data00..Data05: VP (EB_E2EPRN020300)
           Test that
           - NoNewOrRepeatedDataCounter is set to 0 (status WRONGSEQUENCE is returned)
           FOR
           - boundary values of NoNewOrRepeatedDataCounter (1,5,15)

Used Test Strategies:
- Pair wise tests
  (Different values among different E2E_PRNCheckState parameters)
- Boundary Value Analysis
  (Either usage of all possible values or min / intermediate /max value for individual parameters)
- Equivalence Class Partitioning
  (Testing only transitions to Rx status E2E_PRNSTATUS_WRONGSEQUENCE)


Test Input: 

InputDataXX:

CounterOffset                   MaxDeltaCounterInit                   NoNewOrRepeatedDataCounter+
     |                               |  MaxNoNewOrRepeatedData                      LostData+   |  +SyncCounter
     |  +CRCOffset                   |   | SyncCounterInit             NewDataAvailable+    |   |  | data+
     |  | DataID                     |   |   |                    WaitForFirstData+    |    |   |  |     |returned
     |  |  | DataIDNibbleOffset      |   |   |                 MaxDeltaCounter+   |    |    |   |  |     |  CRC+
     |  |  | |                       |   |   |             LastValidCounter+  |   |    |    |   |  |     |     |
     |  |  | |       DataIDMode      |   |   |        Status               |  |   |    |    |   |  |     |     |
00:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U, 1U, 0U},{E2E_PRNSTATUS_INITIAL   ,0U,0U,FALSE,TRUE,0U, 1U,0U},VD001,0x01U}
01:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U, 5U, 0U},{E2E_PRNSTATUS_OK        ,0U,3U,FALSE,TRUE,0U, 5U,0U},VD007,0x07U}
02:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,14U, 0U},{E2E_PRNSTATUS_OKSOMELOST,0U,12,FALSE,TRUE,0U,14U,0U},VD013,0x13U}
03:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U, 1U, 1U},{E2E_PRNSTATUS_WRONGCRC  ,0U,2U,FALSE,TRUE,0U, 1U,0U},VD003,0x03U}
04:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U, 5U, 7U},{E2E_PRNSTATUS_NONEWDATA ,0U,3U,FALSE,TRUE,0U, 5U,0U},VD007,0x07U}
05:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,14U,14U},{E2E_PRNSTATUS_REPEATED  ,0U,4U,FALSE,TRUE,0U,14U,0U},VD011,0x13U}

For input data VDxx, see TS_E2EPRN_ConTest_02_PRNCheckStatus_Repeated.


Test Output: 

OutputDataXX:
                                   NewDataAvailable+    +LostData
                            WaitForFirstData+      |    |   +NoNewOrRepeatedDataCounter
                         MaxDeltaCounter+   |      |    |   |   +SyncCounter
                    LastValidCounter+   |   |      |    |   |   |     +retVal
          +-Status-+                |   |   |      |    |   |   |     |  invokeCRC+
01:  {{E2E_PRNSTATUS_WRONGSEQUENCE, 0U, 1U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
02:  {{E2E_PRNSTATUS_WRONGSEQUENCE, 0U, 4U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
03:  {{E2E_PRNSTATUS_WRONGSEQUENCE, 0U,13U,FALSE, TRUE, 0U, 0U, 0U}, E2E_E_OK,  TRUE},
04:  {{E2E_PRNSTATUS_WRONGSEQUENCE, 4U, 2U,FALSE, TRUE, 0U, 0U, 1U}, E2E_E_OK,  TRUE},
05:  {{E2E_PRNSTATUS_WRONGSEQUENCE, 8U, 2U,FALSE, TRUE, 0U, 0U, 7U}, E2E_E_OK,  TRUE},
06:  {{E2E_PRNSTATUS_WRONGSEQUENCE,14U, 2U,FALSE, TRUE, 0U, 0U,14U}, E2E_E_OK,  TRUE},

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_05_PRNCheckStatus_Repeated</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>2960</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   This test shall check the behavior of the E2E-library for the function
   E2E_PRNCheck() by the path leading to E2E_PRNSTATUS_REPEATED
   that the NoNewOrRepeatedDataCounter is incremented.

    In detail:
        Test that if
          - DeltaCounter equals 0 (difference between data counter and LastValidCounter)
        THEN
          - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_REPEATED
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Successful execution of TS_E2EPRN_ConTest_02_PRNCheck_AllStates.


Test Execution: 

Execute the following steps several times with InputDataXX from input:
   01: Call E2E_PRNCheck() with
       - the E2E_PRNConfig stated in InputDataXX
       - the E2E_PRNCheckState stated in InputDataXX
       - the data VDxx stated in InputDataXX
   02: VP (see VPs of E2ETEST_GenericTest.xx stated
           in TS_E2EPRN_ConTest_02_PRNCheckStatus_WrongSequence)
       E2E_PRNCheck() returns the value stated in OutputDataXX
       E2E_PRNCheckState value are equal to values stated in OutputDataXX

   The following VPs are checked within the SCrc_CalculateCRC8 stub
   (see TS_E2EPRN_ConTest_02_PRNCheck_DataIdMode):
      - EB_E2EPRN020163 (test aspect related to call of SCrc_CalculateCRC8() only)
      - EB_E2EPRN020070,EB_E2EPRN020070
      - EB_E2EPRN020190

Test aspects of individual InputDataXX/OutputDataXX:
   Data00..Data19: VP (EB_E2EPRN020076,EB_E2EPRN020196)
           Test that if
             - DeltaCounter equals 0 (difference between data counter and LastValidCounter)
           THEN
             - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_REPEATED
           FOR
             - different rx counter values (LastValidCounter set to same value)
           INDEPENDENT
             - of parameters: SyncCounter, SyncCounterInit, NoNewOrRepeatedDataCounter,
                              MaxNoNewOrRepeatedData (set to 1), initial Rx status

   Data00..Data19: VP (EB_E2EPRN020196)
           Test that
           - MaxDeltaCounter is incremented by 1 up to 14
           FOR
           - all possible initial values

   Data00..Data19: VP (EB_E2EPRN020196)
           Test that
           - NoNewOrRepeatedDataCounter is incremented by one up to 14
           FOR
           - initial boundary values (0, 12, 13, 14)

Used Test Strategies:
- Pair wise tests
  (Different values among different E2E_PRNCheckState parameters)
- Boundary Value Analysis
  (Either usage of all possible values or min / intermediate /max value for individual parameters)
- Equivalence Class Partitioning
  (Testing only transitions to Rx status E2E_PRNSTATUS_REPEATED)


Test Input: 

InputDataXX:

CounterOffset                   MaxDeltaCounterInit                     NoNewOrRepeatedDataCounter+
     |                               |  MaxNoNewOrRepeatedData                        LostData+   |  +SyncCounter
     |  +CRCOffset                   |   | SyncCounterInit               NewDataAvailable+    |   |  | data+
     |  | DataID                     |   |   |                      WaitForFirstData+    |    |   |  |     |returned
     |  |  | DataIDNibbleOffset      |   |   |                   MaxDeltaCounter+   |    |    |   |  |     |  CRC+
     |  |  | |                       |   |   |               LastValidCounter+  |   |    |    |   |  |     |     |
     |  |  | |       DataIDMode      |   |   |        Status                 |  |   |    |    |   |  |     |     |
00:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 3U},{E2E_PRNSTATUS_OK           , 1U, 3U,FALSE,TRUE,0U, 1U,3U},VD000,0x00U}
01:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 7U},{E2E_PRNSTATUS_OKSOMELOST   , 2U, 4U,FALSE,TRUE,0U, 2U,3U},VD001,0x01U}
02:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U,10U},{E2E_PRNSTATUS_NONEWDATA    , 3U, 5U,FALSE,TRUE,0U, 3U,3U},VD002,0x02U}
03:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U,13U},{E2E_PRNSTATUS_WRONGCRC     , 4U, 6U,FALSE,TRUE,0U, 4U,3U},VD003,0x03U}
04:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 4U},{E2E_PRNSTATUS_SYNC         , 5U, 7U,FALSE,TRUE,0U, 5U,3U},VD004,0x04U}
05:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 9U},{E2E_PRNSTATUS_INITIAL      , 6U, 8U,FALSE,TRUE,0U, 6U,3U},VD005,0x05U}
06:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 3U},{E2E_PRNSTATUS_REPEATED     , 7U, 9U,FALSE,TRUE,0U, 7U,3U},VD006,0x06U}
07:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U,10U},{E2E_PRNSTATUS_WRONGSEQUENCE, 8U,10U,FALSE,TRUE,0U, 8U,3U},VD007,0x07U}
08:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U,11U},{E2E_PRNSTATUS_OK           , 9U,11U,FALSE,TRUE,0U, 9U,3U},VD008,0x08U}
09:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U,12U},{E2E_PRNSTATUS_OKSOMELOST   ,10U,12U,FALSE,TRUE,0U,10U,3U},VD009,0x09U}
10:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U,14U},{E2E_PRNSTATUS_NONEWDATA    ,11U,13U,FALSE,TRUE,0U,11U,3U},VD010,0x10U}
11:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 0U},{E2E_PRNSTATUS_WRONGCRC     ,12U,14U,FALSE,TRUE,0U,12U,3U},VD011,0x11U}
12:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 1U},{E2E_PRNSTATUS_SYNC         ,13U,15U,FALSE,TRUE,0U,13U,3U},VD012,0x12U}
13:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 2U},{E2E_PRNSTATUS_INITIAL      ,14U,15U,FALSE,TRUE,0U,14U,3U},VD013,0x13U}
14:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 3U},{E2E_PRNSTATUS_REPEATED     ,15U,15U,FALSE,TRUE,0U,15U,3U},VD014,0x14U}
15:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 3U},{E2E_PRNSTATUS_REPEATED     , 0U,15U,FALSE,TRUE,0U,15U,3U},VD015,0x15U}
16:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 4U},{E2E_PRNSTATUS_WRONGSEQUENCE, 1U,15U,FALSE,TRUE,0U,15U,3U},VD000,0x00U}
17:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 5U},{E2E_PRNSTATUS_OK           , 2U,15U,FALSE,TRUE,0U,15U,3U},VD001,0x01U}
18:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 6U},{E2E_PRNSTATUS_OKSOMELOST   , 3U,15U,FALSE,TRUE,0U,15U,3U},VD002,0x02U}
19:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 7U},{E2E_PRNSTATUS_NONEWDATA    , 4U,15U,FALSE,TRUE,0U,15U,3U},VD003,0x03U}
20:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,1U, 8U},{E2E_PRNSTATUS_WRONGCRC     , 5U,15U,FALSE,TRUE,0U,15U,3U},VD004,0x04U}


with input data VDxx:
     CRC-+        +-Counter
         |        |      +-Data------------------------------------+
VD000 {0x00U, 0xD1U, 0x00U, 0x11U, 0x12U, 0x13U, 0x14U, 0x15U, 0x16U}
VD001 {0x01U, 0xA2U, 0x10U, 0x11U, 0x12U, 0x13U, 0x14U, 0x15U, 0x16U}
VD002 {0x02U, 0xB3U, 0x20U, 0x21U, 0x22U, 0x23U, 0x24U, 0x25U, 0x26U}
VD003 {0x03U, 0xA4U, 0x30U, 0x31U, 0x32U, 0x33U, 0x34U, 0x35U, 0x36U}
VD004 {0x04U, 0xA5U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD005 {0x05U, 0xA6U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD006 {0x06U, 0xA7U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD007 {0x07U, 0xA8U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD008 {0x08U, 0xA9U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD009 {0x09U, 0xAAU, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD010 {0x10U, 0xDBU, 0x00U, 0x11U, 0x12U, 0x13U, 0x14U, 0x15U, 0x16U}
VD011 {0x11U, 0xACU, 0x10U, 0x11U, 0x12U, 0x13U, 0x14U, 0x15U, 0x16U}
VD012 {0x12U, 0xBDU, 0x20U, 0x21U, 0x22U, 0x23U, 0x24U, 0x25U, 0x26U}
VD013 {0x13U, 0xAEU, 0x30U, 0x31U, 0x32U, 0x33U, 0x34U, 0x35U, 0x36U}
VD014 {0x14U, 0xA0U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD015 {0x15U, 0xA1U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD016 {0x16U, 0xA2U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD017 {0x17U, 0xA3U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD018 {0x18U, 0xA4U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD019 {0x19U, 0xA4U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}
VD020 {0x20U, 0xA4U, 0x40U, 0x41U, 0x42U, 0x43U, 0x44U, 0x45U, 0x46U}


Test Output: 

OutputDataXX:

                                    NewDataAvailable+    +LostData
                             WaitForFirstData+      |    |   +NoNewOrRepeatedDataCounter
                          MaxDeltaCounter+   |      |    |   |   +SyncCounter
                     LastValidCounter+   |   |      |    |   |   |     +retVal
         +-Status-+                  |   |   |      |    |   |   |     |  invokeCRC+
00: {{E2E_PRNSTATUS_REPEATED,      1U, 4U,FALSE, TRUE, 0U, 2U, 3U}, E2E_E_OK,  TRUE},
01: {{E2E_PRNSTATUS_REPEATED,      2U, 5U,FALSE, TRUE, 0U, 3U, 3U}, E2E_E_OK,  TRUE},
02: {{E2E_PRNSTATUS_REPEATED,      3U, 6U,FALSE, TRUE, 0U, 4U, 3U}, E2E_E_OK,  TRUE},
03: {{E2E_PRNSTATUS_REPEATED,      4U, 7U,FALSE, TRUE, 0U, 5U, 3U}, E2E_E_OK,  TRUE},
04: {{E2E_PRNSTATUS_REPEATED,      5U, 8U,FALSE, TRUE, 0U, 6U, 3U}, E2E_E_OK,  TRUE},
05: {{E2E_PRNSTATUS_REPEATED,      6U, 9U,FALSE, TRUE, 0U, 7U, 3U}, E2E_E_OK,  TRUE},
06: {{E2E_PRNSTATUS_REPEATED,      7U,10U,FALSE, TRUE, 0U, 8U, 3U}, E2E_E_OK,  TRUE},
07: {{E2E_PRNSTATUS_REPEATED,      8U,11U,FALSE, TRUE, 0U, 9U, 3U}, E2E_E_OK,  TRUE},
08: {{E2E_PRNSTATUS_REPEATED,      9U,12U,FALSE, TRUE, 0U,10U, 3U}, E2E_E_OK,  TRUE},
09: {{E2E_PRNSTATUS_REPEATED,     10U,13U,FALSE, TRUE, 0U,11U, 3U}, E2E_E_OK,  TRUE},
10: {{E2E_PRNSTATUS_REPEATED,     11U,14U,FALSE, TRUE, 0U,12U, 3U}, E2E_E_OK,  TRUE},
11: {{E2E_PRNSTATUS_REPEATED,     12U,15U,FALSE, TRUE, 0U,13U, 3U}, E2E_E_OK,  TRUE},
12: {{E2E_PRNSTATUS_REPEATED,     13U,15U,FALSE, TRUE, 0U,14U, 3U}, E2E_E_OK,  TRUE},
13: {{E2E_PRNSTATUS_REPEATED,     14U,15U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
14: {{E2E_PRNSTATUS_REPEATED,     15U,15U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
15: {{E2E_PRNSTATUS_REPEATED,      0U,15U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
16: {{E2E_PRNSTATUS_REPEATED,      1U,15U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
17: {{E2E_PRNSTATUS_REPEATED,      2U,15U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
18: {{E2E_PRNSTATUS_REPEATED,      3U,15U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
19: {{E2E_PRNSTATUS_REPEATED,      4U,15U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
20: {{E2E_PRNSTATUS_REPEATED,      5U,15U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},


&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020301</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_06_PRNCheckStatus_Initial</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>3217</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

    This test shall check the behavior of the E2E-library for the function E2E_PRNCheck()
    by the path leading to State-&gt;Status E2E_PRNSTATUS_INITIAL.

    In detail:
        Test that if
          - WaitForFirstData is set to TRUE
        THEN
          - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_INITIAL

&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

Execute the following steps several times with InputDataXX from input:
   01: Call E2E_PRNCheck() with
       - the E2E_PRNConfig stated in InputDataXX
       - the E2E_PRNCheckState stated in InputDataXX
       - the data VDxx stated in InputDataXX
   02: VP (see VPs of E2ETEST_GenericTest.xx stated
           in TS_E2EPRN_ConTest_02_PRNCheckStatus_WrongSequence)
       E2E_PRNCheck() returns the value stated in OutputDataXX
       E2E_PRNCheckState value are equal to values stated in OutputDataXX

   The following VPs are checked within the SCrc_CalculateCRC8 stub
   (see TS_E2EPRN_ConTest_02_PRNCheck_DataIdMode):
      - EB_E2EPRN020163 (test aspect related to call of SCrc_CalculateCRC8() only)
      - EB_E2EPRN020070,EB_E2EPRN020070
      - EB_E2EPRN020190

Test aspects of individual InputDataXX/OutputDataXX:
   Data00..Data19: VP (EB_E2EPRN020196,EB_E2EPRN020148,EB_E2EPRN020076)
           Test that if
             - WaitForFirstData is set to TRUE
           THEN
             - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_INITIAL
           INDEPDENT of all other parameters (e.g. counter values, but correct CRC)
           Note: Other parameters (e.g. NoNewOrRepeatedDataCounter) are not affected

   Data00..Data19: VP (EB_E2EPRN020196)
           Test that WaitForFirstData is set to FALSE

   Data00..Data19: VP (EB_E2EPRN020196,EB_E2EPRN020150)
           Test that
           - MaxDeltaCounter is set to  MaxDeltaCounterInit
           FOR
           - all possible MaxDeltaCounterInit values.

   Data00..Data19: VP (EB_E2EPRN020196,EB_E2EPRN020151)
           Test that
           - LastValidCounter is set to the Counter of the data
           FOR
           - all possible counter values.

Used Test Strategies:
- Pair wise tests
  (Different values among different E2E_PRNCheckState parameters)
- Boundary Value Analysis
  (Either usage of all possible values or min / intermediate /max value for individual parameters)
- Equivalence Class Partitioning
  (Testing only transitions to Rx status E2E_PRNSTATUS_INITIAL)


Test Input: 

InputDataXX:

CounterOffset                   MaxDeltaCounterInit                       NoNewOrRepeatedDataCounter+
     |                               |  MaxNoNewOrRepeatedData                          LostData+   |  +SyncCounter
     |  +CRCOffset                   |   | SyncCounterInit                 NewDataAvailable+    |   |  | data+
     |  | DataID                     |   |   |                        WaitForFirstData+    |    |   |  |     |returned
     |  |  | DataIDNibbleOffset      |   |   |                     MaxDeltaCounter+   |    |    |   |  |     |  CRC+
     |  |  | |                       |   |   |                 LastValidCounter+  |   |    |    |   |  |     |     |
     |  |  | |       DataIDMode      |   |   |        Status                   |  |   |    |    |   |  |     |     |
00:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,14U,1U, 3U},{E2E_PRNSTATUS_OK           , 0U, 3U,TRUE,TRUE,0U, 1U,3U},VD000,0x00U}
01:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,13U,1U, 7U},{E2E_PRNSTATUS_OKSOMELOST   , 8U, 4U,TRUE,TRUE,0U, 2U,3U},VD001,0x01U}
02:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,12U,1U,10U},{E2E_PRNSTATUS_NONEWDATA    ,14U, 5U,TRUE,TRUE,0U, 3U,3U},VD002,0x02U}
03:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,11U,1U,13U},{E2E_PRNSTATUS_WRONGCRC     , 3U, 6U,TRUE,TRUE,0U, 4U,3U},VD003,0x03U}
04:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,10U,1U, 4U},{E2E_PRNSTATUS_SYNC         , 7U, 7U,TRUE,TRUE,0U, 5U,3U},VD004,0x04U}
05:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 9U,1U, 9U},{E2E_PRNSTATUS_INITIAL      , 9U, 8U,TRUE,TRUE,0U, 6U,3U},VD005,0x05U}
06:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 8U,1U, 3U},{E2E_PRNSTATUS_REPEATED     , 2U, 9U,TRUE,TRUE,0U, 7U,3U},VD006,0x06U}
07:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 7U,1U,10U},{E2E_PRNSTATUS_WRONGSEQUENCE, 4U,10U,TRUE,TRUE,0U, 8U,3U},VD007,0x07U}
08:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 6U,1U,11U},{E2E_PRNSTATUS_OK           , 6U,11U,TRUE,TRUE,0U, 9U,3U},VD008,0x08U}
09:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 5U,1U,12U},{E2E_PRNSTATUS_OKSOMELOST   , 8U,12U,TRUE,TRUE,0U,10U,3U},VD009,0x09U}
10:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 4U,1U,14U},{E2E_PRNSTATUS_NONEWDATA    ,10U,13U,TRUE,TRUE,0U,11U,3U},VD010,0x10U}
11:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 3U,1U, 0U},{E2E_PRNSTATUS_WRONGCRC     ,12U,14U,TRUE,TRUE,0U,12U,3U},VD011,0x11U}
12:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2U,1U, 1U},{E2E_PRNSTATUS_SYNC         ,14U,15U,TRUE,TRUE,0U,13U,3U},VD012,0x12U}
13:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 1U,1U, 2U},{E2E_PRNSTATUS_INITIAL      , 1U,15U,TRUE,TRUE,0U,14U,3U},VD013,0x13U}
14:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 0U,1U, 3U},{E2E_PRNSTATUS_REPEATED     , 3U,15U,TRUE,TRUE,0U,15U,3U},VD014,0x14U}
15:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 1U,1U, 4U},{E2E_PRNSTATUS_WRONGSEQUENCE, 5U,15U,TRUE,TRUE,0U,15U,3U},VD015,0x15U}
16:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 2U,1U, 5U},{E2E_PRNSTATUS_OK           , 7U,15U,TRUE,TRUE,0U,15U,3U},VD000,0x00U}
17:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 3U,1U, 6U},{E2E_PRNSTATUS_OKSOMELOST   , 9U,15U,TRUE,TRUE,0U,15U,3U},VD001,0x01U}
18:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 4U,1U, 7U},{E2E_PRNSTATUS_NONEWDATA    , 13,15U,TRUE,TRUE,0U,15U,3U},VD002,0x02U}
19:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH, 5U,1U, 8U},{E2E_PRNSTATUS_WRONGCRC     , 0U,15U,TRUE,TRUE,0U,15U,3U},VD003,0x03U}


For input data VDxx, see TS_E2EPRN_ConTest_02_PRNCheckStatus_Repeated.


Test Output: 

OutputDataXX:
                                   NewDataAvailable+    +LostData
                            WaitForFirstData+      |    |   +NoNewOrRepeatedDataCounter
                         MaxDeltaCounter+   |      |    |   |   +SyncCounter
                    LastValidCounter+   |   |      |    |   |   |     +retVal
          +-Status-+                |   |   |      |    |   |   |     |  invokeCRC+
00: {{E2E_PRNSTATUS_INITIAL  ,     1U,14U,FALSE, TRUE, 0U, 1U, 3U}, E2E_E_OK,  TRUE},
01: {{E2E_PRNSTATUS_INITIAL  ,     2U,13U,FALSE, TRUE, 0U, 2U, 3U}, E2E_E_OK,  TRUE},
02: {{E2E_PRNSTATUS_INITIAL  ,     3U,12U,FALSE, TRUE, 0U, 3U, 3U}, E2E_E_OK,  TRUE},
03: {{E2E_PRNSTATUS_INITIAL  ,     4U,11U,FALSE, TRUE, 0U, 4U, 3U}, E2E_E_OK,  TRUE},
04: {{E2E_PRNSTATUS_INITIAL  ,     5U,10U,FALSE, TRUE, 0U, 5U, 3U}, E2E_E_OK,  TRUE},
05: {{E2E_PRNSTATUS_INITIAL  ,     6U, 9U,FALSE, TRUE, 0U, 6U, 3U}, E2E_E_OK,  TRUE},
06: {{E2E_PRNSTATUS_INITIAL  ,     7U, 8U,FALSE, TRUE, 0U, 7U, 3U}, E2E_E_OK,  TRUE},
07: {{E2E_PRNSTATUS_INITIAL  ,     8U, 7U,FALSE, TRUE, 0U, 8U, 3U}, E2E_E_OK,  TRUE},
08: {{E2E_PRNSTATUS_INITIAL  ,     9U, 6U,FALSE, TRUE, 0U, 9U, 3U}, E2E_E_OK,  TRUE},
09: {{E2E_PRNSTATUS_INITIAL  ,    10U, 5U,FALSE, TRUE, 0U,10U, 3U}, E2E_E_OK,  TRUE},
10: {{E2E_PRNSTATUS_INITIAL  ,    11U, 4U,FALSE, TRUE, 0U,11U, 3U}, E2E_E_OK,  TRUE},
11: {{E2E_PRNSTATUS_INITIAL  ,    12U, 3U,FALSE, TRUE, 0U,12U, 3U}, E2E_E_OK,  TRUE},
12: {{E2E_PRNSTATUS_INITIAL  ,    13U, 2U,FALSE, TRUE, 0U,13U, 3U}, E2E_E_OK,  TRUE},
13: {{E2E_PRNSTATUS_INITIAL  ,    14U, 1U,FALSE, TRUE, 0U,14U, 3U}, E2E_E_OK,  TRUE},
14: {{E2E_PRNSTATUS_INITIAL  ,    15U, 0U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
15: {{E2E_PRNSTATUS_INITIAL  ,     0U, 1U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
16: {{E2E_PRNSTATUS_INITIAL  ,     1U, 2U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
17: {{E2E_PRNSTATUS_INITIAL  ,     2U, 3U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
18: {{E2E_PRNSTATUS_INITIAL  ,     3U, 4U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},
19: {{E2E_PRNSTATUS_INITIAL  ,     4U, 5U,FALSE, TRUE, 0U,15U, 3U}, E2E_E_OK,  TRUE},


&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_07_PRNCheckStatus_NoNewData</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>3450</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   This test shall check the behavior of the E2E-library for the function
   E2E_PRNCheck() by the path leading to E2E_PRNSTATUS_NONEWDATA
   that the NoNewOrRepeatedDataCounter is incremented.

    In detail:
     Test that if
       - E2E_PRNCheckState.NewDataAvailable is set to FALSE
     THEN
       - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_NONEWDATA
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Successful execution of TS_E2EPRN_ConTest_02_PRNCheck_AllStates.


Test Execution: 

Execute the following steps several times with InputDataXX from input:
   01: Call E2E_PRNCheck() with
       - the E2E_PRNConfig stated in InputDataXX
       - the E2E_PRNCheckState stated in InputDataXX
       - the data VDxx stated in InputDataXX
   02: VP (see VPs of E2ETEST_GenericTest.xx stated
           in TS_E2EPRN_ConTest_02_PRNCheckStatus_WrongSequence)
       E2E_PRNCheck() returns the value stated in OutputDataXX
       E2E_PRNCheckState value are equal to values stated in OutputDataXX

   The following VPs are checked within the SCrc_CalculateCRC8 stub
   (see TS_E2EPRN_ConTest_02_PRNCheck_DataIdMode):
      - EB_E2EPRN020163 (test aspect related to call of SCrc_CalculateCRC8() only)
      - EB_E2EPRN020070,EB_E2EPRN020070
      - EB_E2EPRN020190

Test aspects of individual InputDataXX/OutputDataXX:

   Data00..Data19: VP (EB_E2EPRN020076,EB_E2EPRN020196)
           Test that if
             - E2E_PRNCheckState.NewDataAvailable is set to FALSE
           THEN
             - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_NONEWDATA
           INDEPENDENT
             - of all other E2E_PRNCheckState parameters

   Data00..Data19: VP (EB_E2EPRN020196)
           Test that
           - MaxDeltaCounter is incremented by 1 up to 14
           FOR
           - all possible initial values

   Data00..Data19: VP (EB_E2EPRN020301)
           Test that
           - NoNewOrRepeatedDataCounter is incremented by one up to 14
           FOR
           - all possible initial values

Used Test Strategies:
- Pair wise tests
  (Different values among different E2E_PRNCheckState parameters)
- Boundary Value Analysis
  (Either usage of all possible values or min / intermediate /max value for individual parameters)
- Equivalence Class Partitioning
  (Testing only transitions to Rx status E2E_PRNSTATUS_NONEWDATA)


Test Input: 

InputDataXX:

CounterOffset                   MaxDeltaCounterInit                     NoNewOrRepeatedDataCounter+
     |                               |  MaxNoNewOrRepeatedData                         LostData+  | +SyncCounter
     |  +CRCOffset                   |   | SyncCounterInit                NewDataAvailable+    |  | | data+
     |  | DataID                     |   |   |                       WaitForFirstData+    |    |  | |     |returned
     |  |  | DataIDNibbleOffset      |   |   |                    MaxDeltaCounter+   |    |    |  | |     |  CRC+
     |  |  | |                       |   |   |                LastValidCounter+  |   |    |    |  | |     |     |
     |  |  | |       DataIDMode      |   |   |        Status                  |  |   |    |    |  | |     |     |
00:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,14U, 1U, 1U},{E2E_PRNSTATUS_OK           ,0, 2,FALSE,FALSE,0, 0,3},VD000,0x00}
01:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,13U, 2U, 3U},{E2E_PRNSTATUS_OKSOMELOST   ,0, 3,FALSE,FALSE,0, 1,3},VD001,0x01}
02:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,12U, 3U, 5U},{E2E_PRNSTATUS_NONEWDATA    ,0, 4,FALSE,FALSE,0, 2,3},VD002,0x02}
03:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,11U, 4U, 7U},{E2E_PRNSTATUS_WRONGCRC     ,0, 5,FALSE,FALSE,0, 3,3},VD003,0x03}
04:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,10U, 5U, 9U},{E2E_PRNSTATUS_SYNC         ,0, 6,FALSE,FALSE,0, 4,3},VD004,0x04}
05:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,9U, 6U,11U},{E2E_PRNSTATUS_INITIAL      ,0, 7,FALSE,FALSE,0, 5,3},VD005,0x05}
06:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,8U, 7U,13U},{E2E_PRNSTATUS_REPEATED     ,0, 8,FALSE,FALSE,0, 6,3},VD006,0x06}
07:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,7U, 8U,14U},{E2E_PRNSTATUS_WRONGSEQUENCE,0, 9,FALSE,FALSE,0, 7,3},VD007,0x07}
08:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,6U, 9U,13U},{E2E_PRNSTATUS_OK           ,0,10,FALSE,FALSE,0, 8,3},VD008,0x08}
09:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,5U,10U,11U},{E2E_PRNSTATUS_OKSOMELOST   ,0,11,FALSE,FALSE,0, 9,3},VD009,0x09}
10:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,4U,11U, 9U},{E2E_PRNSTATUS_NONEWDATA    ,0,12,FALSE,FALSE,0,10,3},VD010,0x10}
11:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,3U,12U, 7U},{E2E_PRNSTATUS_WRONGCRC     ,0,13,FALSE,FALSE,0,11,3},VD011,0x11}
12:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,13U, 5U},{E2E_PRNSTATUS_SYNC         ,0,14,FALSE,FALSE,0,12,3},VD012,0x12}
13:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,1U,14U, 3U},{E2E_PRNSTATUS_INITIAL      ,0,15,FALSE,FALSE,0,13,3},VD013,0x13}
14:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,0U,13U, 1U},{E2E_PRNSTATUS_REPEATED     ,0,15,FALSE,FALSE,0,14,3},VD014,0x14}
15:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,1U,12U, 0U},{E2E_PRNSTATUS_WRONGSEQUENCE,0,15,FALSE,FALSE,0,15,3},VD015,0x15}
16:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,2U,11U, 2U},{E2E_PRNSTATUS_OK           ,0,15,FALSE,FALSE,0, 1,3},VD016,0x16}
17:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,3U,10U, 4U},{E2E_PRNSTATUS_OKSOMELOST   ,0,15,FALSE,FALSE,0, 2,3},VD017,0x17}
18:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,4U,9U, 6U},{E2E_PRNSTATUS_NONEWDATA    ,0,15,FALSE,FALSE,0, 3,3},VD018,0x18}
19:{8U,0U,1U,0U,E2E_PRN_DATAID_BOTH,5U,8U, 8U},{E2E_PRNSTATUS_WRONGCRC     ,0,15,FALSE,FALSE,0, 4,3},VD019,0x19}


For input data VDxx, see TS_E2EPRN_ConTest_02_PRNCheckStatus_Repeated.


Test Output: 

OutputDataXX:
                                   NewDataAvailable+    +LostData
                            WaitForFirstData+      |    |   +NoNewOrRepeatedDataCounter
                         MaxDeltaCounter+   |      |    |   |   +SyncCounter
                    LastValidCounter+   |   |      |    |   |   |     +retVal
          +-Status-+                |   |   |      |    |   |   |     |  invokeCRC+
00: {{E2E_PRNSTATUS_NONEWDATA,     0U, 3U,FALSE,FALSE, 0U, 1U, 3U}, E2E_E_OK, FALSE},
01: {{E2E_PRNSTATUS_NONEWDATA,     0U, 4U,FALSE,FALSE, 0U, 2U, 3U}, E2E_E_OK, FALSE},
02: {{E2E_PRNSTATUS_NONEWDATA,     0U, 5U,FALSE,FALSE, 0U, 3U, 3U}, E2E_E_OK, FALSE},
03: {{E2E_PRNSTATUS_NONEWDATA,     0U, 6U,FALSE,FALSE, 0U, 4U, 3U}, E2E_E_OK, FALSE},
04: {{E2E_PRNSTATUS_NONEWDATA,     0U, 7U,FALSE,FALSE, 0U, 5U, 3U}, E2E_E_OK, FALSE},
05: {{E2E_PRNSTATUS_NONEWDATA,     0U, 8U,FALSE,FALSE, 0U, 6U, 3U}, E2E_E_OK, FALSE},
06: {{E2E_PRNSTATUS_NONEWDATA,     0U, 9U,FALSE,FALSE, 0U, 7U, 3U}, E2E_E_OK, FALSE},
07: {{E2E_PRNSTATUS_NONEWDATA,     0U,10U,FALSE,FALSE, 0U, 8U, 3U}, E2E_E_OK, FALSE},
08: {{E2E_PRNSTATUS_NONEWDATA,     0U,11U,FALSE,FALSE, 0U, 9U, 3U}, E2E_E_OK, FALSE},
09: {{E2E_PRNSTATUS_NONEWDATA,     0U,12U,FALSE,FALSE, 0U,10U, 3U}, E2E_E_OK, FALSE},
10: {{E2E_PRNSTATUS_NONEWDATA,     0U,13U,FALSE,FALSE, 0U,11U, 3U}, E2E_E_OK, FALSE},
11: {{E2E_PRNSTATUS_NONEWDATA,     0U,14U,FALSE,FALSE, 0U,12U, 3U}, E2E_E_OK, FALSE},
12: {{E2E_PRNSTATUS_NONEWDATA,     0U,15U,FALSE,FALSE, 0U,13U, 3U}, E2E_E_OK, FALSE},
13: {{E2E_PRNSTATUS_NONEWDATA,     0U,15U,FALSE,FALSE, 0U,14U, 3U}, E2E_E_OK, FALSE},
14: {{E2E_PRNSTATUS_NONEWDATA,     0U,15U,FALSE,FALSE, 0U,15U, 3U}, E2E_E_OK, FALSE},
15: {{E2E_PRNSTATUS_NONEWDATA,     0U,15U,FALSE,FALSE, 0U,15U, 3U}, E2E_E_OK, FALSE},
16: {{E2E_PRNSTATUS_NONEWDATA,     0U,15U,FALSE,FALSE, 0U, 2U, 3U}, E2E_E_OK, FALSE},
17: {{E2E_PRNSTATUS_NONEWDATA,     0U,15U,FALSE,FALSE, 0U, 3U, 3U}, E2E_E_OK, FALSE},
18: {{E2E_PRNSTATUS_NONEWDATA,     0U,15U,FALSE,FALSE, 0U, 4U, 3U}, E2E_E_OK, FALSE},
19: {{E2E_PRNSTATUS_NONEWDATA,     0U,15U,FALSE,FALSE, 0U, 5U, 3U}, E2E_E_OK, FALSE},


&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020076</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020301</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_08_PRNCheckStatus_Sync</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>3677</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check the behavior of the E2E-library for the function E2E_PRNCheck()
    by the path leading to
    State-&gt;Status E2E_PRNSTATUS_SYNC.

    Note:
    Since several test strategies are applied intensively, this test-case
    additionally checks some aspects of the paths leading to different
    Status values too (e.g. E2E_PRNSTATUS_OK, E2E_PRNSTATUS_OKSOMELOST,
    E2E_PRNSTATUS_REPEATED, E2E_PRNSTATUS_WRONGSEQUENCE, E2E_PRNSTATUS_REPEATED)
    Test additionally possible different Status values).
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 

For all input vector entries i:
    01: Prepare CRC stub to return correct CRC w.r.t.
        used test data
    02: call E2E_PRNCheck(Config, State, Data) with:
        Config.MaxDeltaCounterInit = 5
        Config.MaxNoNewOrRepeatedData = 6
        Config.SyncCounterInit = 3
        State = IV_E2E_PRNCheckStateType[i]
        Data = some valid data with counter value specified in IV_DataCounterValue[i]
    03: E2E_PRNCheck returns OK and the new PRNCheckState equals
        OV_E2E_PRNCheckStateType[i]

   The following VPs are checked within the SCrc_CalculateCRC8 stub
   (see TS_E2EPRN_ConTest_02_PRNCheck_DataIdMode):
      - EB_E2EPRN020163 (test aspect related to call of SCrc_CalculateCRC8() only)
      - EB_E2EPRN020070,EB_E2EPRN020070
      - EB_E2EPRN020190

Additional Descriptions for steps 02 and 03 w.r.t. IV/OV entries:
      Vector entry id
  Step |
    |  |
   02[01]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData
         (=&gt;invalidates Sync state regarding EB_E2EPRN020298)
       * State.SyncCounter = 0
         (=&gt;invalidates Sync state regarding EB_E2EPRN020299)
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 1 (1&amp;lt;=..&amp;lt;=MaxDeltaCounter+1)
       (Boundary test regarding DeltaCounter and NoNewOrRepeatedDataCounter)
   02[02]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData+1
       * State.SyncCounter = 7
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 1 (1&amp;lt;=..&amp;lt;=MaxDeltaCounter+1)
       (Boundary test regarding DeltaCounter and NoNewOrRepeatedDataCounter)
   02[03]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData
         (=&gt;invalidates Sync state regarding EB_E2EPRN020298)
       * State.SyncCounter = 0
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 11 (1&amp;lt;=..&amp;lt;=MaxDeltaCounter+1)
       (Boundary test regarding DeltaCounter and NoNewOrRepeatedDataCounter)
   02[04]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData+1
       * State.SyncCounter = 8
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 11 (1&amp;lt;=..&amp;lt;=MaxDeltaCounter+1)
       (Boundary test regarding DeltaCounter and NoNewOrRepeatedDataCounter)
   02[05]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData+1
       * State.SyncCounter = 0
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 0 (&amp;lt;1)
         (=&gt;invalidates Sync state regarding EB_E2EPRN020298)
       (Boundary test regarding DeltaCounter and NoNewOrRepeatedDataCounter)
   02[06]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData+1
       * State.SyncCounter = 0
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 12 (&gt;MaxDeltaCounter+1)
         (=&gt;invalidates Sync state regarding EB_E2EPRN020298)
       (Boundary test regarding DeltaCounter and NoNewOrRepeatedDataCounter)

   02[07]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData
       * State.SyncCounter = 3
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 1 (1&amp;lt;=..&amp;lt;=MaxDeltaCounter+1)
       (Boundary test regarding SyncCounter, DeltaCounter, and NoNewOrRepeatedDataCounter)
   02[08]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData+1
         (=&gt;invalidates Sync state regarding EB_E2EPRN020299, but EB_E2EPRN020298 is valid)
       * State.SyncCounter = 3
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 1 (1&amp;lt;=..&amp;lt;=MaxDeltaCounter+1)
       (Boundary test regarding SyncCounter, DeltaCounter, and NoNewOrRepeatedDataCounter)
   02[09]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = 0
       * State.SyncCounter = 2
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 11 (1&amp;lt;=..&amp;lt;=MaxDeltaCounter+1)
       (Boundary test regarding SyncCounter, DeltaCounter, and NoNewOrRepeatedDataCounter)
   02[10]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData+1
         (=&gt;invalidates Sync state regarding EB_E2EPRN020299 but validates EB_E2EPRN020298)
       * State.SyncCounter = 1
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 11 (1&amp;lt;=..&amp;lt;=MaxDeltaCounter+1)
       (Boundary test regarding SyncCounter, DeltaCounter, and NoNewOrRepeatedDataCounter)
   02[11]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData
       * State.SyncCounter = 3
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 0 (&amp;lt;1)
         (=&gt;invalidates Sync state regarding EB_E2EPRN020299)
       (Boundary test regarding SyncCounter, DeltaCounter, and NoNewOrRepeatedDataCounter)
   02[12]:
       Prepare data such that
       * State.NoNewOrRepeatedDataCounter = Config.MaxNoNewOrRepeatedData
       * State.SyncCounter = 3
       * State.MaxDeltaCounter = 10 (Note: is internally incremented before comparison)
       * difference between LastValidCounter and received Counter = 12 (&gt;MaxDeltaCounter+1)
         (=&gt;invalidates Sync state regarding EB_E2EPRN020299)
       (Boundary test regarding SyncCounter, DeltaCounter, and NoNewOrRepeatedDataCounter)

   03[01]: VP (EB_E2EPRN020147, EB_E2EPRN020196, EB_E2EPRN020298, EB_E2EPRN020299)
             ReceiverStateType.status equals E2E_PRNSTATUS_OK
             SyncCounter equals 0
           VP (EB_E2EPRN020300)
             NoNewOrRepeatedDataCounter equals 0
   03[02]: VP (EB_E2EPRN020196, EB_E2EPRN020298)
             ReceiverStateType.status equals E2E_PRNSTATUS_SYNC
             SyncCounter equals Config-&gt;SyncCounterInit
           VP (EB_E2EPRN020196, EB_E2EPRN020150)
             * State-&gt;MaxDeltaCounter equals Config-&gt;MaxDeltaCounterInit
           VP (EB_E2EPRN020196, EB_E2EPRN020151)
             * State-&gt;LastValidCounter equals the counter of the actually received Data
           VP (EB_E2EPRN020196, EB_E2EPRN020300)
             * State-&gt;NoNewOrRepeatedDataCounter equals 0
   03[03]: VP (EB_E2EPRN020148, EB_E2EPRN020196, EB_E2EPRN020298)
             ReceiverStateType.status equals E2E_PRNSTATUS_OKSOMELOST
           VP (EB_E2EPRN020300)
             NoNewOrRepeatedDataCounter equals 0
   03[04]: VP (EB_E2EPRN020196, EB_E2EPRN020298)
             ReceiverStateType.status equals E2E_PRNSTATUS_SYNC
             SyncCounter equals Config-&gt;SyncCounterInit
           VP (EB_E2EPRN020196, EB_E2EPRN020150)
             * State-&gt;MaxDeltaCounter equals Config-&gt;MaxDeltaCounterInit
           VP (EB_E2EPRN020196, EB_E2EPRN020151)
             * State-&gt;LastValidCounter equals the counter of the actually received Data
           VP (EB_E2EPRN020196, EB_E2EPRN020300)
             * State-&gt;NoNewOrRepeatedDataCounter equals 0
   03[05]: VP (EB_E2EPRN020196, EB_E2EPRN020298)
             ReceiverStateType.status does not equal E2E_PRNSTATUS_SYNC
   03[06]: VP (EB_E2EPRN020196, EB_E2EPRN020298)
             ReceiverStateType.status does not equal E2E_PRNSTATUS_SYNC


   03[07]: VP (EB_E2EPRN020196, EB_E2EPRN020299)
             * ReceiverStateType.status equals E2E_PRNSTATUS_SYNC
             * SyncCounter equals 2
           VP (EB_E2EPRN020196, EB_E2EPRN020150)
             * State-&gt;MaxDeltaCounter equals Config-&gt;MaxDeltaCounterInit
           VP (EB_E2EPRN020196, EB_E2EPRN020151)
             * State-&gt;LastValidCounter equals the counter of the actually received Data
           VP (EB_E2EPRN020196, EB_E2EPRN020300)
             * State-&gt;NoNewOrRepeatedDataCounter equals 0
   03[08]: VP (EB_E2EPRN020196, EB_E2EPRN020299, EB_E2EPRN020298)
             * ReceiverStateType.status equals E2E_PRNSTATUS_SYNC
             * SyncCounter equals 3
           VP (EB_E2EPRN020196, EB_E2EPRN020150)
             * State-&gt;MaxDeltaCounter equals Config-&gt;MaxDeltaCounterInit
           VP (EB_E2EPRN020196, EB_E2EPRN020151)
             * State-&gt;LastValidCounter equals the counter of the actually received Data
           VP (EB_E2EPRN020196, EB_E2EPRN020300)
             * State-&gt;NoNewOrRepeatedDataCounter equals 0
   03[09]: VP (EB_E2EPRN020196, EB_E2EPRN020299)
             ReceiverStateType.status equals E2E_PRNSTATUS_SYNC
             SyncCounter equals 1
           VP (EB_E2EPRN020196, EB_E2EPRN020150)
             * State-&gt;MaxDeltaCounter equals Config-&gt;MaxDeltaCounterInit
           VP (EB_E2EPRN020196, EB_E2EPRN020151)
             * State-&gt;LastValidCounter equals the counter of the actually received Data
           VP (EB_E2EPRN020196, EB_E2EPRN020300)
             * State-&gt;NoNewOrRepeatedDataCounter equals 0
   03[10]: VP (EB_E2EPRN020196, EB_E2EPRN020299, EB_E2EPRN020298)
             ReceiverStateType.status equals E2E_PRNSTATUS_SYNC
             SyncCounter equals 3
           VP (EB_E2EPRN020196, EB_E2EPRN020150)
             * State-&gt;MaxDeltaCounter equals Config-&gt;MaxDeltaCounterInit
           VP (EB_E2EPRN020196, EB_E2EPRN020151)
             * State-&gt;LastValidCounter equals the counter of the actually received Data
           VP (EB_E2EPRN020196, EB_E2EPRN020300)
             * State-&gt;NoNewOrRepeatedDataCounter equals 0
   03[11]: VP (EB_E2EPRN020196, EB_E2EPRN020299)
             ReceiverStateType.status does not equal E2E_PRNSTATUS_SYNC
             SyncCounter equals 3
   03[12]: VP (EB_E2EPRN020196, EB_E2EPRN020299)
             ReceiverStateType.status does not equal E2E_PRNSTATUS_SYNC
             SyncCounter equals 3

Used Test Strategies:
- Pair wise tests
  (Different values among different E2E_PRNCheckState parameters)
- Boundary Value Analysis
  (Either usage of all possible values or min / intermediate /max value for individual parameters)
- Equivalence Class Partitioning
  (Testing only transitions to Rx status E2E_PRNSTATUS_SYNC)


Test Input: 

Config.MaxDeltaCounterInit = 5
Config.MaxNoNewOrRepeatedData = 6
Config.SyncCounterInit = 3

                               NewDataAvailable+    +LostData
                        WaitForFirstData+      |    |   +NoNewOrRepeatedDataCounter
                     MaxDeltaCounter+   |      |    |   |   +SyncCounter
               LastValidCounter+    |   |      |    |   |   |
            +-Status-+         |    |   |      |    |   |   |
 IV_E2E_PRNCheckStateType[] =
   01: {E2E_PRNSTATUS_OK,    1U, 10U,FALSE, TRUE, 0U, 6U, 0U},
   02: {E2E_PRNSTATUS_OK,    2U, 10U,FALSE, TRUE, 0U, 7U, 0U},
   03: {E2E_PRNSTATUS_OK,    3U, 10U,FALSE, TRUE, 0U, 6U, 0U},
   04: {E2E_PRNSTATUS_OK,    4U, 10U,FALSE, TRUE, 0U, 7U, 8U},
   05: {E2E_PRNSTATUS_OK,    5U, 10U,FALSE, TRUE, 0U, 7U, 0U},
   06: {E2E_PRNSTATUS_OK,    6U, 10U,FALSE, TRUE, 0U, 7U, 0U},
   07: {E2E_PRNSTATUS_OK,    7U, 10U,FALSE, TRUE, 0U, 6U, 3U},
   08: {E2E_PRNSTATUS_OK,    8U, 10U,FALSE, TRUE, 0U, 7U, 3U},
   09: {E2E_PRNSTATUS_OK,    10U, 10U,FALSE, TRUE, 0U, 0U, 2U},
   10: {E2E_PRNSTATUS_OK,   10U, 10U,FALSE, TRUE, 0U, 7U, 1U},
   11: {E2E_PRNSTATUS_OK,   11U, 10U,FALSE, TRUE, 0U, 6U, 3U},
   12: {E2E_PRNSTATUS_OK,   12U, 10U,FALSE, TRUE, 0U, 6U, 3U},

           +-Counter
           |
 IV_DataCounterValue[] =
   01: {  2U }  =&gt; Delta=1
   02: {  3U }  =&gt; Delta=1
   03: { 14U }  =&gt; Delta=11
   04: { 15U }  =&gt; Delta=11
   05: {  5U }  =&gt; Delta=0
   06: {  3U }  =&gt; Delta=12
   07: {  8U }  =&gt; Delta=1
   08: {  9U }  =&gt; Delta=1
   09: {  5U }  =&gt; Delta=11
   10: {  6U }  =&gt; Delta=11
   11: { 11U }  =&gt; Delta=0
   12: {  9U }  =&gt; Delta=12


Test Output: 


                                        NewDataAvailable+   +LostData
                                 WaitForFirstData+      |    |   +NoNewOrRepeatedDataCounter
                             MaxDeltaCounter+    |      |    |   |   +SyncCounter
                      LastValidCounter+     |    |      |    |   |   |
            +-Status-+                |     |    |      |    |   |   |
 OV_E2E_PRNCheckStateType[] =
   01: {E2E_PRNSTATUS_OK,            2U, 5U, FALSE, TRUE,  0U, 0U, 0U},
   02: {E2E_PRNSTATUS_SYNC,          3U, 5U, FALSE, TRUE,  0U, 0U, 3U},
   03: {E2E_PRNSTATUS_OKSOMELOST,   14U, 5U, FALSE, TRUE, 10U, 0U, 0U},
   04: {E2E_PRNSTATUS_SYNC,          15U, 5U, FALSE, TRUE, 10U, 0U, 3U},
   05: {E2E_PRNSTATUS_REPEATED,      5U,11U, FALSE, TRUE,  0U, 8U, 0U},
   06: {E2E_PRNSTATUS_WRONGSEQUENCE, 3U, 5U, FALSE, TRUE,  0U, 0U, 3U},
   07: {E2E_PRNSTATUS_SYNC,          8U, 5U, FALSE, TRUE,  0U, 0U, 2U},
   08: {E2E_PRNSTATUS_SYNC,          9U, 5U, FALSE, TRUE,  0U, 0U, 3U},
   09: {E2E_PRNSTATUS_SYNC,          5U, 5U, FALSE, TRUE, 10U, 0U, 1U},
   10: {E2E_PRNSTATUS_SYNC,          6U, 5U, FALSE, TRUE, 10U, 0U, 3U},
   11: {E2E_PRNSTATUS_REPEATED,     11U,11U, FALSE, TRUE,  0U, 7U, 3U},
   12: {E2E_PRNSTATUS_WRONGSEQUENCE, 9U, 5U, FALSE, TRUE,  0U, 0U, 3U},

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020298</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020299</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020150</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020300</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020147</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_09_PRNCheckStatus_WrongDataIDNibble</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>4049</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    The function E2E_PRNCheck() shall be tested by the path leading to
    E2E_PRNSTATUS_WRONGCRC if the CRC is correct but the received
    DataIDNibble is wrong.

    In detail:
     Test that if
       - DataIDMode is configured to E2E_PRN_DATAID_NIBBLE, and
       - received Data contains correct CRC, and
       - the received DataIDNibble is different to the value configured in DataID
     THEN
       - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_WRONGCRC
     FOR
       - different DataIdNibbleOffset values
&lt;/para&gt;
&lt;para&gt;

&lt;/para&gt;

Test Object: None.
Test Precondition: 

Successful execution of TS_E2EPRN_ConTest_02_PRNCheck_AllStates.


Test Execution: 

Execute the following steps several times with InputDataXX from input:
   01: Call E2E_PRNCheck() with
       - the E2E_PRNConfig stated in InputDataXX
       - the E2E_PRNCheckState stated in InputDataXX
       - the data VDxx stated in InputDataXX
   02: VP (see VPs of E2ETEST_GenericTest.xx stated
           in TS_E2EPRN_ConTest_02_PRNCheckStatus_WrongSequence)
       E2E_PRNCheck() returns the value stated in OutputDataXX
       E2E_PRNCheckState value are equal to values stated in OutputDataXX

   The following VPs are checked within the SCrc_CalculateCRC8 stub
   (see TS_E2EPRN_ConTest_02_PRNCheck_DataIdMode):
      - EB_E2EPRN020163 (test aspect related to call of SCrc_CalculateCRC8() only)
      - EB_E2EPRN020070,EB_E2EPRN020070
      - EB_E2EPRN020190

Test aspects of individual InputDataXX/OutputDataXX:

   Data01,Data03,Data05: VP (EB_E2EPRN020196)
           Test that if
             - DataIDMode is configured to E2E_PRN_DATAID_NIBBLE, and
             - received Data contains correct CRC, and
             - the received DataIDNibble is different to the value configured in DataID
           THEN
             - E2E_PRNCheckState.Status equals E2E_PRNSTATUS_WRONGCRC
           FOR
             - different DataIdNibbleOffset values, and
             - different DataIdNibble values

   Data02,Data04,Data06: VP (EB_E2EPRN020196)
           Test that if
             - DataIDMode is configured to E2E_PRN_DATAID_NIBBLE, and
             - received Data contains correct CRC, and
             - the received DataIDNibble is equal to the value configured in DataID
           THEN
             - E2E_PRNCheckState.Status does not equal E2E_PRNSTATUS_WRONGCRC
               (equals E2E_PRNSTATUS_OK)
           FOR
             - different DataIdNibbleOffset values, and
             - different DataIdNibble values

   Data01..Data06: VP (EB_E2EPRN020196)
           Test that
           - MaxDeltaCounter is incremented by 1

Used Test Strategies:
- Pair wise tests
  (Different values among different E2E_PRNCheckState parameters)
- Boundary Value Analysis
  (Different and equal DataIdNibble values are tested)
- Equivalence Class Partitioning
  (Testing only transitions to Rx status E2E_PRNSTATUS_WRONGCRC due to incorrect DataIDNibble value)


Test Input: 

InputDataXX:
CounterOffset                        MaxDeltaCounterInit                 NoNewOrRepeatedDataCounter+
     |                                    |MaxNoNewOrRepeatedData                     LostData+  |  +SyncCounter
     |  +CRCOffset                        | |SyncCounterInit            NewDataAvailable+    |  |  | data+
     |  |   DataIDNibble                  | |  |                   WaitForFirstData+    |    |  |  |     |returned
     |  |    |++LowByte of DataID         | |  |                MaxDeltaCounter+   |    |    |  |  |     |  CRC+
     |  |   0||| +-DataIDNibbleOffset     | |  |            LastValidCounter+  |   |    |    |  |  |     |     |
     |  |   |||| |       DataIDMode       | |  |        Status              |  |   |    |    |  |  |     |     |
01:{ 8, 0,0x0023,12,E2E_PRN_DATAID_NIBBLE,7,14,0},{E2E_PRNSTATUS_NONEWDATA,0U,0U,FALSE,TRUE,0U,0U,0U},VD702,0x11U}
02:{ 8, 0,0x0F23,12,E2E_PRN_DATAID_NIBBLE,7,14,0},{E2E_PRNSTATUS_NONEWDATA,0U,0U,FALSE,TRUE,0U,0U,0U},VD702,0x11U}
03:{28,16,0x0734,24,E2E_PRN_DATAID_NIBBLE,7,14,0},{E2E_PRNSTATUS_NONEWDATA,0U,0U,FALSE,TRUE,0U,0U,0U},VD712,0x11U}
04:{28,16,0x0034,24,E2E_PRN_DATAID_NIBBLE,7,14,0},{E2E_PRNSTATUS_NONEWDATA,0U,0U,FALSE,TRUE,0U,0U,0U},VD712,0x11U}
05:{52,56,0x0FA8,40,E2E_PRN_DATAID_NIBBLE,7,14,0},{E2E_PRNSTATUS_NONEWDATA,0U,0U,FALSE,TRUE,0U,0U,0U},VD722,0x11U}
06:{52,56,0x08A8,40,E2E_PRN_DATAID_NIBBLE,7,14,0},{E2E_PRNSTATUS_NONEWDATA,0U,0U,FALSE,TRUE,0U,0U,0U},VD722,0x11U}

with input data VDxx:

                 +-DataIDNibble
      CRC-+      |+-Counter
          |      ||      +-Data------------------------------------+
VD702: {0x11U, 0xF1U, 0x10U, 0x11U, 0x12U, 0x13U, 0x14U, 0x15U, 0x16U}
                               +-Counter
                   CRC-+       |+-DataIDNibble
         +-Data--+     |       ||      +-Data-----------------------+
VD712: {0x10U, 0x11U, 0x11U, 0x10U, 0x12U, 0x13U, 0x14U, 0x15U, 0x16U}
                                             Counter+   CRC-+
                                  DataIDNibble+     |       |
         +-Data---------------------+         |     |       |   +Data+
VD722: {0x15U, 0x14U, 0x10U, 0x11U, 0x12U, 0x18U, 0x1AU, 0x11U, 0x16U}


Test Output: 

OutputDataXX:
                                     NewDataAvailable+       +LostData
                              WaitForFirstData+      |       |   +NoNewOrRepeatedDataCounter
                           MaxDeltaCounter+   |      |       |   |   +SyncCounter
                     LastValidCounter+    |   |      |       |   |   |     +retVal
              +-Status-+             |    |   |      |       |   |   |     |             invokeCRC+
01: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U,FALSE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
02: {{E2E_PRNSTATUS_OK      ,         1U,  7U,FALSE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
03: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U,FALSE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
04: {{E2E_PRNSTATUS_OK      ,         1U,  7U,FALSE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
05: {{E2E_PRNSTATUS_WRONGCRC,         0U,  1U,FALSE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },
06: {{E2E_PRNSTATUS_OK      ,         1U,  7U,FALSE,  TRUE,   0U, 0U, 0U}, E2E_E_OK,             TRUE  },

&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_10_PRNMapStatusToSMProfileBehaviorTRUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>4239</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

     Test that if profileBehavior==TRUE then E2E_PRNMapStatusToSM provides the following
     return value depending on the passed CheckReturn and Status values:

     1) If CheckReturn==E2E_E_OK and:
        Status==E2E_PRNSTATUS_OK =&gt; E2E_P_OK
        Status==E2E_PRNSTATUS_OKSOMELOST =&gt; E2E_P_OK
        Status==E2E_PRNSTATUS_SYNC =&gt; E2E_P_OK
        Status==E2E_PRNSTATUS_WRONGCRC =&gt; E2E_P_ERROR
        Status==E2E_PRNSTATUS_REPEATED =&gt; E2E_P_REPEATED
        Status==E2E_PRNSTATUS_NONEWDATA =&gt; E2E_P_NONEWDATA
        Status==E2E_PRNSTATUS_WRONGSEQUENCE =&gt; E2E_P_WRONGSEQUENCE
        Status==E2E_PRNSTATUS_INITIAL =&gt; E2E_P_WRONGSEQUENCE

     2) If CheckReturn != E2E_E_OK then the function E2E_PRNMapStatusToSM()
        returns E2E_P_ERROR.

     3) If Status is undefined then the function E2E_PRNMapStatusToSM()
        returns E2E_P_ERROR.

  &lt;/para&gt;
  
Test Object: E2E_PRNMapStatusToSM()
Test Precondition: 
  
Test Execution: 

    01: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    02: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_OK.
    03: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_OKSOMELOST
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    04: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_OK.
    05: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_SYNC
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    06: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_OK.
    07: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_WRONGCRC
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    08: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    09: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_REPEATED
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    10: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_REPEATED.
    11: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_NONEWDATA
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    12: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_NONEWDATA.
    13: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_WRONGSEQUENCE
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    14: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_WRONGSEQUENCE.
    15: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_INITIAL
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    16: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_WRONGSEQUENCE.
    17: Set first parameter to E2E_E_OK, second parameter to undefined value (0xFFU)
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    18: VP(EB_E2EPRN020383):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    19: Set first parameter to E2E_E_INPUTERR_NULL, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    20: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    21: Set first parameter to E2E_E_INPUTERR_WRONG, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    22: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    23: Set first parameter to E2E_E_INTERR, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    24: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    25: Set first parameter to E2E_E_INVALID, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    26: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    27: Set first parameter to E2E_E_WRONGSTATE, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to TRUE and call E2E_PRNMapStatusToSM().
    28: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.

    Used Test Strategies:
    - Pair wise tests
    (Different values among different E2E_PRNMapStatusToSM() parameters)

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020383</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020384</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_11_PRNMapStatusToSMProfileBehaviorFALSE</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>4466</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

     Test that if profileBehavior==FALSE then E2E_PRNMapStatusToSM provides the following
     return value depending on the passed CheckReturn and Status values:

     1) If CheckReturn==E2E_E_OK and:
        Status==E2E_PRNSTATUS_OK =&gt; E2E_P_OK
        Status==E2E_PRNSTATUS_OKSOMELOST =&gt; E2E_P_OK
        Status==E2E_PRNSTATUS_INITIAL =&gt; E2E_P_OK
        Status==E2E_PRNSTATUS_WRONGCRC =&gt; E2E_P_ERROR
        Status==E2E_PRNSTATUS_REPEATED =&gt; E2E_P_REPEATED
        Status==E2E_PRNSTATUS_NONEWDATA =&gt; E2E_P_REPEATED
        Status==E2E_PRNSTATUS_WRONGSEQUENCE =&gt; E2E_P_WRONGSEQUENCE
        Status==E2E_PRNSTATUS_SYNC =&gt; E2E_P_WRONGSEQUENCE

     2) If CheckReturn != E2E_E_OK then the function E2E_PRNMapStatusToSM()
        returns E2E_P_ERROR.

     3) If Status is undefined then the function E2E_PRNMapStatusToSM()
        returns E2E_P_ERROR.

  &lt;/para&gt;
  
Test Object: E2E_PRNMapStatusToSM()
Test Precondition: 
  
Test Execution: 

    01: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    02: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_OK.
    03: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_OKSOMELOST
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    04: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_OK.
    05: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_INITIAL
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    06: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_OK.
    07: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_WRONGCRC
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    08: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    09: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_REPEATED
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    10: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_REPEATED.
    11: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_NONEWDATA
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    12: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_NONEWDATA.
    13: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_WRONGSEQUENCE
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    14: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_WRONGSEQUENCE.
    15: Set first parameter to E2E_E_OK, second parameter to E2E_PRNSTATUS_SYNC
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    16: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_WRONGSEQUENCE.
    17: Set first parameter to E2E_E_OK, second parameter to undefined value (0xFFU)
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    18: VP(EB_E2EPRN020476):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    19: Set first parameter to E2E_E_INPUTERR_NULL, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    20: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    21: Set first parameter to E2E_E_INPUTERR_WRONG, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    22: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    23: Set first parameter to E2E_E_INTERR, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    24: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    25: Set first parameter to E2E_E_INVALID, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    26: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.
    27: Set first parameter to E2E_E_WRONGSTATE, second parameter to E2E_PRNSTATUS_OK
        and profileBehavior to FALSE and call E2E_PRNMapStatusToSM().
    28: VP(EB_E2EPRN020384):
        E2E_PRNMapStatusToSM() shall return E2E_P_ERROR.

    Used Test Strategies:
    - Pair wise tests
    (Different values among different E2E_PRNMapStatusToSM() parameters)

  
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020476</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020384</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_12_PRNCheckInit_Ok</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>4693</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

     Test that in case State is valid, E2E_PRNCheckInit()
     initializes the state structure by setting:
     - LastValidCounter = 0
     - MaxDeltaCounter = 0
     - WaitForFirstData = TRUE
     - NewDataAvailable = TRUE
     - LostData = 0
     - Status = E2E_PRNSTATUS_NONEWDATA
     - NoNewOrRepeatedDataCounter = 0
     - SyncCounter = 0

  &lt;/para&gt;
  
Test Object: E2E_PRNCheckInit()
Test Precondition: None.
Test Execution: 

    01: Call E2E_PRNCheckInit() with valid parameter.
    02: VP(EB_E2EPRN020390,EB_E2EPRN020389):
        E2E_PRNCheckInit() returns E2E_E_OK.
        State structure is initialized by setting:
        - LastValidCounter = 0
        - MaxDeltaCounter = 0
        - WaitForFirstData = TRUE
        - NewDataAvailable = TRUE
        - LostData = 0
        - Status = E2E_PRNSTATUS_NONEWDATA
        - NoNewOrRepeatedDataCounter = 0
        - SyncCounter = 0

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to status E2E_E_OK for E2EPRNCheckInit() function)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020390</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_13_PRNCheckInit_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>4774</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

    Test that In case State is NULL, E2E_PRNCheckInit() returns immediately
    with E2E_E_INPUTERR_NULL (no state data is modified).

&lt;/para&gt;

Test Object: E2E_PRNCheckInit
Test Precondition: None.
Test Execution: 

  01: Call E2E_PRNCheckInit() with NULL parameter.
  02: VP(EB_E2EPRN020012,EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020389,EB_E2EPRN020390):
      E2E_PRNCheckInit() returns E2E_E_INPUTERR_NULL.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to status E2E_E_INPUTERR_NULL for E2EPRNCheckInit() function)


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020390</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_14_PRNCheck_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>4835</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check the behavior of the E2E-library for the function E2E_PRNCheck()
    applied to invalid input parameters.
    See also in the SWS section 7.2.1 Error classification
    (End-to-End Communication Protection Library V1.0.0 R4.0 Rev 1).
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 

    01: use a NULL pointer for the configuration parameter
    02: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_NULL
    03: use a NULL pointer for the receiver state parameter
    04: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_NULL
    05: use a NULL pointer for the data parameter
    06: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_NULL
    07: all input parameters (configuration, sender state and
        data) are set to NULL
    08: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_NULL
    09: all input parameters in RAM (sender state and data) are
        set to NULL
    10: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_NULL
    11: maximum allowed State.MaxDeltaCounter exceeds
    12: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020023)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    13: call with a data length which is not a multiple of 8
    14: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020018)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    15: call with a data length exceeding the maximum number of
        specified bits
    16: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020018)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    17: call with a data length smaller then 16 bits
    18: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    19: call with MaxDeltaCounterInit with invalid value
    20: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020023)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    21: WaitForFirstData in the E2E_PRNCheckStateType does
        not equal TRUE nor FALSE
    22: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    23: NewDataAvailable in the E2E_PRNCheckStateType does
        not equal TRUE nor FALSE
    24: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    25: call with value for LastValidCounter greater then 14
    26: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    27: maximum allowed State.NoNewOrRepeatedDataCounter exceeds
    28: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    29: maximum allowed State.SyncCounter exceeds
    30: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    31: maximum allowed Config.MaxNoNewOrRepeatedData exceeds
    32: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020023)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    33: maximum allowed Config.SyncCounterInit exceeds
    34: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    35: maximum allowed Config.MaxDeltaCounterInit exceeds
    36: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020023)
         E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    37: call with a crc offset greater than the configured data length
    38: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020152)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    39: call with a counter offset greater than the configured data length
    40: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020153)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    41: call with data id mode E2E_PRN_DATAID_ALT
    42: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020149)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    43: call with data id mode E2E_PRN_DATAID_NIBBLE and a too high data id (0x1000)
    44: VP (EB_E2EPRN020306)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    45: call with data id mode E2E_PRN_DATAID_NIBBLE and a too high data id (0xFFFF)
    46: VP (EB_E2EPRN020306)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    47: call with data id mode E2E_PRN_DATAID_LOW and DataID &gt;
        8bit value (0x0100U)
    48 VP (EB_E2EPRN020169)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    49: call with data id mode E2E_PRN_DATAID_LOW and DataID &gt;
        8bit value (0xFFFFU)
    50 VP (EB_E2EPRN020169)
        E2E_PRNProtect() returns E2E_E_INPUTERR_WRONG
    51: call with data id mode E2E_PRN_DATAID_NIBBLE and a too high DataIdNibbleOffset)
        (i.e. Config-&gt;DataIDNibbleOffset + 4U) &gt; Config-&gt;DataLength)
    52: VP (EB_E2EPRN020011,EB_E2EPRN020047,EB_E2EPRN020158,EB_E2EPRN020152)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    53: call with data id mode equal to E2E_PRN_DATAID_BOTH
        and DataIDNibbleOffset not equal to 0
    54: VP (EB_E2EPRN020018)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    55: call with data id mode equal to E2E_PRN_DATAID_LOW
        and DataIDNibbleOffset not equal to 0
    56: VP (EB_E2EPRN020018)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG
    57: call with data id mode equal to E2E_PRN_DATAID_BOTH
        and DataIDNibbleOffset not equal to 0
    58: VP (EB_E2EPRN020018)
        E2E_PRNCheck() returns E2E_E_INPUTERR_WRONG


Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020158</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020149</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020306</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_15_PRNCheck_CheckEnum</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>5372</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

   This test shall check enumerations in E2E_PRNCheckStatusType

&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 

    Following values shall be checked:
        NONEWDATA     0x01
        WRONGCRC      0x02
        INITAL        0x04
        REPEATED      0x08
        OK            0x00
        OKSOMELOST    0x20
        WRONGSEQUENCE 0x40
        SYNC          0x03


Test Output: 
    The values of the input set must reflect the values of the
    enumeration E2E_PRNCheckStatusType specified in
    requirement EB_E2EPRN020022.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020022</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_16_Struct</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_02_PRNCheck/source/application/E2EPRN_ConTest_02_PRNCheck.c</sourcefile>
      <sourceline>5433</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test shall check the member order in structures
   E2E_PRNCheckStateType and E2E_PRNConfigType.
 
Test Object: None.
Test Precondition: None.
Test Execution: 

  01: create a typedef E2E_PRNCheckStateCompareType
      that has the expected order of the members
      w.r.t E2E_PRNCheckStateType
  02: create a typedef E2E_PRNCheckStateCompareType
      that has the expected order of the members
      w.r.t E2E_PRNCheckStateType
  03: create a typedef E2E_PRNConfigCompareType
      that has the expected order of the members
      w.r.t E2E_PRNConfigType
  04: Define two local variables of type
      E2E_PRNCheckStateType and E2E_PRNCheckStateCompareType,
      respectively, each having the same values in the ordered
      initializer list
  05: Define two local variables of type
      E2E_PRNCheckStateType and E2E_PRNCheckStateCompareType,
      respectively, each having the same values in the ordered
      initializer list
  06: Define two local variables of type
      E2E_PRNConfigType and E2E_PRNConfigCompareType,
      respectively, each having the same values in the ordered
      initializer list
  07: VP (EB_E2EPRN020021)
      Each member of the the two local variables of Step 04
      are equal
  08: VP (EB_E2EPRN020021)
      Each member of the the two local variables of Step 05
      are equal
  09: VP (EB_E2EPRN020018)
      Each member of the the two local variables of Step 06
      are equal

 
Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020021</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_ConTest_03_PublishedInformation</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_03_General/source/application/E2EPRN_ConTest_03_General.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check the correct definition of the common published information
    provided in the module header file.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 
1. macro definition E2EPRN_VENDOR_ID
2. macro definition E2EPRN_AR_RELEASE_MAJOR_VERSION
3. macro definition E2EPRN_AR_RELEASE_MINOR_VERSION
4. macro definition E2EPRN_AR_RELEASE_REVISION_VERSION
5. macro definition E2EPRN_AR_MAJOR_VERSION
6. macro definition E2EPRN_AR_MINOR_VERSION
7. macro definition E2EPRN_AR_PATCH_VERSION
8. macro definition E2EPRN_SW_MAJOR_VERSION
9. macro definition E2EPRN_SW_MINOR_VERSION
10. macro definition E2EPRN_SW_PATCH_VERSION

Test Output: 
Test Pass Criteria:
1. E2EPRN_VENDOR_ID shall be defined
   with the value globally provided by the tooling
   environment
2. E2EPRN_AR_RELEASE_MAJOR_VERSION shall be defined
   with the value specified in config.mk
3. E2EPRN_AR_RELEASE_MINOR_VERSION shall be defined
   with the value specified in config.mk
4. E2EPRN_AR_RELEASE_REVISION_VERSION shall be defined
   with the value specified in config.mk
5. E2EPRN_AR_MAJOR_VERSION shall be defined
   with the value specified in config.mk
6. E2EPRN_AR_MINOR_VERSION shall be defined
   with the value specified in config.mk
7. E2EPRN_AR_PATCH_VERSION shall be defined
   with the value specified in config.mk
8. E2EPRN_SW_MAJOR_VERSION shall be defined
   with the value specified in config.mk
9. E2EPRN_SW_MINOR_VERSION shall be defined
   with the value specified in config.mk
10. E2EPRN_SW_PATCH_VERSION shall be defined
    with the value specified in config.mk
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_03_NoConfigParams</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_03_General/source/application/E2EPRN_ConTest_03_General.c</sourcefile>
      <sourceline>173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check that the profile does not
    have any configuration options.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 

 TS5 build process steps:
 01: Provide a reference file E2EPRN_Config.txt
     that contains the first line of the configuration
     container of the module configuration
 02: grep all variables of the installed
     profile configuration and for the name of
     the configuration container
 02a: remove all allowed variables from the result of step 02,
     i.e parameters of CommonPublishedInformation and PublishedInformation
 03: Compare the result of Step 2a with
     variables listed in E2EPRN_Config.txt
     and store the difference into
     E2EPRN_Config.txt.diff.
 04: VP (EB_E2EPRN0037)
     Step 03 reveals no difference
     (i.e. E2EPRN_Config.txt.diff is empty)
 05: Include comparison differences of Step 04
     (i.e. E2EPRN_Config.txt.diff)
     within this file.
 06: Compile this file
 07: VP (EB_E2EPRN0037)
     This file compiles without errors.
 08: Execute this test case
 09: VP (EB_E2EPRN0037)
     TS5ATL_RESULT_SUCCESS is returned Step 08

   Note:
    If one of the Verification points is violated, then the
    build process is aborted and an error is reported.


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020037</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_03_TypeDataIDMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_03_General/source/application/E2EPRN_ConTest_03_General.c</sourcefile>
      <sourceline>242</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check that the DataID Mode enumeration type exists and
    is correctly defined.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 

 TS5 build process steps:
 01: define variable of type E2E_PRNDataIDMode
 02: VP (EB_E2EPRN020200)
     size of type E2E_PRNDataIDMode equals size of an enumeration type

For each of the following enumeration values,
    E2E_PRN_DATAID_BOTH,
    E2E_PRN_DATAID_ALT,
    E2E_PRN_DATAID_LOW,
    E2E_PRN_DATAID_NIBBLE
  execute the following steps:
     03: VP (EB_E2EPRN020200)
         value is not defined as a macro
     04: assign the value to the variable of step 01
     05: VP (EB_E2EPRN020200)
         variable contains the same value


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_03_TypeSenderState</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_03_General/source/application/E2EPRN_ConTest_03_General.c</sourcefile>
      <sourceline>344</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall check that the E2E_PRNProtectStateType type exists and
    is correctly defined.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 

 TS5 build process steps:
 01: define variable of type E2E_PRNProtectStateType with initializer list
 02: VP (EB_E2EPRN020020)
     Counter member of defined variable of step 01 equals the value from step 01
     (verifies that exactly one member exists)
 03: VP (EB_E2EPRN020020)
     size of type E2E_PRNProtectStateType equals size of struct typedef
     with one uint8 member
 04: VP (EB_E2EPRN020020)
     Counter member of defined variable of step 01 can be accessed
 05: VP (EB_E2EPRN020020)
     Counter member of defined variable can have values from 0...255


Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020020</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_ConTest_04_IncludeFiles</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_04_Includes/source/application/E2EPRN_ConTest_04_Includes.c</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test shall check that E2E_PRN.h exclusively includes the files
   E2E.h, MemMap.h
   and that E2E_PRN.c exclusively includes the files
   E2E_PRN.h, SCrc_CRC8.h, MemMap.h.
 
Test Object: None.
Test Precondition: 
 
Test Execution: 

 TS5 build process steps:
  1) Provide a reference file includesOf_E2E_PRN.h.txt
     that contains the includes:
     E2E.h, MemMap.h
  2) Provide a reference file includesOf_E2E_PRN.c.txt
     that contains the includes:
     E2E_PRN.h, SCrc_CRC8.h, MemMap.h.
  3) Extract all includes of E2E_PRN.h
  4) Extract all includes of E2E_PRN.c
  5) Compare all includes of Step 3 with the
     reference file includesOf_E2E_PRN.h.txt
     and store difference
     in file includesOf_E2E_PRN.h.txt.diff.
  6) Compare all includes of Step 4 with the
     reference file includesOf_E2E_PRN.c.txt
     and store difference
     in file includesOf_E2E_PRN.h.txt.diff.
  7) Include comparison differences of Step 5 and Step 6
     (i.e. includesOf_E2E_PRN.h.txt.diff and
     includesOf_E2E_PRN.c.txt.diff) within this file.
  8) Compile this file
  9) Execute this test case which always returns
     TS5ATL_RESULT_SUCCESS

 
Test Input: 
 
Test Output: 

   Test pass criteria:
     1) The extracted includes of Step 5 and
        the reference file are identical.
     2) The extracted includes of Step 6 and
        the reference file are identical.
     3) In Step 8, this file compiles without errors.
     4) In Step 9, TS5ATL_RESULT_SUCCESS is returned.
   Note:
    If Criteria 1) or 2) is violated, then the
    build process is aborted and an error is reported.
    Further, if Criteria 1) or 2) is violated,
    then this file will not compile due to the
    inclusion of the diff results which contains
    not compilable text (backup in case the build process
    incorrectly does not abort).

 &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_ConTest_05_Files</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_05_Files/source/application/E2EPRN_ConTest_05_Files.c</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test shall check that the profile PRN specific part
   of the E2E library is built of the following files: E2E_PRN.h and E2E_PRN.c
 
Test Object: None.
Test Precondition: 
 
Test Execution: 

 TS5 build process steps:
  1) Provide a reference file E2EPRN_HeaderFiles.txt
     that contains: E2E_PRN.h
  2) Provide a reference file E2EPRN_SourceFiles.txt
     that contains: E2E_PRN.c
  3) Search for all header files existing in the
     installed Tresos plugin of E2EPRN
  4) Search for all source files existing in the
     installed Tresos plugin of E2EPRN
  5) Compare the found files of Step 3 with the
     files listed in E2EPRN_HeaderFiles.txt
     and store the difference into
     E2EPRN_HeaderFiles.txt.diff.
  6) VP (EB_E2EPRN020048)
     Step 5 reveals no difference
     (i.e. E2EPRN_HeaderFiles.txt.diff is empty)
  7) Compare the found files of Step 4 with the
     files listed in E2EPRN_SourceFiles.txt
     and store the difference into
     E2EPRN_SourceFiles.txt.diff.
  8) VP (EB_E2EPRN020048)
     Step 7 reveals no difference
     (i.e. E2EPRN_SourceFiles.txt.diff is empty)
  9) Include comparison differences of Step 5 and Step 7
     (i.e. E2EPRN_HeaderFiles.txt.diff and
     E2EPRN_SourceFiles.txt.diff) within this file.
  10) Compile this file
  11) VP (EB_E2EPRN020048)
      This file compiles without errors.
  12) Execute this test case
  13) VP (EB_E2EPRN020048)
     TS5ATL_RESULT_SUCCESS is returned in 12

   Note:
    If one of the Verification points is violated, then the
    build process is aborted and an error is reported.

 
Test Input: 
 
Test Output: 
 &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020048</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07000_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf.c</sourcefile>
      <sourceline>100</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that the transformer function returns E_SAFETY_HARD_RUNTIMEERROR when the
  module is not initialized.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  00: Call E2EXf_PartitionDeInit to ensure a non initialized state of the module.
  01: Call the transformer function with valid parameters.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00133.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07001_IOValidParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf.c</sourcefile>
      <sourceline>155</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if the input and output parameters are not valid then the in-place
  function 'E2EXf_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR for profile RN RN.
  This test verifies that the output buffer does not change when the transformer is called with
  a NULL_PTR as input data.
  This test verifies that the output buffer does not change when the transformer returns a
  hard error.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize module

  Case 1
  01: Set buffer to NULL and inputBufferLength different from 0 and call
      in-place transformer function.
      Note: The above condition is the only valid scenario for the first precondition check of
            the requirement tested here since inputBufferLength cannot have a smaller value
            than 0U (inputBufferLength &lt; upperHeaderBitsToShift/8U).
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

  Case 2
  03: Set bufferLength to NULL and call in-place transformer function.
  04: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00102.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00108.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00051.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07002_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf.c</sourcefile>
      <sourceline>243</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the upper header is copied to the front of
  existing parameter buffer by the in-place function 'E2EXf_transformerId' of profile RN RN.

  This test also verifies the imported types of PRN
     - E2E_PRNCheckStateType
     - E2E_PRNCheckStatusType
     - E2E_PRNConfigType
     - E2E_PRNProtectStateType
     - E2E_PRNCheckStateType
     - E2E_PRNProtectStateType
     - E2E_PCheckStatusType
     - E2E_SMCheckStateType
     - E2E_SMConfigType
     Std_Types:
     - Std_ReturnType
     - Std_VersionInfoType
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Call in-place transformer 'E2EXf_transformerId'.
  02: VP: In-place 'E2EXf_transformerId' copied the amount upperHeaderBitsToShift bits,
      in parameter buffer, with starting offset of headerLength, in direction
      left by 'distance' of headerLength.
  03: VP: (E2EPRN.SWS_E2EXf_00047.PRN) Instances of the imported types are defined for:
             E2E_PRNCheckStateType      E2E_PRNCheckState
             E2E_PRNCheckStatusType     E2E_PRNCheckStatus
             E2E_PRNConfigType          E2E_PRNConfig
             E2E_PRNProtectStateType    E2E_PRNProtectState
             E2E_PRNCheckStateType   E2E_PRNReceiverState
             E2E_PRNProtectStateType     E2E_PRNSenderState
             E2E_PCheckStatusType       E2E_PCheckStatus
             E2E_SMCheckStateType       E2E_SMCheckState
             E2E_SMConfigType           E2E_SMConfig
             Std_ReturnType             Std_Return
             Std_VersionInfoType        Std_VersionInfo
  04: VP: Successful compilation of E2E transformer using configuration specified above.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.EB.Transformer.InPlace.NoCopying.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00047.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07003_BufLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf.c</sourcefile>
      <sourceline>352</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place transformer 'E2EXf_transformerId' of profile RN RN sets the
  BufferLength equal to InputBufferLength plus HeaderLength in bytes.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Call in-place transformer function with valid parameters.
  02: VP: BufferLength holds the sum of InputBufferLength and HeaderLength in bytes.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00111.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07004_BufLengthCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf.c</sourcefile>
      <sourceline>408</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that for profile RN RN, in-place transformer 'E2EXf_transformerId()'
  performs a check of the bufferLength (after the computation of bufferLength):
  If bufferLength is different than the configured DataLength, then the function returns
  immediately E_SAFETY_HARD_RUNTIMEERROR (without calling an E2E Library function).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits
  - dataLength: 96 bits

Test Execution: 
  00: Initialize test buffer
  01: Reinitialize module
  02: Set correct InputBufferLength
  03: Call in-place transformer function multiple times and perform
      sanity checks (the counter value increasement is done through E2E_PRNProtect)
  04: Set InputBufferLength equal to a value different from dataLength/8 so that bufferLength
      will be computed erroneously
  05: Call in-place transformer function
  06: VP: No E2E library function was called (the counter value increasement is not done)
  07: VP: BufferLength holds the calculated value
  08: VP: 'E2EXf_transformerId()' returns E_SAFETY_HARD_RUNTIMEERROR

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00139.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07005_InvokeProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf.c</sourcefile>
      <sourceline>511</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place transformer 'E2EXf_transformerId' of profile RN RN
  invokes 'E2E_PRNProtect()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_PRNProtectInit.

  This test verifies implicitly that the mandatory interfaces for a protect transformer are called:
      API function         Description
      E2E_PRNProtect       Protects the array/buffer to  be transmitted using the E2E profile RN RN.
                           This includes checksum calculation, handling of counter and Data ID.
      E2E_PRNProtectInit   Initializes the protection state.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize Buffer with values different to 0U
  01: Reinitialize module and
      - structure of StatePtr is initialized by E2E_PRNProtectInit (Counter set to 0U).
  02: Set correct InputBufferLength.
  03: Call transformer function with valid parameters.
  04: VP: E2E_PRNProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.
  05: Manipulate config local data struct
  06: Calling internal API that is wrapped by transformer API with manipulated config data 3U times.
  07: VP: E2E_PRNProtect() was called, because counter was increased to 3U and set correctly in E2E
          header.
          This verifies indirectly that E2E_PRNProtect() passes the correct pointer to state by
          StatePtr.
          DataId in E2E header is set correctly according configuration.
          This verifies indirectly that E2E_PRNProtect() passes the correct pointer to data by
          DataPtr.
  08: Reinitialize module with respective transformer and
      - structure of StatePtr is initialized by E2E_PRNProtectInit (Counter set to 0U).
  09: Call transformer function with valid parameters.
  10: VP: E2E_PRNProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00107.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00021.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07006_RetValProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf.c</sourcefile>
      <sourceline>662</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if E2E_PRNProtect() returns E2E_E_OK then
  in-place transformer 'E2EXf_transformerId' for profile RN RN returns E_OK,
  otherwise it returns E_SAFETY_HARD_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Reinitialize module.
  02: Call transformer function with valid parameters.
  03: VP: The call was successful and 'E2EXf_transformerId' returns E_OK
  04: Make E2E_PRNProtect() return E2E_E_INPUTERR_NULL by calling internal API that is wrapped
      by transformer API with StatePtr set to NULL_PTR. Note: StatePtr is only checked in
      E2E_PRNProtect function.
  05: VP: The call was successful and 'E2EXf_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00018.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07100_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that the transformer function returns E_SAFETY_HARD_RUNTIMEERROR when the
  module is not initialized.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  00: Call E2EXf_PartitionDeInit to ensure a non initialized state of the module.
  01: Call the transformer function with valid parameters.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00133.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07101_IOValidParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>238</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if the input and output parameters are not valid then the in-place
  function 'E2EXf_Inv_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR for profile RN.
  This test verifies that the output buffer does not change when the transformer is called with
  a NULL_PTR as input data.
  This test verifies that the output buffer does not change when the transformer returns a
  hard error.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize module

  Case 1
  01: Set buffer to NULL and inputBufferLength different from 0 and call
      in-place inverted transformer function.
      Note: The above condition is the only valid scenario for the first precondition check of
            the tested requirement since inputBufferLength cannot have a smaller value than 0U
            (inputBufferLength &lt; headerLength/8U + upperHeaderBitsToShift/8U).
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

  Case 2
  03: Set bufferLength to NULL and call in-place inverted transformer function.
  04: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00105.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00108.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00051.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07102_InvokeCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>324</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId' of profile RN
  invokes 'E2E_PRNCheck()' with proper parameters.
  Additionally it is verified that in the scenario 'no new data is available' (Buffer == NULL and
  InputBufferLength == 0) the pointer to Data is valid. The size of the variable where it points
  to is not tested, as it cannot be tested and it is considered an implementation detail.

  This test also verfies that state structures are initialized correctly by E2E_PRNCheckInit.

  This test verifies that the mandatory interfaces for a check transformer are called:
      API function         Description
      E2E_PRNCheck         Checks the Data received using the E2E profile RN. This includes CRC
                           calculation, handling of Counter and Data ID.
      E2E_PRNCheckInit     Initializes the check state
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Set Buffer to defined values.
  02: Deinitialize module.
  03: VP: Transformer is deinitialized.
  04: Initialize module.
  05: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  06: VP: E2E_PRNCheck() returns E2E_P_WRONGSEQUENCE (indirectly checked, RetVal is provided to E2ESM stub).
          Verifies that state structures are initialized correctly.

  07: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  08: VP: E2E_PRNCheck() returns E2E_P_OK.
          Verifies that E2E_PRNCheck() is called because Counter was checked.

  09: - Set E2E header to values simulating repeated message (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  10: VP: E2E_PRNCheck() returns E2E_P_REPEATED.
          Verifies that E2E_PRNCheck() is called because Counter was checked.

  11: - Set E2E header to correct values (Counter = 3U).
      - Call inverted transformer function with valid parameters.
  12: VP: E2E_PRNCheck() returns E2E_P_OK.
          Verifies that E2E_PRNCheck() is called because Counter was checked.
          Verifies that correct state structure is used.

  13: - Set E2E header to correct values (Counter = 4U) except CRC is set to an incorrect value.
      - Call inverted transformer function with valid parameters.
  14: VP: E2E_PRNCheck() returns E2E_P_ERROR.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  15: - Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function valid parameters.
  16: VP: E2E_PRNCheck() returns returns E2E_P_OK.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  17: - Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function with Buffer == NULL and
        InputBufferLength == 0.
  18: VP: E2E_PRNCheck() returns E2E_P_NONEWDATA.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  19: Initialize module with respectve transformer.
  20: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  21: VP: E2E_PRNCheck() returns E2E_P_WRONGSEQUENCE (indirectly checked, RetVal is provided to E2ESM stub).
  22: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  23: VP: E2E_PRNCheck() returns E2E_P_OK (indirectly checked, RetVal is provided to E2ESM stub).
          Verifies that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00124.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00021.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07103_NewData</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>574</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies the following for an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN:
  - if buffer is equal to NULL and inputBufferLength is equal to 0, then variable
    NewDataAvailable of state object of type E2E_PRNCheckStateType associated with 'transformerId'
    is set to FALSE;
  - if inputBufferLength is equal to the configured DataLength, then variable NewDataAvailable
    of state object of type E2E_PRNCheckStateType associated with 'transformerId' is set
    to TRUE;
  - if the above conditions are not fulfilled then return E_SAFETY_HARD_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits
  - dataLength: 96 bits

Test Execution: 
  01: Set buffer equal to NULL and inputBufferLength equal to 0 and call
      inverted transformer function.
  02: VP: Variable NewDataAvailable is set to FALSE.

  03: Set inputBufferLength equal to the configured DataLength and call inverted
      transformer function.
  04: VP: Variable NewDataAvailable is set to TRUE.

  05: Set inputBufferLength to a value different from dataLength and
      call inverted transformer function.
  06: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00141.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07104_InvokeMapStatusToSM</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>689</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId'
   of profile RN with configuration parameter profileBehavior set to R4_2 invokes
   'E2E_PRNMapStatusToSM()' with proper parameters.

  This test verifies that the mandatory interfaces for a check transformer are called:
      E2E_PRNMapStatusToSM The function maps the check status of profile RN to a generic check
                           status, which can be used by E2E state machine check function.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Reinitialize module
  02: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  03: VP: Inverted transformer function returns E2E_P_WRONGSEQUENCE.
          Ensures that states are correct.
  04: - Set E2E header to values simulating a wrong sequence message (Counter = 4U).
        The ConfigPtr-&gt;MaxDeltaCounter value (2U) determines the threshold of a wrong sequence.
      - Call inverted transformer function with valid parameters.
  05: VP: E2E_PRNMapStatusToSM() is called. Verified by checking the return value of
          E2E_PRNMapStatusToSM() which is passed to E2ESM stub. It is expected to be E2E_P_WRONGSEQUENCE.
          Verifies that E2E_PRNMapStatusToSM() passes the Status provided by initialization.
  06: - Set E2E header to correct values back again (Counter = 5U) from the wrong sequence value.
      - Call inverted transformer function with valid parameters multiple times until the
        counter value reaches E2EPRN_COUNTER_MAX.
  07: - Set E2E header to values provoking E2E_PRNSTATUS_WRONGSEQUENCE, i.e. set counter to a value
        smaller than the current ConfigPtr-&gt;MaxDeltaCounter value.
      - Call inverted transformer function.
  08: VP: E2E_PRNCheck() returns E2E_PRNSTATUS_WRONGSEQUENCE.
  09: - Set E2E header to values provoking E2E_P_ERROR through an overflow of the
        E2EPRN_COUNTER_MAX value.
      - Call inverted transformer function.
  10: VP: E2E_PRNCheck() returns E2E_P_ERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00029.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07105_InvokeSMCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>845</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN invokes 'E2E_SMCheck()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_SMCheckInit.

  This test verifies that the mandatory interfaces for a check transformer are called:
      E2E_SMCheck          Checks the communication channel. It determines if the data can be used
                           for safety-related application, based on history of checks performed by
                           a corresponding E2E_P0XCheck() function.
      E2E_SMCheckInit      Initializes the state machine.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Reinitialize module
  02: VP: Init functions are called.
  03: Set E2E header to correct values
      Call inverted transformer function with valid parameters.
  04: VP: E2E_SMCheck() is called.
  05: VP: E2E_SMCheck() passes the correct ProfileStatus
      (the returned value of E2E_PRNMapStatusToSM).
  06: VP: E2E_SMCheck() points through ConfigPtr to the static SM configuration
      (provided by initialization module via E2E_SMCheckInit).
  07: VP: E2E_SMCheck() passes the correct pointer to state by StatePtr and state structures
      are initialized correctly (verified within callout).

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00028.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00021.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07106_SMCheckRetVal</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>961</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN returns E2E_E_OK after a 'E2E_SMCheck()' call, then:
  - the high nibble of the return will be set to the low nibble of the state
    of the state machine (member SMState of object of type E2E_SMStateType that
    is associated with 'transformerId');
  - the low nibble of the return will be set to the low nibble of the profile-independent
    check status of type E2E_PCheckStatusType;
  otherwise the return of the 'E2E_SMCheck()' call is E_SAFETY_SOFT_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Initialize SMState of StatePtr and return a value equal to E2E_E_OK by E2E_SMCheck.
  02: Call in-place inverted transformer function with valid parameters.
  03: VP: The high nibble of the returned value of E2EXf_Inv_'transformerId' function is
      set to the low nibble of the state of the state machine.
  04: VP: The low nibble of the returned value of E2EXf_Inv_'transformerId' function is
      set to the low nibble of the profile-independent check status of type E2E_PCheckStatusType.

  05: Return a value different to E2E_E_OK by E2E_SMCheck.
  06: VP: E2E_SMCheck() returns E_SAFETY_SOFT_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00027.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07107_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>1050</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that the buffer remains unchanged after an in-place function call
  'E2EXf_Inv_transformerId' of profile RN when upperHeaderBitsToShift is equal to 0.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Reinitialize module
  01: Call in-place inverted transformer function with inputBuffer different from NULL and
      upperHeaderBitsToShift equal to 0.
  02: VP: In-place 'E2EXf_Inv_transformerId' keeps the buffer unchanged.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.EB.InvTransformer.InPlace.NoCopying.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_07108_BufLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_07_E2EXf_InP_ComXf/source/application/E2EPRN_ConTest_07_InP_ComXf_Inv.c</sourcefile>
      <sourceline>1116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN sets the BufferLength equal to InputBufferLength minus HeaderLength in bytes.
  Additionally it is verified that BufferLength is set to zero in the case that no new data
  is available (InputBufferLength == 0 and Buffer == NULL).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits
  - dataLength: 96 bits

Test Execution: 
  Case 1 (Normal operation: For PRN, it works only if inputBufferLength equals the
    configured DataLength)
  00: Reinitialize module
  01: Set InputBufferLength to configured DataLength.
  02: Call in-place inverted transformer function with valid parameters.
  03: VP: BufferLength holds the correct value given by the subtraction of
      E2E transformer HeaderLength in bytes from InputBufferLength.

  Case 2 (No new data available: InputBufferLength equals zero and Buffer equals NULL)
  04: Set InputBufferLength to 0.
  05: Call in-place inverted transformer function with Buffer set to NULL.
  06: VP: BufferLength is 0.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00114.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08000_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf.c</sourcefile>
      <sourceline>79</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that the transformer function returns E_SAFETY_HARD_RUNTIMEERROR when the
  module is not initialized.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  00: Call E2EXf_PartitionDeInit to ensure a non initialized state of the module.
  01: Call the transformer function with valid parameters.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00133.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08001_IOValidParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf.c</sourcefile>
      <sourceline>136</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if the input and output parameters are not valid then the out-of-place
  function 'E2EXf_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR for profile RN.
  This test verifies that the output buffer does not change when the transformer is called with
  a NULL_PTR as input data.
  This test verifies that the output buffer does not change when the transformer returns a
  hard error.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize module

  Case 1 part 1
  01: Set inputBuffer to NULL and inputBufferLength different from 0 and call
      out-of-place transformer function.
      Note: The above condition is the only valid scenario for the first precondition check of
            the tested requirement since inputBufferLength cannot have a smaller value than 0U
            (inputBufferLength &lt; upperHeaderBitsToShift/8U).
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 2
  03: Set bufferLength equal to NULL and call out-of-place transformer function.
  04: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 3
  05: Set buffer equal to NULL and call out-of-place transformer function.
  06: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00106.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00108.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00051.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08002_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf.c</sourcefile>
      <sourceline>244</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if (inputBuffer is not NULL and upperHeaderBitsToShift is equal to 0),
  out-of-place transformer 'E2EXf_transformerId' of profile RN copies inputBuffer to buffer
  starting with the destination offset of headerLength.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Set inputBuffer different from NULL and upperHeaderBitsToShift equal to 0 and call
      out-of-place transformer function.
  02: VP: The function copies the inputBuffer to buffer starting with the destination offset of
      headerLength.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00115.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08003_BufLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf.c</sourcefile>
      <sourceline>311</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place transformer 'E2EXf_transformerId' of profile RN sets the
  BufferLength equal to InputBufferLength plus HeaderLength in bytes.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Call out-of-place transformer function with valid parameters.
  02: VP: BufferLength holds the sum of InputBufferLength and HeaderLength in bytes.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00111.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08004_BufLengthCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf.c</sourcefile>
      <sourceline>369</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that for profile RN, out-of-place transformer 'E2EXf_transformerId()'
  performs a check of the bufferLength (after the computation of bufferLength):
  If bufferLength is different than the configured DataLength, then the function returns
  immediately E_SAFETY_HARD_RUNTIMEERROR (without calling an E2E Library function).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits
  - dataLength: 64 bits

Test Execution: 
  00: Initialize test buffer
  01: Reinitialize module
  02: Set correct InputBufferLength
  03: Call in-place transformer function multiple times and perform
      sanity checks (the counter value increasement is done through E2E_PRNProtect)
  04: Set InputBufferLength equal to a value different from dataLength/8 so that bufferLength
      will be computed erroneously
  05: Call in-place transformer function
  06: VP: No E2E library function was called (the counter value increasement is not done)
  07: VP: BufferLength holds the calculated value
  08: VP: 'E2EXf_transformerId()' returns E_SAFETY_HARD_RUNTIMEERROR

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00139.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08005_InvokeProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf.c</sourcefile>
      <sourceline>475</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place transformer 'E2EXf_transformerId' of profile RN
  invokes 'E2E_PRNProtect()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_PRNProtectInit.

  This test verifies implicitly that the mandatory interfaces for a protect transformer are called:
      API function         Description
      E2E_PRNProtect       Protects the array/buffer to  be transmitted using the E2E profile RN.
                           This includes checksum calculation, handling of counter and Data ID.
      E2E_PRNProtectInit   Initializes the protection state.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize Buffer with values different to 0U
  01: Reinitialize module and
      - structure of StatePtr is initialized by E2E_PRNProtectInit (Counter set to 0U).
  02: Set correct InputBufferLength.
  03: Call transformer function with valid parameters.
  04: VP: E2E_PRNProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.
  05: Manipulate config local data struct
  06: Calling internal API that is wrapped by transformer API with manipulated config data 3U times.
  07: VP: E2E_PRNProtect() was called, because counter was increased to 3U and set correctly in E2E
          header.
          This verifies indirectly that E2E_PRNProtect() passes the correct pointer to state by
          StatePtr.
          DataId in E2E header is set correctly according configuration.
          This verifies indirectly that E2E_PRNProtect() passes the correct pointer to data by
          DataPtr.
  08: Reinitialize module with respective transformer and
      - structure of StatePtr is initialized by E2E_PRNProtectInit (Counter set to 0U).
  09: Call transformer function with valid parameters.
  10: VP: E2E_PRNProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00107.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00021.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08006_RetValProtect</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf.c</sourcefile>
      <sourceline>630</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if E2E_PRNProtect() returns E2E_E_OK then
  in-place transformer 'E2EXf_transformerId' for profile RN returns E_OK,
  otherwise it returns E_SAFETY_HARD_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Reinitialize module.
  02: Call transformer function with valid parameters.
  03: VP: The call was successful and 'E2EXf_transformerId' returns E_OK
  04: Make E2E_PRNProtect() return E2E_E_INPUTERR_NULL by calling internal API that is wrapped
      by transformer API with StatePtr set to NULL_PTR. Note: StatePtr is only checked in
      E2E_PRNProtect function.
  05: VP: The call was successful and 'E2EXf_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00018.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08100_NotInitialized</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  The test verifies that the transformer function returns E_SAFETY_HARD_RUNTIMEERROR when the
  module is not initialized.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  00: Call E2EXf_PartitionDeInit to ensure a non initialized state of the module.
  01: Call the transformer function with valid parameters.
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00133.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08101_IOValidParamCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if the input and output parameters are not valid then the out-of-place
  function 'E2EXf_Inv_transformerId' returns E_SAFETY_HARD_RUNTIMEERROR for profile RN.
  This test verifies that the output buffer does not change when the transformer is called with
  a NULL_PTR as input data.
  This test verifies that the output buffer does not change when the transformer returns a
  hard error.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize module

  Case 1
  01: Set inputBuffer to NULL and inputBufferLength different from 0 and call
      out-of-place inverted transformer function.
      Note: The above condition is the only valid scenario for the first precondition check of
            the tested requirement since inputBufferLength cannot have a smaller value than 0U
            (inputBufferLength &lt; headerLength/8U + upperHeaderBitsToShift/8U).
  02: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 2
  03: Set bufferLength to NULL and call out-of-place inverted transformer function.
  04: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.
          The output buffer does not change.

  Case 3
  05: Set buffer equal to NULL and call out-of-place inverted transformer function.
  06: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00103.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00108.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00051.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08102_InvokeCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>348</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN invokes 'E2E_PRNCheck()' with proper parameters.
  Additionally it is verified that in the scenario 'no new data is available' (InputBuffer == NULL
  and InputBufferLength == 0) the pointer to Data is valid. The size of the variable where it points
  to is not tested, as it cannot be tested and it is considered an implementation detail.

  This test also verfies that state structures are initialized correctly by E2E_PRNCheckInit.

  This test verifies that the mandatory interfaces for a check transformer are called:
      API function         Description
      E2E_PRNCheck         Checks the Data received using the E2E profile RN. This includes CRC
                           calculation, handling of Counter and Data ID.
      E2E_PRNCheckInit     Initializes the check state
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Set Buffer to defined values.
  02: Deinitialize module.
  03: VP: Transformer is deinitialized.
  04: Initialize module.
  05: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  06: VP: E2E_PRNCheck() returns E2E_P_WRONGSEQUENCE (indirectly checked, RetVal is provided to E2ESM stub).
          Verifies that state structures are initialized correctly.

  07: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  08: VP: E2E_PRNCheck() returns E2E_P_OK.
          Verifies that E2E_PRNCheck() is called because Counter was checked.

  09: - Set E2E header to values simulating repeated message (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  10: VP: E2E_PRNCheck() returns E2E_P_REPEATED.
          Verifies that E2E_PRNCheck() is called because Counter was checked.

  11: - Set E2E header to correct values (Counter = 3U).
      - Call inverted transformer function with valid parameters.
  12: VP: E2E_PRNCheck() returns E2E_P_OK.
          Verifies that E2E_PRNCheck() is called because Counter was checked.
          Verifies that correct state structure is used.

  13: - Set E2E header to correct values (Counter = 4U) except CRC is set to an incorrect value.
      - Call inverted transformer function with valid parameters.
  14: VP: E2E_PRNCheck() returns E2E_P_ERROR.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  15: - Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function with valid parameters
  16: VP: E2E_PRNCheck() returns E2E_P_OK.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.
  17: Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function with InputBuffer == NULL and
        InputBufferLength == 0.
  18: VP: E2E_PRNCheck() returns E2E_P_NONEWDATA.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPt
  19: Initialize module with respective transformer.
  20: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  21: VP: E2E_PRNCheck() returns E2E_P_WRONGSEQUENCE
  22: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  23: VP: E2E_PRNCheck() returns E2E_P_OK (indirectly checked, RetVal is provided to E2ESM stub).
          Verifies that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00123.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00021.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08103_NewData</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>611</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies the following for an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN:
  - if inputBuffer is equal to NULL and inputBufferLength is equal to 0, then variable
    NewDataAvailable of state object of type E2E_PRNCheckStateType associated with 'transformerId'
    is set to FALSE
  - if inputBuffer is equal to NULL the output buffer does not change
  - if inputBufferLength is equal to the configured DataLength, then variable NewDataAvailable
    of state object of type E2E_PRNCheckStateType associated with 'transformerId' is set
    to TRUE
  - if the above conditions are not fulfilled then return E_SAFETY_HARD_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits
  - dataLength: 96 bits

Test Execution: 
  01: Set buffer equal to NULL and inputBufferLength equal to 0 and call
      inverted transformer function.
  02: VP: E2E_P_NONEWDATA is set to E2E_P_NONEWDATA.
  03: VP: buffer did not change
  04: Set inputBufferLength equal to the configured DataLength and call inverted
      transformer function.
  05: VP: ProfileStatus is not set to E2E_P_NONEWDATA.
  06: Set inputBufferLength to a value different from dataLength and
      call inverted transformer function.
  07: VP: The function returns E_SAFETY_HARD_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00140.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00108.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08104_InvokeMapStatusToSM</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>732</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN with configuration parameter profileBehavior set to R4_2 invokes
  'E2E_PRNMapStatusToSM()' with proper parameters.

  This test verifies that the mandatory interfaces for a check transformer are called:
      E2E_PRNMapStatusToSM The function maps the check status of profile RN to a generic check
                           status, which can be used by E2E state machine check function.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Reinitialize module
  02: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  03: VP: Inverted transformer function returns E2E_P_WRONGSEQUENCE.
          Ensures that states are correct.
  04: - Set E2E header to values simulating a wrong sequence message (Counter = 4U).
        The ConfigPtr-&gt;MaxDeltaCounter value (2U) determines the threshold of a wrong sequence.
      - Call inverted transformer function with valid parameters.
  05: VP: E2E_PRNMapStatusToSM() is called. Verified by checking the return value of
          E2E_PRNMapStatusToSM() which is passed to E2ESM stub. It is expected to be E2E_P_WRONGSEQUENCE.
          Verifies that E2E_PRNMapStatusToSM() passes the Status provided by initialization.
  06: - Set E2E header to correct values back again (Counter = 5U) from the wrong sequence value.
      - Call inverted transformer function with valid parameters multiple times until the
        counter value reaches E2EPRN_COUNTER_MAX.
  07: - Set E2E header to values provoking E2E_PRNSTATUS_WRONGSEQUENCE, i.e. set counter to a value
        smaller than the current ConfigPtr-&gt;MaxDeltaCounter value.
      - Call inverted transformer function.
  08: VP: E2E_PRNCheck() returns E2E_PRNSTATUS_WRONGSEQUENCE.
  09: - Set E2E header to values provoking E2E_P_ERROR through an overflow of the
        E2EPRN_COUNTER_MAX value.
      - Call inverted transformer function.
  10: VP: E2E_PRNCheck() returns E2E_P_ERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00029.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08105_InvokeSMCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>894</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN invokes 'E2E_SMCheck()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_SMCheckInit.

  This test verifies that the mandatory interfaces for a check transformer are called:
      E2E_SMCheck          Checks the communication channel. It determines if the data can be used
                           for safety-related application, based on history of checks performed by
                           a corresponding E2E_P0XCheck() function.
      E2E_SMCheckInit      Initializes the state machine.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Reinitialize module
  02: VP: Init functions are called.
  03: Set E2E header to correct values
      Call inverted transformer function with valid parameters.
  04: VP: E2E_SMCheck() is called.
  05: VP: E2E_SMCheck() passes the correct ProfileStatus
      (the returned value of E2E_PRNMapStatusToSM).
  06: VP: E2E_SMCheck() points through ConfigPtr to the static SM configuration
      (provided by initialization module via E2E_SMCheckInit).
  07: VP: E2E_SMCheck() passes the correct pointer to state by StatePtr and state structures
      are initialized correctly (verified within callout).

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00028.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00021.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08106_SMCheckRetVal</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>1012</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN returns E2E_E_OK after a 'E2E_SMCheck()' call, then:
  - the high nibble of the return will be set to the low nibble of the state
    of the state machine (member SMState of object of type E2E_SMStateType that
    is associated with 'transformerId');
  - the low nibble of the return will be set to the low nibble of the profile-independent
    check status of type E2E_PCheckStatusType;
  otherwise the return of the 'E2E_SMCheck()' call is E_SAFETY_SOFT_RUNTIMEERROR.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Initialize SMState of StatePtr and return a value equal to E2E_E_OK by E2E_SMCheck.
  02: Call out-of-place inverted transformer function with valid parameters.
  03: VP: The high nibble of the returned value of E2EXf_Inv_'transformerId' function is
      set to the low nibble of the state of the state machine.
  04: VP: The low nibble of the returned value of E2EXf_Inv_'transformerId' function is
      set to the low nibble of the profile-independent check status of type E2E_PCheckStatusType.

  05: Return a value different to E2E_E_OK by E2E_SMCheck.
  06: VP: E2E_SMCheck() returns E_SAFETY_SOFT_RUNTIMEERROR.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00027.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08107_CopyUpperHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>1104</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if (inputBuffer is not NULL and upperHeaderBitsToShift is equal to 0),
  out-of-place inverted transformer 'E2EXf_Inv_transformerId' of profile RN copies inputBuffer to
  buffer starting with the destination offset of headerLength.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Reinitialize module
  01: Call in-place inverted transformer function with inputBuffer different from NULL and
      upperHeaderBitsToShift equal to 0.
  02: VP: In-place 'E2EXf_Inv_transformerId' keeps the buffer unchanged.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00116.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_08108_BufLength</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_08_E2EXf_OoP_ComXf/source/application/E2EPRN_ConTest_08_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>1173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN sets the BufferLength equal to InputBufferLength minus HeaderLength in bytes.
  Additionally it is verified that BufferLength is set to zero in the case that no new data
  is available (InputBufferLength == 0 and InputBuffer == NULL).
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits
  - dataLength: 96 bits

Test Execution: 
  Case 1 (Normal operation: For PRN, it works only if inputBufferLength equals the
    configured DataLength)
  00: Reinitialize module
  01: Set InputBufferLength to configured DataLength.
  02: Call in-place inverted transformer function with valid parameters.
  03: VP: BufferLength holds the correct value given by the subtraction of
      E2E transformer HeaderLength in bytes from InputBufferLength.

  Case 2 (No new data available: InputBufferLength equals zero and Buffer equals NULL)
  04: Set InputBufferLength to 0.
  05: Call in-place inverted transformer function with Buffer set to NULL.
  06: VP: BufferLength is 0.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00114.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_09101_MaxDeltaCounterCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_09_E2EXf_InP_ComXf_PRE_R4_2/source/application/E2EPRN_ConTest_09_E2EXf_InP_ComXf_PRE_R4_2_Inv.c</sourcefile>
      <sourceline>86</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if configuration parameter profileBehavior is PRE_R4_2,then
  E2EXf_Inv_&amp;lt;transformerId&amp;gt; () shall set the variable MaxDeltaCounter of the state
  object to the value of variable MaxDeltaCounterInit of the corresponding configuration object.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - EndToEndTransformationDescription.profileBehavior: PRE_R4_2

Test Execution: 
TestRun 1:
  01: Reinitialize module with same data as within the partition
      (mocked through global test config struct).
  02: Call in-place inverted transformer function with valid parameters.
  03: Call in-place inverted transformer function with valid parameters again.
  04: Call in-place inverted transformer function with invalid parameters which
      produces a wrong sequence error if PXXConfig.ProfileBehavior is FALSE.
  05: VP: ProfileStatus is set to E2E_P_WRONGSEQUENCE and E2E_P_WRONGSEQUENCE is
          returned from the in-place inverted transformer function.
  06: Manipulate ProfileBehavior (set to TRUE) for second test iteration.
TestRun 2: (the steps 01 to 05 will be repeated)
  07: VP: ProfileStatus is set to E2E_E_OK and E2E_E_OK is
          returned from the in-place inverted transformer function.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00142.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_09102_ProfileBehaviorParameterCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_09_E2EXf_InP_ComXf_PRE_R4_2/source/application/E2EPRN_ConTest_09_E2EXf_InP_ComXf_PRE_R4_2_Inv.c</sourcefile>
      <sourceline>250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN with configuration parameter profileBehavior set to PRE_R4_2 invokes
  'E2E_PRNMapStatusToSM()' with call parameter profileBehavior = 0.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - EndToEndTransformationDescription.profileBehavior: PRE_R4_2

Test Execution: 
TestRun 1:
  01: Reinitialize module with same data as within the partition
      (mocked through global test config struct).
  02: Set valid CRC and counter.
  03: Manipulate WaitForFirstData in a way that E2E_PRNSTATUS_INITIAL is forced.
  04: Call in-place inverted transformer function with valid parameters.
  05: VP: E2E_PRNMapStatusToSM() is invoked with profileBehavior set to 0 - PRE_R4_2.
  06: Set ProfileBehavior to 1 for second test iteration.
TestRun 2: (the steps 01 to 05 will be repeated)
  07: VP: E2E_PRNMapStatusToSM() is invoked with profileBehavior set to 1 after manipulation
          of the profileBehavior.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00029.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_10101_MaxDeltaCounterCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_10_E2EXf_OoP_ComXf_PRE_R4_2/source/application/E2EPRN_ConTest_10_E2EXf_OoP_ComXf_PRE_R4_2_Inv.c</sourcefile>
      <sourceline>92</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that if configuration parameter profileBehavior is PRE_R4_2,then
  E2EXf_Inv_&amp;lt;transformerId&amp;gt; () shall set the variable MaxDeltaCounter of the state
  object to the value of variable MaxDeltaCounterInit of the corresponding configuration object.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - EndToEndTransformationDescription.profileBehavior: PRE_R4_2

Test Execution: 
TestRun 1:
  01: Reinitialize module with same data as within the partition
      (mocked through global test config struct).
  02: Call out-of-place inverted transformer function with valid parameters.
  03: Call out-of-place inverted transformer function with valid parameters again.
  04: Call out-of-place inverted transformer function with invalid parameters which
      produces a wrong sequence error if PXXConfig.ProfileBehavior is FALSE.
  05: VP: ProfileStatus is set to E2E_P_WRONGSEQUENCE and E2E_P_WRONGSEQUENCE is
          returned from the out-of-place inverted transformer function.
  06: Manipulate ProfileBehavior (set to TRUE) for second test iteration.
TestRun 2: (the steps 01 to 05 will be repeated)
  07: VP: ProfileStatus is set to E2E_E_OK and E2E_E_OK is
          returned from the out-of-place inverted transformer function.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00142.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_10102_ProfileBehaviorParameterCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_10_E2EXf_OoP_ComXf_PRE_R4_2/source/application/E2EPRN_ConTest_10_E2EXf_OoP_ComXf_PRE_R4_2_Inv.c</sourcefile>
      <sourceline>261</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN with configuration parameter profileBehavior set to PRE_R4_2 invokes
  'E2E_PRNMapStatusToSM()' with call parameter profileBehavior = 0
&lt;/para&gt;

Test Object: None.
Test Precondition: 
  - EndToEndTransformationDescription.profileBehavior: PRE_R4_2

Test Execution: 
TestRun 1:
  01: Reinitialize module with same data as within the partition
      (mocked through global test config struct).
  02: Set valid CRC and counter.
  03: Manipulate WaitForFirstData in a way that E2E_PRNSTATUS_INITIAL is forced.
  04: Call out-of-place inverted transformer function with valid parameters.
  05: VP: E2E_PRNMapStatusToSM() is invoked with profileBehavior set to 0 - PRE_R4_2.
  06: Set ProfileBehavior to 1 for second test iteration.
TestRun 2: (the steps 01 to 05 will be repeated)
  07: VP: E2E_PRNMapStatusToSM() is invoked with profileBehavior set to 1 after manipulation
          of the profileBehavior.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00029.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_ConTest_01_PRNCRCCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_11_PRNCRC/source/application/E2EPRN_ConTest_11_PRNCRC.c</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

    Test that Calculated CRC matches with manually calculated CRC.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 

    010: Copy the data to a local buffer.
    020: Call E2E_PRNProtect().
    030: VP(EB_E2EPRN020195):
         Test that E2E_PRNProtect()
    040: Verify the Calculated CRC of E2E_PRNProtect() against manual calculated CRC.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to E2E_E_OK status for E2E_PRNProtectInit() function)

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020195</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_02_LengthUpTo8BytesCRCCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_11_PRNCRC/source/application/E2EPRN_ConTest_11_PRNCRC.c</sourcefile>
      <sourceline>266</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;

    Test that Calculated CRC matches with manually calculated CRC, If data length is less than 8 bytes.

  &lt;/para&gt;
  
Test Object: None.
Test Precondition: None.
Test Execution: 

    010: Copy the data to a local buffer.
    020: Call E2E_PRNProtect().
    030: VP(EB_E2EPRN020070.Lessthan8bytes):
         Test that E2E_PRNProtect()
    040: Verify the Calculated CRC of E2E_PRNProtect() against manual calculated CRC.

    Used Test Strategies:
    - Equivalence Class Partitioning
    (Testing only transitions to E2E_E_OK status for E2E_PRNProtectInit() function)

  
Test Input: 

  TestDataBlock 1 test aspects:
  =============================
    - DataIDMode E2E_PRN_DATAID_BOTH
    - CRC at first Byte
    - Counter at second Byte
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFF
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             0
  InputTstCfg.CounterOffset:         8
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                     { 0, MAX, 1, 7, 2 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different size and values)

  TestDataBlock 2 test aspects:
  =============================
    - DataIDMode E2E_PRN_DATAID_BOTH
    - CRC in the middle of the Data (not first, not last byte)
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFF
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             16
  InputTstCfg.CounterOffset:         8
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                     { 0, MAX, 1, 7, 2 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different size and values)

  TestDataBlock 3 test aspects:
  =============================
    - DataIDMode E2E_PRN_DATAID_BOTH
    - CRC in the last byte of the Data with data length less than 8 bytes
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFF
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             32
  InputTstCfg.CounterOffset:         8
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different values)

  TestDataBlock 4 test aspects:
  =============================
    - DataIDMode E2E_PRN_DATAID_BOTH
    - CRC in the last byte of the Data
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFF
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             56
  InputTstCfg.CounterOffset:         8
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Protect
                                   { 0, MAX, 1, 7, 2 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Protect (different values)

  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020070.Lessthan8bytes</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_ConTest_01_PRNForward</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_12_PRNForward/source/application/E2EPRN_ConTest_12_PRNFoward.c</sourcefile>
      <sourceline>696</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    The aspects stated below are done on valid input data only.

    1) (EB_E2EPRN020588,EB_E2EPRN020608)
       Test that E2E_PRNForward()
       a) writes the Counter in the Data at the Counter position specified
       in the State data,
       b) writes DataID Nibble in Data (if E2E_PRN_DATAID_NIBBLE is used) at the Nibble
       position specified in the configuration data,
       c) computes the CRC over DataID (depending on DataID mode - see
       test aspects 5), 6), and 7)) and Data,
       d) writes the CRC in the Data at the CRC position provided in the configuration data, and
       e) increments the Counter in the State data.

    2) (EB_E2EPRN020075)
       Test that E2E_PRNForward() increments the passed State Counter
       value by 1 up to 15, and then restarts with 0 again.

    3) (EB_E2EPRN020190)
       Test that E2E_PRNForward() calls the SCrc_CalculateCRC8() function

    4) (EB_E2EPRN020070)
       Test that E2E_PRNForward() uses CRC-8-SAE J1850 with 0U as start value for the calculation of
       the CRC (That is,  SCrc_CalculateCRC8() is called with StartValue8=0U).

    5) (EB_E2EPRN020163.1)
       Test that for DataId inclusion Mode E2E_PRN_DATAID_BOTH,
       first low byte and then high byte of the DataID are included in the CRC calculation
       step regarding the DataID.

    6) (EB_E2EPRN020163.4)
       Test that for DataID inclusion Mode E2E_PRN_DATAID_NIBBLE,
       the low Nibble of the high byte of the DataID is written to the
       Data(covered by CRC calculation when computing CRC over Data). The high nibble of the
       high byte is left out. The low byte of the DataID is then included in the CRC calculation.
       The high byte is treated as 0.

    7) (EB_E2EPRN020163.2)
       Test that for DataID inclusion Mode E2E_PRN_DATAID_ALT,
       the DataID is implicitly transmitted.
       One of the two bytes of the Data ID is included in the CRC calculation,
       alternating high and low byte, depending on parity of the counter.
       For an even counter, the low byte is included. For an odd counter, the high byte is included.

    8) (EB_E2EPRN020163.3)
       Test that for DataID inclusion Mode E2E_PRN_DATAID_LOW,
       only low byte of the DataID is included in the CRC calculation
       step regarding the DataID.
  &lt;/para&gt;
  &lt;para&gt;
    Test strategies applied:
    Equivalence Class Partitioning:
    Test execution is done with a permutation of following parameters
    - E2E_PRNProtectStateType.Counter
    - E2E_PRNConfigType.CounterOffset
    - E2E_PRNConfigType.CRCOffset
    - E2E_PRNConfigType.DataIDNibbleOffset
    - E2E_PRNConfigType.DataIDMode
    - E2E_PRNConfigType.DataLength
    - E2E_PRNConfigType.DataID
    Note: The following parameters are not used at sender side and therefore not relevant:
    - MaxDeltaCounter

    Pair wise tests: Tests are executed with a  combination of following parameters / values
    - DataIDMode
    - CRCOffset
    - CounterOffset
    - DataIDNibbleOffset (only relevant for E2E_PRN_DATAID_NIBBLE)

    Boundary Value Analysis in combination
    with test-case E2EPRN_ConTest_11_PRNForward_InvalidInput (outside bound):
    DataIdMode: [E2E_PRN_DATAID_BOTH, E2E_PRN_DATAID_LOW, E2E_PRN_DATAID_NIBBLE]
    DataLength: MIN=2, MAX=30
    Counter: MIN=0, MAX=15; (First Byte, Last Byte, in between Data)
    DataId: MIN=0, MAX=0xFFFF (E2E_PRN_DATAID_BOTH)
    DataId: MIN=0, MAX=0xFFFF (E2E_PRN_DATAID_ALT)
                   MAX=0x0FFF (E2E_PRN_DATAID_NIBBLE)
                   MAX=0x00FF (E2E_PRN_DATAID_LOW)
    DataIDNibbleOffset: MIN=12, MAX=DataLength (low nibble and high nibble)
    CounterOffset: MIN=0, MAX=DataLength
    CRCOffset: MIN=0, MAX=DataLength
  &lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 

  010: Prepare CRC stub (SCrc_CalculateCRC8) to return the number of overall Stub calls
      XORed by 0xFF

    For each stated TestDataBlock (InputTstCfg), execute the following steps:
    02: call the E2E_Forward function with following parameters:
    - Parameter Config points to following test-data
    Config.DataIDMode       = InputTstCfg.DataIDMode
    Config.DataID           = InputTstCfg.DataID
    Config.DataIDNibbleOffset = InputTstCfg.DataIDNibbleOffset
    Config.CRCOffset        = InputTstCfg.CRCOffset
    Config.CounterOffset    = InputTstCfg.CounterOffset
    Config.DataLength       = InputTstCfg.DataLength
    Config.TstData          = InputTstCfg.TstData
    - Parameter State points to following input data
    State.Counter           = InputTstCfg.Counter
    - Parameter Data points to valid input data
    03: VP (EB_E2EPRN020588):
    E2E_Forward function returns E2E_E_OK
    04: VP (EB_E2EPRN020504,EB_E2EPRN020588,EB_E2EPRN020608)
    State.Counter is updated as follows:
    If InputTstCfg.Counter==MAX(15) =&gt; State.Counter=0
    If InputTstCfg.Counter &lt; MAX(15) =&gt; State.Counter=InputTstCfg.Counter+1
    05: VP (EB_E2EPRN020588,EB_E2EPRN020075)
    TestData at position Config.CounterOffset (4 bits) equals InputTstCfg.Counter
    06: VP (EB_E2EPRN020588)
    If Config.DataIDMode=E2E_PRN_DATAID_NIBBLE =&gt;
    TestData at position Config.DataIDNibbleOffset (4 bits) equals
    the low Nibble of the high byte of Config.DataID
    07: VP (EB_E2EPRN020588,EB_E2EPRN020190)
    TestData at position Config.CRCOffset (8 bits) equals
    the number of overall calls to the SCrc_CalculateCRC8 CRC stub
    08: VP (EB_E2EPRN020588,EB_E2EPRN020190)
    Number of SCrc_CalculateCRC8 CRC stub calls equals n where:

    IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
    and InputTstCfg.CRCOffset is first or last byte in TestData
    =&gt; n=3
    IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
    and InputTstCfg.CRCOffset is not first and not last byte in TestData
    =&gt; n=4
    IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
    and InputTstCfg.CRCOffset is first or last byte in TestData
    =&gt; n=3
    IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
    and InputTstCfg.CRCOffset is not first and not last byte in TestData
    =&gt; n=4
    IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_ALT
    and InputTstCfg.CRCOffset is first or last byte in TestData
    =&gt; n=2
    IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_ALT
    and InputTstCfg.CRCOffset is not first and not last byte in TestData
    =&gt; n=3
    09: VP (EB_E2EPRN020070,EB_E2EPRN020190,EB_E2EPRN020075,EB_E2EPRN020076,EB_E2EPRN020163,)
    No other data except CRC / Counter and DataId Nibble is modified in TestData
    10: VP (EB_E2EPRN020588,EB_E2EPRN020190,EB_E2EPRN020070)
    1st call to SCrc_CalculateCRC8 CRC stub in this test iteration:
    - SCrc_DataPtr points to a value that equals the low byte of InputTstCfg.DataID
    - SCrc_Length equals 1
    - SCrc_StartValue8 equals 0x0U
    - SCrc_IsFirstCall equals FALSE
    11: VP (EB_E2EPRN020588,EB_E2EPRN020190,EB_E2EPRN020070)
    Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on DataIdMode):
    If InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH:
    - SCrc_DataPtr points to a value that equals the high byte of InputTstCfg.DataID
    - SCrc_Length equals 1
    - SCrc_StartValue8 equals the SCrc return value from the previous stub call
    - SCrc_IsFirstCall equals FALSE
    If InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE:
    - SCrc_DataPtr points to a value 0
    - SCrc_Length equals 1
    - SCrc_StartValue8 equals the SCrc return value from the previous stub call
    - SCrc_IsFirstCall equals FALSE
    12: VP (EB_E2EPRN020588,EB_E2EPRN020190,EB_E2EPRN020070)
    Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
    if InputTstCfg.CRCOffset is first byte in TestData
    - SCrc_DataPtr points to 2nd byte of the data passed to E2E_Forward
    - SCrc_Length equals Config.DataLength-1
    - SCrc_StartValue8 equals the SCrc return value from the previous stub call
    (number of overall SCrc stub calls)
    - SCrc_IsFirstCall equals FALSE
    if InputTstCfg.CRCOffset is not first byte in TestData
    - SCrc_DataPtr points to 1st byte of the data passed to E2E_Forward
    - SCrc_Length equals Config.CRCOffset / 8 (excludes CRC value)
    - SCrc_StartValue8 equals the SCrc return value from the previous stub call
    (number of overall SCrc stub calls)
    - SCrc_IsFirstCall equals FALSE
    13: VP (EB_E2EPRN020588,EB_E2EPRN020190,EB_E2EPRN020070)
    Next call to SCrc_CalculateCRC8 CRC stub in this test iteration (depends on CRC position):
    if InputTstCfg.CRCOffset is not first byte and not last byte
    - SCrc_DataPtr points to 1st byte after CRC byte in the TestData
    - SCrc_Length equals Config.DataLength-(Config.CRCOffset/8) (Data after CRC byte)
    - SCrc_StartValue8 equals the SCrc return value from the previous stub call
    (number of overall SCrc stub calls)
    - SCrc_IsFirstCall equals FALSE


Test Input: 
  Note: MAX ... maximum possible counter value =  15

  TestDataBlock 1 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_BOTH
  - CRC at first Byte
  - Counter at second Byte
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             0
  InputTstCfg.CounterOffset:         8
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 1 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different size and values)

  TestDataBlock 2 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_BOTH
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             16
  InputTstCfg.CounterOffset:         28
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 0, 1, 2, 0, 2 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different size and values)

  TestDataBlock 3 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_BOTH
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_BOTH
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             56
  InputTstCfg.CounterOffset:         52
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 6 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different values)


  TestDataBlock 4 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC at first Byte
  - Counter at second Byte
  - DataID Nibble at bit position 12 (High Nibble)
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_NIBBLE
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
  InputTstCfg.DataIDNibbleOffset:    12
  InputTstCfg.CRCOffset:             0
  InputTstCfg.CounterOffset:         8
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 1 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different size and values)

  TestDataBlock 5 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  - DataID Nibble at bit position 32  (Low Nibble)
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_NIBBLE
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
  InputTstCfg.DataIDNibbleOffset:    32
  InputTstCfg.CRCOffset:             16
  InputTstCfg.CounterOffset:         28
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 5 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different size and values)

  TestDataBlock 6 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  - DataID Nibble at bit position 8 (Low Nibble)
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_NIBBLE
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
  InputTstCfg.DataIDNibbleOffset:    8
  InputTstCfg.CRCOffset:             56
  InputTstCfg.CounterOffset:         52
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 6 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different values)

  TestDataBlock 7 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC at first Byte
  - Counter at second Byte
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_NIBBLE
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
  InputTstCfg.DataIDNibbleOffset:    12
  InputTstCfg.CRCOffset:             0
  InputTstCfg.CounterOffset:         8
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 5, 0, 5, 5, 5 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different size and values)

  TestDataBlock 8 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  - DataIDNibble in first byte in low nibble
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_NIBBLE
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             8
  InputTstCfg.CounterOffset:         12
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 8, MAX, 2, 0, MAX }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different size and values)

  TestDataBlock 9 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_NIBBLE
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  -- DataIDNibble in the third byte as low nibble
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_NIBBLE
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0x0FFFU
  InputTstCfg.DataIDNibbleOffset:    16
  InputTstCfg.CRCOffset:             56
  InputTstCfg.CounterOffset:         44
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 0, 1, 2, 0, 2 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different values)

  TestDataBlock 10 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_ALT
  - CRC at first Byte
  - Counter at second Byte
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_ALT
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             0
  InputTstCfg.CounterOffset:         8
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  {1,15,1}
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different values)

  TestDataBlock 11 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_ALT
  - CRC in the middle of the Data (not first, not last byte)
  - Counter at in the middle of the Data block (not first, not last byte)
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_ALT
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             16
  InputTstCfg.CounterOffset:         28
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 3,1,3}
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different values)

  TestDataBlock 12 test aspects:
  =============================
  - DataIDMode E2E_PRN_DATAID_ALT
  - CRC in the last byte of the Data
  - Counter at in the next to last byte of the Data
  InputTstCfg.DataIDMode:            E2E_PRN_DATAID_ALT
  InputTstCfg.DataID:                Different valid values from 0 to maximum 0xFFFFU
  InputTstCfg.DataIDNibbleOffset:    0
  InputTstCfg.CRCOffset:             56
  InputTstCfg.CounterOffset:         52
  InputTstCfg.Counter:               State Counter provided as input for E2EPRN_Forward
  { 6 }
  InputTstCfg.DataLength:            correct length of TstData
  InputTstCfg.TstData:               Data passed to E2EPRN_Forward (different values)

Test Output: 
  return value for all tests shall be E2E_E_OK
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020588</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020608</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020075</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020163.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_02_PRNForward_InvalidInput</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_12_PRNForward/source/application/E2EPRN_ConTest_12_PRNFoward.c</sourcefile>
      <sourceline>1252</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;

  1) Check that the E2E-library function E2E_PRNForward()
  returns the error codes E2E_E_INPUTERR_NULL if:
  - NULL_PTR is passed for configuration data / state data / data to be forwarded

  2) Check that the E2E-library function E2E_PRNForward()
  returns the error codes E2E_E_INPUTERR_WRONG if:
  - Unsupported Data ID Inclusion Mode does not equal E2E_PRN_DATAID_ALT
  - invalid counter values in state data (maximum value exceeded)
  - invalid data length (not a multiple of 8, maximum value exceeded, value smaller than 16)
  - invalid crc offsets (greater than data length, )
  - invalid counter offset (greater than data length, )
  - invalid DataIDNibbleOffset in case of DataID mode not equal to E2E_PRN_DATAID_NIBBLE (!=0)
  - invalid DataId value in case of DataID mode E2E_PRN_DATAID_NIBBLE (value exceeds 12 bit limit)

  See also in the SWS section 7.2.1 Error classification
  (End-to-End Communication Protection Library V1.0.0 R4.0 Rev 1).
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: None.
Test Input: 
  The input/output parameter(s) shall hold the following
  value(s) for calling E2E_PRNForward():
  01: set configuration to NULL
  02: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_NULL
  03: set sender state to NULL
  04: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_NULL
  05: set data to NULL
  06: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_NULL
  07: set all input parameters (configuration, sender state
  and data) to NULL
  08: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_NULL
  09: set all input parameters in RAM (sender state and data)
  to NULL
  10: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_NULL
  11: exceed maximum allowed State.Counter
  12: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  13: call with a data length which is not a multiple of 8
  14: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  15: call with a data length exceeding the maximum number of
  specified bits
  16: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  17: call with a data length smaller than 16 bits
  18: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  19: call with a crc offset greater than the configured data length
  20: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047,EB_E2EPRN020153)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  21: call with a counter offset greater than the configured data length
  22: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047,EB_E2EPRN020152)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  23: call with data id mode INVALID_DATAIDMODE
  24: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  27: call with data id mode E2E_PRN_DATAID_BOTH and DataIDNibbleOffset != 0
  28 VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  29: call with data id mode E2E_PRN_DATAID_ALT and DataIDNibbleOffset != 0
  30 VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  31: call with data id mode E2E_PRN_DATAID_LOW and DataIDNibbleOffset != 0
  32 VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  33: call with data id mode E2E_PRN_DATAID_NIBBLE and DataID &gt;
  12bit value (0x1000U)
  34 VP (EB_E2EPRN020306)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  35: call with data id mode E2E_PRN_DATAID_NIBBLE and DataID &gt;
  12bit value (0xFFFFU)
  36 VP (EB_E2EPRN020306)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  37: call with data id mode E2E_PRN_DATAID_LOW and DataID &gt;
  8bit value (0x0100U)
  38 VP (EB_E2EPRN020169)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  39: call with data id mode E2E_PRN_DATAID_LOW and DataID &gt;
  8bit value (0xFFFFU)
  40 VP (EB_E2EPRN020169)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG
  41: call with data id mode E2E_PRN_DATAID_NIBBLE and a too high DataIdNibbleOffset)
  (i.e. Config-&gt;DataIDNibbleOffset + 4U) &gt; Config-&gt;DataLength)
  42: VP (EB_E2EPRN020011,EB_E2EPRN020012,EB_E2EPRN020588,EB_E2EPRN020047)
  E2E_PRNForward() returns E2E_E_INPUTERR_WRONG

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020047</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020588</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020149</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020306</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020169</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>EB_E2EPRN020609</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_03_PRNForward_WriteCounter_FS_Repeated</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_12_PRNForward/source/application/E2EPRN_ConTest_12_PRNFoward.c</sourcefile>
      <sourceline>1534</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that correct Counter is written in the E2E Header in Big Endian format
    tested by iterating among all counter values, wrap around of the counter is considered.
    counter = StatePtr-&gt;Counter - 1U
  &lt;/para&gt;

Test Object: E2E_PRNForward()
Test Precondition: 

Test Execution: 
  Iterate the following steps several times:

  00: Loop through:
  - different positions of PRN header (CRCOffset, CounterOffset and DataIDNibbleOffset)
  - different Length values (encoded in header)
  - all possible values of state Counter (0U to 15U)

  For each stated TestDataBlock (InputTstCfg), execute the following steps:
  01: call the E2E_Forward function with following parameters:
       - Parameter Config points to following test-data
           Config.DataIDMode       = InputTstCfg.DataIDMode
           Config.DataID           = InputTstCfg.DataID
           Config.DataIDNibbleOffset = InputTstCfg.DataIDNibbleOffset
           Config.CRCOffset        = InputTstCfg.CRCOffset
           Config.CounterOffset    = InputTstCfg.CounterOffset
           Config.DataLength       = InputTstCfg.DataLength
           Config.TstData          = InputTstCfg.TstData
        - Parameter State points to following input data
           State.Counter           = InputTstCfg.Counter
        - Parameter Data points to valid input data
  02: VP (EB_E2EPRN020588):
      E2E_Forward function returns E2E_E_OK
  03: VP (EB_E2EPRN020075,EB_E2EPRN020588,EB_E2EPRN020610)
      State.Counter is updated as follows:
          If InputTstCfg.Counter==MAX(15) =&gt; State.Counter=0
          If InputTstCfg.Counter &lt; MAX(15) =&gt; State.Counter=InputTstCfg.Counter+1
  04: VP (EB_E2EPRN020588,EB_E2EPRN020610)
      TestData at position Config.CounterOffset (4 bits) equals InputTstCfg.Counter
  05: VP (EB_E2EPRN020588,EB_E2EPRN020190,EB_E2EPRN020070,EB_E2EPRN020163.1
           EB_E2EPRN020163.3,EB_E2EPRN020163.4,EB_E2EPRN020610)
       Number of SCrc_CalculateCRC8 CRC stub calls equals n where:
          IF Config.DataIDMode==E2E_PRN_DATAID_LOW
             and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=2 when datalength &gt;= 8 bytes, n=3 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_LOW
             and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
             and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
            and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
             and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
  06: VP (EB_E2EPRN020610)
         No other data except CRC / Counter and DataId Nibble is modified in TestData

  Used Test Strategies:
  - Pair wise tests:
  Different values among the configuration parameters "Offset", "DataLength" and state
  parameter "Counter".
  - Boundary Value Analysis
  Usage of minimum, intermediate and maximum values of state parameter "Counter".
  - Equivalence Class Partitioning
  Testing only transitions to E2E_E_OK status for E2E_PRNForward() function.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020610</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_04_PRNForward_WriteCounter_FS_WrongSeq</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_12_PRNForward/source/application/E2EPRN_ConTest_12_PRNFoward.c</sourcefile>
      <sourceline>1796</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that correct Counter is written in the E2E Header in Big Endian format
    tested by iterating among all counter values, wrap around of the counter is considered.

    counter = StatePtr-&gt;Counter + ConfigPtr-&gt;MaxDeltaCounter
  &lt;/para&gt;

Test Object: E2E_PRNForward()
Test Precondition: 

Test Execution: 
  Iterate the following steps several times:

  00: Loop through:
  - different positions of PRN header (CRCOffset, CounterOffset and DataIDNibbleOffset)
  - different Length values (encoded in header)
  - all possible values of state Counter (0U to 15U)
  
  For each stated TestDataBlock (InputTstCfg), execute the following steps:
  01: call the E2E_Forward function with following parameters:
       - Parameter Config points to following test-data
           Config.DataIDMode       = InputTstCfg.DataIDMode
           Config.DataID           = InputTstCfg.DataID
           Config.DataIDNibbleOffset = InputTstCfg.DataIDNibbleOffset
           Config.CRCOffset        = InputTstCfg.CRCOffset
           Config.CounterOffset    = InputTstCfg.CounterOffset
           Config.DataLength       = InputTstCfg.DataLength
           Config.TstData          = InputTstCfg.TstData
        - Parameter State points to following input data
           State.Counter           = InputTstCfg.Counter
        - Parameter Data points to valid input data
  02: VP (EB_E2EPRN020588):
      E2E_Forward function returns E2E_E_OK
  03: VP (EB_E2EPRN020075,EB_E2EPRN020588,EB_E2EPRN020611)
      State.Counter is updated as follows:
          If InputTstCfg.Counter==MAX(15) =&gt; State.Counter=0
          If InputTstCfg.Counter &lt; MAX(15) =&gt; State.Counter=InputTstCfg.Counter+1
  04: VP (EB_E2EPRN020588,EB_E2EPRN020163.4,EB_E2EPRN020611)
      If Config.DataIDMode=E2E_PRN_DATAID_NIBBLE =&gt;
        TestData at position Config.DataIDNibbleOffset (4 bits) equals
        the low Nibble of the high byte of Config.DataID
  05: VP (EB_E2EPRN020588,EB_E2EPRN020611)
      TestData at position Config.CRCOffset (8 bits) equals
      the number of overall calls to the SCrc_CalculateCRC8 CRC stub
  06: VP (EB_E2EPRN020588,EB_E2EPRN020190,EB_E2EPRN020070,EB_E2EPRN020163.1
           EB_E2EPRN020163.3,EB_E2EPRN020163.4,EB_E2EPRN020611)
       Number of SCrc_CalculateCRC8 CRC stub calls equals n where:
          IF Config.DataIDMode==E2E_PRN_DATAID_LOW
             and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=2 when datalength &gt;= 8 bytes, n=3 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_LOW
             and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
             and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
            and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
             and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
  07: VP (EB_E2EPRN020611)
         No other data except CRC / Counter and DataId Nibble is modified in TestData

  Used Test Strategies:
  - Pair wise tests:
  Different values among the configuration parameters "Offset", "DataLength" and state
  parameter "Counter".
  - Boundary Value Analysis
  Usage of minimum, intermediate and maximum values of state parameter "Counter".
  - Equivalence Class Partitioning
  Testing only transitions to E2E_E_OK status for E2E_PRNForward() function.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020611</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_05_PRNForward_WriteDataID_FS_Error</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_12_PRNForward/source/application/E2EPRN_ConTest_12_PRNFoward.c</sourcefile>
      <sourceline>2056</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that correct DataID incremented by 1 is written
    in the E2E Header in Big Endian format if check status is error.
  &lt;/para&gt;

Test Object: E2E_PRNForward()
Test Precondition: 

Test Execution: 
  Iterate the following steps several times:
  
  00: Loop through:
  - different positions of PRN header (CRCOffset, CounterOffset and DataIDNibbleOffset)
  - different Length values (encoded in header)
  - all possible values of state Counter (0U to 15U)
  
  For each stated TestDataBlock (InputTstCfg), execute the following steps:
  01: call the E2E_Forward function with following parameters:
       - Parameter Config points to following test-data
           Config.DataIDMode       = InputTstCfg.DataIDMode
           Config.DataID           = InputTstCfg.DataID
           Config.DataIDNibbleOffset = InputTstCfg.DataIDNibbleOffset
           Config.CRCOffset        = InputTstCfg.CRCOffset
           Config.CounterOffset    = InputTstCfg.CounterOffset
           Config.DataLength       = InputTstCfg.DataLength
           Config.TstData          = InputTstCfg.TstData
        - Parameter State points to following input data
           State.Counter           = InputTstCfg.Counter
        - Parameter Data points to valid input data
  02: VP (EB_E2EPRN020588):
      E2E_Forward function returns E2E_E_OK
  03: VP (EB_E2EPRN020075,EB_E2EPRN020588,EB_E2EPRN020612)
      State.Counter is updated as follows:
          If InputTstCfg.Counter==MAX(15) =&gt; State.Counter=0
          If InputTstCfg.Counter &lt; MAX(15) =&gt; State.Counter=InputTstCfg.Counter+1
  04: VP (EB_E2EPRN020588,EB_E2EPRN020612)
      TestData at position Config.CounterOffset (4 bits) equals InputTstCfg.Counter
  05: VP (EB_E2EPRN020588,EB_E2EPRN020163.4,EB_E2EPRN020612)
      If Config.DataIDMode=E2E_PRN_DATAID_NIBBLE =&gt;
        TestData at position Config.DataIDNibbleOffset (4 bits) equals
        the low Nibble of the high byte of Config.DataID
  06: VP (EB_E2EPRN020588,EB_E2EPRN020612)
      TestData at position Config.CRCOffset (8 bits) equals
      the number of overall calls to the SCrc_CalculateCRC8 CRC stub
  07: VP (EB_E2EPRN020588,EB_E2EPRN020190,EB_E2EPRN020070,EB_E2EPRN020163.1
           EB_E2EPRN020163.3,EB_E2EPRN020163.4,EB_E2EPRN020612)
       Number of SCrc_CalculateCRC8 CRC stub calls equals n where:
          IF Config.DataIDMode==E2E_PRN_DATAID_LOW
             and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=2 when datalength &gt;= 8 bytes, n=3 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_LOW
             and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
             and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_BOTH
            and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
            and InputTstCfg.CRCOffset is first or last byte in TestData
             =&gt; n=3 when datalength &gt;= 8 bytes, n=4 when datalength &lt; 8 bytes
          IF InputTstCfg.DataIDMode==E2E_PRN_DATAID_NIBBLE
             and InputTstCfg.CRCOffset is not first and not last byte in TestData
             =&gt; n=4 when datalength &gt;= 8 bytes, n=5 when datalength &lt; 8 bytes
  08: VP (EB_E2EPRN020612)
         No other data except CRC / Counter and DataId Nibble is modified in TestData

  Used Test Strategies:
  - Pair wise tests:
  Different values among the configuration parameters "Offset", "DataLength" and state
  parameter "Counter".
  - Boundary Value Analysis
  Usage of minimum, intermediate and maximum values of state parameter "Counter".
  - Equivalence Class Partitioning
  Testing only transitions to E2E_E_OK status for E2E_PRNForward() function.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>TS_E2EPRN_ConTest_06_PRNForward_FS_Nonewdata</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_12_PRNForward/source/application/E2EPRN_ConTest_12_PRNFoward.c</sourcefile>
      <sourceline>2312</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  &lt;para&gt;
    This test verifies that if forward status is E2E_P_NONEWDATA then
    forward status shall return E2E_E_INPUTERR_WRONG.
  &lt;/para&gt;

Test Object: E2E_PRNForward()
Test Precondition: 

Test Execution: 
  01: Call E2E_PRNForward().
  02: VP:E2E_PRNForward() returns E2E_E_INPUTERR_WRONG.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>EB_E2EPRN020588</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_13000_FWCodeStatusCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_13_E2EXf_InP_ComXf_FWCode/source/application/E2EPRN_ConTest_13_E2EXf_InP_ComXf_FWCode.c</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place transformer 'E2EXf_transformerId' of profile RN
  invokes 'E2E_PRNForward()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_PRNProtectInit.

  This test verifies implicitly that the mandatory interfaces for a protect transformer are called:
      API function         Description
      E2E_PRNForward       Forwards the array/buffer to  be transmitted using the E2E profile RN RN.
                           This includes checksum calculation, handling of counter and Data ID.
      E2E_PRNProtectInit   Initializes the protection state.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Initialize Buffer with values different to 0U
  01: Reinitialize module and
      - structure of StatePtr is initialized by E2E_PRNProtectInit (Counter set to 0U).
  02: Set correct InputBufferLength.
  03: Call transformer function with valid parameters.
  04: VP: E2E_PRNProtectInit() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.
  05: Call transformer function with valid parameters, which increments the counter.
  06: VP: E2E_PRNForward() was called, because counter was incremented to 1U in E2E header.
          This verifies that counter is incremented correctly.
  07: VP: E2EXf_PRN_InP_ComXf_Tx1_Init() was called, so that state structures are initialized
          correctly.
  08: VP: E2E_PRNForward() was called, because counter was set correctly to 0U in E2E header.
          This verifies indirectly that state structures are initialized correctly.
  09: Manipulate config local data struct
  10: Calling internal API that is wrapped by transformer API with manipulated config data 3U times.
  11: VP: E2E_PRNForward() was called, because counter was increased to 3U and set correctly in E2E
          header.
          This verifies indirectly that E2E_PRNForward() passes the correct pointer to state by
          StatePtr.
          DataId in E2E header is set correctly according configuration.
          This verifies indirectly that E2E_PRNForward() passes the correct pointer to data by
          DataPtr.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00107.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00168.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.SWS_E2EXf_00021.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.EB.Transformer.Init.SR</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_14000_FWCodeStatusCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_14_E2EXf_OoP_ComXf_FWCode/source/application/E2EPRN_ConTest_14_E2EXf_OoP_ComXf_FWCode.c</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place transformer 'E2EXf_transformerId' of profile RN
  invokes 'E2E_PRNForward()' with proper parameters.

  This test also verfies that state structures are initialized correctly by E2E_PRNProtectInit.

  This test verifies implicitly that the mandatory interfaces for a protect transformer are called:
      API function         Description
      E2E_PRNForward       Forwards the array/buffer to  be transmitted using the E2E profile RN.
                           This includes checksum calculation, handling of counter and Data ID.
      E2E_PRNProtectInit   Initializes the protection state.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Initialize Buffer with values different to 0U.
  02: Reinitialize module and
      - structure of StatePtr is initialized by E2E_PRNProtectInit (Counter set to 0U).
  03: Call transformer function with valid parameters.
  04: VP: E2E_PRNForward() was called, because transformer function is called with forwardedCode as
          E_OK (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_OK), counter was set correctly to
          0U in E2E header. The Counter will be incremented which will be used in the next
          invocation of E2E_PRNForward.
  05: Call transformer function with valid parameters.
  06: VP: E2E_PRNForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_REP (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_REPEATED), counter
          was decremented and set correctly to 0U in E2E header. The Counter will be incremented
          which will be used in the next invocation of E2E_PRNForward.
  07: Call transformer function with valid parameters.
  08: VP: E2E_PRNForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_SEQ (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_WRONGSEQUENCE),
          counter was set to (Counter + MaxDeltaCounterInit)U in E2E header. The Counter will be
          incremented which will be used in the next invocation of E2E_PRNForward.
  09: Call transformer function with valid parameters.
  10: VP: E2E_PRNForward() was called, because transformer function is called with forwardedCode as
          E_SAFETY_INVALID_CRC (E2EXf_MapCodeToStatus returns Checkstatus = E2E_P_ERROR),
          counter was incremented and set in E2E header. DataId will be incremented by 1U and set
          in E2E header.
  11: VP: Length in E2E header is set correctly (InputbufferLength + E2E header length).
          This verifies indirectly that E2E_PRNForward() passes the correct pointer to data by
          DataPtr.
          This verifies indirectly that E2E_PRNForward() passes the correct length of the data bytes
          by Length.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00107.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00168.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00208.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00047.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_15000_InvokeCheck_DisableE2ESM_TRUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_15_E2EXf_InP_ComXf_DisableE2ESM/source/application/E2EPRN_ConTest_15_InP_ComXf_Inv.c</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an in-place inverted transformer 'E2EXf_Inv_transformerId' of profile RN
  invokes 'E2E_PRNCheck()' with disableEndToEndStateMachine TRUE.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  00: Set Buffer to defined values.

  01: Deinitialize and Initialize module.

  02: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  03: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_SEQ.
          Verifies that state structures are initialized correctly.

  04: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  05: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PRNCheck() is called because Counter was checked.

  06: - Set E2E header to values simulating repeated message (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  07: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_REP.
          Verifies that E2E_PRNCheck() is called because Counter was checked.

  08: - Set E2E header to correct values (Counter = 3U).
      - Call inverted transformer function with valid parameters.
  09: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PRNCheck() is called because Counter was checked.
          Verifies that correct state structure is used.

  10: - Set E2E header to correct values (Counter = 4U) except CRC is set to an incorrect value.
      - Call inverted transformer function with valid parameters.
  11: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_ERR.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  12: - Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function valid parameters.
  13: VP: E2E_PRNCheck() returns returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  14: - Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function with Buffer == NULL and
        InputBufferLength == 0.
  15: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_NND.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  16: - Set E2E header to values and set counter to a value smaller than the current
        ConfigPtr-&gt;MaxDeltaCounter value.
      - Call inverted transformer function.
  17: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_SEQ.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00169.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00032.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
  </specobjects>
    <specobjects doctype="tcs">
    <specobject>
      <id>TS_E2EPRN_E2EXf_CON_16000_InvokeCheck_DisableE2ESM_TRUE</id>
      <status>approved</status>
      <source>EB test case specification (asc_E2EPRN)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_E2EPRN/test/ts5/Conformance/IN/E2EPRN_ConTest_16_E2EXf_OoP_ComXf_DisableE2ESM/source/application/E2EPRN_ConTest_16_OoP_ComXf_Inv.c</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  This test verifies that an out-of-place inverted transformer 'E2EXf_Inv_transformerId'
  of profile RN invokes 'E2E_PRNCheck()' with disableEndToEndStateMachine TRUE.
&lt;/para&gt;
&lt;programlisting&gt;
  The following configuration parameter is permuted:

  Parameter / Permutation     |   p0   |   p1   |
  -----------------------------------------------
  E2EXF_XFRMBUFFERLENGTH_TYPE | uint16 | uint32 |
  -----------------------------------------------
&lt;/programlisting&gt;

Test Object: None.
Test Precondition: 
  - headerLength: 0 bits
  - upperHeaderBitsToShift: 0 bits

Test Execution: 
  01: Set Buffer to defined values.

  02: Deinitialize and Initialize module.

  03: - Set E2E header to correct values (Counter = 1U).
      - Call inverted transformer function with valid parameters.
  04: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_SEQ..
          Verifies that state structures are initialized correctly.

  05: - Set E2E header to correct values (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  06: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PRNCheck() is called because Counter was checked.

  07: - Set E2E header to values simulating repeated message (Counter = 2U).
      - Call inverted transformer function with valid parameters.
  08: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_REP.
          Verifies that E2E_PRNCheck() is called because Counter was checked.

  09: - Set E2E header to correct values (Counter = 3U).
      - Call inverted transformer function with valid parameters.
  10: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PRNCheck() is called because Counter was checked.
          Verifies that correct state structure is used.

  11: - Set E2E header to correct values (Counter = 4U) except CRC is set to an incorrect value.
      - Call inverted transformer function with valid parameters.
  12: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_ERR.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  13: - Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function with valid parameters
  14: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_OK.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr.

  15: Set E2E header to correct values (Counter = 4U).
      - Call inverted transformer function with InputBuffer == NULL and
        InputBufferLength == 0.
  16: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_NND.
          Verifies that E2E_PRNCheck() passes the correct pointer to data by DataPtr

  17: - Set E2E header to correct values, set Counter to a value larger than
        ConfigPtr-&gt;MaxDeltaCounter.
      - Call inverted transformer function with valid parameters.
  18: VP: E2E_PRNCheck() returns E_SAFETY_NOSM_SEQ.
          Verifies that state structures are initialized correctly.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00169.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_E2EXf_00037.PRN</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>E2EPRN.SWS_Xfrm_00032.PRN</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>req</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
