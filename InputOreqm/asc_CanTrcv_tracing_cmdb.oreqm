<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_CanTrcv_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_T03_requirements_AUTOSAR_SWS_CANTransceiverDriver.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_T03_requirements_CanTrcv_EBExtensions.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_requirements_general_AUTOSAR_SWS_CANTransceiverDriver.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_requirements_general_CanTrcv_EBExtensions.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_requirements_pn_AUTOSAR_SWS_PartialNetworking.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_requirements_pn_CanTrcv_EBExtensions.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_PbcfgM_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_GenericImporter/reqm_DSN_GENERIC.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 21:44:46 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_CanTrcv_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_T03_requirements_AUTOSAR_SWS_CANTransceiverDriver.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_T03_requirements_CanTrcv_EBExtensions.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_requirements_general_AUTOSAR_SWS_CANTransceiverDriver.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_requirements_general_CanTrcv_EBExtensions.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_requirements_pn_AUTOSAR_SWS_PartialNetworking.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_Native/asc_CanTrcv_Autosar_requirements_pn_CanTrcv_EBExtensions.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_PbcfgM_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_GenericImporter/reqm_DSN_GENERIC.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="swurs">

     <specobject>
         <id>CanTrcv.ASR40.CanTrcv167</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If supported by hardware, CanTrcv_Init shall validate whether there has been
        a wake up due to transceiver activity and if TRUE, reporting shall be
        done to EcuM via API EcuM_SetWakeupEvent.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_CAN_TRCV_INIT_CAN_FLAG</srcid><srcstatus/><internalId>312</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_CAN_TRCV_INIT_SYSERR_FLAG</srcid><srcstatus/><internalId>313</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv062</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv_Cfg.c: Pre-compile time configuration code file.
        It's generated by the configuration tool.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.PBsupport</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv065</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv147</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        This figure shows the include structure for the module CanTrcv (part2)
      </description>
         <comment>
        This requirement is not applicable.
        CanTrcv with post build configuration does not provide such a file.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv113</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication towards the transceiver, the function
        CanTrcv_Init shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL. For Eg., there are different transceiver types
        and different access ways (port connection, SPI). This development error
        should be signaled if you detect any miscommunication with your hardware.
        Depending on connection type and depending on your transceiver hardware
        you may not run in situations where you have to signal this error.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_LOOP_SPI_FAILURE</srcid><srcstatus/><internalId>333</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_DET_NO_TRCV_CONTROL</srcid><srcstatus/><internalId>341</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv114</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication to the transceiver, the function
        CanTrcv_SetOpMode shall report development error
        CANTRCV_E_NO_TRCV_CONTROL and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_LOOP_SPI_FAILURE</srcid><srcstatus/><internalId>333</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_DET_NO_TRCV_CONTROL</srcid><srcstatus/><internalId>341</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv115</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication to the transceiver, the function
        CanTrcv_GetOpMode shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_DET_NO_TRCV_CONTROL</srcid><srcstatus/><internalId>341</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv116</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication to the transceiver, the function
        CanTrcv_GetBusWuReason shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL and return E_OK.
      </description>
         <comment>
        This requirement is not applicable.
        In this implementation CanTrcv_GetBusWuReason makes no SPI access.
        Wakeup reason is internally stored when wakekup status is obtained.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv117</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication to the transceiver, the function
        CanTrcv_SetWakeupMode shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_LOOP_SPI_FAILURE</srcid><srcstatus/><internalId>333</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_DET_NO_TRCV_CONTROL</srcid><srcstatus/><internalId>341</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv190</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication to the transceiver, the function
        CanTrcv_GetTrcvSystemData shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.GetTrcvSystemData</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv196</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication to the transceiver, the function
        CanTrcv_ClearTrcvWufFlag shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_DET_NO_TRCV_CONTROL_PN</srcid><srcstatus/><internalId>303</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv180</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_Init shall initialize all the connected CAN transceivers
        based on their initialization sequences and configuration (provided by
        parameter ConfigPtr). Meanwhile, it shall support the configuration
        sequence of the AUTOSAR stack also.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv185</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled for CanTrcv module: the function CanTrcv_Init shall raise the
        development error CANTRCV_E_PARAM_POINTER, if NULL pointer is passed as
        ConfigPtr parameter.
      </description>
         <comment>
        This requirement is not applicable.
        This requirement is replaced by CanTrcv.ASR40.CanTrcv185.1.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv185.1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled and PbcfgM support is disabled for CanTrcv module:
        The function CanTrcv_Init shall raise the development error
        CANTRCV_E_PARAM_POINTER, if NULL pointer is passed as
        ConfigPtr parameter.
      </description>
         <comment>
        In case PbcfgM support is enabled, a passed NULL pointer loads the
        CanTrcv configuration from the Postbuild configuration manager module.
        This requirement replaces CanTrcv.ASR40.CanTrcv185.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_DET_PARAM_POINTER_INIT</srcid><srcstatus/><internalId>340</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv179_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvSPICommRetries
        Description Indicates the maximal number of communication retries in case of
                    failed  SPI communication (applies both to timed out communication
                    and to er rors/NACK in the response data). (0...255 times, 0 means
                    no retry al lowed, communication must succeed at first try)
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...255
        Default value 0
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Local
                           dependency: This parameter exists inly if a SPI Sequence is
                           referenced in  SPIREF.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.AutosarSchema</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_SPI_ASYNC_RETRIES</srcid><srcstatus/><internalId>262</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SPI_RETRIES</srcid><srcstatus/><internalId>332</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv178_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvSPICommTimeout
        Description Indicates the maximal time allowed to the Transceiver in order to reply
                    (either positively or negatively) to a SPI command. (value in ms, 0ms
                    means no specific timeout is to be used, communication is executed at
                    the  best of the SPI HW capacity)
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...100
        Default value 0
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Local
                           dependency: This parameter exists only if a SPI Sequence is
                           referenced in CanTrcvSpiSequence.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.AutosarSchema</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv156_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvWaitCount
        Description Indicates the number of wait states to change the transceiver
                    operation  mode. Transceiver hardware may need wait
                    states for some transitions.
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...4294967295
        Default value 0
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Module
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv176_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>2</version>
         <description>
        Name CanTrcvSpiAccessSynchronous {CANTRCV_SPI_ACCESS_SYNCHRONOUS}
        Description This parameter is used to define whether the access to the Spi
                    sequence is synchronous or asynchronous.
                    true: SPI access is synchronous.
                    false: SPI access is asynchronous.
        Multiplicity 0..1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Module
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv151_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvSpiSequenceName {CANTRCV_SPI_SEQUENCE_NAME}
        Description Reference to a Spi sequence configuration container.
        Multiplicity 1
        Type Reference to [ SpiSequence ]
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Instance
                           dependency: SpiSequence
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_SPI_SEQ_REF</srcid><srcstatus/><internalId>345</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv150_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvHardwareInterfaceName {CANTRCV_HARDWARE_INTERFACE_NAME}
        Description CAN transceiver hardware interface name. It is typically
                    the name of a pin. From a Dio point of view it is either
                    a port, a single channel or a channel group. Depending
                    on this fact either CANTRCV_DIO_PORT_SYMBOLIC_NAME or
                    CANTRCV_DIO_CHANNEL_SYMBOLIC_NAME or
                    CANTRCV_DIO_CHANNEL_GROUP_SYMBOLIC_NAME shall reference a
                    Dio configuration. The CAN transceiver driver implementation
                    description shall list up this name for the appropriate
                    CAN transceiver hardware.
        Multiplicity 1
        Type EcucStringParamDef
        Default value -
        maxLength -
        minLength -
        regularExpression -
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Instance
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv149_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvDioSymNameRef
        Description Choice Reference to a DIO Port, DIO Channel or DIO Channel Group.
                    This reference replaces the CANTRCV_DIO_PORT_SYM_NAME,
                    CANTRCV_DIO_CHANNEL_SYM_NAME and CANTRCV_DIO_GROUP_SYM_NAME
                    references in the Can Trcv SWS.
        Multiplicity 1
        Type Choice reference to [ DioChannel , DioChannelGroup , DioPort ]
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency -
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.AutosarSchema</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv157_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Container Name CanTrcvDioChannelAccess{CanTrcvDioChannelAccess}
        Description Container gives DIO channel access by single Can transceiver channel.
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv145_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Container Name CanTrcvDioAccess{CanTransceiverDioAccess}
        Description Container gives CAN transceiver driver information about
                    accessing ports and port pins. In addition relation between
                    CAN transceiver hardware pin names and Dio port access
                    information is given. If a CAN transceiver hardware has
                    no Dio interface, there is no instance of this container.
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

      <specobject>
         <id>CanTrcv.EB.OperationMode.ApiEnable</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        There shall be a pre-compile-time configuration parameter
        (CanTrcvOperationModeApiEnable|CANTRCV_OPERATION_MODE_API_ENABLE)
        for enabling/disabling the API functions CanTrcv_[VARIANT]_SetOpMode and
        CanTrcv_[VARIANT]_GetOpMode. If the API is disabled, the function
        CanTrcv_[VARIANT]_Init always enters the mode specified by configuration
        parameter CanTrcvInitState.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_ON_WUP_DISABLE</srcid><srcstatus/><internalId>279</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_MODE_API_DISABLED</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_ALL_APIS_DISABLED</srcid><srcstatus/><internalId>281</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_OP_MODE_NO_API</srcid><srcstatus/><internalId>343</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.WakeupMode.ApiEnable</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        There shall be a pre-compile-time configuration parameter
        (CanTrcvWakeupModeApiEnable|CANTRCV_WAKEUP_MODE_API_ENABLE)
        for enabling/disabling the API functions CanTrcv_[VARIANT]_GetBusWuReason,
        CanTrcv_[VARIANT]_SetWakeupMode and CanTrcv_[VARIANT]_CheckWakeup.
        WakeupModeApiEnable can only be set to false if the configuration parameter
        CanTrcvWakeUpSupport is set to 'CANTRCV_WAKEUP_NOT_SUPPORTED'.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_CHECK_WU_BY_PIN_NO_BYBUS_ENABLED</srcid><srcstatus/><internalId>264</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_ON_WUP_DISABLE</srcid><srcstatus/><internalId>279</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_MODE_API_DISABLED</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_ALL_APIS_DISABLED</srcid><srcstatus/><internalId>281</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.SetOpMode.InvalidMode</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is disabled:
        If called with an invalid operating mode, the function CanTrcv_SetOpMode
        shall remain in the old operating state and return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INV_OPMODE_NO_DET</srcid><srcstatus/><internalId>327</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.HeaderFileStructure</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The header file include structure differs in following points from
        AUTOSAR_SWS_CANTransceiverDriver.pdf p.12:
        1.) Instead of including CanIf.h CanTrcv shall include CanIf_Cbk.h.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_HEADER_FILE_STRUCTURE_01</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv067</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.TrcvWakeupReasonType.NotSupported</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name: CanTrcv_TrcvWakeupReasonType
        Type: Enumeration
        Range:
        CANTRCV_WU_RESET
        The transceiver has detected, that the "wake up" is  due
        to an ECU reset.  Description: This type denotes the wake up reason
        detected by the CAN transceiver in detail.
      </description>
         <comment>
        This requirement is not applicable.
        The listed enumeration ranges are not supported
      </comment>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv165</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.TrcvWakeupReasonType.Supported</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name: CanTrcv_TrcvWakeupReasonType
        Type: Enumeration
        Range:
        CANTRCV_WU_BY_BUS
        The transceiver has detected, that the network has caused the wake up of
        the ECU.
        CANTRCV_WU_INTERNALLY
        The transceiver has detected, that the network has
        woken up by the ECU via a request to NORMAL  mode.
        CANTRCV_WU_NOT_SUPPORTED
        The transceiver does not support any information
        for the wake up reason.
        CANTRCV_WU_BY_PIN The transceiver has detected a wake-up event
        at  one of the transceiver's pins (not at the CAN bus).
        CANTRCV_WU_POWER_ON
        The transceiver has detected, that the "wake up" is  due to an ECU reset
        after power on.
        CANTRCV_WU_ERROR =0
        Due to an error wake up reason was not detected.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_CHECK_WU_BY_PIN_NO_BYBUS_ENABLED</srcid><srcstatus/><internalId>264</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_PRIORITY</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_DISABLE</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_REASON_BUS_PIN</srcid><srcstatus/><internalId>331</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv165</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.BSWMDGeneration_1</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanTrcv module's generator shall generate a basic software
        module description (BSWMD) based on the CanTrcv module's
        configuration containing information on the exclusive areas
        required by the CanTrcv module's implementation.
      </description>
         <comment>
        This requirement is not applicable.
        The CanTrcv module does not use any exclusive areas.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.BSWMDGeneration_2</id>
         <status>rejected</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanTrcv module's generator shall generate a basic software
        module description (BSWMD) based on the CanTrcv module's
        configuration containing information on the scheduled
        MainFunctions together with the scheduling period.
      </description>
         <comment>
        This requirement is not applicable.
        The CanTrcv module does not have any MainFunctions.
      </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.BSWMDGeneration_3</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanTrcv module's BSWMD shall be generated using a generator
        mode named "generate_swcd".
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANTRCV_SCHM</srcid><srcstatus/><internalId>282</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.CanTrcv_CheckWakeup</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The following functions shall inform EcuM by calling EcuM_SetWakeupEvent with
        the corresponding wakeup source if they detect a wakeup event:
        - CanTrcv_Init
        - CanTrcv_CheckWakeFlag
        - CanTrcv_CheckWakeup
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_CHECK_WAKEUP_FLAG</srcid><srcstatus/><internalId>301</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_CAN_TRCV_INIT_CAN_FLAG</srcid><srcstatus/><internalId>312</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_CAN_TRCV_INIT_SYSERR_FLAG</srcid><srcstatus/><internalId>313</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_ENABLE</srcid><srcstatus/><internalId>328</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.CanTrcvSilentDetection_Conf</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name CanTrcvSilentDetection
        Description Switches CAN bus silence detection on or off.
                    In case the silent detection is disabled API
                    service CanTrcv_ReadTrcvSilenceFlag can not obtain
                    the silence status.
        Multiplicity 1
        Type EcucBooleanParamDef Default
        Default value false
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Module
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_READ_SILENCE_FLAG</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SILENCE_DETECT_OFF</srcid><srcstatus/><internalId>261</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.CanTrcvCanFailureDetection_Conf</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name CanTrcvCanFailureDetection
        Description Switches CAN failure detection on or off.
                    In case CAN failure detection is enabled the CanTrcv sets the SYSERR flag
                    if the TXD dominant time-out time is exceeded.
        Multiplicity 1
        Type EcucBooleanParamDef Default
        Default value false
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Module
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_READ_TIMEOUT_FLAG</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_TIMEOUT_DETECT_OFF</srcid><srcstatus/><internalId>319</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.CanTrcvRisingEdgeDetection_Conf</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name CanTrcvRisingEdgeDetection
        Description Switches rising-edge detection on WAKE pin on or off.
                    In case of a rising edge the CanTrcv reports a wake-up.
        Multiplicity 1
        Type EcucBooleanParamDef Default
        Default value false
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Module
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE3_LWU</srcid><srcstatus/><internalId>258</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.CanTrcvFallingEdgeDetection_Conf</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name CanTrcvFallingEdgeDetection
        Description Switches falling-edge detection on WAKE pin on or off.
                    In case of a falling edge the CanTrcv reports a wake-up.
        Multiplicity 1
        Type EcucBooleanParamDef Default
        Default value false
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Module
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE3_LWU</srcid><srcstatus/><internalId>258</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.GetWuReason.Update</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        CanTrcv_GetBusWuReason shall not update the wakeup reason on its own.
        The wakeup reason shall be internally updated when CanTrcv_CheckWakeup is invoked
        (or in case of reason CANTRCV_WU_INTERNALLY when CanTrcv_SetOpMode is invoked).
        CanTrcv_GetBusWuReason shall return this internally stored wakeup reason.
      </description>
         <comment>
        This ensures that the event which wake-up the CanTrcv is the same event
        as by notified by CanTrcv_GetBusWuReason.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_WAKEUP_PRIORITY</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_REASON_BUS_PIN</srcid><srcstatus/><internalId>331</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.GetWuReason.Priority</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        In case of multiple wakeup events, CanTrcv_GetBusWuReason shall
        return the wakeup reason with the highest priority.
        The priority is as follows (from highest to lowest):
        - CANTRCV_WU_POWER_ON
        - CANTRCV_WU_BY_SYSERR
        - CANTRCV_WU_BY_BUS
        - CANTRCV_WU_BY_PIN
        - CANTRCV_WU_INTERNALLY
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_WAKEUP_PRIORITY</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_REASON_BUS_PIN</srcid><srcstatus/><internalId>331</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.PnSupport</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name CanTrcvPnSupport {CANTRCV_PN_SUPPORT}
        Description Indicates whether the HW supports the selective wake-up function
                    TRUE =  Selective wakeup feature is supported by the transceiver
                    FALSE = Selective wakeup functionality is not available in
                            transceiver
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Local
                           dependency: CanTrcvWakeUpSupport
      </description>
         <comment>
        This requirement replaces CanTrcv.ASR40.CanTrcv160_Conf.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_ENABLED_INIT</srcid><srcstatus/><internalId>304</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv174</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.CanFdTolerance</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name: CanTrcvCanFdTolerance {CANTRCV_1_T03_FD_TOLERANCE}
        Description Indicates whether CAN-FD frames are tolerated in combination
                    with partial networking (passive support).
                    TRUE = CFDC bit set in control register
                    FALSE = CFDC bit _not_ set in control register
        Multiplicity: 1
        Type: EcucBooleanParamDef
        Default value: false
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Local
                           dependency: CanTrcvPnSupport
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ENABLE_PN_STATE</srcid><srcstatus/><internalId>317</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_CHECK_CFDC_INIT</srcid><srcstatus/><internalId>321</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_CHECK_CFDC_SLEEPCYCLE</srcid><srcstatus/><internalId>322</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.E_UNINIT.ReadTrcvTimeoutFlag</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_ReadTrcvTimeoutFlag shall raise the development error CANTRCV_E_UNINIT and
        return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_DET_UNINIT_READTIMEOUT</srcid><srcstatus/><internalId>336</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.E_UNINIT.ClearTrcvTimeoutFlag</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_ClearTrcvTimeoutFlag shall raise the development error CANTRCV_E_UNINIT and
        return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_DET_UNINIT_CLEARTIMEOUT</srcid><srcstatus/><internalId>337</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.E_UNINIT.ReadTrcvSilenceFlag</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_ReadTrcvSilenceFlag shall raise the development error CANTRCV_E_UNINIT and
        return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_DET_UNINIT_READSILENCE</srcid><srcstatus/><internalId>338</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.E_UNINIT.CheckWakeFlag</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_CheckWakeFlag shall raise the development error CANTRCV_E_UNINIT and
        return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_DET_UNINIT_CHECKWAKEFLAG</srcid><srcstatus/><internalId>339</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.NoRegularWupEvent</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If none of the wakeup events is enabled in the CanTrcv configuration
        the API service CanTrcv_SetOpMode denies the request and returns
        E_NOT_OK when a transition to SLEEP takes place.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_NO_WUP_EVENT_ENABLED</srcid><srcstatus/><internalId>318</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.Generator.SpiConf</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The generator shall ensure the validity of the SPI configuration
        referenced by the CanTrcv.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01001_Err_MultipleJobs</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01002_Err_MultipleChannels</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01003_Err_RedefinedSequenceId</srcid><srcstatus/><internalId>268</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.Generator.CanTrcvConf</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The generator shall ensure the validity of the CanTrcv configuration.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01004_Err_WrongMsgDLC</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01005_Err_DuplicatedDataMaskIndex</srcid><srcstatus/><internalId>270</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01006_Err_UnexpectedDataMaskIndex</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01007_Warn_NoWakeupData</srcid><srcstatus/><internalId>272</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01008_Err_WrongWakeupConfig</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01009_Err_WrongPNConfig</srcid><srcstatus/><internalId>274</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

      <specobject>
         <id>CanTrcv_1_T03.EB.RelocatablePBCfg</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      In order to support post-build-time configuration data handled by relative offsets to the configuration start address,
      the container VendorSpecific must be extended by the configuration parameter CanTrcvRelocatablePbcfgEnable.
    </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_PBcfgM_Off</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>CanTrcv_1_T03_Test_PBcfgM_On</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>
    
      <specobject>
         <id>CanTrcv_1_T03.EB.CanTrcvSpiAccessAsynchronousTimeout</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Name: CanTrcvSpiAccessAsynchronousTimeout
        Description: Indicates the maximum number of loop iterations used from polling the completion of the asynchronous transfer.
                     This parameter is related to the SpiMainFunctionPeriod parameter
        Multiplicity: 1
        Type: EcucIntegerParamDef
        Default value: 1
        ConfigurationClass:
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Module
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_SPI_ASYNC_POLLING</srcid><srcstatus/><internalId>263</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>
    
  </specobjects>
    <specobjects doctype="swurs">

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv098</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The CAN bus transceiver hardware shall provide the functionality and an
        interface which can be mapped to the operation mode model of the AUTOSAR
        CAN transceiver driver. (BSW172)
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement is too imprecise and is formulated by several other requirements
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv070</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        In case different CAN transceiver hardware chips are used in one ECU, the
        function names of the different CAN transceiver drivers must be modified
        such that no two functions with the same names are generated. It is the
        responsibility of the user to take care that no two functions with the
        same names are configured. The names may be extended with a vendor ID or
        a type ID. (BSW00347)
      </description>
         <comment>
        The EB CanTrcv always uses a vendor specifc prefix to distinguish from other drivers.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv064</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The naming convention prescribed by AUTOSAR is applied to all files of the
        CanTrcv module. (BSW00300)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.man.NamingConvention</srcid><srcstatus/><internalId>248</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv065</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The CanTrcv module consists of the following files:
        CanTrcv.c, CanTrcv.h, CanTrcv_Cfg.h, CanTrcv_Cfg.c
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv062</srcid><srcstatus/><internalId>1</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv069</srcid><srcstatus/><internalId>53</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv052</srcid><srcstatus/><internalId>54</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv083</srcid><srcstatus/><internalId>55</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv069</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv.c: The implementation general c file. It does not contain interrupt routines.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar_T03/src/CanTrcv_1_T03.c_31</srcid><srcstatus/><internalId>251</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv065</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv052</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv.h: It contains only information relevant for other BSW mod-ules (API).
        Differences in API depending in configuration are encapsulated.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar_T03/include/CanTrcv_1_T03.h_6</srcid><srcstatus/><internalId>250</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv065</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv083</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv_Cfg.h: Pre-compile time configuration parameter file.
        It's gener-ated by the configuration tool.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar_T03/generate/include/CanTrcv_1_T03_Cfg.h_22</srcid><srcstatus/><internalId>249</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv065</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv067</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        This figure shows the include structure for the module CanTrcv (part1)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.EB.HeaderFileStructure</srcid><srcstatus/><internalId>25</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv068</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        For AUTOSAR standard data types, header file Std_Types.h is included.
        (BSW00348)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_HEADER_FILE_STRUCTURE_01</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv061</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The name of the compiler specific header file is Compiler.h. All mappings of not
        standardized keywords of compiler specific scope shall be placed and
        organized in this compiler specific type and keyword header. (BSW00361)
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for ComStack_Types.h (Base module).
        It is not a requirement of the Can transceiver itself.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv063</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The name of the platform specific header file is Platform_Types.h. All integer
        type definitions of target and compiler specific scope shall be placed
        and organized in this single type header. (BSW00353)
      </description>
         <comment>
        This requirement is not applicable.
        This is no requirement for the module CanTrcv.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv156</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv.h shall include CanTrcv_Cfg.h, for the API pre-compiler switches
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_HEADER_FILE_STRUCTURE_01</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv162</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv.h shall include Can_GeneralTypes.h, for the general CAN type
        definitions.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_HEADER_FILE_STRUCTURE_01</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv166</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The imported types described in CanTrcv163, CanTrcv164 and CanTrcv165 shall be
        defined in Can_GeneralTypes.h.
      </description>
         <comment>
        This requirement is not applicable.
        This is a requirement for Base (where Can_GeneralTypes.h is part of) and not for CanTrcv.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv055</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The CanTrcv module shall implement the state diagram shown below, independently
        for each configured transceiver. (BSW01098, BSW01099, BSW01100)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_STATE_MASCHINE</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_OP_MODE_SEQ</srcid><srcstatus/><internalId>326</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv148</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_Init causes a state change to either CANTRCV_TRCVMODE_SLEEP,
        CANTRCV_TRCVMODE_NORMAL or CANTRCV_TRCVMODE_STANDBY.
        This depends on the configuration and is independently
        configurable for each transceiver.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DISABLE_PN_STATE</srcid><srcstatus/><internalId>316</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv161</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        A mode switch request to the current mode is allowed and shall not lead to an
        error, even if DET is enabled.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_STATE_MASCHINE</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_SETOPMODE_SAME_MODE</srcid><srcstatus/><internalId>342</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv158</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The CanTrcv module shall invoke the callback function CanIf_TrcvModeIndication,
        for each mode switch request with call to CanTrcv_SetOpMode, after the
        requested mode has been reached.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_OP_MODE_REGRESSION</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_STATE_MASCHINE</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_SETOPMODE_SAME_MODE</srcid><srcstatus/><internalId>342</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv090</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        NOT_SUPPORTED mode:
        In mode NOT_SUPPORTED, no wake ups are generated by CAN transceiver driver.
        This mode is supported by all CAN transceiver hardware types. (BSW00388,
        BSW00389, BSW00390, BSW00391, BSW00392, BSW00393, BSW00394, BSW00408, BSW00425,
        BSW160, BSW172, BSW01090)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_NO_WUP_1</srcid><srcstatus/><internalId>323</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_NO_WUP_2</srcid><srcstatus/><internalId>324</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_NO_WUP_3</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv091</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        POLLING mode:
        In mode POLLING, wake ups generated by CAN transceiver driver may cause
        CAN channel wake ups. In this mode, no MCU wake ups are possible.
        This mode presumes a support by used CAN transceiver hardware type.
        Wake up mode POLLING requires function CanTrcv_CheckWakeup and main function
        CanTrcv_MainFunction to be present in source code.
        The main function CanTrcv_MainFunction shall be called by BSW sche-duler
        and CanTrcv_CheckWakeup by CanIf. (BSW00388, BSW00389, BSW00390, BSW00391,
        BSW00392, BSW00393, BSW00394, BSW00395, BSW00408, BSW160, BSW172, BSW01090, BSW01092)
      </description>
         <comment>
        CanTrcv_Mainfunction is not implemented so it wont be called
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv057</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Development error values are of type uint8.
      </description>
         <comment>
        This requirement is informational only.
        This is a requriement on the SWS but not on the implementation.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv050</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Type or error           Relevance     Related error code                Value [hex]
        API called with wrong   Development   CANTRCV_E_INVALID_TRANSCEIVER     1
        parameter for the
        CAN transceiver

        API called with null    Development   CANTRCV_E_PARAM_POINTER           2
        pointer parameter

        API service used        Development   CANTRCV_E_UNINIT                  11
        without initialization

        API service called in   Development   CANTRCV_E_TRCV_NOT_STANDBY        21
        wrong transceiver                     CANTRCV_E_TRCV_NOT_NORMAL         22
        operation mode

        API service called      Development   CANTRCV_E_PARAM_TRCV_WAKEUP_MODE  23
        with invalid parameter
        for TrcvWakeupMode

        API service called      Development   CANTRCV_E_PARAM_TRCV_OPMODE       24
        with invalid parameter
        for OpMode

        Configured baud rate    Development   CANTRCV_E_BAUDRATE_NOT_SUPPORTED  25
        is not supported by
        the transceiver

        No/incorrect commu      Development   CANTRCV_E_NO_TRCV_CONTROL         26
        -nication to trans-
        ceiver.
      </description>
      <furtherinfo>
         Justifying rule: WRN.swurs.needscoverage.count violation.
         This swurs is covered by more than 10 EB swurs.
      </furtherinfo>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ReadTrcvTimeoutFlag</srcid><srcstatus/><internalId>40</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ClearTrcvTimeoutFlag</srcid><srcstatus/><internalId>41</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ReadTrcvSilenceFlag</srcid><srcstatus/><internalId>42</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.CheckWakeFlag</srcid><srcstatus/><internalId>43</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv120</srcid><srcstatus/><internalId>98</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv121</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv122</srcid><srcstatus/><internalId>100</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv123</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv087</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv124</srcid><srcstatus/><internalId>105</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv129</srcid><srcstatus/><internalId>106</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv132</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv125</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv130</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv133</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv134</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv127</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv131</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv089</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv144</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv145</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv128</srcid><srcstatus/><internalId>133</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv023</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The detection of all development errors is configurable (ON/OFF) at Pre-compile
        time. The switch CanTrcvDevErrorDetect shall activate or deactivate the
        detection of all development errors. (BSW00350)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_INV_OPMODE_NO_DET</srcid><srcstatus/><internalId>327</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv048</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If the CanTrcvDevErrorDetect switch is enabled API parameter checking is
        enabled. The detailed description of the detected errors can be found in
        chapter 7.6. (BSW00323)
      </description>
      <furtherinfo>
         Justifying rule: WRN.swurs.needscoverage.count violation.
         This swurs is covered by more than 10 EB swurs.
      </furtherinfo>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv113</srcid><srcstatus/><internalId>3</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv114</srcid><srcstatus/><internalId>4</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv115</srcid><srcstatus/><internalId>5</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv116</srcid><srcstatus/><internalId>6</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv117</srcid><srcstatus/><internalId>7</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv190</srcid><srcstatus/><internalId>8</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv196</srcid><srcstatus/><internalId>9</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv185.1</srcid><srcstatus/><internalId>12</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ReadTrcvTimeoutFlag</srcid><srcstatus/><internalId>40</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ClearTrcvTimeoutFlag</srcid><srcstatus/><internalId>41</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ReadTrcvSilenceFlag</srcid><srcstatus/><internalId>42</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.CheckWakeFlag</srcid><srcstatus/><internalId>43</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv120</srcid><srcstatus/><internalId>98</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv121</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv122</srcid><srcstatus/><internalId>100</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv123</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv087</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv124</srcid><srcstatus/><internalId>105</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv129</srcid><srcstatus/><internalId>106</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv132</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv125</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv130</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv133</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv134</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv127</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv131</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv089</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv144</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv145</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv128</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvTimeoutFlag</srcid><srcstatus/><internalId>218</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvSilenceFlag</srcid><srcstatus/><internalId>219</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_NO_TRCV_CONTROL.SetPNActivationState</srcid><srcstatus/><internalId>220</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_NO_TRCV_CONTROL.CheckWakeup</srcid><srcstatus/><internalId>221</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv058</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The detection of production code errors cannot be switched off.
        (BSW00339, BSW00421)
      </description>
         <comment>
        This requirement is not applicable.
        Conflicts with EB requirement [BSWM_EB_002].
        See:
        http://wiki.elektrobit.com/index.php/Project:EB_tresos/Engineering_AutoCore/
            Software_Construction/Coding_Guidelines
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv040</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Detected development errors will be reported to the error hook of the
        Development Error Tracer (Det) if the pre-processor switch
        CanTrcvDevErrorDetect is set. (BSW00338)
      </description>
      <furtherinfo>
         Justifying rule: WRN.swurs.needscoverage.count violation.
         This swurs is covered by more than 10 EB swurs.
      </furtherinfo>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv113</srcid><srcstatus/><internalId>3</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv114</srcid><srcstatus/><internalId>4</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv115</srcid><srcstatus/><internalId>5</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv116</srcid><srcstatus/><internalId>6</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv117</srcid><srcstatus/><internalId>7</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv190</srcid><srcstatus/><internalId>8</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv196</srcid><srcstatus/><internalId>9</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv185.1</srcid><srcstatus/><internalId>12</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ReadTrcvTimeoutFlag</srcid><srcstatus/><internalId>40</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ClearTrcvTimeoutFlag</srcid><srcstatus/><internalId>41</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.ReadTrcvSilenceFlag</srcid><srcstatus/><internalId>42</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_UNINIT.CheckWakeFlag</srcid><srcstatus/><internalId>43</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv120</srcid><srcstatus/><internalId>98</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv121</srcid><srcstatus/><internalId>99</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv122</srcid><srcstatus/><internalId>100</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv123</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv087</srcid><srcstatus/><internalId>102</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv124</srcid><srcstatus/><internalId>105</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv129</srcid><srcstatus/><internalId>106</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv132</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv125</srcid><srcstatus/><internalId>110</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv130</srcid><srcstatus/><internalId>111</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv133</srcid><srcstatus/><internalId>112</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv134</srcid><srcstatus/><internalId>117</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv127</srcid><srcstatus/><internalId>124</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv131</srcid><srcstatus/><internalId>125</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv089</srcid><srcstatus/><internalId>126</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv144</srcid><srcstatus/><internalId>128</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv145</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv128</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvTimeoutFlag</srcid><srcstatus/><internalId>218</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvSilenceFlag</srcid><srcstatus/><internalId>219</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_NO_TRCV_CONTROL.SetPNActivationState</srcid><srcstatus/><internalId>220</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.E_NO_TRCV_CONTROL.CheckWakeup</srcid><srcstatus/><internalId>221</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv024</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Production errors shall be reported to Diagnostic Event Manager (Dem). Only
        error cases are reported to the Dem.
      </description>
         <comment>
        This requirement is not applicable.
        CanTrcv does not use DEM.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv099</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The environment of the CanTrcv module shall make sure that all necessary BSW
        drivers (used by the CanTrcv module) have been initialized and are usable
        before CanTrcv_Init is called.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is no requirement for the module CanTrcv.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv016</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        For each different CAN transceiver hardware type, an ECU has one CAN transceiver
        driver instance. One instance serves all CAN transceiver hardware of same
        type.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is no requirement for the module CanTrcv.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv151</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        All type definitions of variables which shall be debugged, shall be accessible
        by the header file CanTrcv.h
      </description>
         <comment>
        EB Debug and Trace will be supported instead.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.Debugging</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv152</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Each variable that shall be accessible by AUTOSAR Debugging, shall be
        defined as a global variable.
      </description>
         <comment>
        EB Debug and Trace will be supported instead.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.Debugging</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv153</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The declaration of variables in the header file shall be such, that it is
        possible to calculate the size of the variables by C-"sizeof".
      </description>
         <comment>
        EB Debug and Trace will be supported instead.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.Debugging</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv154</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Variables available for debugging shall be described in the respective Basic
        Software Module Description.
      </description>
         <comment>
        EB Debug and Trace will be supported instead.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.Debugging</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv155</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The states of CAN Transceiver Driver state machine shall be available for
        debugging.
      </description>
         <comment>
        EB Debug and Trace will be supported instead.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.Debugging</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv160</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The CanTrcv module shall perform Inter-Module checks to avoid integration of
        incompatible files. (BSW003, BSW00318, BSW004)
      </description>
         <comment>
        This requirement is not applicable.
        overruled by coding guideline [BSWM_CHK_401]
        Description: Although required by the SRS General, BSW004, inter-module
        version-checks SHALL NOT be done. A deviation is documented globally for
        all BSW modules within the release notes and SHALL NOT be documented for each module.
        Rationale: AutoCore is an integrated product. Inter-module checks are very error
        prone and could not be handled between different suppliers
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv084</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Module                Imported Type
        Can_GeneralTypes      CanTrcv_TrcvModeType
                              CanTrcv_TrcvWakeupModeType
                              CanTrcv_TrcvWakeupReasonType
        Dio                   Dio_ChannelType
                              Dio_LevelType
                              Dio_PortLevelType
                              Dio_PortType
                              Dio_ChannelGroupType
        Icu                   Icu_ChannelType
        Spi                   Spi_ChannelType
                              Spi_DataType
                              Spi_NumberOfDataType
                              Spi_SequenceType
                              Spi_StatusType
        Std_Types             Std_ReturnType
                              Std_VersionInfoType
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This paragraph is no requirement, just a summary of used types.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv163</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name: CanTrcv_TrcvModeType
        Type: Enumeration
        Range: CANTRCV_TRCVMODE_NORMAL    = 0
                                          Transceiver mode NORMAL
               CANTRCV_TRCVMODE_SLEEP     Transceiver mode SLEEP
               CANTRCV_TRCVMODE_STANDBY   Transceiver mode STANDBY
        Description: Operating modes of the CAN Transceiver Driver.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for Can_GeneralTypes.h (Base module). It is not a requirement
        of the Can transceiver itself.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv164</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name: CanTrcv_TrcvWakeupModeType
        Type: Enumeration
        Range: CANTRCV_WUMODE_CLEAR   A stored wakeup event is cleared on the addressed
                                      network.
               CANTRCV_WUMODE_DISABLE The notification for wakeup events is disabled on
                                      the  addressed network.
               CANTRCV_WUMODE_ENABLE  = 0
                                      The notification for wakeup events is enabled on the
                                      addressed network.
        Description: This type shall be used to control the CAN transceiver concerning wake up
                     events and wake up notifications.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for Can_GeneralTypes.h (Base module). It is not a requirement
        of the Can transceiver itself.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv165</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name: CanTrcv_TrcvWakeupReasonType
        Type: Enumeration
        Range: CANTRCV_WU_BY_BUS         The transceiver has detected, that the network has
                                        caused the wake up of the ECU.
              CANTRCV_WU_BY_PIN         The transceiver has detected a wake-up event at
                                        one of the transceiver's pins (not at the CAN bus).
              CANTRCV_WU_ERROR          =0
                                        Due to an error wake up reason was not detected.
                                        This value may only be reported when error was
                                        reported to DEM before.
              CANTRCV_WU_INTERNALLY     The transceiver has detected, that the network
                                        has woken up by the ECU via a request to NORMAL
                                        mode.
              CANTRCV_WU_NOT_SUPPORTED  The transceiver does not support any information
                                        for the wake up reason.
              CANTRCV_WU_POWER_ON       The transceiver has detected, that the "wake up"
                                        is  due to an ECU reset after power on.
              CANTRCV_WU_RESET          The transceiver has detected, that the "wake up"
                                        is  due to an ECU reset.
              CANTRCV_WU_BY_SYSERR      The transceiver has detected, that the wake up of
                                        the ECU was caused by a HW related device failure.
        Description: This type denotes the wake up reason detected by the CAN transceiver in detail.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.EB.TrcvWakeupReasonType.NotSupported</srcid><srcstatus/><internalId>26</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.EB.TrcvWakeupReasonType.Supported</srcid><srcstatus/><internalId>27</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv209</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name: CanTrcv_ConfigType
        Type: Structure
        Range: Implementation specific
        Description: This is the type of the external data structure containing
        the overall initialization  data for the CAN transceiver driver and
        settings affecting all transceivers. Fur thermore it contains pointers to
        transceiver configuration structures. The contents  of the initialization
        data structure are CAN transceiver hardware specific.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for Can_GeneralTypes.h (Base module). It is not a requirement
        of the Can transceiver itself.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv210</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name: CanTrcv_PNActivationType
        Type: Enumeration
        Range: PN_ENABLED PN wakeup functionality in CanTrcv is enabled.
               PN_DISABLED PN wakeup functionality in CanTrcv is disabled.
        Description: Datatype used for describing whether PN wakeup functionality
        in CanTrcv is en abled or disabled.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for Can_GeneralTypes.h (Base module). It is not a requirement
        of the Can transceiver itself.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv211</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name: CanTrcv_TrcvFlagStateType
        Type: Enumeration
        Range: CANTRCV_FLAG_SET The flag is set in the transceiver hardware.
               CANTRCV_FLAG_CLEARED The flag is cleared in the transceiver hardware.
        Description: Provides the state of a flag in the transceiver hardware.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is a requirement for Can_GeneralTypes.h (Base module). It is not a requirement
        of the Can transceiver itself.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv001</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_Init
        Syntax: void CanTrcv_Init(  const CanTrcv_ConfigType* ConfigPtr  )
        Service ID[hex]: 0x00
        Sync/Async: Synchronous  Reentrancy: Non Reentrant
        Parameters (in): None
        Parameters (in- None  out): None
        Parameters (out): None
        Return value: None
        Description: Initializes the CanTrcv module.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_INIT</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE</srcid><srcstatus/><internalId>298</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE_2</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DISABLE_PN_STATE</srcid><srcstatus/><internalId>316</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv100</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_Init shall set the CAN transceiver hardware to the state
        configured by the configuration parameter CanTrcvInitState.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv002</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_SetOpMode
        Syntax: Std_ReturnType CanTrcv_SetOpMode( uint8 Transceiver,
                                                  CanTrcv_TrcvModeType OpMode  )
        Service ID[hex]: 0x01
        Sync/Async: Asynchronous
        Reentrancy: Reentrant for different transceivers
        Parameters (in): Transceiver: CAN transceiver to which API call has to be applied.
                         OpMode: This parameter contains the desired operating mode
        Parameters (in- None  out):
        Parameters (out): None
        Return value: Std_ReturnType E_OK: will be returned if the transceiver state
                                           has been changed  to the requested mode.
                                     E_NOT_OK: will be returned if the transceiver state
                                               change has  failed or the parameter is out
                                               of the allowed range. The previous  state has
                                               not been changed.
        Description: Sets the mode of the Transceiver to the value OpMode.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_ON_WUP_DISABLE</srcid><srcstatus/><internalId>279</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_OPMODE</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv102</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_SetOpMode shall switch the internal state of Transceiver to
        the value of the parameter OpMode, which can be CANTRCV_TRCVMODE_NORMAL,
        CANTRCV_TRCVMODE_STANDBY or CANTRCV_TRCVMODE_SLEEP.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_STATE_MASCHINE</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_SETOPMODE_SAME_MODE</srcid><srcstatus/><internalId>342</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv103</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The user of the CanTrcv module shall call the function CanTrcv_SetOpMode with
        OpMode = CANTRCV_TRCVMODE_STANDBY or CANTRCV_TRCVMODE_NORMAL, if the
        Transceiver is in mode CANTRCV_TRCVMODE_NORMAL.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement just explains how the user should use the function.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv104</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The user of the CanTrcv module shall call the function CanTrcv_SetOpMode with
        OpMode = CANTRCV_TRCVMODE_SLEEP or CANTRCV_TRCVMODE_STANDBY, if the
        Transceiver is in mode CANTRCV_TRCVMODE_STANDBY.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This requirement just explains how the user should use the function.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv105</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If the requested mode is not supported by the underlying transceiver hardware,
        the function CanTrcv_SetOpMode shall return E_NOT_OK.
      </description>
         <comment>
        This requirement is not applicable.
        This requirement is in conflict with CanTrcv.ASR40.CanTrcv055.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv120</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If the
        function CanTrcv_SetOpMode is called with OpMode =
        CANTRCV_TRCVMODE_STANDBY, and the Transceiver is not in mode
        CANTRCV_TRCVMODE_NORMAL or CANTRCV_TRCVMODE_STANDBY, the function
        CanTrcv_SetOpMode shall raise the development error
        CANTRCV_E_TRCV_NOT_NORMAL and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_TRCV_NOT_NORMAL</srcid><srcstatus/><internalId>335</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv121</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If the
        function CanTrcv_SetOpMode is called with OpMode =
        CANTRCV_TRCVMODE_SLEEP, and the Transceiver is not in mode
        CANTRCV_TRCVMODE_STANDBY or CANTRCV_TRCVMODE_SLEEP, the function
        CanTrcv_SetOpMode shall raise the development error
        CANTRCV_E_TRCV_NOT_STANDBY and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_STATE_MASCHINE</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv122</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_SetOpMode shall raise the development error CANTRCV_E_UNINIT and
        return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv123</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called with
        an invalid Transceiver number, the function CanTrcv_SetOpMode shall raise
        the development error CANTRCV_E_INVALID_TRANSCEIVER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv087</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called with
        an invalid OpMode, the function CanTrcv_SetOpMode shall raise the
        development error CANTRCV_E_PARAM_TRCV_OPMODE and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_OPMODE</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv005</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_GetOpMode
        Syntax: Std_ReturnType CanTrcv_GetOpMode( uint8 Transceiver,
                                            CanTrcv_TrcvModeType* OpMode  )
        Service ID[hex]: 0x02
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): Transceiver CAN transceiver to which API call has to be applied.
        Parameters (in- out): None
        Parameters (out): OpMode Pointer to operation mode of the bus the API is applied to.
        Return value: Std_ReturnType E_OK: will be returned if the operation mode was detected.
                                     E_NOT_OK: will be returned if the operation mode was not
                                               detected.
        Description: Gets the mode of the Transceiver and returns it in OpMode.
        (BSW00310, BSW00329, BSW00369, BSW00371, BSW00377, BSW00406, BSW01091,
        BSW01097, BSW01101, BSW01109, BSW01110)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_ON_WUP_DISABLE</srcid><srcstatus/><internalId>279</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_STATE_MASCHINE</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv106</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_GetOpMode shall collect the actual state of the CAN
        transceiver driver in the out parameter OpMode.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv124</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_GetOpMode shall raise the development error CANTRCV_E_UNINIT and
        return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv129</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called with
        an invalid Transceiver number, the function CanTrcv_GetOpMode shall raise
        the development error CANTRCV_E_INVALID_TRANSCEIVER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv132</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled:
        If called with OpMode = NULL, the function CanTrcv_GetOpMode shall
        raise the de-velopment error CANTRCV_E_PARAM_POINTER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv007</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_GetBusWuReason
        Syntax: Std_ReturnType CanTrcv_GetBusWuReason(  uint8 Transceiver,
                                    CanTrcv_TrcvWakeupReasonType* reason  )
        Service ID[hex]: 0x03
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): Transceiver CAN transceiver to which API call has to be applied.
        Parameters (in- out): None
        Parameters (out): reason Pointer to wake up reason of the bus the API is applied to.
        Return value: Std_ReturnType E_OK: will be returned if the transceiver wakeup
                                           reason was provided.
                                     E_NOT_OK: will be returned if the service request
                                               failed due to development errors OR the
                                               transceiver wakeup reason is not  defined in
                                               CanIf_TrcvWakeupReasonType.
        Description: Gets the wakeup reason for the Transceiver and returns it in parameter
                     Reason.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_MODE_API_DISABLED</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_PRIORITY</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv107</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_GetBusWuReason shall collect the reason for the wake up
        that the CAN transceiver has detected in the parameter Reason.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_WAKEUP_PRIORITY</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_REASON_BUS_PIN</srcid><srcstatus/><internalId>331</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv125</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_GetBusWuReason shall raise development error CANTRCV_E_UNINIT and
        return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv130</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        with an invalid Transceiver number, the function CanTrcv_GetBusWuReason shall raise
        development error CANTRCV_E_INVALID_TRANSCEIVER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv133</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called with
        Reason = NULL, the function CanTrcv_GetBusWuReason shall raise the
        development error CANTRCV_E_PARAM_POINTER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv008</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_GetVersionInfo
        Syntax: void CanTrcv_GetVersionInfo( Std_VersionInfoType* versioninfo  )
        Service ID[hex]: 0x04
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): None
        Parameters (in- out): None
        Parameters (out): versioninfo Pointer to version information of this module.
        Return value: None
        Description: Gets the version of the module and returns it in VersionInfo.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv108</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_GetVersionInfo shall return the version information of this
        module. The version information includes:
        - Module Id
        - Vendor Id
        - Vendor specific version numbers
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_GET_VERSIONINFO</srcid><srcstatus/><internalId>292</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv109</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_GetVersionInfo shall be pre-compile time configurable
        On/Off by the configuration parameter CanTrcvGetVersionInfo.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_ON_WUP_DISABLE</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv110</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If source code for caller and callee of this function is available, the CanTrcv
        module should realize this function as a macro defined in the module's
        header file.
      </description>
         <comment>
        This requirement is not applicable.
        Caller or Callee of this function is unknown, therefore the source code is not available.
        CanTrcv_GetVersionInfo can only be configured as function.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv134</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called with
        VersionInfo = NULL, the function CanTrcv_GetVersionInfo shall raise
        development error CANTRCV_E_PARAM_POINTER.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_GET_VERSIONINFO</srcid><srcstatus/><internalId>292</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv009</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_SetWakeupMode
        Syntax: Std_ReturnType CanTrcv_SetWakeupMode(  uint8 Transceiver,
                              CanTrcv_TrcvWakeupModeType TrcvWakeupMode  )
        Service ID[hex]: 0x05
        Sync/Async: Synchronous
        Reentrancy: Reentrant for different transceivers
        Parameters (in): Transceiver CAN transceiver to which API call has to be applied.
                         TrcvWakeupMode Requested transceiver wakeup reason
        Parameters (in- out): None
        Parameters (out): None
        Return value: Std_ReturnType E_OK: Will be returned, if the wakeup state has been
                                           changed to the requested mode.
                                     E_NOT_OK: Will be returned, if the wakeup state change
                                               has failed or the parameter is out of the
                                               allowed range. The previ ous state has not been
                                               changed.
        Description: Enables, disables or clears wake-up events of the Transceiver according
                     to TrcvWakeupMode.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_MODE_API_DISABLED</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_MODE</srcid><srcstatus/><internalId>289</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_ENABLE</srcid><srcstatus/><internalId>328</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_DISABLE</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_CLEAR</srcid><srcstatus/><internalId>330</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv111</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Enabled: If the function CanTrcv_SetWakeupMode is called with TrcvWakupMode =
        CANTRCV_ WUMODE_ENABLE and if the CanTrcv module has a stored wakeup
        event pending for the addressed bus, the CanTrcv module shall update its
        wakeup event as 'present'.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_ENABLE</srcid><srcstatus/><internalId>328</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv093</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Disabled: If the function CanTrcv_SetWakeupMode is called with TrcvWakeupMode =
        CANTRCV_ WUMODE_DISABLE, the wakeup events are disabled on the addressed
        transceiver. It is required by the transceiver device and the transceiver
        driver to detect the wakeup events and store it internally, in order to
        raise the wakeup events when the wakeup mode is enabled again.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_DISABLE</srcid><srcstatus/><internalId>329</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv094</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Clear: If the function CanTrcv_SetWakeupMode is called with TrcvWakeupMode =
        CANTRCV_ WUMODE_CLEAR, then a stored wakeup event is cleared on the
        addressed transceiver.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_CLEAR</srcid><srcstatus/><internalId>330</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv150</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Clearing of wakeup events have to be used when the wake up notification is
        disabled to clear all stored wake up events under control of the higher
        layer.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Requirement specifies behavior for higher layer and is no CanTrcv requirement.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv095</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The implementation can enable, disable or clear wake up events from the last
        communication cycle. It is very important not to lose wake up events
        during the disabled period. (BSW00388, BSW00389, BSW00390, BSW00391,
        BSW00392, BSW00393, BSW00394, BSW00395, BSW00408, BSW160, BSW01090)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_ENABLE</srcid><srcstatus/><internalId>328</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_DISABLE</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SET_WAKEUP_MODE_CLEAR</srcid><srcstatus/><internalId>330</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv127</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv has been initialized, the function
        CanTrcv_SetWakeupMode shall raise development error CANTRCV_E_UNINIT and
        return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv131</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called with
        an invalid Transceiver number, the function CanTrcv_SetWakeupMode shall
        raise development error CANTRCV_E_INVALID_TRANSCEIVER and return
        E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv089</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called with
        an invalid TrcvWakeupMode, the function CanTrcv_SetWakeupMode shall raise
        the development error CANTRCV_E_PARAM_TRCV_WAKEUP_MODE and return
        E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_MODE</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv143</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_CheckWakeup
        Syntax: Std_ReturnType CanTrcv_CheckWakeup( uint8 Transceiver  )
        Service ID[hex]: 0x07
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): Transceiver CAN transceiver to which API call has to be applied.
        Parameters (in- out): None
        Parameters (out): None
        Return value: Std_ReturnType E_OK when a valid interrupt is detected
                                     E_NOT_OK when a no interrupt is detected
        Description: Service is called by underlying CANIF in case a wake up
                     interrupt is detected.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_MODE_API_DISABLED</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_PRIORITY</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv144</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_CheckWakeup shall raise the development error CANTRCV_E_UNINIT
        and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv145</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called with
        an invalid Transceiver number, the function CanTrcv_CheckWakeup shall
        raise the development error CANTRCV_E_INVALID_TRANSCEIVER and return
        E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv146</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        This function notifies the calling function if a wakeup is detected in the
        Transceiver by returning E_OK else returns E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_WAKEUP_PRIORITY</srcid><srcstatus/><internalId>315</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_WAKEUP_REASON_BUS_PIN</srcid><srcstatus/><internalId>331</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv013</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_MainFunction
        Syntax: void CanTrcv_MainFunction(  void  )
        Service ID[hex]: 0x06
        Timing: FIXED_CYCLIC
        Description: Service to scan all busses for wake up events and perform these event.
      </description>
         <comment>
        MainFunction is not implemented as function.
        Rationale:
        MainFunction is not necessary for a correct implementation regarding to AUTOSAR 4.0.
        The complete polling mechanism is implemented in CanTrcv_1_T01_CheckWakeup (if
        notification via CanTrcv_1_T01_WakeupByBusNotification is disabled).
        Therefore MainFunction is implemented as an empty function like macro.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunction</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv112</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The CanTrcv_MainFunction shall scan all busses in STANDBY and SLEEP for wake up
        events. This function shall set a wake-up event flag to perform these
        events.
      </description>
         <comment>
        MainFunction is not implemented as function.
        Rationale:
        MainFunction is not necessary for a correct implementation regarding to AUTOSAR 4.0.
        The complete polling mechanism is implemented in CanTrcv_1_T01_CheckWakeup (if
        notification via CanTrcv_1_T01_WakeupByBusNotification is disabled).
        Therefore MainFunction is implemented as an empty function like macro.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunction</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv128</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv has been initialized, the function
        CanTrcv_MainFunction shall raise development error CANTRCV_E_UNINIT.
      </description>
         <comment>
        Violated AUTOSAR 4.0 general requirement BSW00450 (AUTOSAR_SRS_BSWGeneral):
        Description:
        If a Main function of a un-initialized module is called from the BSW Scheduler,
        then it shall return immediately without performing any functionality and without
        raising any errors.
        Rationale:
        Main Function processing of an un-initialized Module may result in undesired
        and non defined behaviour.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunction</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv050</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv218</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_MainFunctionDiagnostics
        Syntax: void CanTrcv_MainFunctionDiagnostics( void )
        Service ID[hex]: 0x08
        Timing: FIXED_CYCLIC
        Description: Reads the transceiver diagnostic status periodically and sets
                     product/development accordingly.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv204</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The cyclic function CanTrcv_MainFunctionDiagnostics shall read the transceiver
        status periodically and report production/development errors accordingly.
      </description>
         <comment>
        CanTrcv does not support Dem.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunctionDiagnostics</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv205</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The cyclic function CanTrcv_MainFunctionDiagnostics shall exist only if
        CanTrcvBusErrFlag = TRUE.
      </description>
         <comment>
        CanTrcv_MainFunctionDiagnostics not implemented.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunctionDiagnostics</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv206</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If configured and supported by hardware: if the BUSERR flag is set, function
        CanTrcv_MainFunctionDiagnostics shall set the production error
        CANTRCV_E_BUS_ERROR.
      </description>
         <comment>
        CanTrcv does not support Dem.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunctionDiagnostics</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv207</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET for the module CanTrcv is enabled: If called before the CanTrcv has been
        initialized, the function CanTrcv_MainFunctionDiagnostics shall raise
        development error CANTRCV_E_UNINIT.
      </description>
         <comment>
        Violated AUTOSAR 4.0 general requirement BSW00450 (AUTOSAR_SRS_BSWGeneral):
        Description:
        If a Main function of a un-initialized module is called from the BSW Scheduler,
        then it shall return immediately without performing any functionality and without
        raising any errors.
        Rationale:
        Main Function processing of an un-initialized Module may result in undesired
        and non defined behaviour.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunctionDiagnostics</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv085</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        API function CanIf_TrcvModeIndication
        Description: This service indicates a transceiver state transition
        referring to the cor responding CAN transceiver. Dem_ReportErrorStatus
        Queues the reported events from the BSW modules (API is only used  by BSW modules).
        The interface has an asynchronous behavior, be cause the processing of the event is done
        within the Dem main function.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Just a summary of used interface.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv086</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        API function                        Description
        CanIf_CheckTrcvWakeFlagIndication   This service indicates the reason for
                                            the wake up that the CAN  transceiver has
                                            detected.
        CanIf_ClearTrcvWufFlagIndication    This service indicates that the transceiver
                                            has cleared the Wuf Flag.
        CanIf_ConfirmPnAvailability         This service indicates that the transceiver
                                            is running in PN com munication mode.
        Det_ReportError                     Service to report development errors.
        Dio_ReadChannel                     Returns the value of the specified DIO channel.
        Dio_ReadChannelGroup                This Service reads a subset of the adjoining
                                            bits of a port.
        Dio_ReadPort                        Returns the level of all channels of that port.
        Dio_WriteChannel                    Service to set a level of a channel.
        Dio_WriteChannelGroup               Service to set a subset of the adjoining bits
                                            of a port to a speci fied level.
        Dio_WritePort                       Service to set a value of the port.
        Icu_DisableNotification             This function disables the notification of
                                            a channel.
        Icu_EnableNotification              This function enables the notification on the
                                            given channel.
        Spi_GetStatus                       Service returns the SPI Handler/Driver software
                                            module status.
        Spi_ReadIB                          Service for reading synchronously one or more
                                            data from an IB  SPI Handler/Driver Channel
                                            specified by parameter.
        Spi_SetupEB                         Service to setup the buffers and the length of
                                            data for the EB SPI  Handler/Driver Channel
                                            specified.
        Spi_SyncTransmit                    Service to transmit data on the SPI bus
        Spi_WriteIB                         Service for writing one or more data to an
                                            IB SPI Handler/Driver  Channel specified by
                                            parameter.
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        Just a summary of possibly used interface.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv017</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Only Pre-compile time configuration is allowed. Thus only VARIANTPRE-COMPILE is
        allowed.
      </description>
         <comment>
        Link-time configuration is also supported. Link-time configuration also supports the
        features of pre-compile time configuration.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.PBsupport</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv169</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The standardized common published parameters as required by BSW00402 in the
        General Requirements on Basic Software Modules (see ch. 3) shall be
        published within the header file of this module and need to be provided
        in the BSW Module Description. The according module abbreviation can be
        found in the List of Basic Software Modules (see ch. 3). (BSW00402)
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is not a requirement for the Can transceiver driver itself.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv999</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        These requirements are not applicable to this specification.
        (BSW00304, BSW00305, BSW00306, BSW00307, BSW00308, BSW00309, BSW00312,
        BSW00321, BSW00325, BSW00326, BSW00328, BSW00330, BSW00331, BSW00333,
        BSW00334, BSW00335, BSW00336, BSW00341, BSW00342, BSW00344, BSW00355,
        BSW00359, BSW00360, BSW00378, BSW00383, BSW00384, BSW00387, BSW00398,
        BSW00399, BSW00400, BSW00401, BSW00404, BSW00405, BSW00410, BSW00416,
        BSW00417, BSW00420, BSW00422, BSW00423, BSW00426, BSW00427, BSW00429,
        BSW00431, BSW00432, BSW00433, BSW00434, BSW005, BSW006, BSW007, BSW009,
        BSW010, BSW161, BSW164, BSW168, BSW01107, BSW01138)
      </description>
         <comment>
        This requirement is informational only.
        Rationale:
        This is not a requirement for the Can transceiver driver itself.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv171</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv driver shall use the following APIs provided by ICU driver, to enable
        and disable the wakeup event notification:
        - Icu_EnableNotification
        - Icu_DisableNotification
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ICU_NOTIFICATION</srcid><srcstatus/><internalId>344</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv172</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        It shall enable the ICU channels when the transceiver transitions to the Standby
        mode (CANTRCV_STANDBY).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ICU_NOTIFICATION</srcid><srcstatus/><internalId>344</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv172.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        CanTrcv shall call Icu_EnableEdgeDetection() of the associated ICU channel if the
        transceiver is switched to the Standby mode (CANTRCV_STANDBY).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ICU_NOTIFICATION</srcid><srcstatus/><internalId>344</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv173</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        It shall disable the ICU channels when the transceiver transitions to the Normal
        mode (CANTRCV_NORMAL).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ICU_NOTIFICATION</srcid><srcstatus/><internalId>344</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv173.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        CanTrcv shall call Icu_DisableEdgeDetection() of the associated ICU channel if the
        transceiver is switched to the Normal mode (CANTRCV_NORMAL).
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ICU_NOTIFICATION</srcid><srcstatus/><internalId>344</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv178</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If the transceiver has the ability to identify bus failures (and distinguish
        between bus failures and other hardware failures), it shall be indicated
        using the configuration parameter CanTrcvBusErrFlag for bus diagnostic
        purposes.
      </description>
         <comment>
        Bus failures are polled by function CanTrcv_MainFunctionDiagnostics.
        CanTrcv_MainFunctionDiagnostics is not implemented, therefore CanTrcvBusErrFlag
        is not used.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunctionDiagnostics</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv213</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_GetTrcvSystemData
        Syntax: Std_ReturnType CanTrcv_GetTrcvSystemData(  uint8 Transceiver,
                                                      const uint32* TrcvSysData )
        Service ID[hex]: 0x09
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): Transceiver CAN transceiver ID.
        Parameters (in- out): None
        Parameters (out): TrcvSysData Configuration/Status data of the transceiver.
        Return value: Std_ReturnType E_OK: will be returned if the transceiver status
                                           is successfully read.
                                     E_NOT_OK: will be returned if the transceiver
                                               status data is not available or a
                                               development error occurs.
        Description: Reads the transceiver configuration/status data and returns it
                     through parameter TrcvSysData. This API shall exist only if
                     CanTrcvHwPnSupport = TRUE.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_ENABLE</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_GETTRCVSYSTEMDATA</srcid><srcstatus/><internalId>302</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv191</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled for the CanTrcv module: if called before the CanTrcv has been
        initialized, the function CanTrcv_GetTrcvSystemData shall raise
        development error CANTRCV_E_UNINIT and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv192</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled for the CanTrcv module: if called with an invalid transceiver
        ID for parameter Transceiver, function CanTrcv_GetTrcvSystemData shall
        raise the development error CANTRCV_E_INVALID_TRANSCEIVER and return
        E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv193</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled for the CanTrcv module: if called with NULL pointer for
        parameter TrcvSysData, function CanTrcv_GetTrcvSystemData shall raise the
        development error CANTRCV_E_PARAM_POINTER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv214</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_ClearTrcvWufFlag
        Syntax: Std_ReturnType CanTrcv_ClearTrcvWufFlag(  uint8 Transceiver  )
        Service ID[hex]: 0x0a
        Sync/Async: Synchronous
        Reentrancy: Reentrant for different transceivers
        Parameters (in): Transceiver CAN Transceiver ID.
        Parameters (in- out): None
        Parameters (out): None
        Return value: Std_ReturnType E_OK: will be returned if the WUF flag has
                                           been cleared.
                                     E_NOT_OK: will be returned if the WUF flag has
                                               not been  cleared or a development
                                               error occurs.
        Description: Clears the WUF flag in the transceiver hardware. This API
                     shall exist only if CanTrcvHwPnSupport = TRUE.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_ENABLE</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_CLEAR_WAKEUP_FLAG</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv197</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled for the CanTrcv module: if called before the CanTrcv has been
        initialized, the function CanTrcv_ClearTrcvWufFlag shall raise
        development error CANTRCV_E_UNINIT and return E_NOT_OK
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv198</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled for the CanTrcv module: if called with an invalid transceiver
        ID for parameter Transceiver, function CanTrcv_ClearTrcvWufFlag shall
        raise the development error CANTRCV_E_INVALID_TRANSCEIVER and return
        E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv215</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_ReadTrcvTimeoutFlag
        Syntax: Std_ReturnType CanTrcv_ReadTrcvTimeoutFlag(  uint8 Transceiver,
                                        CanTrcv_TrcvFlagStateType* FlagState  )
        Service ID[hex]: 0x0b
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): Transceiver CAN transceiver ID.
        Parameters (in- out): None
        Parameters (out): FlagState State of the timeout flag.
        Return value: Std_ReturnType E_OK: Will be returned, if status of the timeout flag
                                           is success fully read.
                                     E_NOT_OK: Will be returned, if status of the
                                               timeout flag could not be read.
        Description: Reads the status of the timeout flag from the transceiver hardware.
                     This API shall  exist only if CanTrcvHwPnSupport = TRUE.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_READ_TIMEOUT_FLAG</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_ENABLE</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_TIMEOUT_DETECT_OFF</srcid><srcstatus/><internalId>319</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv199</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET for the module CanTrcv is enabled: If called with an invalid transceiver
        ID Transceiver, the function CanTrcv_ReadTrcvTimeoutFlag shall raise the
        development error CANTRCV_E_INVALID_TRANSCEIVER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv200</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET for the module CanTrcv is enabled: If called with FlagState = NULL, the
        function CanTrcv_ReadTrcvTimeoutFlag shall raise the development error
        CANTRCV_E_PARAM_POINTER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv216</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_ClearTrcvTimeoutFlag
        Syntax: Std_ReturnType CanTrcv_ClearTrcvTimeoutFlag( uint8 Transceiver )
        Service ID[hex]: 0x0c
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): Transceiver CAN transceiver ID.
        Parameters (in- out): None
        Parameters (out): None
        Return value: Std_ReturnType E_OK: Will be returned, if the timeout flag
                                           is successfully cleared.
                                     E_NOT_OK: Will be returned, if the timeout flag
                                               could not be cleared.
        Description: Clears the status of the timeout flag in the transceiver hardware.
                     This API shall  exist only if CanTrcvHwPnSupport = TRUE.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_ENABLE</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_CLEAR_TIMEOUT_FLAG</srcid><srcstatus/><internalId>320</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv201</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET for the module CanTrcv is enabled: If called with an invalid transceiver
        ID Transceiver, the function CanTrcv_ClearTrcvTimeoutFlag shall raise the
        development error CANTRCV_E_INVALID_TRANSCEIVER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv217</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_ReadTrcvSilenceFlag
        Syntax: Std_ReturnType CanTrcv_ReadTrcvSilenceFlag(  uint8 Transceiver,
                                        CanTrcv_TrcvFlagStateType* FlagState  )
        Service ID[hex]: 0x0d
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): Transceiver CAN transceiver ID.
        Parameters (in- out): None
        Parameters (out): FlagState State of the silence flag.
        Return value: Std_ReturnType E_OK: Will be returned, if status of the
                                           silence flag is success fully read.
                                     E_NOT_OK: Will be returned, if status of the
                                               silence flag could not be read.
        Description: Reads the status of the silence flag from the transceiver hardware.
                     This API shall  exist only if CanTrcvHwPnSupport = TRUE.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_READ_SILENCE_FLAG</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SILENCE_DETECT_OFF</srcid><srcstatus/><internalId>261</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_ENABLE</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv202</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET for the module CanTrcv is enabled: If called with an invalid transceiver
        ID Transceiver, the function CanTrcv_ReadTrcvSilenceFlag shall raise the
        development error CANTRCV_E_INVALID_TRANSCEIVER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv203</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET for the module CanTrcv is enabled: If called with FlagState = NULL, the
        function CanTrcv_ReadTrcvSilenceFlag shall raise the development error
        CANTRCV_E_PARAM_POINTER and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_PARAM_POINTER</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv219</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_SetPNActivationState
        Syntax: Std_ReturnType CanTrcv_SetPNActivationState(
                    CanTrcv_PNActivationType ActivationState )
        Service ID[hex]: 0x0f
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): ActivationState PN_ENABLED: PN wakeup functionality in CanTrcv
                                                     shall be enabled.
                                         PN_DIABLED: PN wakeup functionality in CanTrcv
                                                     shall be disabled.
        Parameters (in- out): None
        Parameters (out): None
        Return value: Std_ReturnType E_OK: Will be returned, if the PN has been changed to
                                           the  requested configuration.
                                     E_NOT_OK: Will be returned, if the PN configuration
                                               change has failed. The previous configuration
                                               has not been changed.
        Description: The API configures the wake-up of the transceiver for Standby and Sleep Mode:
        Either the CAN transceiver is woken up by a remote wake-up pattern (standard CAN
        wake-up) or by the configured remote wake-up frame.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_ENABLE</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DISABLE_PN_STATE</srcid><srcstatus/><internalId>316</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv220</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If development error detection for the module CanTrcv is enabled: If called
        before the CanTrcv module has been initialized, the function
        CanTrcv_SetPNActivationState shall raise the development error
        CANTRCV_E_UNINIT and return E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_UNINIT</srcid><srcstatus/><internalId>285</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv223</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Service name: CanTrcv_CheckWakeFlag
        Syntax: Std_ReturnType CanTrcv_CheckWakeFlag( uint8 Transceiver )
        Service ID[hex]: 0x0e
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): Transceiver CAN transceiver ID.
        Parameters (in-out): None
        Parameters (out): None
        Return value: Std_ReturnType E_OK: Will be returned, if the request for
                                           checking the wakeup flag has been accepted.
                                     E_NOT_OK: Will be returned, if the request for
                                     checking the wakeup flag has not been accepted.
        Description: Requests to check the status of the wakeup flag from the transceiver
                     hardware.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_API_ENABLE</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_CHECK_WAKEUP_FLAG</srcid><srcstatus/><internalId>301</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv225</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET for the module CanTrcv is enabled: If called with an invalid
        transceiver ID Transceiver, the function CanTrcv_CheckWakeFlag shall
        raise the development error CANTRCV_E_INVALID_TRANSCEIVER and return
        E_NOT_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DET_INVALID_CAN_NETWORK</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv175</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The configuration container for selective wakeup functionality
        (CanTrcvPartialNetwork) and for the following APIs:
        - 8.4.7 CanTrcv_GetTrcvSystemData,
        - 8.4.8 CanTrcv_ClearTrcvWufFlag,
        - 8.4.9 CanTrcv_ReadTrcvTimeoutFlag,
        - 8.4.10 CanTrcv_ClearTrcvTimeoutFlag and
        - 8.4.11 CanTrcv_ReadTrcvSilenceFlag
        shall exist only if  CanTrcvHwPnSupport = TRUE.
      </description>
         <comment>
        This requirement is not applicable.
        This requirement is not complete and replaced by CanTrcv.ASR40.CanTrcv175.1.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv175.1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The configuration container for selective wakeup functionality (Can-TrcvPartialNetwork)
        and for the following APIs:
        - 8.3.7 CanTrcv_GetTrcvSystemData,
        - 8.3.8 CanTrcv_ClearTrcvWufFlag,
        - 8.3.9 CanTrcv_ReadTrcvTimeoutFlag,
        - 8.3.10 CanTrcv_ClearTrcvTimeoutFlag and
        - 8.3.11 CanTrcv_ReadTrcvSilenceFlag
        - 8.3.13 CanTrcv_SetPNActivationState
        - 8.3.14 CanTrcv_CheckWakeFlag
        shall exist only if CanTrcvHwPnSupport = TRUE.
      </description>
         <comment>
        Rationale: In additon to the API services stated in the CanTrcv SWS, the API
        services CanTrcv_SetPNActivationState and CanTrcv_CheckWakeFlag handles also
        partial networking functionality only.
        This requirement replaces CanTrcv.ASR40.CanTrcv175.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_API_DISABLE</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_ALL_APIS_DISABLED</srcid><srcstatus/><internalId>281</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv090_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Container Name: CanTrcvGeneral
        Description: Container gives CAN transceiver driver
                     basic information. Configuration Parameters
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv152_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvDevErrorDetect {CANTRCV_DEV_ERROR_DETECT}
        Description Switches development error detection and notification on
                    and off. If  switched on, #define CANTRCV_DEV _ERROR_DETECT ON
                    shall be  generated. If switched off, #define CANTRCV_DEV_ERROR _DETECT
                    OFF shall be generated. Define shall be part of file CanTrcv_Cfg.h.
        Multiplicity 1
        Type EcucBooleanParamDef Default
        Default value -
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Module
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ALL_APIS_DISABLED</srcid><srcstatus/><internalId>281</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv153_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvGetVersionInfo {CANTRCV_GET_VERSION_INFO}
        Description Switches version information API on and off. If switched off,
                    function  need not be present in compiled code.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Module
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ALL_APIS_DISABLED</srcid><srcstatus/><internalId>281</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv154_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvWakeUpSupport {CANTRCV_GENERAL_WAKE_UP_SUPPORT}
        Description Informs whether wake up is supported by polling or not supported.
                    In case no wake up is supported by the hardware, setting has to be
                    NOT_SUPPORTED. Only in the case of wake up supported by polling,
                    function CanTrcv_MainFunction has to be present and to be invoked
                    by the scheduler.
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range CANTRCV_WAKEUP_BY_POLLING Wake up by polling
              CANTRCV_WAKEUP_NOT_SUPPORTED Wake up is not supported
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope /Dependency scope: Module
                          dependency: CanTrcvWakeupByBusUsed
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CANTRCV_T03_REGRESSIONTEST_INFIX</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_OFF_WUP_POLLING</srcid><srcstatus/><internalId>278</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_DET_ON_WUP_DISABLE</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv143_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Container Name CanTrcvChannel{CanTranceiverChannels}
        Description Container gives CAN transceiver driver information about a single
        CAN transceiver (channel).
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv155_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvChannelId {CANTRCV_CHANNEL_ID}
        Description Unique identifier of the CAN Transceiver Channel.
        Multiplicity 1
        Type EcucIntegerParamDef (Symbolic Name generated for this parameter)
        Range 0...255
        Default value -
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: ECU
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_SYMBOLIC_NAME_VALUES</srcid><srcstatus/><internalId>283</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_T03_SYMBOLIC_NAME_VALUES_1</srcid><srcstatus/><internalId>284</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_SPI_SEQ_REF</srcid><srcstatus/><internalId>345</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv096_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvChannelUsed {CANTRCV_CHANNEL_USED}
        Description Shall the related CAN transceiver channel be used?
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value true
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Instance
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv097_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvControlsPowerSupply  {CANTRCV_CONTROLS_POWER_SUPPLY}
        Description Is ECU power supply controlled by this transceiver?
                    TRUE = Controlled  by transceiver.
                    FALSE = Not controlled by transceiver.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Instance
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv146_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvInitState {CANTRCV_INIT_STATE}
        Description State of CAN transceiver after call to CanTrcv_Init.
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range CANTRCV_OP_MODE_NORMAL Normal operation mode  (default)
              CANTRCV_OP_MODE_SLEEP Sleep operation mode
              CANTRCV_OP_MODE_STANDBY Standby operation mode
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Instance
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv147_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvMaxBaudrate {CANTRCV_MAX_BAUDRATE}
        Description Max baudrate for transceiver hardware type. Only used for
                    validation purposes. Value shall be configured by
                    configuration tool based on transceiver
        hardware type.
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0 ... 1000
        Default value -
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Instance
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv148_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvWakeupByBusUsed {CANTRCV_WAKEUP_BY_BUS_USED}
        Description Is wake up by bus supported? If CAN transceiver hardware
                    does not support wake up by bus value is always FALSE.
                    If CAN transceiver hardware supports wake up by bus value
                    is TRUE or FALSE depending  whether it is used or not.
                    TRUE = Is used. FALSE = Is not used.
        Multiplicity 0..1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Instance
                           dependency: CanTrcvWakeUpSupport
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_WAKEUPBYBUS_USED</srcid><srcstatus/><internalId>308</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv177_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvWakeupSourceRef {CANTRCV_WAKEUP_SOURCE_REF}
        Description Reference to a wakeup source in the EcuM configuration.
                    This reference is  only needed if CanTrcvWakeupByBusUsed
                    is true.
        Multiplicity 0..1
        Type Reference to [EcuMWakeupSource ]
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: ECU
                           dependency: CanTrcvWakeupByBusUsed
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv101_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Choice container Name CanTrcvAccess
        Container gives CanTrcv Driver information about access to a single
        CAN Description transceiver.
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv144_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Container Name CanTrcvSpiSequence{CanTransceiverSPISequences}
        Description Container gives CAN transceiver driver information about one
                    SPI sequence. One SPI sequence used by CAN transceiver
                    driver is in exclusive use for it.
                    No other driver is allowed to access this sequence.
                    CAN transceiver driver may use one sequence to access n CAN
                    transceiver hardwares chips of the  same type or n sequences
                    are used to access one single CAN transceiver hardware chip.
                    If a CAN transceiver hardware has no SPI interface, there is no
                    instance of this container.
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

      <specobject>
         <id>CanTrcv.EB.CanIfTrcvId</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanTrcv shall use the abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        in the CanIf configuration for all callback API functions done to CanIf.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_CANIFTRCVID_OPMODE</srcid><srcstatus/><internalId>293</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_CANIFTRCVID_CLEARWUF</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_CANIFTRCVID_CHECKWUF</srcid><srcstatus/><internalId>295</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv181</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If selective wakeup is enabled and supported by hardware: POR and
        SYSERR flags of the transceiver status shall be checked by CanTrcv_Init API.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.RegisterInitialization</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv182</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If the POR flag or SYSERR flag is set, transceiver shall be reconfigured for
        selective wakeup functionality by running the configuration sequence.
        If the POR flag or SYSERR flag is not set, the configuration stored in
        the transceiver memory will be still valid and re-configuration is not necessary.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.RegisterInitialization</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv183</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If the POR flag is set, wakeup shall be reported to EcuM through API
        EcuM_SetWakeupEvent with CANIF_TRCV_WU_POWERON as the wakeup reason.
      </description>
         <comment>
        ...in function CanTrcv_Init
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.PowerUpWakeup</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv184</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If the SYSERR flag is set, wakeup shall be reported to EcuM through API
        EcuM_SetWakeupEvent with CANIF_TRCV_WU_BY_SYSERR as the wakeup reason.
      </description>
         <comment>
        ...in function CanTrcv_Init
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_CAN_TRCV_INIT_SYSERR_FLAG</srcid><srcstatus/><internalId>313</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv186</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If selective wakeup is supported by hardware: the flags POR and SYSERR of the
        transceiver status shall be checked by CanTrcv_SetOpMode API.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.RegisterInitialization</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv187</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If the POR flag is set, transceiver shall be re-initialized to run the
        transceiver's configuration sequence.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.RegisterInitialization</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv188</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>2</version>
         <description>
        If the SYSERR flag is NOT set and the requested mode is CANTRCV_NORMAL,
        transceiver shall call the API CanIf_ConfirmPnAvailability() for the
        corresponding TransceiverId.
      </description>
         <comment>
          Changed to: If partial networking is enabled for this transceiver and the requested mode 
          when calling CanTrcv_SetOpMode() is CANTRCV_NORMAL, then the driver shall call the API 
          CanIf_ConfirmPnAvailability() for the corresponding TransceiverId.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PNCONFIRM</srcid><srcstatus/><internalId>314</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv189</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_GetTrcvSystemData shall read the configuration/status of
        the CAN transceiver and store the read data in the out parameter
        TrcvSysData. If this is successful, E_OK shall be returned.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.GetTrcvSystemData</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv194</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        The function CanTrcv_ClearTrcvWufFlag shall clear the wakeup flag in the CAN
        transceiver. If successful, E_OK shall be returned.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_CLEAR_WAKEUP_FLAG</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv194.1</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
         CanTrcv_ClearTrcvWufFlag: The CAN transceiver shall be put into
         Standby mode ( CANTRCV_STANDBY ) after clearing of the WUF flag.
      </description>
         <comment>
        This requirement is not applicable.
        Rational:
        During a transition to 'NO COMMUNICATION' the CanSM requests a transition
        towards CANTRCV_TRCVMODE_NORMAL.
        An interim transition to CANTRCV_TRCVMODE_STANDBY makes no sense.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv195</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv shall inform CanIf that the wakeup flag has been cleared for the
        requested Transceiver, through the callback notification
        CanIf_ClearTrcvWufFlagIndication.
      </description>
         <comment>
        ...in function CanTrcv_ClearTrcvWufFlag
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_CLEAR_WAKEUP_FLAG</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv168</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If DET is enabled for CanTrcv module: the function CanTrcv_Init shall raise
        the development error CANTRCV_E_BAUDRATE_NOT_SUPPORTED, if the configured
        baud rate is not supported by the transceiver.
      </description>
         <comment>
        This requirement is not applicable.
        CanTrcv configuration allows only baud rates supported by the transceiver
        device.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv221</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv shall enable the PN wakeup functionality when function
        CanTrcv_SetPNActivationState is called with ActivationState= PN_ENABLED
        and return E_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_ENABLE_PN_STATE</srcid><srcstatus/><internalId>317</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv222</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv shall disable the PN wakeup functionality when function
        CanTrcv_SetPNActivationState is called with ActivationState= PN_DISABLED
        and return E_OK.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_DISABLE_PN_STATE</srcid><srcstatus/><internalId>316</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv224</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv shall inform CanIf that a wakeup has been detected in the
        requested Transceiver, through the callback notification
        CanIf_CheckTrcvWakeFlagIndication.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.CanSMIncompatibilty</srcid><srcstatus/><internalId>244</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv224.1</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If the request for checking the wakeup flags has been successfully completed
        then CanTrcv shall inform CanIf through the callback notification
        CanIf_CheckTrcvWakeFlagIndication even if no wakeup was detected.
      </description>
         <comment>
        This requirement replaces CanTrcv.ASR40.CanTrcv224.
        Rational:
        CanSM expects an indication after checking the wakeup flags.
        If there is no indication CanSM restarts the DeInit state machine.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_CHECK_WAKEUP_FLAG</srcid><srcstatus/><internalId>301</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv224.2</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        CanTrcv shall inform EcuM that a wakeup has been detected in the
        requested Transceiver, through the callback notification
        EcuM_SetWakeupEvent.
      </description>
         <comment>
        This requirement replaces CanTrcv.ASR40.CanTrcv224.
        Rational:
        A detected wakeup event is always reported to EcuM.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_CHECK_WAKEUP_FLAG</srcid><srcstatus/><internalId>301</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv174</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If selective wakeup is supported by the transceiver hardware, it shall be
        indicated with the configuration parameter CanTrcvHwPnSupport.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.EB.PnSupport</srcid><srcstatus/><internalId>38</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv172_Conf</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv177</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        If selective wakeup is supported, CAN transceivers shall be configured to wake
        up on a particular CAN frame or a group of CAN frames using the
        parameters CanTrcvPnFrameCanId, CanTrcvPnFrameCanIdMask and
        CanTrcvPnFrameDataMask.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv163_Conf</srcid><srcstatus/><internalId>210</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv162_Conf</srcid><srcstatus/><internalId>211</internalId></linkedfrom><linkedfrom><srcid>CanTrcv.ASR40.CanTrcv166_Conf</srcid><srcstatus/><internalId>214</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv160_Conf</id>
         <status>rejected</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvHwPnSupport {CANTRCV_HW_PN_SUPPORT}
        Description Indicates whether the HW supports the selective wake-up function
                    TRUE =  Selective wakeup feature is supported by the transceiver
                    FALSE = Selective wakeup functionality is not available in
                            transceiver
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X All Variants
          Link time -
          Post-build time -
        Scope / Dependency scope: Local
                           dependency: CanTrcvWakeUpSupport
      </description>
         <comment>
        This requirement is not applicable.
        This requirement is replaced by CanTrcv.EB.PnSupport.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv161_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Container Name CanTrcvPartialNetwork
        Description Container gives CAN transceiver driver information about the
                    configuration of Partial Networking functionality.
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv169_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvBaudRate {CANTRCV_BAUD_RATE}
        Description Indicates the CAN Bus communication baud rate in kbps.
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...1000
        Default value -
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
                           dependency: Although WUF with DLC=0 is technically
                                       possible, it is explic itly not wanted.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv164_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvPnCanIdIsExtended {CANTRCV_PN_CAN_ID_IS_EXTENDED}
        Description Indicates whether extended or standard ID is used.
                    TRUE = Extended Can identifier is used.
                    FALSE = Standard Can identifier is used
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE_2</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv172_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvPnEnabled {CANTRCV_PN_ENABLED}
        Description Indicates whether the selective wake-up function
                    is enabled or disabled in  HW.
                    TRUE = Selective wakeup feature is enabled in
                    the transceiver hardware
                    FALSE = Selective wakeup feature is disabled in
                    the transceiver hardware
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_PN_ENABLED_INIT</srcid><srcstatus/><internalId>304</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_ENABLED_SETOPMODE</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_ENABLED_CLEARFLAG</srcid><srcstatus/><internalId>306</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_ENABLED_READFLAG</srcid><srcstatus/><internalId>307</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_ENABLED_CLEARTRCVTIMEOUT</srcid><srcstatus/><internalId>309</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_ENABLED_READSILENCEFLAG</srcid><srcstatus/><internalId>310</internalId></linkedfrom><linkedfrom><srcid>EB_CANTRCV_PN_ENABLED_CHECKWAKEFLAG</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv174</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>203</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv163_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvPnFrameCanId {CANTRCV_PN_FRAME_CAN_ID}
        Description CAN ID of the Wake-up Frame (WUF).
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...4294967295
        Default value -
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE_2</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv177</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv162_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvPnFrameCanIdMask {CANTRCV_PN_FRAME_CAN_ID_MASK}
        Description ID Mask for the selective activation of the transceiver.
                    It is used to enable Frame Wake-up (WUF) on a group of
                    IDs.
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...4294967295
        Default value -
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE_2</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv177</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv168_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvPnFrameDlc {CANTRCV_PN_FRAME_DLC}
        Description Data Length of the Wake-up Frame (WUF).
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...8
        Default value -
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE_2</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv165_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Container Name CanTrcvPnFrameDataMaskSpec{CANTRCV_PN_FRAME_DATA_MASK_SPEC}
        Description Defines data payload mask to be used on the received
                    payload in order to determine if the transceiver must
                    be woken up by the received Wake-up Frame (WUF).
      </description>
         <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv166_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvPnFrameDataMask {CANTRCV_PN_FRAME_DATA_MASK}
        Description Defines the n byte (Byte0 = LSB) of the data
                    payload mask to be used on the received payload
                    in order to determine if the transceiver must
                    be  woken up by the received Wake-up Frame (WUF).
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...255
        Default value -
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE_2</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv177</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv167_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvPnFrameDataMaskIndex  {CANTRCV_PN_FRAME_DATA_MASK_INDEX}
        Description holds the position n in frame of the mask-part
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0...7
        Default value -
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_INIT_SEQUENCE_2</srcid><srcstatus/><internalId>299</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv171_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvBusErrFlag {CANTRCV_BUS_ERR_FLAG}
        Description Indicates if the Bus Error (BUSERR) flag is managed by the BSW.
                    This  flag is set if a bus failure is detected by the
                    transceiver.
                    TRUE = Supported  by transceiver and managed by BSW.
                    FALSE = Not managed by BSW.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.MainFunctionDiagnostics</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>

      <specobject>
         <id>CanTrcv.ASR40.CanTrcv170_Conf</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANTransceiverDriver.pdf, V3.0.0</source>
         <version>1</version>
         <description>
        Name CanTrcvPowerOnFlag {CANTRCV_POWER_ON_FLAG}
        Description Indicates if the Power On Reset (POR) flag is
                    available and is  managed by the transceiver.
                    TRUE = Supported by Hardware.
                    FALSE =  Not supported
        by Hardware
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time -
          Post-build time X VARIANT-POST-BUILD
        Scope / Dependency scope: Local
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanTrcv.PowerUpWakeup</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">

      <specobject>
         <id>CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvTimeoutFlag</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication towards the transceiver, the
        function CanTrcv_ReadTrcvTimeoutFlag shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL .
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_LOOP_SPI_FAILURE_2</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvSilenceFlag</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication towards the transceiver, the
        function CanTrcv_ReadTrcvSilenceFlag shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL .
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_LOOP_SPI_FAILURE_2</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.E_NO_TRCV_CONTROL.SetPNActivationState</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication towards the transceiver, the
        function CanTrcv_SetPNActivationState shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL .
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_LOOP_SPI_FAILURE_2</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>

      <specobject>
         <id>CanTrcv.EB.E_NO_TRCV_CONTROL.CheckWakeup</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If there is no/incorrect communication towards the transceiver, the
        function CanTrcv_SetWakeup shall report the development error
        CANTRCV_E_NO_TRCV_CONTROL .
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>EB_CANTRCV_T03_LOOP_SPI_FAILURE_2</srcid><srcstatus/><internalId>334</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv048</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
            <provcov>
               <linksto>CanTrcv.ASR40.CanTrcv040</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanTrcv_1_T03.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTrcv_1_T03_DBGINST_001</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTrcv_1_T03_DBGINST_001</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTrcv_1_T03_DBGINST_001</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTrcv_1_T03_DBGINST_001</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanTrcv_1_T03_DBGINST_001</srcid><srcstatus/><internalId>253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM101</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: CanTrcv_1_T03_IsValidConfig
        Syntax: Std_ReturnType CanTrcv_1_T03_IsValidConfig( void* ConfigPtr )
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): ConfigPtr, post build configuration manager
        configuration.
        Parameters (inout): None
        Parameters (out): None
        Return value: Returns E_OK if the CanTrcv_1_T03 configuration is valid otherwise E_NOT_OK. A
        null pointer is interpreted as invalid configuration.
        Description: This function determines if the CanTrcv_1_T03 configuration is valid. This
        function can be called also before the CanTrcv_1_T03 is initialized. No error reporting
        is necessary within this function.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_IsValidConfig</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM102</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A configuration is valid
        - if the platform signature in the post build configuration equals the value
          determined by the macro TS_PlatformSigIsValid.
        - if the link time signature in the post build configuration equals the link time
          signature in the link time configuration file.
        - if the compile time signature in the post build configuration equals the value of
          the macro CANTRCV_1_T03_CFG_SIGNATURE.
        - if the compile time signature of Published information in the post build configuration
          equals the value of the macro CANTRCV_1_T03_PUBLIC_INFO_SIGNATURE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_IsValidConfig</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM104</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          CfgSignature.
        - the CanTrcv_1_T03_Cfg.h file shall contain the macro
          CANTRCV_1_T03_CFG_SIGNATURE.
        - the MCG shall generate this signature value of compile time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of compile time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_IsValidConfig</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM104_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          PublicInfoSignature.
        - the CanTrcv_1_T03_Cfg.h file shall contain the macro
          CANTRCV_1_T03_PUBLIC_INFO_SIGNATURE.
        - The MCG shall generate this signature value from the list of parameters of
          configuration class 'PublishedInformation' except 'Release'. The XPath function
          asc:getConfigSignature(nodeset) shall be used to determine the signature out of the
          list of parameters. The list of parameters shall be determined with the function
          asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_IsValidConfig</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM105</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the link time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          LcfgSignature.
        - the link time configuration shall contain the uint32 value
          CanTrcv_1_T03_LcfgSignature.
        - the MCG shall generate this signature value of link time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of link time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_IsValidConfig</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM106</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For Platform verification:
        - the CanTrcv_1_T03 post build configuration structure shall contain the value
          uint32 PlatformSignature. This uint32 must be the first value of the post build
          configuration structure to guarantee the correct access not disturbed by any padding
          bytes.
        - the MCG shall generate this signature for the selected target. The generator shall
          use the x-path function asc:getPlatformSignature() to determine this value.
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
        https://issue.ebgroup.elektrobit.com/browse/ASCBASE-1485
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_IsValidConfig</srcid><srcstatus/><internalId>254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM107</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The PbcfgM support shall be enabled or disabled via the macro
        CANTRCV_1_T03_PBCFGM_SUPPORT_ENABLED defined in the file
        CanTrcv_1_T03_Cfg.h.
        If the PbcfgM configuration references the CanTrcv_1_T03 configuration
        the macro is set to STD_ON otherwise, or if no PbcfgM configuration is
        available it is set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_IsValidConfig</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>CanTrcv_1_T03_Test_PBcfgM_Off</srcid><srcstatus/><internalId>256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM108</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the CanTrcv_1_T03 is referenced by the PbcfgM, the parameter regarding the
        relocatable feature, shall not be editable and the MCG shall use the configuration of
        the PbcfgM.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_PBcfgM_Off</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>CanTrcv_1_T03_Test_PBcfgM_On</srcid><srcstatus/><internalId>257</internalId></linkedfrom><linkedfrom><srcid>CanTrcv_T03_ComTest_NoPBCfg</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar_T03/config/CanTrcv_1_T03_EBParameters.xdm_477</srcid><srcstatus/><internalId>252</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PBCFGM110</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTrcv_1_T03_Init() function must be extended to enable the PbcgfM
        features.
        The initialization function shall obtain the CanTrcv_1_T03 configuration
        from the PbcfgM if the PbcfgM support is enabled within this CanTrcv_1_T03
        and the initialization function is called with a null pointer.
        The validity of the configuration shall be checked by the function
        CanTrcv_1_T03_IsValidConfig(). The validity shall be check regardless the PbcfgM
        support is enabled or not.
        If no valid configuration can be obtained the initialization function shall
        return, leaving the CanTrcv_1_T03 uninitialized.
        In the case error reporting is enabled and no valid configuration can be obtained
        an erroneous parameter shall be indicated.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_VerifyInitWithPcfgM</srcid><srcstatus/><internalId>255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PostBuild_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTrcv_1_T03 module shall compile and build an executable even in the absence
        of a post build configuration, i.e. without any post build generated .c and .h files
        available.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_T03_ComTest_NoPBCfg</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PbcfgM_General_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanTrcv_1_T03 shall provide the following macros in the header file
        CanTrcv_1_T03_Cfg.h:
        - CANTRCV_1_T03_RELOCATABLE_CFG_ENABLE which is set to STD_ON
          if relocatable config shall be enabled, otherwise it's set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_PBcfgM_On</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>

    <specobject>
      <id>CanTrcv_1_T03.EB.PbcfgM_General_6</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PbcfgM support is enabled CanTrcv_1_T03 shall define the following macros in
        CanTrcv_1_T03_PBCfg.c:
        - TS_PB_CFG_LAYOUT_TYPE: Shall expand to the type definition of the Postbuild
          configuration layout type (e.g. CanTrcv_1_T03_ConstConfigLayoutType)
        - TS_PB_CFG_NAME: Shall expand to the name of the structure defining the Postbuild
          configuration layout (e.g. CanTrcv_1_T03_ConfigLayout)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanTrcv_1_T03_Test_PBcfgM_Off</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>CanTrcv_1_T03_Test_PBcfgM_On</srcid><srcstatus/><internalId>257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.CanTrcv.MainFunction</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>36</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv112</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv128</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <specobject>
      <id>dev.CanTrcv.MainFunctionDiagnostics</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv205</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv206</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv207</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv171_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>216</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv204</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>dev.CanTrcv.GetTrcvSystemData</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv190</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>dev.CanTrcv.Debugging</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>137</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv151</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv152</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv153</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv154</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv155</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>dev.CanTrcv.PBsupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>157</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv017</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv062</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>dev.CanTrcv.CanSMIncompatibilty</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>180</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>dev.CanTrcv.AutosarSchema</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>248</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv149_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv178_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv179_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    <specobject>
      <id>dev.CanTrcv.RegisterInitialization</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>278</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv181</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv182</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv186</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv187</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
    <specobject>
      <id>dev.CanTrcv.PowerUpWakeup</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/public/changelog/Deviations.xml</sourcefile>
      <sourceline>305</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv170_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
  </specobjects>
    <specobjects doctype="man">
    <specobject>
      <id>CanTrcv.man.NamingConvention</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/doc/Autosar_T03/project/test/Manual_TestSpec.xml</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar_T03/generate/include/CanTrcv_1_T03_Cfg.h_22</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/src/Autosar_T03/generate/include/CanTrcv_1_T03_Cfg.h</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv083</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar_T03/include/CanTrcv_1_T03.h_6</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/src/Autosar_T03/include/CanTrcv_1_T03.h</sourcefile>
      <sourceline>6</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv052</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar_T03/src/CanTrcv_1_T03.c_31</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/src/Autosar_T03/src/CanTrcv_1_T03.c</sourcefile>
      <sourceline>31</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv069</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar_T03/config/CanTrcv_1_T03_EBParameters.xdm_477</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/src/Autosar_T03/config/CanTrcv_1_T03_EBParameters.xdm</sourcefile>
      <sourceline>477</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CanTrcv_1_T03_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTrcv_1_T03_Test_IsValidConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the function CanTrcv_1_T03_IsValidConfig() is implemented as specified.
  
Test Object: 
    CanTrcv_1_T03_IsValidConfig()
  
Test Precondition: 
    The CanTrcv_1_T03 module is not initialized.
  
Test Execution: 
    01: Call the function CanTrcv_1_T03_IsValidConfig() with an NULL_PTR.
    02: VP:
        The function must have returned with E_NOT_OK.
    03: Create an invalid configuration regarding the endianness and alignment.
    04: Call the function CanTrcv_1_T03_IsValidConfig() with this invalid configuration.
    05: VP(CanTrcv_1_T03.EB.PBCFGM106):
        The function must have returned with E_NOT_OK.
    The following 3 steps are only executed if the module has a link-time configuration:
        06: Create an invalid configuration regarding the link time configuration.
        07: Call the function CanTrcv_1_T03_IsValidConfig() with this invalid configuration.
        08: VP(CanTrcv_1_T03.EB.PBCFGM105):
                The function must have returned with E_NOT_OK.
    09: Create an invalid configuration regarding the compile time configuration.
    10: Call the function CanTrcv_1_T03_IsValidConfig() with this invalid configuration.
    11: VP(CanTrcv_1_T03.EB.PBCFGM104):
        The function must have returned with E_NOT_OK.
    12: Create an invalid configuration regarding the published information configuration.
    13: Call the function CanTrcv_1_T03_IsValidConfig() with this invalid configuration.
    14: VP(CanTrcv_1_T03.EB.PBCFGM104_1):
        The function must have returned with E_NOT_OK.
    15: Call the function CanTrcv_1_T03_IsValidConfig() with a valid configuration.
    16: VP:
        The function must have returned with E_OK.
    17: VP(CanTrcv_1_T03.EB.PBCFGM107):
        Check if CANTRCV_1_T03_PBCFGM_SUPPORT_ENABLED is set to STD_ON.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM104_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    <specobject>
      <id>CanTrcv_1_T03_Test_VerifyInitWithPcfgM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CanTrcv_1_T03 can be initialized via the PbcfgM.
  
Test Object: 
    CanTrcv_1_T03_IsValidConfig()
  
Test Precondition: 
    The CanTrcv_1_T03 module must not have been initialized.
  
Test Execution: 
    01: Create an invalid configuration regarding the endianness and alignment.
    02: Call the function CanTrcv_1_T03_Init() with this invalid configuration.
    03: VP:
        A Det call must have been performed correctly.
    04: Create an invalid configuration regarding the compile time configuration.
    05: Call the function CanTrcv_1_T03_Init() with this invalid configuration.
    06: VP:
        A Det call must have been performed correctly.
    The following 3 steps are only executed if the module has a link-time configuration:
        07: Create an invalid configuration regarding the link time configuration.
        08: Call the function CanTrcv_1_T03_Init() with this invalid configuration.
        09: VP:
            A Det call must have been performed correctly.
    10: Create an invalid configuration regarding the published information configuration.
    11: Call the function CanTrcv_1_T03_Init() with this invalid configuration.
    12: VP:
        A Det call must have been performed correctly.
    13: Initialize the PbcfgM_GetConfig() stub that way that it can return a valid function.
    14: Call the function CanTrcv_1_T03_Init() with a null pointer.
    15: VP:
        The function PbcfgM_GetConfig() must have been called once.
    16: VP:
        No Det call must have been performed.
    17: VP:
        The module internal configuration pointer CanTrcv_1_T03_RootPtr must equal
        the pointer supplied to the initialization function
    18: PbcfgM_GetConfig shall return E_NOT_OK.
        set the configuration pointer which is returned to NULL_PTR
    19: Call CanTrcv_1_T03_Init with NULL_PTR.
    20: VP(CanTrcv_1_T03.EB.PBCFGM110):
        Check if Det error is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM110</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTrcv_1_T03_Test_PBcfgM_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_PbcfgM_Off_Compile_Test.c</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Verify that if PbcfgM support is disabled then CanTrcv_1_T03_PBCfg.c shall define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
      CANTRCV_1_T03_PBCFGM_SUPPORT_ENABLED shall be set to STD_OFF.
      CANTRCV_1_T03_RELOCATABLE_CFG_ENABLE shall be set to STD_OFF.
    
Test Object: None.
Test Precondition: 
      - PbcfgM configuration does not refer to module CanTrcv_1_T03 (or no config exists)
      - Include CanTrcv_1_T03_PBcfg.c only for step 01 and 02.
      - Include CanTrcv_1_T03_Cfg.h for step 03.
    
Test Execution: 
        01: VP(CanTrcv_1_T03.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exists.
        02: VP(CanTrcv_1_T03.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME has the value
            CanTrcv_1_T03_ConfigLayoutType and CANTRCV_1_T03_CONFIG_NAME respectively.
        03: VP (CanTrcv_1_T03.EB.PBCFGM107):
            Verify that CANTRCV_1_T03_PBCFGM_SUPPORT_ENABLED is set to STD_OFF.
        04: VP(CanTrcv_1_T03.EB.PBCFGM108, CanTrcv_1_T03.EB.RelocatablePBCfg):
            CANTRCV_1_T03_RELOCATABLE_CFG_ENABLE shall be STD_OFF
    
Test Input: 
    
Test Output: 
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTrcv_1_T03_Test_PBcfgM_On</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/build/reqm/common_req/CanTrcv_1_T03_PbcfgM_On_Compile_Test.c</sourcefile>
      <sourceline>24</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      1.)
      Verify that CANTRCV_1_T03_RELOCATABLE_CFG_ENABLE is defined
      in the header file CanTrcv_1_T03_Cfg.h.
      2.)
      Verify that if PbcfgM support is enabled then CanTrcv_1_T03_PBCfg.c shall NOT define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
    
Test Object: None.
Test Precondition: 
        - CANTRCV_1_T03_PBCFGM_SUPPORT_ENABLED = STD_ON
    
Test Execution: 
        ------------------------ 1.) ---------------------
        01: VP (CanTrcv_1_T03.EB.PbcfgM_General_3,
                CanTrcv_1_T03.EB.PBCFGM108,
                CanTrcv_1_T03.EB.RelocatablePBCfg):
            Verify that CANTRCV_1_T03_RELOCATABLE_CFG_ENABLE is set to STD_ON.
        ------------------------ 2.) ---------------------
        02: Include CanTrcv_1_T03_PBcfg.c.
        03: VP(CanTrcv_1_T03.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exist.
    
Test Input: 
        None.
    
Test Output: 
        Binary file.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PbcfgM_General_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_INIT_SEQUENCE3_LWU</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Conformance/IN/CanTrcv_ConTest_T03_01/source/application/CanTrcv_ConTest_T03_01_LWU_Init.c</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that the CanTrcv initializes control registers defining the local wakeup type according to
  the configuration.

Test Object: 
  CanTrcv initialization sequence

Test Precondition: 
  CanTrcv module is initialized (EB_CANTRCV_INIT_SEQUENCE was executed before).

Test Execution: 
  --- Channel 0 ---
  01: VP:
      - Check that the CanTrcv wakeup pin is configured for falling-edge on channel 0
--- Channel 1 ---
  02: VP:
      - Check that the CanTrcv wakeup pin is configured for rising-edge on channel 1

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcvFallingEdgeDetection_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcvRisingEdgeDetection_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_READ_SILENCE_FLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Conformance/IN/CanTrcv_ConTest_T03_08/source/application/CanTrcv_ConTest_T03_08.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_ReadTrcvSilenceFlag.
  Check if the status of the silence flag is obtained from the transceiver hardware.

Test Object: 
  API service CanTrcv_ReadTrcvSilenceFlag

Test Precondition: 
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - CAN bus silence detection enabled in configuration for tested transceiver

Test Execution: 
  01: VP (CanTrcv.EB.CanTrcvSilentDetection_Conf):
      Check that the CanTrcv enables CAN bus silence detection in the transceiver hardware.
  02: Call CanTrcv_ReadTrcvSilenceFlag().
  03: VP (CanTrcv.EB.CanTrcvSilentDetection_Conf, CanTrcv.ASR40.CanTrcv217):
      CanTrcv_ReadTrcvSilenceFlag indicates that silence flag was successful read.
  04: VP (CanTrcv.ASR40.CanTrcv217):
      CanTrcv reports that there is no silence on the CAN bus.
  05: Simulate silence on the CAN Bus.
  06: Call CanTrcv_ReadTrcvSilenceFlag().
  07: VP (CanTrcv.EB.CanTrcvSilentDetection_Conf, CanTrcv.ASR40.CanTrcv217):
      CanTrcv_ReadTrcvSilenceFlag indicates that silence flag was successful read.
  08: VP (CanTrcv.ASR40.CanTrcv217):
      CanTrcv reports that there is silence on the CAN bus.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcvSilentDetection_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_READ_TIMEOUT_FLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Conformance/IN/CanTrcv_ConTest_T03_08/source/application/CanTrcv_ConTest_T03_08.c</sourcefile>
      <sourceline>150</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_ReadTrcvTimeoutFlag.
  Check the status of the Timeout flag is read from the transceiver hardware.

Test Object: None.
Test Precondition: 
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - CAN bus failure detection enabled in configuration for tested transceiver

Test Execution: 
  01: VP (CanTrcv.EB.CanTrcvCanFailureDetection_Conf):
      Check that the CanTrcv enables CAN bus failure detection in the transceiver hardware.
  02: Call CanTrcv_ReadTrcvTimeoutFlag().
  03: VP (CanTrcv.EB.CanTrcvCanFailureDetection_Conf, CanTrcv.ASR40.CanTrcv215):
      CanTrcv_ReadTrcvTimeoutFlag indicates that timeout flag was successful read.
  04: VP (CanTrcv.ASR40.CanTrcv215):
      CanTrcv reports that there is no timeout on the CAN bus.
  05: Simulate timeout on the CAN Bus.
  06: Call CanTrcv_ReadTrcvTimeoutFlag().
  07: VP (CanTrcv.EB.CanTrcvCanFailureDetection_Conf, CanTrcv.ASR40.CanTrcv215):
      CanTrcv_ReadTrcvTimeoutFlag indicates that timeout flag was successful read.
  08: VP (CanTrcv.ASR40.CanTrcv215):
      CanTrcv reports that there is timeout on the CAN bus.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcvCanFailureDetection_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_SILENCE_DETECT_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Conformance/IN/CanTrcv_ConTest_T03_08/source/application/CanTrcv_ConTest_T03_08.c</sourcefile>
      <sourceline>239</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_ReadTrcvSilenceFlag.
  Check if the status of the silence flag can not be obtained from the transceiver
  hardware if this feature is disabled by configuration.

Test Object: 
  API service CanTrcv_ReadTrcvSilenceFlag

Test Precondition: 
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - CAN bus silence detection disabled in configuration for tested transceiver

Test Execution: 
  01: VP (CanTrcv.EB.CanTrcvSilentDetection_Conf):
      Check that the CanTrcv disables CAN bus silence detection in the transceiver hardware.
  02: Call CanTrcv_ReadTrcvSilenceFlag().
  03: VP (CanTrcv.EB.CanTrcvSilentDetection_Conf, CanTrcv.ASR40.CanTrcv217):
      CanTrcv_ReadTrcvSilenceFlag returns with error.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcvSilentDetection_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_SPI_ASYNC_RETRIES</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Conformance/IN/CanTrcv_ConTest_T03_10/source/application/CanTrcv_ConTest_T03_10.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks if the CanTrcv retries to access the SPI bus
  after a failing attempt. Number of retries shall depend on configuration
  parameter CanTrcvSPICommRetries.

Test Object: 

Test Precondition: 
  - CanTrcvSPICommRetries set to 3.
  - DET error detection enabled
  - CanTrcv shall be initialized

Test Execution: 
  01: The code stub function Spi_AsyncTransmit shall return an error.
  02: Call CanTrcv_GetOpMode().
  03: VP (CanTrcv.ASR40.CanTrcv179_Conf):
      CanTrcv_GetOpMode return an error.
  04: VP (CanTrcv.ASR40.CanTrcv179_Conf):
      CanTrcv tried to transmit 4 times (1 + 3 retransmissions).
  05: VP (CanTrcv.ASR40.CanTrcv179_Conf):
      A DET error with error ID CANTRCV_1_T03_E_NO_TRCV_CONTROL occurs.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv179_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_SPI_ASYNC_POLLING</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Conformance/IN/CanTrcv_ConTest_T03_10/source/application/CanTrcv_ConTest_T03_10.c</sourcefile>
      <sourceline>142</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks if the CanTrcv retries to poll result from SPI bus
  after a failing attempt. Number of retries shall depend on configuration
  parameter CanTrcvSpiAccessAsynchronousTimeout.

Test Object: 

Test Precondition: 
  - CanTrcvSpiAccessAsynchronousTimeout set to 2.
  - DET error detection enabled
  - CanTrcv shall be initialized

Test Execution: 
  01: The code stub function Spi_GetSequenceResult shall return an error.
  02: Call CanTrcv_GetOpMode().
  03: Value of CANTRCV_1_T03_SPI_TIMEOUT_COUNTER shall be the value of
      CanTrcvSpiAccessAsynchronousTimeout.
      Value of CANTRCV_1_T03_SPI_COMM_RETRIES shall be the value of 
      CanTrcvSPICommRetries.
  04: VP :
      CanTrcv_GetOpMode should return E_NOT_OK.
  05: VP :
      CanTrcv should have polled as many times as configured in CanTrcvSPICommRetries
  06: The code stub function Spi_GetSequenceResult shall return pending.
  07: Call CanTrcv_GetOpMode().
  08: VP :
           CanTrcv_GetOpMode return should return not ok.
  09: VP :
           CanTrcv should have polled CanTrcvSpiAccessAsynchronousTimeout times CanTrcvSPICommRetries

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.CanTrcvSpiAccessAsynchronousTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_CHECK_WU_BY_PIN_NO_BYBUS_ENABLED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Conformance/IN/CanTrcv_ConTest_T03_11/source/application/CanTrcv_T03_ConTest_11.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that it's possible to have WakeupByPin without having WakeupByBus.
  WakeupByBus has been disabled for the channel.

  https://issue.ebgroup.elektrobit.com/browse/ASCCANTRCV-354

Test Object: None.
Test Precondition: 
  WakeUpByBus disabled for the channel.

Test Execution: 
  01: VP: Channel is in sleep mode
  02: VP: Wake pin pulled up
  03: VP: Wake up occurs because of WakeupByPin

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.WakeupMode.ApiEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.TrcvWakeupReasonType.Supported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_OP_MODE_REGRESSION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Conformance/IN/CanTrcv_ConTest_T03_OpModeRegression/source/application/CanTrcv_ConTest_T03_OpModeRegression.c</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test is a regression test.
  This test verifies that the function SetOpMode truly changes the mode of the CanTrcv by reading
  the mode of the CanTrcv from the HW after having written the new mode. This needs to be done because
  it is possible by the HW that the mode changes due to internal behavior (Wakeup, ...). Simply writing
  the new mode is not sufficient and the successful mode change needs to be checked.
  In particular (according to datasheet): 
    If a wake-up event and SetOpMode(Normal) occur at the same time the SPI command is ignored.
  This means if CanTrcv was in SLEEP it will be in STANDBY mode after a wake-up event. But SW stack will
  think it changed mode to NORMAL (STANDBY != NORMAL)

Test Object: 

Test Precondition: 
  CanTrcv module will be in STANDBY mode

Test Execution: 
  01: Provide new callback function to Spi_ReadIB
  02: Call CanTrcv_SetOpMode with SLEEP and check that it fails
  03: Call CanTrcv_SetOpMode with SLEEP and check that it succeeds
  04: Call CanTrcv_SetOpMode with NORMAL and check that it fails
  05: Call CanTrcv_SetOpMode with NORMAL and check that it succeeds
  06: Call CanTrcv_SetOpMode with STANDBY and check that it fails
  07: Call CanTrcv_SetOpMode with STANDBY and check that it succeeds
  08: Call CanTrcv_SetOpMode with NORMAL and check that it fails
  09: Call CanTrcv_SetOpMode with NORMAL and check that it succeeds

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_01001_Err_MultipleJobs</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error in case the SPI sequence
    used by the CanTrcv refers to more than one SPI job.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid SPI config where the SPI sequence references more than one SPI jobs.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "Too many jobs for the spi sequence SpiSequence_0. Only one shall be define!."

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.SpiConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01002_Err_MultipleChannels</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>53</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error in case the SPI job
    used by the CanTrcv refers to more than one SPI channel.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid SPI config where the SPI sequence references a SPI job
    which references more than one SPI jobs.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "Too many channels for this spi job SpiJob_0\. Only one shall be define!"

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.SpiConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01003_Err_RedefinedSequenceId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>80</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error in case the SPI sequence
    used by the CanTrcv does not have a unique Id.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid SPI config where the SPI sequence used by the CanTrcv
    has the same SequenceId as another SPI sequence.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "The 'SpiSequenceId' = 0 is defined more than once!."

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.SpiConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01004_Err_WrongMsgDLC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>107</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error in case there are more
    or less data masks for partial network configured than the CAN message DLC indicates.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid CanTrcv config where the number of configured CanTrcvPnFrameDataMaskSpec
    container differs from the value of CanTrcvPnFrameDlc.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "The CanTrcvPnFrameDlc (2) is not in accordance with number of data define into CanTrcvPnFrameDataMaskSpec (1)."

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.CanTrcvConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01005_Err_DuplicatedDataMaskIndex</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>134</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error in case there are two
    data masks for partial network configured with the same Id.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid CanTrcv config where two CanTrcvPnFrameDataMaskSpec
    have the same value for CanTrcvPnFrameDataMaskIndex.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "The parameter 'CanTrcvPnFrameDataMaskIndex' has an index define more than once!"

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.CanTrcvConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01006_Err_UnexpectedDataMaskIndex</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>161</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error in case the Id of the
    data masks for partial network are not zero-based and dense.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid CanTrcv config where the entries of CanTrcvPnFrameDataMaskSpec
    does not have a zero-based and dense CanTrcvPnFrameDataMaskIndex.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "Unexpected value for parameter 'CanTrcvPnFrameDataMaskSpec'\. It has to be under DLC value."

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.CanTrcvConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01007_Warn_NoWakeupData</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>188</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues a warning in case none of the
    data masks for partial network have at least a single bit set.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid CanTrcv config where all entries of CanTrcvPnFrameDataMaskSpec
    have a value of 0.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "The CanTrcv will not wake-up if any data is configured with one bit to 1."

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.CanTrcvConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01008_Err_WrongWakeupConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>215</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error in case 
    CanTrcvHwPnSupport is enabled and VendorSpecific/CanTrcvPnSupport is set to false
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid CanTrcv config where CanTrcvHwPnSupport for a channel is se to True
    and VendorSpecific/CanTrcvPnSupport is set to False.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "CanTrcvPnSupport should be enabled to use this function"

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.CanTrcvConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01009_Err_WrongPNConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Generic/IN/CanTrcv_GenTest_T03_00_InvalidConfiguration/source/application/testspec.h</sourcefile>
      <sourceline>242</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall verify that the generator issues an error in case 
    CanTrcvPnEnabled is enabled and VendorSpecific/CanTrcvPnCanIfCallbackSupport is set to false
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    Provide an invalid CanTrcv config where CanTrcvPnEnabled for a channel is se to True
    and VendorSpecific/CanTrcvPnCanIfCallbackSupport is set to False.

Test Execution: 
    01: Start generator with valid configuration.
    02: VP: Check for error pattern. Verify that no errors have been issued.
    03: Start generator with erroneous configuration.
    04: VP: The generator must have issued the following error:
            "CanTrcvPnCanIfCallbackSupport should be enabled to use this function"

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.Generator.CanTrcvConf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CANTRCV_T03_REGRESSIONTEST_INFIX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Compile_RegressionTest/source/application/CanTrcv_ComTest_RegressionTest.c</sourcefile>
      <sourceline>25</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Regression test for the ticket: ASCCANTRCV-429
  Verify that the defines
    CANTRCV_WAKEUP_BY_POLLING
    CANTRCV_WAKEUP_NOT_SUPPORTED
  are NOT generated
  They should have their resepctive infix (1_T03)
    CANTRCV_1_T03_WAKEUP_BY_POLLING
    CANTRCV_1_T03_WAKEUP_NOT_SUPPORTED
  The header file CanTrcv_1_T03_Cfg.h includes those defines therefore this test checks
  whether the defines without the infix exist (which they should not)

Test Object: None.
Test Precondition: 
  - Include CanTrcv_1_T03_Cfg.h

Test Execution: 
    01: VP(Check that threse defines exist):
              CANTRCV_1_T03_WAKEUP_BY_POLLING
              CANTRCV_1_T03_WAKEUP_NOT_SUPPORTED
    02: VP(Check that these defines do not exist):
              CANTRCV_WAKEUP_BY_POLLING
              CANTRCV_WAKEUP_NOT_SUPPORTED

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv154_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_PN_API_DISABLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_Common/source/application/CanTrcv_ComTest_Common.c</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check, that the api functions CanTrcv_GetTrcvSystemData, CanTrcv_ClearTrcvWufFlag,
  CanTrcv_ReadTrcvTimeoutFlag, CanTrcv_ClearTrcvTimeoutFlag,
  CanTrcv_SetPNActivationState, CanTrcv_CheckWakeFlag and
  CanTrcv_ReadTrcvSilenceFlag are not available in case the configuration parameters
  CanTrcvHwPnSupport is set to false.

Test Object: None.
Test Precondition: 
  CanTrcvHwPnSupport = false

Test Execution: 
No restrictions

Test Input: 
  None.

Test Output: 
  None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv219</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv223</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv175.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv070</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_PN_API_ENABLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_Common/source/application/CanTrcv_ComTest_Common.c</sourcefile>
      <sourceline>91</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check, that the api functions CanTrcv_GetTrcvSystemData, CanTrcv_ClearTrcvWufFlag,
  CanTrcv_ReadTrcvTimeoutFlag, CanTrcv_ClearTrcvTimeoutFlag,
  CanTrcv_ReadTrcvSilenceFlag, CanTrcv_SetPNActivationState and
  CanTrcv_CheckWakeFlag are available in case the configuration parameters
  CanTrcvHwPnSupport is set to true.

Test Object: None.
Test Precondition: 
  CanTrcvHwPnSupport = true

Test Execution: 
No restrictions

Test Input: 
None.

Test Output: 
None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv219</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv223</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_DET_OFF_WUP_POLLING</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_Common/source/application/CanTrcv_ComTest_Common.c</sourcefile>
      <sourceline>129</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check, if module compiles with CanTrcvDevErrorDetect 'false',
  CanTrcvWakeUpSupport 'CANTRCV_WAKEUP_BY_POLLING' (general wakeup support enabled),
  CanTrcvGetVersionInfo 'false', CanTrcvHwPnSupport= 'true'

Test Object: None.
Test Precondition: 
  - configuration parameter set as described in description

Test Execution: 
No restrictions

Test Input: 
None.

Test Output: 
None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv091</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv218</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv154_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv175.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_DET_ON_WUP_DISABLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_Common/source/application/CanTrcv_ComTest_Common.c</sourcefile>
      <sourceline>172</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check, if module compiles with CanTrcvDevErrorDetect 'true',
  CanTrcvWakeUpSupport 'CANTRCV_WAKEUP_NOT_SUPPORTED' (general wakeup support disabled),
  CanTrcvGetVersionInfo 'true' AND CanTrcvOperationModeApi 'false'

Test Object: None.
Test Precondition: 
  - configuration parameter set as described in description

Test Execution: 
No restrictions

Test Input: 
None.

Test Output: 
None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.WakeupMode.ApiEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.OperationMode.ApiEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv154_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv109</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_WAKEUP_MODE_API_DISABLED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_Common/source/application/CanTrcv_ComTest_Common.c</sourcefile>
      <sourceline>207</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Verify that API functions CanTrcv_GetBusWuReason, CanTrcv_SetWakeupMode,
  CanTrcv_CheckWakeup are disabled if CanTrcvWakeupModeApi is 'false'
  Verify that API functions CanTrcv_SetOpMode and CanTrcv_GetOpMode are enabled
  if OperationModeApiEnable is 'true'

Test Object: None.
Test Precondition: 
  - CanTrcvWakeupModeApiEnable set to 'false'
  - OperationModeApiEnable set to 'true'

Test Execution: 
No restrictions

Test Input: 
None.

Test Output: 
None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.WakeupMode.ApiEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.OperationMode.ApiEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_ALL_APIS_DISABLED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_Common/source/application/CanTrcv_ComTest_Common.c</sourcefile>
      <sourceline>243</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Verify that following API functions are not available if CanTrcvDevErrorDetect,
  CanTrcvGetVersionInfo, CanTrcvWakeupModeApiEnable, CanTrcvOperationModeApiEnable,
  CanTrcvPnSupport are turned off:
    - CanTrcv_SetOpMode, CanTrcv_GetOpMode, CanTrcv_GetBusWuReason,
      CanTrcv_GetBusWuReason, CanTrcv_SetWakeupMode, CanTrcv_CheckWakeup.
      CanTrcv_GetVersionInfo, CanTrcv_GetTrcvSystemData, CanTrcv_ClearTrcvWufFlag,
      CanTrcv_ReadTrcvTimeoutFlag, CanTrcv_ClearTrcvTimeoutFlag,
      CanTrcv_ReadTrcvSilenceFlag, CanTrcv_SetPNActivationState,
      CanTrcv_CheckWakeFlag

Test Object: None.
Test Precondition: 
  CanTrcvDevErrorDetect set to 'false'
  CanTrcvGetVersionInfo set to 'false'
  CanTrcvWakeupModeApiEnable set to 'false'
  CanTrcvOperationModeApiEnable set to 'false'
  CanTrcvPnSupport set to 'false'
  CanTrcvWakeUpSupport set to 'CANTRCV_WAKEUP_NOT_SUPPORTED'

Test Execution: 
No restrictions

Test Input: 
None.

Test Output: 
None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.OperationMode.ApiEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.WakeupMode.ApiEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv175.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv153_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv152_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>172</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
    <specobject>
      <id>TS_CANTRCV_SCHM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_Common/source/application/CanTrcv_ComTest_Common.c</sourcefile>
      <sourceline>288</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test checks that the CanTrcv module's generator generates a
   syntactically and semantically valid basic software module
   description (BSWMD) when the generator mode "generate_swcd" is
   invoked.

Test Object: 

Test Precondition: 

Test Execution: 
  Ts5 build environment steps:
    The module configuration generator produces the BSWMD. This
    implicitly verifies that the BSWMD is syntactically and
    semantically correct.

Test Input: 
  Usage of a common ASR configuration having all adjacent ASR modules
  configured.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_T03_SYMBOLIC_NAME_VALUES</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_SymbolicNames/source/application/CanTrcv_ComTest_SymbolicNames.c</sourcefile>
      <sourceline>63</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Check that macros are generated for configuration parameters which are specified as
    SYMBOLICNAMEVALUES.
&lt;/para&gt;

Test Object: symbolic name value macros
Test Precondition: 
  CANTRCV_DONT_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined.

Test Execution: 
    01: Check that macros are generated with the names and the values listed in output.

Test Input: 
None.

Test Output: 
    macro generation:
    CanTrcvConf_1_T03_CanTrcvChannel_CanTrcvChannel_0 1U
    CanTrcvConf_1_T03_CanTrcvChannel_CanTrcvChannel_1 0U
    CanTrcvChannel_0 1U
    CanTrcvChannel_1 0U
    CanTrcv_1_T03_CanTrcvChannel_0 1U
    CanTrcv_1_T03_CanTrcvChannel_1 0U
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv155_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_T03_SYMBOLIC_NAME_VALUES_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Compile_SymbolicNames_1/source/application/CanTrcv_ComTest_SymbolicNames.c</sourcefile>
      <sourceline>66</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    Check that macros are generated for configuration parameters which are specified as
    SYMBOLICNAMEVALUES.
&lt;/para&gt;

Test Object: symbolic name value macros
Test Precondition: 
  CANTRCV_DONT_PROVIDE_LEGACY_SYMBOLIC_NAMES is defined.

Test Execution: 
    01: Check that macros are generated with the names and the values listed in output.

Test Input: 
None.

Test Output: 
    macro generation:
    CanTrcvConf_1_T03_CanTrcvChannel_CanTrcvChannel_0 1U
    CanTrcvConf_1_T03_CanTrcvChannel_CanTrcvChannel_1 0U
    The macros CanTrcvChannel_0, CanTrcvChannel_1, CanTrcv_1_T03_CanTrcvChannel_0 or
    CanTrcv_1_T03_CanTrcvChannel_1 shall not be generated.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv155_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_DET_UNINIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Det/source/application/CanTrcv_ConTest_Det.c</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check API of CanTrcv while module is not initialized and CanTrcvDevErrorDetect
    switch is enabled.
    The following functions will be tested:
      CanTrcv_SetOpMode, CanTrcv_GetOpMode, CanTrcv_GetBusWuReason,
      CanTrcv_SetWakeupMode, CanTrcv_CheckWakeup,
      CanTrcv_GetTrcvSystemData, CanTrcv_ClearTrcvWufFlag,
      CanTrcv_SetPNActivationState
    Verify that functions raise the development error CANTRCV_E_UNINIT.
  
Test Object: 
      CanTrcv_SetOpMode()
      CanTrcv_GetOpMode()
      CanTrcv_GetBusWuReason()
      CanTrcv_SetWakeupMode()
      CanTrcv_CheckWakeup()
      CanTrcv_GetTrcvSystemData()
      CanTrcv_ClearTrcvWufFlag()
      CanTrcv_SetPNActivationState()
  
Test Precondition: 
    CanTrcv is uninitialized
  
Test Execution: 
    01: VP(CanTrcv002, CanTrcv122)
        Call CanTrcv_SetOpMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_UNINIT to Det with service id 0x01
    02: VP(CanTrcv005, CanTrcv124)
        Call CanTrcv_GetOpMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_UNINIT to Det with service id 0x02
    03: VP(CanTrcv007, CanTrcv125)
        Call CanTrcv_GetBusWuReason() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_UNINIT to Det with service id 0x03
    04: VP(CanTrcv009, CanTrcv127)
        Call CanTrcv_SetWakeupMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_UNINIT to Det with service id 0x05
    05: VP(CanTrcv143, CanTrcv144)
        Call CanTrcv_CheckWakeup() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_UNINIT to Det with service id 0x07
    06: VP(CanTrcv213, CanTrcv191)
        Call CanTrcv_GetTrcvSystemData() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_UNINIT to Det with service id 0x09
    07: VP(CanTrcv214, CanTrcv197)
        Call CanTrcv_ClearTrcvWufFlag() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_UNINIT to Det with service id 0x0a
    08: VP(CanTrcv219, CanTrcv220)
        Call CanTrcv_SetPNActivationState() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_UNINIT to Det with service id 0x0f
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv122</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv124</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv125</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv127</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv144</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv191</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv197</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv219</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv220</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Det/source/application/CanTrcv_ConTest_Det.c</sourcefile>
      <sourceline>207</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check functionality of CanTrcv_Init. Check if operation mode is set correctly.
  
Test Object: 
    CanTrcv_Init()
  
Test Precondition: 
    CanTrcv module is not initialized.
  
Test Execution: 
    01: Initialize Can transceiver
    02: VP(CanTrcv001)
        Call CanTrcv_GetOpMode() and verify that function returns E_OK
    03: VP(CanTrcv100, CanTrcv148, CanTrcv106, CanTrcv146_Conf)
        Verify that the transceiver state is NORMAL
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv146_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>179</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_DET_INVALID_CAN_NETWORK</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Det/source/application/CanTrcv_ConTest_Det.c</sourcefile>
      <sourceline>275</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check API of CanTrcv while using a wrong CanNetwork and CanTrcvDevErrorDetect
    switch is enabled.
    The following functions will be tested:
      CanTrcv_SetOpMode, CanTrcv_GetOpMode, CanTrcv_GetBusWuReason and
      CanTrcv_SetWakeupMode, CanTrcv_CheckWakeup, CanTrcv_GetTrcvSystemData,
      CanTrcv_ClearTrcvWufFlag, CanTrcv_ReadTrcvTimeoutFlag,
      CanTrcv_ClearTrcvTimeoutFlag, CanTrcv_ReadTrcvSilenceFlag,
      CanTrcv_CheckWakeFlag
    Verify that functions raise the development error CANTRCV_E_INVALID_TRANSCEIVER.
  
Test Object: 
    CanTrcv_SetOpMode()
    CanTrcv_GetOpMode()
    CanTrcv_GetBusWuReason()
    CanTrcv_SetWakeupMode()
    CanTrcv_CheckWakeup()
    CanTrcv_GetTrcvSystemData()
    CanTrcv_ClearTrcvWufFlag()
    CanTrcv_ReadTrcvTimeoutFlag()
    CanTrcv_ClearTrcvTimeoutFlag()
    CanTrcv_ReadTrcvSilenceFlag()
    CanTrcv_CheckWakeFlag()
  
Test Precondition: 
    CanTrcv module is initialized.
  
Test Execution: 
    01: VP(CanTrcv002, CanTrcv123)
        Call CanTrcv_SetOpMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x01
    02: VP(CanTrcv005, CanTrcv129)
        Call CanTrcv_GetOpMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x02
    03: VP(CanTrcv007, CanTrcv130)
        Call CanTrcv_GetBusWuReason() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x03
    04: VP(CanTrcv009, CanTrcv131)
        Call CanTrcv_SetWakeupMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x05
    05: VP(CanTrcv143, CanTrcv145)
        Call CanTrcv_CheckWakeup() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x07
    06: VP(CanTrcv213, CanTrcv192)
        Call CanTrcv_GetTrcvSystemData() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x09
    07: VP(CanTrcv214, CanTrcv198)
        Call CanTrcv_ClearTrcvWufFlag() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x0a
    08: VP(CanTrcv215, CanTrcv199)
        Call CanTrcv_ReadTrcvTimeoutFlag() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x0b
    09: VP(CanTrcv216, CanTrcv201)
        Call CanTrcv_ClearTrcvTimeoutFlag() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x0c
    10: VP(CanTrcv217, CanTrcv202)
        Call CanTrcv_ReadTrcvSilenceFlag() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x0d
    11: VP(CanTrcv223, CanTrcv225)
        Call CanTrcv_CheckWakeFlag() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_INVALID_TRANSCEIVER to Det with service id 0x0e
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv123</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv129</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv130</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv131</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv145</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv192</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv199</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv223</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv225</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_DET_PARAM_POINTER</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Det/source/application/CanTrcv_ConTest_Det.c</sourcefile>
      <sourceline>471</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check API of CanTrcv while using a null pointer as parameter value and
    CanTrcvDevErrorDetect switch is enabled.
    The following functions will be tested:
      CanTrcv_GetBusWuReason, CanTrcv_GetOpMode, CanTrcv_ReadTrcvSilenceFlag
      CanTrcv_GetTrcvSystemData, CanTrcv_ReadTrcvTimeoutFlag
    Verify that functions raise the development error CANTRCV_E_PARAM_POINTER.
  
Test Object: 
    CanTrcv_GetBusWuReason()
    CanTrcv_GetOpMode()
    CanTrcv_ReadTrcvSilenceFlag()
    CanTrcv_GetTrcvSystemData()
    CanTrcv_ReadTrcvTimeoutFlag()
  
Test Precondition: 
    CanTrcv module is initialized.
  
Test Execution: 
    01: VP(CanTrcv007, CanTrcv133)
        Call CanTrcv_GetBusWuReason() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_PARAM_POINTER to Det with service id 0x03
    02: VP(CanTrcv005, CanTrcv132)
        Call CanTrcv_GetOpMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_PARAM_POINTER to Det with service id 0x02
    03: VP(CanTrcv217, CanTrcv203)
        Call CanTrcv_ReadTrcvSilenceFlag() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_PARAM_POINTER to Det with service id 0x0d
    04: VP(CanTrcv213, CanTrcv193)
        Call CanTrcv_GetTrcvSystemData() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_PARAM_POINTER to Det with service id 0x09
    05: VP(CanTrcv215, CanTrcv200)
        Call CanTrcv_ReadTrcvTimeoutFlag() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_PARAM_POINTER to Det with service id 0x0b
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv132</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv133</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv193</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv200</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv203</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv217</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_DET_MODE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Det/source/application/CanTrcv_ConTest_Det.c</sourcefile>
      <sourceline>585</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check API of CanTrcv while using an incorrect TransceiverModeType and
    CanTrcvDevErrorDetect switch is enabled.
    The following functions will be tested:
      CanTrcv_SetWakeupMode.
    Verify that functions raise the development error CANTRCV_E_PARAM_TRCV_WAKEUP_MODE.
  
Test Object: 
    CanTrcv_SetWakeupMode()
  
Test Precondition: 
    CanTrcv module is initialized.
  
Test Execution: 
     01: VP(CanTrcv009, CanTrcv089)
         Call CanTrcv_SetWakeupMode() and verify that function returns E_NOT_OK
         and reports CANTRCV_E_PARAM_TRCV_WAKEUP_MODE to Det with service id 0x05
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv089</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_DET_INVALID_OPMODE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Det/source/application/CanTrcv_ConTest_Det.c</sourcefile>
      <sourceline>644</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTrcv_SetOpMode() reports CANTRCV_E_PARAM_TRCV_OPMODE to Det
    and return E_NOT_OK if function is called with invalid OpMode
  
Test Object: 
    CanTrcv_SetOpMode()
  
Test Precondition: 
    CanTrcv module is initialized.
  
Test Execution: 
    01: VP(CanTrcv002, CanTrcv087)
        Call CanTrcv_SetOpMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_PARAM_TRCV_OPMODE to Det with service id 0x01
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv087</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_DET_STATE_MASCHINE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Det/source/application/CanTrcv_ConTest_Det.c</sourcefile>
      <sourceline>698</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check the different states and their transitions. If there is a wrong state
    transition, the function should generate a DET error. This is a simple state
    machine test without sleep state.
  
Test Object: 
    CanTrcv_SetOpMode()
  
Test Precondition: 
    CanTrcv module is initialized.
    CANTRCV_INIT_STATE is configured as CANTRCV_NORMAL.
  
Test Execution: 
    01: Call CanTrcv_SetOpMode to set the transceiver into SLEEP mode
    02: VP(CanTrcv121)
        Verify that Det was called because of invalid transition
        NORMAL-&gt;SLEEP
    03: VP(CanTrcv055, CanTrcv005)
        Call CanTrcv_GetOpMode and verify that current state is NORMAL
    04: VP(CanTrcv055, CanTrcv102, CanTrcv158)
        Call CanTrcv_SetOpMode to set the transceiver into STANDBY mode,
        verify that current state is STANDBY by calling CanTrcv_GetOpMode
        and verify that CanIf_TrcvModeIndication was called
    05: VP(CanTrcv055, CanTrcv102, CanTrcv161, CanTrcv158)
        Call CanTrcv_SetOpMode to set the transceiver into STANDBY mode
        again and verify that current state is still STANDBY
    06: VP(CanTrcv055, CanTrcv102, CanTrcv158)
        Call CanTrcv_SetOpMode to set the transceiver into NORMAL mode
        and verify that current state is NORMAL by calling
        CanTrcv_GetOpMode
    07: VP(CanTrcv055, CanTrcv102, CanTrcv161, CanTrcv158)
        Call CanTrcv_SetOpMode to set the transceiver into NORMAL mode
        again, verify that current state is still NORMAL,
        and check that CanIf_TrcvModeIndication was called
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv121</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_GET_VERSIONINFO</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Det/source/application/CanTrcv_ConTest_Det.c</sourcefile>
      <sourceline>886</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanTrcv_GetVersionInfo() reports CANTRCV_E_PARAM_POINTER to Det
    if function is called with null pointer.
    Verify that CanTrcv_GetVersionInfo() returns the correct version
  
Test Object: 
    CanTrcv_GetVersionInfo()
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanTrcv134):
        Call CanTrcv_GetVersionInfo and verify that function reports
        CANTRCV_E_PARAM_POINTER to Det
    02: VP(CanTrcv108):
        Call CanTrcv_GetVersionInfo once again and verify that function returns
        the correct version info of the module
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv134</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_CANIFTRCVID_OPMODE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_General/source/application/CanTrcv_ConTest_General.c</sourcefile>
      <sourceline>50</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies if the CanTrcv uses the correct, abstracted CanIfTrcvId
    for mode indications and CanIf_ConfirmPnAvailability (optinal for Pn implementations).
  
Test Object: 
    CanTrcv_SetOpMode()
  
Test Precondition: 
    - CanTrcv is initialized
    - Initial OpMode is configured to CANTRCV_TRCVMODE_STANDBY
    - Partial network support enabled
  
Test Execution: 
    01: Switch CanTrcv channel 0 to Opmode CANTRCV_TRCVMODE_NORMAL
    --- OPTIONAL SECTION (for PN implementations) ---
    02: VP:
        Verify that CanTrcv call CanIf_ConfirmPnAvailability with the
        abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        (the one referencing channel 0).
    --- END OF OPTIONAL SECTION ---
    03: VP:
        Verify that CanTrcv call CanIf_TrcvModeIndication with the
        abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        (the one referencing channel 0).
    04: Switch CanTrcv channel 1 to Opmode CANTRCV_TRCVMODE_NORMAL
    --- OPTIONAL SECTION (for PN implementations) ---
    05: VP:
        Verify that CanTrcv call CanIf_ConfirmPnAvailability with the
        abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        (the one referencing channel 1).
    --- END OF OPTIONAL SECTION ---
    06: VP:
        Verify that CanTrcv call CanIf_TrcvModeIndication with the
        abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        (the one referencing channel 1).
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.CanIfTrcvId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_CANIFTRCVID_CLEARWUF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_General/source/application/CanTrcv_ConTest_General.c</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies if the CanTrcv uses the correct, abstracted CanIfTrcvId
    for the Clear Trcv Wakeupflag Indication.
    The checks are optional, since the Clear Trcv Wakeupflag Indication is only
    implemented for CanTrcv drivers with the partial network feature.
  
Test Object: 
    CanTrcv_ClearTrcvWufFlag()
  
Test Precondition: 
    - CanTrcv is initialized
    - Partial network support enabled
  
Test Execution: 
    01: Call CanTrcv_ClearTrcvWufFlag for channel 0.
    --- OPTIONAL SECTION (for PN implementations) ---
    02: VP:
        Verify that CanTrcv call CanIf_ClearTrcvWufFlagIndication with the
        abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        (the one referencing channel 0).
    --- END OF OPTIONAL SECTION ---
    03: Call CanTrcv_ClearTrcvWufFlag for channel 1.
    --- OPTIONAL SECTION (for PN implementations) ---
    04: VP:
        Verify that CanTrcv call CanIf_ClearTrcvWufFlagIndication with the
        abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        (the one referencing channel 1).
    --- END OF OPTIONAL SECTION ---
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.CanIfTrcvId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_CANIFTRCVID_CHECKWUF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_General/source/application/CanTrcv_ConTest_General.c</sourcefile>
      <sourceline>243</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies if the CanTrcv uses the correct, abstracted CanIfTrcvId
    for the Check Trcv Wakeupflag Indication.
    The checks are optional, since the Check Trcv Wakeupflag Indication is only
    implemented for CanTrcv drivers with the partial network feature.
  
Test Object: 
    CanTrcv_CheckTrcvWufFlag()
  
Test Precondition: 
    - CanTrcv is initialized
    - Partial network support enabled
  
Test Execution: 
    01: Call CanTrcv_CheckWakeFlag for channel 0.
    --- OPTIONAL SECTION (for PN implementations) ---
    02: VP:
        Verify that CanTrcv call CanIf_CheckTrcvWakeFlagIndication with the
        abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        (the one referencing channel 0).
    --- END OF OPTIONAL SECTION ---
    03: Call CanTrcv_CheckWakeFlag for channel 1.
    --- OPTIONAL SECTION (for PN implementations) ---
    04: VP:
        Verify that CanTrcv call CanIf_CheckTrcvWakeFlagIndication with the
        abstracted CanIfTrcvId of the corresponding CanIfTrcvCfg
        (the one referencing channel 1).
    --- END OF OPTIONAL SECTION ---
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.CanIfTrcvId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_T03_HEADER_FILE_STRUCTURE_01</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_General/CanTrcv_Conformance_Header_01/source/application/CanTrcv_ConTest_Header_01.c</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
Check if all headers of CanTrcv.c were included.
&lt;/para&gt;

Test Object: None.
Test Precondition: None.
Test Execution: 
No restrictions

Test Input: 
None.

Test Output: 
None.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv068</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.HeaderFileStructure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanTrcv_T03_ComTest_NoPBCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_ComTest_NoPBCfg/source/application/CanTrcv_ComTest_NoPBCfg.c</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall prove that that the CanTrcv also compiles without any post build information
  
Test Object: 
    Compile test
  
Test Precondition: 
        * Set TS_CANTRCV_COMPILE_WITH_POSTBUILD to FALSE in the merged make file to prevent the compilation
          of the post build C file.
        * The merged make file holds a rule which removes all post build files after generation
  
Test Execution: 
        The test run is successful when the CanTrcv compiles under sticking to the precondition.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
        <provcov>
          <linksto>CanTrcv_1_T03.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_INIT_SEQUENCE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_01/source/application/CanTrcv_ConTest_01.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that the CanTrcv initialize the register regarding its configuration.
  The channels shall have a POR event simulated to run through the whole
  initialization sequence.

Test Object: 
  CanTrcv initialization sequence

Test Precondition: 
  CanTrcv module is not initialized.

Test Execution: 
  01: Initialize the CanTrcv.
  --- Channel 0 ---
  02: VP:
      Check channel 0 configuration.
      - Check that the CanTrcv channel is set to state 'normal'
      - Check that the CanTrcv channel has selective wakeup enabled
      - Check that the CanTrcv channel is set to mode 'active'
      - Check that the CanTrcv channel is set to a baudrate of 500kbit/s.
--- Channel 1 ---
  03: VP:
      Check channel 1 configuration.
      - Check that the CanTrcv channel is set to state 'standby'
      - Check that the CanTrcv channel has selective wakeup enabled
      - Check that the CanTrcv channel is set to mode 'active'
      - Check that the CanTrcv channel is set to a baudrate of 250kbit/s.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv180</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv100</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv169_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_INIT_SEQUENCE_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_01/source/application/CanTrcv_ConTest_01.c</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that the parameters CanTrcvPnFrameCanId, CanTrcvPnFrameCanIdMask and CanTrcvPnFrameDataMask
  are configured into the Transceiver registers.

Test Object: 
  CanTrcv initialization sequence

Test Precondition: 
  CanTrcv module is initialized.

Test Execution: 
  --- Channel 0 ---
  01: VP:
      Check channel 0 configuration.
      - Check that the CanTrcv channel is configured of standard CAN IDs.
      - Check that the CanTrcv channel has set the DLC of CAN messages to 0
      - Check that the CanTrcv has no data mask configured (all entries set to 0)
--- Channel 1 ---
  02: VP:
      Check channel 1 configuration.
      - Check that the CanTrcv channel is configured of extended CAN IDs.
      - Check that the CanTrcv channel has set the DLC of CAN messages to 8
      - Check that the Can ID is set to 520158976
      - Check that the Can Mask ID is set to 536870910
      - Check that the CanTrcv has the following mask configured:
        Byte0  Byte1  Byte2  Byte3  Byte4  Byte5  Byte6  Byte7
        23     24     22     123    22     123    234    250

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv162_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv163_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv164_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv166_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>214</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv167_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv168_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>212</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_T03_CLEAR_WAKEUP_FLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_03/source/application/CanTrcv_ConTest_03.c</sourcefile>
      <sourceline>81</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_ClearTrcvWufFlag.
  Check the behavior of ECU when the clear of transceiver wake-up flag is requested via
  CanTrcv_ClearTrcvWufFlag.

Test Object: 
  CanTrcv_ClearTrcvWufFlag

Test Precondition: 
  - CanTrcvPnSupport shall be enabled.
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence).

Test Execution: 
  01: Bring transceiver to SLEEP mode.
  02: Simulate a wakeup in the transceiver hardware
  03: Call CanTrcv_ClearTrcvWufFlag() to clear the WUF flag.
  04: VP (CanTrcv.ASR40.CanTrcv194, CanTrcv214):
      Check that CanTrcv_ClearTrcvWufFlag returns E_OK indicating that WUF flag has been cleared.
  05: VP (CanTrcv.ASR40.CanTrcv195):
      Verify whether CanIf_ClearTrcvWufFlagIndication() is called to indicate CanIf regarding
      clearing of WUF.
  06: VP (CanTrcv.ASR40.CanTrcv194):
      Check that CanTrcv_CheckWakeup indicates no wakeup event.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>194</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv195</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv214</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_CHECK_WAKEUP_FLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_03/source/application/CanTrcv_ConTest_03.c</sourcefile>
      <sourceline>173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_CheckWakeFlag.
  Check that CanIf will be informed regarding the wake up by
  calling CanIf_CheckTrcvWakeFlagIndication

Test Object: 
  CanTrcv_CheckWakeFlag

Test Precondition: 
   - CanTrcv module is initialized.
   - Wakeup shall be enabled.
   - Partial networking shall be enabled.

Test Execution: 
  01: Make a transition to state 'STANDBY' and ensure that there
      is no pending wakeup event in the transceiver hardware
  02: Call CanTrcv_CheckWakeFlag to check the status of WUF.
  03: VP(CanTrcv.ASR40.CanTrcv223):
      Verify that the request for checking the wakeup flag has been accepted.
  04: VP (CanTrcv.ASR40.CanTrcv224.1):
      Verify that CanTrcv calls CanIf_CheckTrcvWakeFlagIndication.
  05: VP (CanTrcv.ASR40.CanTrcv224.2):
      Verify that CanTrcv does not notify EcuM about a pending wakeup.
  06: Simulate a pending event.
  07: Call CanTrcv_CheckWakeFlag to check the status of WUF.
  08: VP(CanTrcv.ASR40.CanTrcv223):
      Verify that the request for checking the wakeup flag has been accepted.
  09: VP (CanTrcv.ASR40.CanTrcv224.2):
      Verify that CanTrcv notifies EcuM about a pending wakeup (bus wakeup).
  10: VP (CanTrcv.ASR40.CanTrcv224.1):
      Verify that CanTrcv inform calls CanIf_CheckTrcvWakeFlagIndication.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv223</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv224.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>201</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv224.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcv_CheckWakeup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_GETTRCVSYSTEMDATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_03/source/application/CanTrcv_ConTest_03.c</sourcefile>
      <sourceline>279</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if the not implemented function CanTrcv_GetTrcvSystemData
    denies the request, even if invoked with valid function parameter.
  
Test Object: 
    CanTrcv_GetTrcvSystemData()
  
Test Precondition: 
    - CanTrcv module is initialized.
  
Test Execution: 
    01: Call CanTrcv_GetTrcvSystemData() with valid function parameter.
    02: VP (CanTrcv.ASR40.CanTrcv213):
        Verify that the function returns E_NOT_OK.
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv213</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_DET_NO_TRCV_CONTROL_PN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_03/source/application/CanTrcv_ConTest_03.c</sourcefile>
      <sourceline>334</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check API of CanTrcv while there is no/incorrect communication towards
    the transceiver and CanTrcvDevErrorDetect switch is enabled.
    The following functions will be tested:
      CanTrcv_ClearTrcvWufFlag().
    Verify that functions raise the development error CANTRCV_E_NO_TRCV_CONTROL.
  
Test Object: 
    CanTrcv_ClearTrcvWufFlag()
  
Test Precondition: 
    - Set SPI stub to return E_NOT_OK for SPI access functions
    - CanTrcv module is initialized.
  
Test Execution: 
    01: Call CanTrcv_ClearTrcvWufFlag().
    02: VP (CanTrcv.ASR40.CanTrcv196):
        Verify that the function returns E_NOT_OK.
    03: VP (CanTrcv.ASR40.CanTrcv196):
        Verify that the function reports CANTRCV_E_NO_TRCV_CONTROL
        to Det with service id 0x0c.
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv196</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_PN_ENABLED_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_04/source/application/CanTrcv_ConTest_04.c</sourcefile>
      <sourceline>79</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the behavior of the CanTrcv channels for different
  settings of parameter CanTrcvPnEnabled during CanTrcv_Init().

Test Object: 
  CanTrcvPnEnabled

Test Precondition: 
  - Configuration as described above

Test Execution: 
  01: VP (CanTrcv.EB.PnSupport):
      The precompile time parameter for Selective wakeup {CANTRCV_PN_SUPPORT}
      is enabled.
  02: Initialize the CanTrcv
  03: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      For channel 0:
      - Partial networking register configured
      - Event Capture register configured
      - operating mode set
      For channel 1:
      - NO partial networking register configured
      - Event Capture register configured
      - operating mode set
      For channel 0:
      - NO partial networking register configured
      - NO event Capture register configured
      - operating mode set

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.PnSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_PN_ENABLED_SETOPMODE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_04/source/application/CanTrcv_ConTest_04.c</sourcefile>
      <sourceline>194</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the behavior of the CanTrcv channels for different
  settings of parameter CanTrcvPnEnabled  during CanTrcv_SetOpMode().

Test Object: 
  CanTrcvPnEnabled

Test Precondition: 
  - Configuration as described above
  - CanTrcv channels are in operation state 'Standby'

Test Execution: 
  Repeat steps 01 - 05 for each transceiver channel:
  01: Set transceiver mode to 'Normal'
  02: VP(): if applicable for the transceiver (according to configuration):
      Check that Icu_DisableEdgeDetection() and Icu_DisableNotification() have been called with the correct IcuChannel
  03: VP(CanTrcv.ASR40.CanTrcv172_Conf): if applicable for the transceiver (according to configuration):
      Check that CanIf_ConfirmPnAvailability() has been called with the correct TransceiverId
  04: VP():
      Check that CanIf_TrcvModeIndication() has been called with the correct TransceiverId
  05: VP ():
      Call CanTrcv_GetOpMode() and check that the transceiver is in state 'Normal'

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_PN_ENABLED_CLEARFLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_04/source/application/CanTrcv_ConTest_04.c</sourcefile>
      <sourceline>297</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the behavior of the CanTrcv channels for different
  settings of parameter CanTrcvPnEnabled  during CanTrcv_ClearTrcvWufFlag().

Test Object: 
  CanTrcvPnEnabled

Test Precondition: 
  - Configuration as described above

Test Execution: 
  01: Call CanTrcv_ClearEvStatusReg for all 3 CanTrcv channels
  02: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      There is only one CanIf_ClearTrcvWufFlagIndication notification for CanTrcv channel 0.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_PN_ENABLED_READFLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_04/source/application/CanTrcv_ConTest_04.c</sourcefile>
      <sourceline>347</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the behavior of the CanTrcv channels for different
  settings of parameter CanTrcvPnEnabled  during CanTrcv_ReadTrcvTimeoutFlag().

Test Object: 
  CanTrcvPnEnabled

Test Precondition: 
  - Configuration as described above

Test Execution: 
  01: Call CanTrcv_ReadTrcvTimeoutFlag for all 3 CanTrcv channels
  02: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      The request is only accepted for CanTrcv channel 0.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_WAKEUPBYBUS_USED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_04/source/application/CanTrcv_ConTest_04.c</sourcefile>
      <sourceline>401</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the behavior of the CanTrcv channels for different
  settings of parameter CanTrcvWakeupByBusUsed.

Test Object: 
  CanTrcvWakeupByBusUsed

Test Precondition: 
  - Configuration as described above

Test Execution: 
  01: Simulate a Can wakeup event on all 3 CanTrcv channels
  02: Check for a wakeup event with CanTrcv_CheckWakeup().
  03: VP (CanTrcv.ASR40.CanTrcv148_Conf):
      CanTrcv reports a wakeup event for channel 0 and 1 (but not for channel 2)

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv148_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_PN_ENABLED_CLEARTRCVTIMEOUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_04/source/application/CanTrcv_ConTest_04.c</sourcefile>
      <sourceline>470</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the behavior of the CanTrcv channels for different
  settings of parameter CanTrcvPnEnabled  during CanTrcv_ClearTrcvTimeoutFlag().

Test Object: 
  CanTrcvPnEnabled

Test Precondition: 
  - Configuration as described above

Test Execution: 
  01: Simulate a CAN bus timeout for all 3 CanTrcv channels
  02: Call CanTrcv_ClearTrcvTimeoutFlag for channel 0.
  03: VP:
      CanTrcv_ClearTrcvTimeoutFlag returns E_OK
  04: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      CAN bus timeout flag was cleared.
  05: Call CanTrcv_ClearTrcvTimeoutFlag for channel 1 and 2.
  06: VP:
      CanTrcv_ClearTrcvTimeoutFlag returns E_NOT_OK
  07: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      CAN bus timeout flags still set.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_PN_ENABLED_READSILENCEFLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_04/source/application/CanTrcv_ConTest_04.c</sourcefile>
      <sourceline>548</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the behavior of the CanTrcv channels for different
  settings of parameter CanTrcvPnEnabled  during CanTrcv_ReadTrcvSilenceFlag().

Test Object: 
  CanTrcvPnEnabled

Test Precondition: 
  - Configuration as described above

Test Execution: 
  01: Call CanTrcv_ReadTrcvSilenceFlag for channel 0.
  02: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      CanTrcv_ClearTrcvTimeoutFlag returns E_OK
  03: VP:
      The flag state is set to CANTRCV_FLAG_CLEARED.
  04: Call CanTrcv_ReadTrcvSilenceFlag for channel 1 and 2.
  05: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      CanTrcv_ClearTrcvTimeoutFlag returns E_NOT_OK

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_PN_ENABLED_CHECKWAKEFLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_04/source/application/CanTrcv_ConTest_04.c</sourcefile>
      <sourceline>612</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the behavior of the CanTrcv channels for different
  settings of parameter CanTrcvPnEnabled during CanTrcv_CheckWakeFlag().

Test Object: 
  CanTrcvPnEnabled

Test Precondition: 
  - Configuration as described above

Test Execution: 
  01: Simulate a wakeup for all 3 channels.
  02: Call CanTrcv_CheckWakeFlag for channel 0.
  03: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      CanTrcv_CheckWakeFlag returns E_OK
  04: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      CanTrcv calls EcuM_SetWakeupEvent
  05: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      CanTrcv calls CanIf_CheckTrcvWakeFlagIndication
  06: Call CanTrcv_CheckWakeFlag for channel 1 and 2.
  07: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      CanTrcv_CheckWakeFlag returns E_NOT_OK
  08: VP (CanTrcv.ASR40.CanTrcv172_Conf):
      No other API function called

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>209</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_CAN_TRCV_INIT_CAN_FLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_05/source/application/CanTrcv_ConTest_05.c</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check the behavior the function CanTrcv_Init when the can wakeup flag is set/cleared.

Test Object: 

Test Precondition: 

Test Execution: 
  01: Initialize the CanTrcv
  02: VP (CanTrcv167):
      CanTrcv signals a can wakeup event for each configured CanTrcv channel.
      SourceId of chanenl0: bit 31
      SourceId of chanenl1: bit 4
  03: clear the wakeup event flag in the transceiver hardware
  04: Initialize the CanTrcv again
  05: VP (CanTrcv167):
      CanTrcv does not signal a power on wakeup event.
      Wakeup Reason is Power ON for both transceivers.
  06: No other function has been called.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcv_CheckWakeup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_CAN_TRCV_INIT_SYSERR_FLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_05/source/application/CanTrcv_ConTest_05.c</sourcefile>
      <sourceline>166</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check the behavior the function CanTrcv_Init when the SYSERR is set/cleared.

Test Object: 
  EcuM wakeup notification

Test Precondition: 
  - A system error flag (e.g. partial networking frame error) set for both CanTrcv channels

Test Execution: 
  01: Initialize the CanTrcv
  02: VP (CanTrcv.ASR40.CanTrcv184, CanTrcv167):
      CanTrcv signalizes a wakeup event for each configured CanTrcv channel.
      SourceId of chanenl0: bit 4
      SourceId of chanenl1: bit 2
  03: clear the system error flags in the transceiver hardware (along with all other flags)
  04: Initialize the CanTrcv again
  05: VP (CanTrcv.ASR40.CanTrcv167):
      CanTrcv does not signal a power on wakeup event.
      Wakeup Reason is Power ON for both transceivers.
  06: VP() No other API function shall be called.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv184</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcv_CheckWakeup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv167</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_PNCONFIRM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_05/source/application/CanTrcv_ConTest_05.c</sourcefile>
      <sourceline>274</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check the that CanTrcv_SetOpMode calls CanIf_ConfirmPnAvailability.

Test Object: 
  SYSERR flag

Test Precondition: 
  - No system error flag is set

Test Execution: 
  01: Make a transition to mode 'STANDBY'
  02: VP (CanTrcv.ASR40.CanTrcv188):
      Check that only CanIf_TrcvModeIndication is called.
  03: Make a transition back to mode 'NORMAL'
  04: VP (CanTrcv.ASR40.CanTrcv188):
      CanTrcv invoked API CanIf_ConfirmPnAvailability in addition to CanIf_TrcvModeIndication

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv188</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_WAKEUP_PRIORITY</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_05/source/application/CanTrcv_ConTest_05.c</sourcefile>
      <sourceline>333</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that the wakeup reason CANTRCV_WU_POWER_ON is notified (if the corresponding
  event is set).
  Check that the wakeup reason CANTRCV_WU_BY_SYSERR is notified (if the corresponding
  event is set).
  Check the correct priorities of the wakeup reasons.

Test Object: 
  - CanTrcv is initialized
  - internally stored wakeup reason is not set.

Test Precondition: 

Test Execution: 
  01: - Set all events that causes a wakeup event.
  02: VP (CanTrcv.EB.GetWuReason.Update):
      Check that the wakeup reason is power on.
  03: Check for wakeup calling CanTrcv_CheckWakeup().
  04: VP (CanTrcv.ASR40.CanTrcv146, CanTrcv143):
          Wakeup is detected and CanTrcv_CheckWakeup() returns E_OK
  05: VP (CanTrcv.ASR40.CanTrcv107, CanTrcv.EB.GetWuReason.Priority, CanTrcv007,
      TrcvWakeupReasonType.Supported):
      Check that can wakeup event is notified as wakeup reason and
      CanTrcv_GetBusWuReason returns E_OK.
  06: Delete can wakeup event.
  07: Check for wakeup calling CanTrcv_CheckWakeup().
  08: VP (CanTrcv.ASR40.CanTrcv146, CanTrcv143):
          Wakeup is detected and CanTrcv_CheckWakeup() returns E_OK.
  09: VP (CanTrcv.ASR40.CanTrcv107, CanTrcv.EB.GetWuReason.Priority, CanTrcv007,
      TrcvWakeupReasonType.Supported):
      Check that wakeup pin event is notified as wakeup reason and
      CanTrcv_GetBusWuReason returns E_OK.
  10: Delete pin wakeup event.
  11: Check for wakeup calling CanTrcv_CheckWakeup().
  12: VP (CanTrcv.ASR40.CanTrcv146, CanTrcv143):
          Wakeup is detected and CanTrcv_CheckWakeup() returns E_OK.
  13: VP (CanTrcv.ASR40.CanTrcv107, CanTrcv.EB.GetWuReason.Priority, CanTrcv007,
      TrcvWakeupReasonType.Supported):
      Check that SYSERR event is notified as wakeup reason and
      CanTrcv_GetBusWuReason returns E_OK.
  14: Delete can failure (part of SYSERR) flag.
  15: Check for wakeup calling CanTrcv_CheckWakeup().
  16: VP (CanTrcv.ASR40.CanTrcv146, CanTrcv143):
          Wakeup is detected and CanTrcv_CheckWakeup() returns E_OK.
  17: VP (CanTrcv.ASR40.CanTrcv107, CanTrcv.EB.GetWuReason.Priority, CanTrcv007,
      TrcvWakeupReasonType.Supported):
      Check that SYSERR event is notified as wakeup reason and
      CanTrcv_GetBusWuReason returns E_OK.
  18: Delete last SYSERR flag.
  19: Check for wakeup calling CanTrcv_CheckWakeup().
  20: VP (CanTrcv.ASR40.CanTrcv146, CanTrcv143):
          wakeup is detected but not reported and CheckWakeup returns E_NOT_OK.
  21: VP (CanTrcv.ASR40.CanTrcv107, CanTrcv.EB.GetWuReason.Priority, CanTrcv007,
      TrcvWakeupReasonType.Supported):
      Check that power on event is notified as wakeup reason and
      CanTrcv_GetBusWuReason returns E_OK.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.GetWuReason.Update</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.GetWuReason.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.TrcvWakeupReasonType.Supported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv143</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_DISABLE_PN_STATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_07/source/application/CanTrcv_ConTest_07.c</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test checks that the function CanTrcv_SetPNActivationState.
  disabled the selective wakeup functionality in the transceiver hardware.

Test Object: 
  API CanTrcv_SetPNActivationState

Test Precondition: 
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - Transceiver channel 0 has selective wakeup configured
  - Transceiver channel 1 has no selective wakeup configured

Test Execution: 
  01: VP(CanTrcv148): Verify that the init state of channel 1 is STANDBY and channel 0 is SLEEP
  02: VP (CanTrcv.ASR40.CanTrcv001):
      Check that transceiver channel 0  has selective wakeup enabled after initialization
  03: VP (CanTrcv.ASR40.CanTrcv001):
      Check that transceiver channel 1  has selective wakeup disabled after initialization
  04: Disable selective wakeup (CanTrcv_SetPNActivationState)
  05: VP (CanTrcv.ASR40.CanTrcv222, CanTrcv219):
      CanTrcv_SetPNActivationState accepts the request.
  06: VP (CanTrcv.ASR40.CanTrcv222):
      Check that transceiver channel 0 has selective wakeup disabled now

Test Input: 

Test Output: 
If ActivationState = PN_ENABLED then CPNC = PNCOK = 1 from CAN Control register.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv222</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>199</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv219</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv148</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_ENABLE_PN_STATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_07/source/application/CanTrcv_ConTest_07.c</sourcefile>
      <sourceline>159</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test checks that the function CanTrcv_SetPNActivationState.
  enabled the selective wakeup functionality in the transceiver hardware.

  The test also checks that the CFDC bit is not set if not configured.

Test Object: 
  API CanTrcv_SetPNActivationState

Test Precondition: 
  - CanTrcv is initialized.
  - Transceiver channel 0 has selective wakeup configured
  - Transceiver channel 1 has no selective wakeup configured

Test Execution: 
  01: Enable selective wakeup (CanTrcv_SetPNActivationState)
  02: VP (CanTrcv.ASR40.CanTrcv221):
      CanTrcv_SetPNActivationState accepts the request.
  03: VP (CanTrcv.ASR40.CanTrcv221):
      Check that transceiver channel 0 has selective wakeup enabled
  04: VP:
      Check that transceiver channel 1 has selective wakeup disabled
  05: VP (CanTrcv.EB.CanFdTolerance):
      Check that CAN-FD passive support is not enabled (disabled in configuration)

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv221</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanFdTolerance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_NO_WUP_EVENT_ENABLED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_07/source/application/CanTrcv_ConTest_07.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test checks that the function CanTrcv_SetOpMode denies the request when set
  into operating mode SLEEP, but there is no wakeup event enabled in the transceiver.

Test Object: 
  API CanTrcv_SetOpMode

Test Precondition: 
  - CanTrcv is initialized.
  - Transceiver channel 1 has no wakeup event configured
  - Transceiver channel 1 is in mode STANDBY

Test Execution: 
  01: Invoke CanTrcv_SetOpMode for channel 1.
  02: VP (CanTrcv.EB.NoRegularWupEvent):
      CanTrcv denies the request
  03: VP (CanTrcv.EB.NoRegularWupEvent):
      CanTrcv is still in mode STANDBY
  04: VP (CanTrcv.EB.NoRegularWupEvent):
      CanTrcv must not indicate a mode indication

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.NoRegularWupEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_TIMEOUT_DETECT_OFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_08/source/application/CanTrcv_ConTest_08.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_ReadTrcvTimeoutFlag.
  Check if the status of the timeout flag can not be obtained from the transceiver
  hardware if this feature is disabled by configuration.

Test Object: 
  API service CanTrcv_ReadTrcvTimeoutFlag

Test Precondition: 
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - CAN bus timeout detection disabled in configuration for tested transceiver

Test Execution: 
  01: VP (CanTrcv.EB.CanTrcvCanFailureDetection_Conf):
      Check that the CanTrcv disables CAN bus timeout detection in the transceiver hardware.
  02: Call CanTrcv_ReadTrcvTimeoutFlag().
  03: VP (CanTrcv.EB.CanTrcvCanFailureDetection_Conf, CanTrcv.ASR40.CanTrcv215):
      CanTrcv_ReadTrcvTimeoutFlag returns with error.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv215</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcvCanFailureDetection_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_CLEAR_TIMEOUT_FLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_08/source/application/CanTrcv_ConTest_08.c</sourcefile>
      <sourceline>122</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_ClearTrcvTimeoutFlag.
  Check that the status of the Timeout flag is reset.

Test Object: None.
Test Precondition: 
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - CAN bus failure detection enabled in configuration for tested transceiver

Test Execution: 
  01: Simulate timeout on the CAN Bus.
  02: Call CanTrcv_ReadTrcvTimeoutFlag() twice
      Ideal: to check that timeout flag is not reset automatically after the first call.
  03: VP:
      CanTrcv_ReadTrcvTimeoutFlag indicates that timeout flag was successful read.
  04: VP:
      CanTrcv reports that there is timeout on the CAN bus.
  05: Clear the timeout flag.
  06: VP (CanTrcv.ASR40.CanTrcv216):
      CanTrcv_ClearTrcvTimeoutFlag returns with success.
  07: Call CanTrcv_ReadTrcvTimeoutFlag()
  08: VP:
      CanTrcv_ReadTrcvTimeoutFlag indicates that timeout flag was successful read.
  09: VP (CanTrcv.ASR40.CanTrcv216):
      CanTrcv reports that there is no timeout on the CAN bus.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv216</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_CHECK_CFDC_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_09/source/application/CanTrcv_ConTest_09.c</sourcefile>
      <sourceline>56</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_Init().
  Check that the CFDC bit is set at initialization, if configured.

Test Object: 
  API service CanTrcv_Init

Test Precondition: 
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - Partial networking and CAN-FD tolerance enabled in the configuration

Test Execution: 
  01: VP (CanTrcv.EB.CanFdTolerance):
      Check that the CFDC bit is set in the Can control register of the transceiver

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.CanFdTolerance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_CHECK_CFDC_SLEEPCYCLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_09/source/application/CanTrcv_ConTest_09.c</sourcefile>
      <sourceline>108</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that the CFDC bit is set after a Sleep cycle as well.
  (TJA1145 data sheet Table 32 states that it won't change)

Test Object: 
  API service CanTrcv_Init

Test Precondition: 
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - Partial networking and CAN-FD tolerance enabled in the configuration

Test Execution: 
  01: VP (CanTrcv.EB.CanFdTolerance):
      Check that the CFDC bit is set in the Can control register of the transceiver
      after initialization
  02: VP (CanTrcv.EB.CanFdTolerance):
      Check that the CFDC bit survives a sleep cycle.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.CanFdTolerance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_NO_WUP_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_NoWakeup/source/application/CanTrcv_ConTest_Pn_NoWakeup.c</sourcefile>
      <sourceline>60</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This tests checks the behavior of the wakeup related API services
  if wakeup is disabled by precompile time parameter 'CanTrcvWakeUpSupport'.

Test Object: 
  Disabled wakeup

Test Precondition: 
  Parameter 'CanTrcvWakeUpSupport' set to 'CANTRCV_WAKEUP_NOT_SUPPORTED'

Test Execution: 
  01: Initialize the CanTrcv.
  02: Simulate a wakeup event for an enabled wakeup source
  03: Check for the existence of a wakeup event.
  04: VP (CanTrcv.ASR40.CanTrcv090):
      CanTrcv_CheckWakeup returns E_NOT_OK.
  05: VP (CanTrcv.ASR40.CanTrcv090):
      CanTrcv_CheckWakeup reports no wakeup.
  06: Check for the wakeup reason
  07: VP (CanTrcv.ASR40.CanTrcv090):
      CanTrcv signalizes that wakeup is not supported
      (value: CANTRCV_WU_NOT_SUPPORTED and E_OK).
  08: Invoke API CanTrcv_SetWakeupMode()
  09: VP (CanTrcv.ASR40.CanTrcv090):
      CanTrcv_SetWakeupMode returns E_NOT_OK.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_NO_WUP_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_NoWakeup/source/application/CanTrcv_ConTest_Pn_NoWakeup.c</sourcefile>
      <sourceline>149</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This tests checks the behavior of the API service CanTrcv_SetWakeup()
  if wakeup is disabled by precompile time parameter 'CanTrcvWakeUpSupport'.

Test Object: 
  Disabled wakeup

Test Precondition: 
  Parameter 'CanTrcvWakeUpSupport' set to 'CANTRCV_WAKEUP_NOT_SUPPORTED'

Test Execution: 
  01: Make a transition to mode 'standby' for transceiver channel 0.
  02: VP (CanTrcv.ASR40.CanTrcv090):
      CanTrcv is in mode 'standby'
  03: Make a transition to mode 'sleep' for transceiver channel 0.
  04: VP (CanTrcv.ASR40.CanTrcv090):
      CanTrcv denies transition to mode 'sleep'
  05: VP (CanTrcv.ASR40.CanTrcv090):
      CanTrcv is still in mode 'standby'

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_NO_WUP_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Pn/CanTrcv_Conformance_Pn_NoWakeup/source/application/CanTrcv_ConTest_Pn_NoWakeup.c</sourcefile>
      <sourceline>220</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This tests checks the behavior of the wakeup related API services
  if wakeup is disabled by precompile time parameter 'CanTrcvWakeUpSupport'.

Test Object: 
  Disabled wakeup

Test Precondition: 
  Parameter 'CanTrcvWakeUpSupport' set to 'CANTRCV_WAKEUP_NOT_SUPPORTED'
  CanTrcv is initialized and mode is 'normal'

Test Execution: 
  01: Make a transition to mode 'normal' for transceiver channel 0.
  02: VP (CanTrcv.ASR40.CanTrcv090):
      CanTrcv is in mode 'normal'

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv090</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_OP_MODE_SEQ</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_02/source/application/CanTrcv_ConTest_02.c</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that the CanTrcv writes the correct Operation mode code into the transceiver
  register.

Test Object: 

Test Precondition: 
  CanTrcv module is initialized

Test Execution: 
  01: Step transceiver channel 0 into mode 'standby'
  02: VP:
      Check that CanTrcv_SetOpMode returns success.
  03: VP:
      The CanTrcv writes the correct code to the transceiver register.
  04: Step transceiver channel 0 into mode 'sleep'
  05: VP:
      Check that CanTrcv_SetOpMode returns success.
  06: VP:
      The CanTrcv writes the correct code to the transceiver register.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv055</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_INV_OPMODE_NO_DET</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_02/source/application/CanTrcv_ConTest_02.c</sourcefile>
      <sourceline>139</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check the behavior the function CanTrcv_SetOpMode when invoked with an invalid
  OpMode and development error detection is disabled.

Test Object: 
  - CanTrcvDevErrorDetect := false
  - CanTrcv is in OpMode 'Normal'

Test Precondition: 

Test Execution: 
  01: Make a transition to mode 'SLEEP'
  02: VP:
      Check that the CanTrcv_SetOpMode denies the request.
  03: VP:
      Check that the CanTrcv stays in mode 'NORMAL'
  04: VP:
      Check that there is no mode indication.
  05: Make a transition to mode 'STANDBY'
  06: Make a transition to mode 'SLEEP'
  07: Make a transition to mode 'STANDBY'
  08: VP:
      Check that the CanTrcv_SetOpMode denies the request.
  09: VP:
      Check that the CanTrcv stays in mode 'SLEEP'
  10: VP:
      Check that there is no mode indication.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.SetOpMode.InvalidMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv023</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_SET_WAKEUP_MODE_ENABLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_02/source/application/CanTrcv_ConTest_02.c</sourcefile>
      <sourceline>248</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
  Check functionality of CanTrcv_SetWakeupMode.
  Check the behavior of ECU when the WakeUp mode is set to CANTRCV_WUMODE_ENABLE.
&lt;/para&gt;

Test Object: 
  CanTrcv_SetWakeupMode

Test Precondition: 
  - CanTrcvWakeupModeApiEnable shall be enabled.
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)

Test Execution: 
  01: Bring the transceiver to SLEEP mode.
  02: Simulate a wakeup event in the transceiver hardware
  03: Call CanTrcv_SetWakeupMode with CANTRCV_WUMODE_ENABLE to enable wake up events.
  04: VP(CanTrcv.ASR40.CanTrcv009, CanTrcv.ASR40.CanTrcv111):
      Verify that setting of wakeup mode is successful.
  05: Call CanTrcv_CheckWakeup to check whether a wake up event is detected.
  06: VP:
      CanTrcv_CheckWakeup shall return E_OK indicating that a wake up event is detected.
  07: VP:
      CanTrcv inform EcuM about wakeup event.
  08: Call CanTrcv_GetBusWuReason to get the reason of wake up.
  09: CanTrcv_GetBusWuReason shall inform the wake up reason as CANTRCV_WU_BY_BUS.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv111</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.CanTrcv_CheckWakeup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_SET_WAKEUP_MODE_DISABLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_02/source/application/CanTrcv_ConTest_02.c</sourcefile>
      <sourceline>340</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_SetWakeupMode.
  Check the behavior of ECU when the WakeUp mode is set to CANTRCV_WUMODE_DISABLE and then to
  CANTRCV_WUMODE_ENABLE.
  The wake up event shall be stored if the event happened when WakeUp mode is disabled.
&lt;/para&gt;

Test Object: 
  CanTrcv_SetWakeupMode

Test Precondition: 
  - CanTrcvWakeupModeApiEnable shall be enabled.
  - The CanTrcv module is initialized (Power-on-reset set to force initialization sequence)
  - CanTrcv is in sleep mode

Test Execution: 
    01: VP (CanTrcv.ASR40.CanTrcv009):
        Call CanTrcv_SetWakeupMode with TrcvWakeupMode = CANTRCV_WUMODE_DISABLE and verify that
        the request is accepted.
    02: Simulate a wake up event by bus.
    03: VP:
        Call CanTrcv_CheckWakeup() and verify that it returned E_NOT_OK indicating that
        no wakeup occurred.
    04: Clear all events.
    05: VP(CanTrcv.ASR40.CanTrcv009):
           Call CanTrcv_SetWakeupMode with TrcvWakeupMode = CANTRCV_WUMODE_ENABLE and verify that
           the request is accepted.
    06: VP(CanTrcv.ASR40.CanTrcv093): CanTrcv shall call EcuM_SetWakeupreason while enabling the wakeup mode.
    07: VP(): Call CanTrcv_GetBusWuReason() and verify that wakeup is CANTRCV_WU_POWER_ON.

Test Input: None.
Test Output: 
The CAN transceiver shouldn't wake up if the Wake-up mode is disabled.
Check that the wake-up events are stored.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv093</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.TrcvWakeupReasonType.Supported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_SET_WAKEUP_MODE_CLEAR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_02/source/application/CanTrcv_ConTest_02.c</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check functionality of CanTrcv_SetWakeupMode.
  Check the behaviour of ECU when the WakeUp mode is set to CANTRCV_WUMODE_DISABLE and then to
  CANTRCV_WUMODE_CLEAR.
  Check that a stored wakeup event is cleared when CanTrcv_SetWakeupMode is called with
  CANTRCV_WUMODE_CLEAR

Test Object: 
  CanTrcv_SetWakeupMode

Test Precondition: 
  CanTrcv module is initialized and the wake-up events are enabled.
  Transceiver is in sleep mode.

Test Execution: 
    01: Call CanTrcv_SetWakeupMode with TrcvWakeupMode = CANTRCV_WUMODE_ENABLE.
    02: Simulate a wake up event by bus: a wake up event pending for the addressed bus.
    03: Call CanTrcv_SetWakeupMode with TrcvWakeupMode = CANTRCV_WUMODE_CLEAR.
    04: VP (CanTrcv.ASR40.CanTrcv094):
        Check that the request is accepted.
    05: VP(CanTrcv.ASR40.CanTrcv009, CanTrcv.ASR40.CanTrcv094):
        Call CanTrcv_CheckWakeup and verify that no wakeup event is reported.
    06: Simulate a wake up event by bus: a wake up event pending for the addressed bus.
    07: VP:
        Call CanTrcv_CheckWakeup and verify that a can wake up is detected in the transceiver.

Test Input: 

Test Output: 
The CAN transceiver shouldn't wake up if the Wake-up mode is disabled.
Check that the wake-up events are cleared.
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv094</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv095</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_WAKEUP_REASON_BUS_PIN</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_02/source/application/CanTrcv_ConTest_02.c</sourcefile>
      <sourceline>562</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that the wakeup reason CANTRCV_WU_BY_BUS, CANTRCV_WU_BY_PIN and
  CANTRCV_WU_INTERNALLY are notified (if the corresponding event are set).
  Check the correct priorities of the wakeup reasons.

Test Object: 
  - CanTrcv is initialized
  - internally stored wakeup reason is not set.
  - CanTrcv is in operation mode SLEEP.

Test Precondition: 

Test Execution: 
  01: - Set all events that causes a wakeup-by-bus event.
      - Set all events that causes a pin wakeup event.
      - Make a transition to operation mode NORMAL for internal wakeup
  02: VP (CanTrcv.EB.TrcvWakeupReasonType.Supported, GetWuReason.Update):
      Check that internally wakeup event is notified as wakeup reason.
  03: Switch transceiver to standby mode and set can wakeup event
  04: Check for wakeup.
  05: VP (CanTrcv.ASR40.CanTrcv146):
      Wakeup is detected.
  06: VP (CanTrcv.ASR40.CanTrcv107, CanTrcv.EB.GetWuReason.Priority):
      Check that wakeup-by-bus event is notified as wakeup reason.
  07: Delete wakeup-by-bus event
  08: VP (CanTrcv.EB.GetWuReason.Update):
      Check that wakeup-by-bus event is notified as wakeup reason now.
  09: Switch the transceiver to Normal mode, causing an internal wakeup.
  10: VP() check that still the Can wakeup is reported, since the higher priority.
  11: Delete wakeup-by-pin event
  12: VP (CanTrcv.EB.GetWuReason.Priority):
      Check that no wakeup event is notified now.
  13: Make a transition from STANDBY to NORMAL to trigger internally wakeup
  14: VP (CanTrcv.EB.GetWuReason.Update):
      Check that internally wakeup event is notified as wakeup reason now.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.GetWuReason.Update</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.GetWuReason.Priority</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.TrcvWakeupReasonType.Supported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv146</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_SPI_RETRIES</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Access/source/application/CanTrcv_ConTest_Spi_Access.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks if the CanTrcv retries to access the SPI bus
  after a failling attempt. Number of retries shall depend on configuration
  parameter CanTrcvSPICommRetries.

Test Object: 

Test Precondition: 
  - CanTrcvSPICommRetries set to 3.
  - DET error detection enabled
  - CanTrcv shall be initialized

Test Execution: 
  01: The code stub function Spi_SyncTransmit shall return an error.
  02: Call CanTrcv_GetOpMode().
  03: VP (CanTrcv.ASR40.CanTrcv179_Conf):
      CanTrcv_GetOpMode return an error.
  04: VP (CanTrcv.ASR40.CanTrcv179_Conf):
      CanTrcv tried to transmit 4 times (1 + 3 retransmissions).
  05: VP (CanTrcv.ASR40.CanTrcv179_Conf):
      A DET error with error ID CANTRCV_1_T03_E_NO_TRCV_CONTROL occurs.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv179_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_T03_LOOP_SPI_FAILURE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_LoopSpiFailure.c</sourcefile>
      <sourceline>55</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that checks the behavior for the functions CanTrcv_Init, CanTrcv_SetOpMode
  and CanTrcv_SetWakeupMode when a SPI error happens at different execution points
  inside the functions.

Test Object: 
  SPI access error

Test Precondition: 
  DET is enabled

Test Execution: 
  01: VP (CanTrcv.ASR40.CanTrcv113):
      check that CanTrcv_Init reports a DET error when an invalid SPI access
      is detected.
      Check that this always happens, independent of which SPI access fails
      inside the function.
  02: Initialize the CanTrcv without any SPI error
  03: Make a transition to STANDBY (for the full range of SPI accesses
      side CanTrcv_SetOpMode)
  04: VP (CanTrcv.ASR40.CanTrcv114):
      check that CanTrcv_SetOpMode reports a DET error when an invalid SPI access
      is detected during a transition to NORMAL.
      Check that this always happens, independent of which SPI access fails
      inside the function.
  05: Make a transition to NORMAL (for the full range of SPI accesses
      side CanTrcv_SetOpMode)
  06: VP (CanTrcv.ASR40.CanTrcv114):
      check that CanTrcv_SetOpMode reports a DET error when an invalid SPI access
      is detected during a transition to STANDBY.
      Check that this always happens, independent of which SPI access fails
      inside the function.
  07: Make a transition to STANDBY (for the full range of SPI accesses
      side CanTrcv_SetOpMode)
  08: VP (CanTrcv.ASR40.CanTrcv114):
      check that CanTrcv_SetOpMode reports a DET error when an invalid SPI access
      is detected during a transition to SLEEP.
      Check that this always happens, independent of which SPI access fails
      inside the function.
  09: VP (CanTrcv.ASR40.CanTrcv117):
      check that CanTrcv_SetWakeupMode reports a DET error when an invalid SPI access
      is detected during a CLEAN request.
      Check that this always happens, independent of which SPI access fails
      inside the function.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv117</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_LOOP_SPI_FAILURE_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_LoopSpiFailure.c</sourcefile>
      <sourceline>241</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that checks the behavior for the functions CanTrcv_ReadTrcvTimeoutFlag,
  CanTrcv_ReadTrcvSilenceFlag, CanTrcv_SetPNActivationState and CanTrcv_CheckWakeup
  when a SPI error happens at different execution points inside the functions.

Test Object: 
  SPI access error

Test Precondition: 
  - DET is enabled
  - CanTrcv is initialized

Test Execution: 
  01: VP (CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvTimeoutFlag):
      check that CanTrcv_ReadTrcvTimeoutFlag reports a DET error when an invalid SPI access
      is detected.
      Check that this always happens, independent of which SPI access fails
      inside the function.
  02: VP (CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvSilenceFlag):
      check that CanTrcv_ReadTrcvSilenceFlag reports a DET error when an invalid SPI access
      is detected.
      Check that this always happens, independent of which SPI access fails
      inside the function.
  03: VP (CanTrcv.EB.E_NO_TRCV_CONTROL.SetPNActivationState):
      check that CanTrcv_SetPNActivationState reports a DET error when an invalid SPI access
      is detected.
      Check that this always happens, independent of which SPI access fails
      inside the function.
  04: VP (CanTrcv.EB.E_NO_TRCV_CONTROL.CheckWakeup):
      check that CanTrcv_CheckWakeup reports a DET error when an invalid SPI access
      is detected.
      Check that this always happens, independent of which SPI access fails
      inside the function.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvTimeoutFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.E_NO_TRCV_CONTROL.ReadTrcvSilenceFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.E_NO_TRCV_CONTROL.SetPNActivationState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.EB.E_NO_TRCV_CONTROL.CheckWakeup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_T03_TRCV_NOT_NORMAL</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_T03.c</sourcefile>
      <sourceline>65</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify the transition from SLEEP to STANDBY
  
Test Object: 
    CanTrcv_SetOpMode()
  
Test Precondition: 
    CanTrcv module is initialized.
    CANTRCV_INIT_STATE is configured as CANTRCV_TRCVMODE_STANDBY.
  
Test Execution: 
    01: Call CanTrcv_GetOpMode and verify that current state is STANDBY
    02: Call CanTrcv_SetOpMode to set the transceiver into SLEEP mode
    03: VP(CanTrcv120): Call CanTrcv_SetOpMode to set the transceiver into STANDBY mode and
        verify that it returns E_NOT_OK and CANTRCV_E_TRCV_NOT_NORMAL is reported to DET
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv120</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_DET_UNINIT_READTIMEOUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_T03.c</sourcefile>
      <sourceline>143</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that API CanTrcv_ReadTrcvTimeoutFlag reports the DET error
    CANTRCV_E_UNINIT when called uninitialized
  
Test Object: 
    CanTrcv_ReadTrcvTimeoutFlag()
  
Test Precondition: 
    - CanTrcv is uninitialized
    - DET is enabled
  
Test Execution: 
    01: Call CanTrcv_ReadTrcvTimeoutFlag().
    02: VP (CanTrcv.EB.E_UNINIT.ReadTrcvTimeoutFlag):
        CanTrcv_ReadTrcvTimeoutFlag() reports CANTRCV_E_UNINIT.
    03: VP (CanTrcv.EB.E_UNINIT.ReadTrcvTimeoutFlag):
        Call CanTrcv_ReadTrcvTimeoutFlag() was rejected.
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.E_UNINIT.ReadTrcvTimeoutFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_DET_UNINIT_CLEARTIMEOUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_T03.c</sourcefile>
      <sourceline>203</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that API CanTrcv_ClearTrcvTimeoutFlag reports the DET error
    CANTRCV_E_UNINIT when called uninitialized
  
Test Object: 
    CanTrcv_ClearTrcvTimeoutFlag()
  
Test Precondition: 
    - CanTrcv is uninitialized
    - DET is enabled
  
Test Execution: 
    01: Call CanTrcv_ClearTrcvTimeoutFlag().
    02: VP (CanTrcv.EB.E_UNINIT.ClearTrcvTimeoutFlag):
        CanTrcv_ClearTrcvTimeoutFlag() reports CANTRCV_E_UNINIT.
    03: VP (CanTrcv.EB.E_UNINIT.ClearTrcvTimeoutFlag):
        Call CanTrcv_ClearTrcvTimeoutFlag() was rejected.
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.E_UNINIT.ClearTrcvTimeoutFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_DET_UNINIT_READSILENCE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_T03.c</sourcefile>
      <sourceline>257</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that API CanTrcv_ReadTrcvSilenceFlag reports the DET error
    CANTRCV_E_UNINIT when called uninitialized
  
Test Object: 
    CanTrcv_ReadTrcvSilenceFlag()
  
Test Precondition: 
    - CanTrcv is uninitialized
    - DET is enabled
  
Test Execution: 
    01: Call CanTrcv_ReadTrcvSilenceFlag().
    02: VP (CanTrcv.EB.E_UNINIT.ReadTrcvSilenceFlag):
        CanTrcv_ReadTrcvSilenceFlag() reports CANTRCV_E_UNINIT.
    03: VP (CanTrcv.EB.E_UNINIT.ReadTrcvSilenceFlag):
        Call CanTrcv_ReadTrcvSilenceFlag() was rejected.
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.E_UNINIT.ReadTrcvSilenceFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_DET_UNINIT_CHECKWAKEFLAG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_T03.c</sourcefile>
      <sourceline>313</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that API CanTrcv_CheckWakeFlag reports the DET error
    CANTRCV_E_UNINIT when called uninitialized
  
Test Object: 
    CanTrcv_CheckWakeFlag()
  
Test Precondition: 
    - CanTrcv is uninitialized
    - DET is enabled
  
Test Execution: 
    01: Call CanTrcv_CheckWakeFlag().
    02: VP (CanTrcv.EB.E_UNINIT.CheckWakeFlag):
        CanTrcv_CheckWakeFlag() reports CANTRCV_E_UNINIT.
    03: VP (CanTrcv.EB.E_UNINIT.CheckWakeFlag):
        Call CanTrcv_CheckWakeFlag() was rejected.
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.E_UNINIT.CheckWakeFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_DET_PARAM_POINTER_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_T03.c</sourcefile>
      <sourceline>368</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check API of CanTrcv while using a null pointer as parameter value and
    CanTrcvDevErrorDetect switch is enabled.
    The following functions will be tested:
      CanTrcv_Init()
    Verify that functions raise the development error CANTRCV_E_PARAM_POINTER.
  
Test Object: 
    CanTrcv_Init()
  
Test Precondition: 
    - CanTrcv is uninitialized
    - DET is enabled
    - PbcfgM support disabled
  
Test Execution: 
    01: VP (CanTrcv185.1):
        Call CanTrcv_Init() and verify that function reports CANTRCV_E_PARAM_POINTER
        to Det with service id 0x00
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv185.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_DET_NO_TRCV_CONTROL</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_T03.c</sourcefile>
      <sourceline>416</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check API of CanTrcv while there is no/incorrect communication towards
    the transceiver and CanTrcvDevErrorDetect switch is enabled.
    The following functions will be tested:
      CanTrcv_Init(), CanTrcv_SetOpMode(), CanTrcv_GetOpMode(),
      CanTrcv_GetBusWuReason(), CanTrcv_SetWakeupMode().
    Verify that functions raise the development error CANTRCV_E_NO_TRCV_CONTROL.
  
Test Object: 
    CanTrcv_Init()
    CanTrcv_SetOpMode()
    CanTrcv_GetOpMode()
    CanTrcv_GetBusWuReason()
    CanTrcv_SetWakeupMode()
  
Test Precondition: 
    - Set SPI stub to return E_NOT_OK for SPI access functions
  
Test Execution: 
    01: VP(CanTrcv113)
        Call CanTrcv_Init() and verify that function reports CANTRCV_E_NO_TRCV_CONTROL
        to Det with service id 0x00
    02: Successful initialize CanTrcv.
    03: Set SPI stub to return E_NOT_OK for SPI access functions.
    04: VP(CanTrcv114)
        Call CanTrcv_SetOpMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_NO_TRCV_CONTROL to Det with service id 0x01
    05: VP(CanTrcv115)
        Call CanTrcv_GetOpMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_NO_TRCV_CONTROL to Det with service id 0x02
    06: VP(CanTrcv117)
        Call CanTrcv_SetWakeupMode() and verify that function returns E_NOT_OK
        and reports CANTRCV_E_NO_TRCV_CONTROL to Det with service id 0x05
  
Test Input: None.
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv113</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv114</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv115</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv117</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_T03_SETOPMODE_SAME_MODE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_Det/source/application/CanTrcv_ConTest_Det_T03.c</sourcefile>
      <sourceline>526</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that seting the module to SLEEP state while in SLEEP state will not trigger any DET
  
Test Object: 
  SetOpMode
  
Test Precondition: 
    DET is enabled
  
Test Execution: 
    01: Get the module to SLEEP state
    02: VP(CanTrcv102): Call SetOpMode with mode SLEEP and verify that it returns E_OK
    03: (CanTrcv158):
         Verify that CanIf_TrcvModeIndication was called when switching from STANDBY to SLEEP
    04: Set the mode to SLEEP while the module is in SLEEP mode
    05: (CanTrcv158):
         Verify that CanIf_TrcvModeIndication was called when switching from SLEEP to SLEEP
    06:VP(CanTrcv161): Verify that no DET was reported
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv161</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_OP_MODE_NO_API</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_NoOpModeApi/source/application/CanTrcv_ConTest_NoOpModeApi.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  Check that the CanTrcv writes the correct Operation mode code into the transceiver
  register during CanTrcv_Init.
  The API CanTrcv_SetOpMode is disabled

Test Object: 

Test Precondition: 
  - CanTrcv module is not initialized
  - CanTrcvOperationModeApiEnable
  - CanTrcvInitState of channel 0 set to mode NORMAL
  - CanTrcvInitState of channel 1 set to mode STANDBY

Test Execution: 
  01: Initialize the CanTrcv
  02: VP (CanTrcv.EB.OperationMode.ApiEnable):
      CanTrcv channel 0 is in operation mode CANTRCV_TRCVMODE_NORMAL.
  03: VP (CanTrcv.EB.OperationMode.ApiEnable):
      CanTrcv channel 1 is in operation mode CANTRCV_TRCVMODE_STANDBY.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.EB.OperationMode.ApiEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>EB_CANTRCV_ICU_NOTIFICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_References/source/application/CanTrcv_ConTest_References.c</sourcefile>
      <sourceline>75</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the notifications for module Icu.

Test Object: 
  - CanTrcv is initialized

Test Precondition: 

Test Execution: 
  01: Make a transition to state 'standby' for transceiver channel 0.
  02: VP (CanTrcv.ASR40.CanTrcv171, CanTrcv.ASR40.CanTrcv172):
      CanTrcv enables the Icu channels
  03: Make a transition to state 'normal' for transceiver channel 0.
  04: VP (CanTrcv.ASR40.CanTrcv171, CanTrcv.ASR40.CanTrcv173):
      CanTrcv disables the Icu channels
  05: Make a transition from state 'sleep' to 'normal' for transceiver channel 1.
  06: VP (CanTrcv.ASR40.CanTrcv171, CanTrcv.ASR40.CanTrcv173):
      CanTrcv disables the Icu channels

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv171</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv173</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv172.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv173.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
    <specobject>
      <id>EB_CANTRCV_SPI_SEQ_REF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanTrcv)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanTrcv/test/ts5/Include/CanTrcv_Test_Applications/CanTrcv_Spi/CanTrcv_Conformance_Spi_References/source/application/CanTrcv_ConTest_References.c</sourcefile>
      <sourceline>175</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  This test sequence checks the configured reference into the Spi module.

Test Object: 
  - CanTrcv is initialized

Test Precondition: 

Test Execution: 
  01: Call CanTrcv_GetOpMode for transceiver channel 1.
  02: VP (CanTrcv.ASR40.CanTrcv151_Conf, CanTrcv.ASR40.CanTrcv155_Conf):
      Check that the SPI access happens with the correct Channel and Sequence.
  03: Call CanTrcv_GetOpMode for transceiver channel 0.
  04: VP (CanTrcv.ASR40.CanTrcv151_Conf, CanTrcv.ASR40.CanTrcv155_Conf):
      Check that the SPI access happens with the correct Channel and Sequence.

Test Input: 

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv151_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
        <provcov>
          <linksto>CanTrcv.ASR40.CanTrcv155_Conf</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
