<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_Dccm_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/ReqM2_Native/asc_Dccm_requirements_EB_Requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/common_req/Dccm_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 21:47:24 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_Dccm_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/ReqM2_Native/asc_Dccm_requirements_EB_Requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/common_req/Dccm_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="swurs">
    <specobject>
      <id>Dccm.DataConsistency.SchMUsage</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The Dccm shall use SchM APIs for implementing critical sections (by default).
      </description>
      <tags>
        <tag>basic</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.Dccm.SchMEnterCS</srcid><srcstatus/><internalId>160</internalId></linkedfrom><linkedfrom><srcid>dsn.Dccm.SchMLeaveCS</srcid><srcstatus/><internalId>161</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

    <specobject>
      <id>Dccm.EB.BSWMDGeneration_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The Dccm module's generator shall generate a basic software
        module description (BSWMD) based on the Dccm module's
        configuration containing information on the exclusive areas
        required by the Dccm module's implementation.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_OUTPUT</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

    <specobject>
      <id>Dccm.EB.BSWMDGeneration_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The Dccm module's BSWMD shall be generated using a generator mode named "generate_swcd".
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_OUTPUT</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

    <specobject>
      <id>Dccm.Config.Id</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The code generator shall generate a unique configuration Id (hash value) into the file Dccm_Cfg.h
      </description>
      <rationale>
        Requested by customers to support their configuration management.
      </rationale>
      <tags>
        <tag>General Requirement</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_GET_DIAGNOSTIC_PROTOCOL_STATUS_OUTPUT</srcid><srcstatus/><internalId>180</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_NO_RETRY_WRONG_LENGTH_10_4</srcid><srcstatus/><internalId>280</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

    <specobject>
      <id>Dccm.Config.Dccm_Dev_Error_Detect</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Name:      Dccm_Dev_Error_Detect (Dccm_Dev_Error_Detect)
        Description:  The detection of development errors within the Dccm module shall be
                configurable (ON/OFF) at pre-compile time. The switch Dccm_Dev_Error_Detect
                shall activate or deactivate the detection of all development errors.
      </description>
      <tags>
        <tag>General Requirement</tag>
        <tag>Configuration Specification</tag>
        <tag>Dccm interfacing</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_DevErrorDetectOff</srcid><srcstatus/><internalId>163</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_DevErrorDetectOn</srcid><srcstatus/><internalId>164</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_NOT_SUPPORTED_OUTPUT</srcid><srcstatus/><internalId>269</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_REQUEST_OUT_OF_RANGE_OUTPUT</srcid><srcstatus/><internalId>271</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_NOT_SUPPORTED_IN_ACTIVE_SESSION_OUTPUT</srcid><srcstatus/><internalId>272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

    <specobject>
      <id>Dccm.Config.DccmMainfunctionCycle</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Name:        DccmTaskTime (DCCM_EXE_INTERVAL)
        Description:    Allow to configure the time for the periodic cyclic task.
        Notes:        This configuration value shall be equal to the value in the
                  ScheduleManager module. The AUTOSAR configuration standard is to
                  use SI units, so this  parameter is defined as float value in
                  seconds. Dccm configuration tools  must convert this float value to
                  the appropriate value format for the use in  the software
                  implementation of Dccm. min: A negative value is not allowed.
        upperMultiplicity:  Exactly one TaskTime must be specified per configuration.
        lowerMultiplicity:  Exactly one TaskTime must be specified per configuration.
        Multiplicity:    1
        Type:        EcucFloatParamDef
        Range:        0 .. 100
        Default value    0.005
        Scope/Dependency:  scope: module
      </description>
      <comment>Limitation on range. Changed to 0.001..1 sec</comment>
      <tags>
        <tag>Configuration Specification</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_RESPONSE_EXCEEDS_BUFFER_LENGTH</srcid><srcstatus/><internalId>232</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_SINGLE_TRANSFER_OUTPUT</srcid><srcstatus/><internalId>235</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_NOT_SUPPORTED_IN_ACTIVE_SESSION_OUTPUT</srcid><srcstatus/><internalId>272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

    <specobject>
      <id>Dccm.Config.DccmPhysicalPduIds</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:    DccmPhysicalPduIds
        Description:    This container contains a list of target ECU that can be
                  used for physical communication (PhysicalRxPduIds / PhysicalTxPduIds)
      </description>
      <tags>
        <tag>Configuration Specification</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RXINDICATION_RESPONSE_WRONG_BUFFERSIZE</srcid><srcstatus/><internalId>246</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_RX_DATA_WRONG_BUFFERSIZE</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

    <specobject>
      <id>Dccm.EB.CustomXPath_unit_tests</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        There may be unit tests for the custom xpath code.
      </description>
      <comment>
        Unit tests are not meant to guarantee the correctness of the code, they are rather a tool
        for the developer to get feedback at the early stages of development and to increase
        maintainability of the code.
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_Disable_TesterPresent_Zero_NumberOfProtocolIdsForTesterPresentMessages</srcid><srcstatus/><internalId>376</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

    <specobject>
      <id>Dccm.PositiveResponseCodes</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The Dccm module shall use the following positive response codes:
        Type                                        Relevance    Related error code            Value [hex]
        Requested service executed without error    Development  DCCM_RSP_OK                   0x00
        Response when Tx confirmation was OK        Development  DCCM_TX_CONFIRMATION_OK       0x11
        and suppress bit is set
      </description>
      <tags>
        <tag>Interfacing</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_WRONG_TXPDUID</srcid><srcstatus/><internalId>308</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_WRONG_SIZE_FOR_PDUR</srcid><srcstatus/><internalId>309</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_OUTPUT</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DIFFERENT_TIMING_OUTPUT</srcid><srcstatus/><internalId>330</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_OUTPUT_NoNotificationToSwc</srcid><srcstatus/><internalId>345</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DIFFERENT_TIMING_OUTPUT_NoNotificationToSwc</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>Dccm.ErrorCodes001</id>
      <status>approved</status>
      <source>EB</source>
      <version>5</version>
      <description>
        The Dccm module shall detect the following errors and exceptions:
        Error code                                 Value [hex]     Relevance       Details
        DCCM_RSP_TX_FAILED                                0x01     Development     Data transmission has failed.
        DCCM_RSP_TX_TRIG_FAILED                           0x02     Development     Triggering of data transmission
                                                                                   has failed.
        DCCM_RSP_RX_FAILED                                0x03     Development     Data receiving has failed
                                                                                   response. Error code is copied
                                                                                   into response buffer.
        DCCM_RSP_INVALID_RESPONSE_PENDING_FORMAT          0x04     Development     Response to indicate that a
                                                                                   ResponsePending message was
                                                                                   received for another service,
                                                                                   not the one for which the
                                                                                   request was made.
        DCCM_RSP_TIMEOUT_P2CLIENT                         0x05     Development     No response from server during
                                                                                   the P2Client or P2*Client timeout.
        DCCM_RSP_TIMEOUT_INTERNAL                         0x06     Development     No response from server during
                                                                                   the internal timer.
        DCCM_RSP_WRONG_BUFFER_SIZE                        0x08     Development     Receive buffer size is wrong.
        DCCM_RSP_TIMEOUT_P6CLIENT                         0x09     Development     No response from server during
                                                                                   the P6Client or P6*Client timeout.
        DCCM_RSP_TIMEOUT_P2CLIENT_SPRMIB_TRUE             0x0A     Development     No response from server during
                                                                                   the P2Client or P2*Client timeout,
                                                                                   but the request was sent with
                                                                                   suppressPosRspMsgIndicationBit
                                                                                   set to TRUE.
        DCCM_RSP_TIMEOUT_P6CLIENT_SPRMIB_TRUE             0x0B     Development     No response from server during
                                                                                   the P6Client or P6*Client timeout,
                                                                                   but the request was sent with
                                                                                   suppressPosRspMsgIndicationBit
                                                                                   set to TRUE.
      </description>
      <tags>
        <tag>Interfacing</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Dccm_PhysicalComm_SPRMIBTrue_NoResponse</srcid><srcstatus/><internalId>196</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_INCOMPLETE_RESPONSE</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_P2CLIENT_TIMEOUT</srcid><srcstatus/><internalId>293</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TRANSMISSION_TX_NULL_AVAILABLE_DATA</srcid><srcstatus/><internalId>305</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

    <specobject>
      <id>Dccm.ErrorCodes002</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The Dccm module shall understand and handle the following UDS Server return codes:
        Type or error                               Related error code                                Value [hex]
        Request correctly received but the action   DCCM_E_RESPONSE_PENDING                             0x78
        was not performed yet.
      </description>
      <tags>
        <tag>Interfacing</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_MULTIPLE_TRANSFER_OUTPUT</srcid><srcstatus/><internalId>234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>Dccm.Error_Reporting</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If the development error detection is enabled for this module, for every request except
        Dccm_Init, it shall be ensured that the Dccm module is already initialized and detected errors
        shall be reported to the Development Error Tracer.
      </description>
      <tags>
        <tag>Error Classification</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_INVALID_KEY_OUTPUT</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_VEHICLE_SPEED_TOO_HIGH_OUTPUT</srcid><srcstatus/><internalId>277</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_PROTOCOL_NOT_ALLOCATED</srcid><srcstatus/><internalId>324</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_BEFORE_MODULE_INITIALIZATION</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>Dccm.ModuleId</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The header file of the Dccm, Dccm.h, shall provide a module ID called DCCM_MODULE_ID set to the value 0xff.
      </description>
      <tags>
        <tag>Error Classification</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TWO_MESSAGES_OUTPUT</srcid><srcstatus/><internalId>227</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>Dccm.Api.Interfacing.Types</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The folowing types should be included in Dccm_Types.h:
          Dccm_CallbackType - defines a new type for the callback function
          Dccm_BufferStreamingCallbackType - defines a type to request next chunk of data in case Buffer Streaming is enabled
          Dccm_TimeoutType - type for timeout counter
          Dccm_DiagnosticProtocolStatusType -  status of a diagnostic protocol
          Dccm_ProtocolIdType - type used to identify the diagnostic protocol
          Dccm_DiagProtocolResponseCodeType - this type contains all Dccm Diagnostic Protocol result values, which can be reported via the callback method
      </description>
      <tags>
        <tag>Header file structure</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATE_PHYSICAL_PROTOCOLS_EXCEEDING_NR_MAX_OF_PHYSICAL_PROTOCOLS</srcid><srcstatus/><internalId>192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SupportedServices</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The generic SendRequest Dccm function will allow user to send any payload request including the standard UDS Services:
        Service                             Function group                            Request SID   Response SID
        Diagnostic Session Control          Diagnostic and Communication Management   0x10          0x50
        ECU Reset                           Diagnostic and Communication Management   0x11          0x51
        Security Access                     Diagnostic and Communication Management   0x27          0x67
        Communication Control               Diagnostic and Communication Management   0x28          0x68
        Tester Present                      Diagnostic and Communication Management   0x3E          0x7E
        Access Timing Parameter             Diagnostic and Communication Management   0x83          0xC3
        Secured Data Transmission           Diagnostic and Communication Management   0x84          0xC4
        Control DTC Setting                 Diagnostic and Communication Management   0x85          0xC5
        Link Control                        Diagnostic and Communication Management   0x87          0xC7
        Read Data By Identifier             Data Transmission                         0x22          0x62
        Read Memory By Address              Data Transmission                         0x23          0x63
        Read Scaling Data By Identifier     Data Transmission                         0x24          0x64
        Dynamically Define Data Identifier  Data Transmission                         0x2C          0x6C
        Write Data By Identifier            Data Transmission                         0x2E          0x6E
        Write Memory By Address             Data Transmission                         0x3D          0x7D
        Clear Diagnostic Information        Stored Data Transmission                  0x14          0x54
        Read DTC Information                Stored Data Transmission                  0x19          0x59
        Input Output Control By Identifier  InputOutput Control                       0x2F          0x6F
        Routine Control                     Remote Activation of Routine              0x31          0x71
        Request Download                    Upload Download                           0x34          0x74
        Request Upload                      Upload Download                           0x35          0x75
        Transfer Data                       Upload Download                           0x36          0x76
        Request Transfer Exit               Upload Download                           0x37          0x77
        Request File Transfer               Upload Download                           0x38          0x78
      </description>
      <tags>
        <tag>UDS Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_ReleaseAllDiagnosticProtocols_With_Non_Releasable_Protocol</srcid><srcstatus/><internalId>377</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>Dccm.Api.DisableTesterPresent.DuringSendingOfTesterPresentMessage</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When the user asks to disable the sending of the TesterPresent message,
        but the sending of a TesterPresent message is ongoing on the selected protocol,
        the Dccm module will take the necessary actions
        to disable the sending of the TesterPresent message as soon as possible.
      </description>
      <tags>
        <tag>TesterPresent</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_BEFORE_1ST_SENDTESTERPRESENT</srcid><srcstatus/><internalId>331</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_AFTER_1ST_COPYTXDATA</srcid><srcstatus/><internalId>332</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_BEFORE_TXCONFIRMATION</srcid><srcstatus/><internalId>333</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_AFTER_TXCONFIRMATION</srcid><srcstatus/><internalId>334</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_AFTER_1ST_NOTIFICATION</srcid><srcstatus/><internalId>335</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_BEFORE_COPYTXDATA</srcid><srcstatus/><internalId>336</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ReleaseDiagnosticProtocol.DuringSendingOfTesterPresentMessage</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When the user asks to release a communication protocol,
        but the sending of a TesterPresent message is ongoing on the selected protocol,
        the Dccm module will not release the protocol,
        but will take the necessary actions to disable the sending of the TesterPresent message as soon as possible.
      </description>
      <tags>
        <tag>Dccm Service ReleaseDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_BEFORE_1ST_SENDTESTERPRESENT</srcid><srcstatus/><internalId>337</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_BEFORE_COPYTXDATA</srcid><srcstatus/><internalId>339</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_AFTER_1ST_COPYTXDATA</srcid><srcstatus/><internalId>341</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_BEFORE_TXCONFIRMATION</srcid><srcstatus/><internalId>342</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_AFTER_TXCONFIRMATION</srcid><srcstatus/><internalId>343</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_AFTER_1ST_NOTIFICATION</srcid><srcstatus/><internalId>344</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ReleaseAllDiagnosticProtocols.DuringSendingOfTesterPresentMessage</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm module shouldn't allow the Client to release all the allocated diagnostic protocols when the sending
        of a TesterPresent message is ongoing on one or more protocols.
      </description>
      <tags>
        <tag>Dccm Service ReleaseAllDiagnosticProtocols</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_RELEASEALLDIAGNOSTICPROTOCOLS_BEFORE_1ST_SENDTESTERPRESENT</srcid><srcstatus/><internalId>338</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_RELEASEALLDIAGNOSTICPROTOCOLS_BEFORE_COPYTXDATA</srcid><srcstatus/><internalId>340</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ParallelProcessing_01</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm module should allow parallel processing of UDS service requests on different protocols.
      </description>
      <tags>
        <tag>UDS Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WRONG_BUFFER_MESSAGE</srcid><srcstatus/><internalId>313</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ParallelProcessing_02</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For a specific protocol, in case Dccm is in the middle of processing a specific UDS service request and a new
        service request is initiated on the same protocol then Dccm service request should report to DET the code DCCM_STD_E_BUSY.
      </description>
      <tags>
        <tag>UDS Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_REJECT_SECOND_CALL_WHEN_JUST_STARTED_PROCCESSING</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_DataLengthPtr_WithValueZero</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_DataLengthPtr_WithValueOne</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

    <specobject>
      <id>Dccm.Api.CallbacksNotDefined</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The Dccm service request should return E_NOT_OK if the UDS services are called without
        providing a callback function.
      </description>
      <tags>
        <tag>UDS Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_NO_CALLBACK_PROVIDED</srcid><srcstatus/><internalId>183</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>

    <specobject>
      <id>Dccm.Api.InputDataValidation</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Each service should perform a consistency check of the input parameters.
        If the input data is incorrect or incomplete then it should return with E_NOT_OK.
      </description>
      <tags>
        <tag>UDS Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RETRY_SUPPORT_WRONG_TPDATASTATE</srcid><srcstatus/><internalId>312</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>Dccm.API.Init</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Service name:     Dccm_Init
        Syntax:       void Dccm_Init(void)
        Service ID[hex]:  0x00
        Sync/Async:     Synchronous
        Reentrancy:      Non Reentrant
        Parameters (in):  None
        Parameters (inout):  None
        Parameters (out):  None
        Return value:    None
        Description:    This service initializes the Dccm.
      </description>
      <tags>
        <tag>Startup</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATE_PROTOCOL_WITHOUT_DCCM_INIT</srcid><srcstatus/><internalId>194</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_START_TRANSMISSION_FAIL</srcid><srcstatus/><internalId>307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Service name:    Dccm_MainFunction
        Syntax:        void Dccm_MainFunction(void)
        Service ID[hex]:  0x01
        Sync/Async:      Synchronous
        Reentrancy:      Non Reentrant
        Timing:        FIXED_CYCLIC
        Parameters (in):  None
        Parameters (inout):  None
        Parameters (out):  None
        Return value:    None
        Description:    This service is used for processing the tasks of the main loop.
      </description>
      <tags>
        <tag>Scheduled Functions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WRONG_PDU_TX_CALLS</srcid><srcstatus/><internalId>306</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_TP_DATARETRY_WRONG_BUFFER</srcid><srcstatus/><internalId>310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.InitCheck</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If a Main function of a un-initialized module is called from the BSW Scheduler,
        then it shall return immediately without performing any functionality and
        without raising any errors.
      </description>
      <rationale>
        Main Function processing of an un-initialized Module may result in undesired and non defined behavior.

        Rationale for the deviation list: The SchM module may schedule the modules main
        function before the module is initialized. This would result in lots of errors during start up.
        Therefore the modules main function should not throw any
        error if the module is not yet initialized but instead should simply return.
      </rationale>
      <comment>
        EB requirement is in line with the AUTOSAR 4.0 General SRS requirement BSW00450.
      </comment>
      <tags>
        <tag>basic</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_MainFunction_No_Module_Init</srcid><srcstatus/><internalId>374</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.SheduledFunctions</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Dccm_MainFunction shall integrate all scheduled functions.
      </description>
      <tags>
        <tag>Scheduled Functions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL</srcid><srcstatus/><internalId>318</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL_DELAY_IN_TRANSMISSION</srcid><srcstatus/><internalId>319</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.Transmission_01</id>
      <status>approved</status>
      <source>EB</source>
      <version>3</version>
      <description>
        When the transmission data is ready the main function shall trigger
        the transmission to the PduR, using the value of TxPduId that is defined
        in the configuration file of the module PduR.
      </description>
      <tags>
        <tag>Communication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TRANSMISSION_TX_NULL_BUFFER</srcid><srcstatus/><internalId>304</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WRONG_PDU_TX_CALLS</srcid><srcstatus/><internalId>306</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_START_TRANSMISSION_FAIL</srcid><srcstatus/><internalId>307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.Transmission_03</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        In case of a transmission failure Dccm should imediatly notify the SWC.
      </description>
      <tags>
        <tag>Communication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TRANSMISSION_TX_NULL_AVAILABLE_DATA</srcid><srcstatus/><internalId>305</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_TP_DATARETRY_WRONG_BUFFER</srcid><srcstatus/><internalId>310</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.Transmission_04</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The functionally addressed messages (including TesterPresent) should be sent with higher priority
        than the physically addressed messages.
      </description>
      <rationale>
        This reduces the risk of a timeout of diagnostic sessions, security settings, and authentication states.
      </rationale>
      <tags>
        <tag>Communication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TWO_PROTOCOLS_1_PHYSICAL_1_FUNCTIONAL</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.Receive_01</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The received data should be aggregated in the Dccm output buffer by the main function.
      </description>
      <tags>
        <tag>Communication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_WRONG_TXPDUID</srcid><srcstatus/><internalId>308</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.Receive_02</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        After the data is aggregated the SWC should be notified with a positive response code.
      </description>
      <tags>
        <tag>Communication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_WRONG_SIZE_FOR_PDUR</srcid><srcstatus/><internalId>309</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_TP_DATARETRY_ON_CONFIRMED_BYTES</srcid><srcstatus/><internalId>311</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.Receive_03</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        In case of a receiving failure Dccm should imediatly notify the SWC.
      </description>
      <tags>
        <tag>Communication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RECEIVING_RX_BUFFER_TOO_SMALL</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>Dccm.API.MainFunction.Timeout</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The main function shall provide a mechanism of resetting the communication
        in case a configurable amount of time has passed without any communication outcome.
      </description>
      <tags>
        <tag>Communication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_RX_INTERNALTIMEOUT_NEGATIVE</srcid><srcstatus/><internalId>291</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.Internal</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide an internal timer that will start twice during the processing of a request.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALL_TIMEOUTS_OUTPUT</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.Internal.Behavior_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide a timer between the PduR_DccmTransmit() and Dccm_TxConfirmation().
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_TX_INTERNALTIMEOUT_NEGATIVE</srcid><srcstatus/><internalId>292</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.Internal.Behavior_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Dccm shall provide a timer between the Dccm_StartOfReception() and Dccm_RxIndication().
      </description>
      <comment>&lt;pre&gt;
        Note:Note: If the configuration parameter DccmP6Client is enabled, the behavior for
        the reception part is not applicable, because the same time-frame
        is already covered by the P6Client/P6*Client timer.
        In this use-case, this requirement is not applicable.
      &lt;/pre&gt;</comment>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_RX_INTERNALTIMEOUT_NEGATIVE</srcid><srcstatus/><internalId>291</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_P6CLIENT_OUTPUT</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.P2Client</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide a timer that will represent the maximum amount of time in milliseconds between
        a successfully transmitted request and the start of the corresponding response.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALL_TIMEOUTS_OUTPUT</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.P2Client.Behavior</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide a timer that will starts in Dccm_TxConfirmation() and ends in Dccm_StartOfReception().
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_P2CLIENT_TIMEOUT</srcid><srcstatus/><internalId>293</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.P2StarClient</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide a timer that will represent the maximum amount of time in milliseconds between
        a response containing the negative response code 0x78 and the start of the next response.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALL_TIMEOUTS_OUTPUT</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.P2StarClient.Behavior</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        After the reception of a negative response code 0x78 "requestCorrectlyReceived-ResponsePending",
        Dccm shall provide a timer between Dccm_RxIndication() and Dccm_StartOfReception().
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_P2STARCLIENT_TIMEOUT</srcid><srcstatus/><internalId>295</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_P2STARCLIENT_TIMEOUT_RequestLengthOneByte</srcid><srcstatus/><internalId>296</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.P6Client</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide a timer that will represent the maximum amount of time in milliseconds between
        a successfully transmitted request and the complete reception of the corresponding response.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_P6CLIENT_EXPIRES</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_P6CLIENT_EXPIRES_SPRMIbTrue</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.P6Client.Behavior</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide a timer that will starts in Dccm_TxConfirmation() and ends in Dccm_RxIndication().
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_P6CLIENT_EXPIRES</srcid><srcstatus/><internalId>299</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_P6CLIENT_EXPIRES_SPRMIbTrue</srcid><srcstatus/><internalId>300</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.P6StarClient</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide a timer that will represent the maximum amount of time in milliseconds between
        a response containing the negative response code 0x78 and the complete reception of the response.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_P6STARCLIENT_EXPIRES</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.P6StarClient.Behavior</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        After the reception of a negative response code 0x78 "requestCorrectlyReceived-ResponsePending",
        Dccm shall provide a timer between Dccm_RxIndication() and the complete reception of the response
        message, that is also indicated via Dccm_RxIndication().
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_P6STARCLIENT_EXPIRES</srcid><srcstatus/><internalId>298</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.Application_timers</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide two timers: Timeout and InternalTimeout.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALL_TIMEOUTS_OUTPUT</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.Application_timer_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Dccm shall provide a unique timer which is triggered (reloaded, started, and stopped). Depending on the configuration, 
        this timer shall use the configuration values of P2Client and P2StarClient or P6Client and P6StarClient.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALL_TIMEOUTS_OUTPUT</srcid><srcstatus/><internalId>294</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_P6CLIENT_OUTPUT</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.Application_timer_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide a timer which is triggered (reloaded, started, and stopped) using the configuration values of internal timeout.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALL_TIMEOUTS_OUTPUT</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.Measurement_unit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        All Dccm comunication parameters shall be configured in miliseconds.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALL_TIMEOUTS_OUTPUT</srcid><srcstatus/><internalId>294</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

    <specobject>
      <id>Dccm.Timeout.Disable_InternalTimeout</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall provide support for deactivating the InternalTimeout by setting it's value to "0".
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_DISABLE_INTERNAL_TIMEOUT</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

    <specobject>
      <id>Dccm.Config.Dccm_Configurable_Timeouts</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        The Dccm should provide a mechanism for configuring the timeouts at the compile time.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_P2ClientTimeoutDefaultValue</srcid><srcstatus/><internalId>165</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_InternalTimeoutDefaultValue</srcid><srcstatus/><internalId>166</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_P2StarClientTimeoutDefaultValue</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_TimeoutDisableInternal</srcid><srcstatus/><internalId>168</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_P2ClientConfigValue</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_InternalConfigValue</srcid><srcstatus/><internalId>170</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_P2StarClientConfigValue</srcid><srcstatus/><internalId>171</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_P6ClientConfigValue</srcid><srcstatus/><internalId>172</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_P6StarClientConfigValue</srcid><srcstatus/><internalId>173</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

    <specobject>
      <id>Dccm.Config.Dccm_Configurable_Timeouts_Runtime_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm should provide a mechanism for configuring timeouts at runtime for each diagnostic protocol.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SETCOMMUNICATIONTIMEOUTPARAMETERS_OUTPUT</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

    <specobject>
      <id>Dccm.Config.Dccm_Configurable_Timeouts_Runtime_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm should use the compile time defined timeouts as default values for each diagnostic protocol.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_DISABLE_INTERNAL_TIMEOUT</srcid><srcstatus/><internalId>290</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

    <specobject>
      <id>Dccm.Config.Dccm_Configurable_Timeouts_Runtime_4</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm should allow changes of the diagnostic protocol timeout parameters
        to be made only when the diagnostic protocol is ready but not seding or received data.
      </description>
      <tags>
        <tag>Timeouts</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SETCOMMUNICATIONTIMEOUTPARAMETERS_OUTPUT</srcid><srcstatus/><internalId>289</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>52</internalId></specobject>

    <specobject>
      <id>Dccm.Config.DccmFunctionalPduIds</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name:    DccmFunctionalPduIds
        Description:    This container contains a list of target ECU that can be
                  used for functional communication (FunctionalTxPduIds/FunctionalRxPduIds)
      </description>
      <tags>
        <tag>Configuration Specification</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_FUNCTIONAL_REQUEST_OUTPUT</srcid><srcstatus/><internalId>229</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

    <specobject>
      <id>Dccm.Config.NumOfParallelDiagnosticProtocols</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:        Number of Parallel Diagnostic Protocols supported (DCCM_MAX_DIAGNOSTIC_PROTOCOLS).
        Description:    Allow to configure the maximum number of diagnostic protocols that will be used for communication.
                  The maximum number of diagnostic protocols is the sum of the maximum number of diagnostic protocols
                  used for functional communication and the maximum number of diagnostic protocols used for physical communication.
        Notes:        All values ​​that are not in range are not allowed.
        Type:        Integer
        Range:        1 .. 254
        Default value    8
      </description>
      <tags>
        <tag>Configuration Specification</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_MainFunction_No_Module_Init</srcid><srcstatus/><internalId>374</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

    <specobject>
      <id>Dccm.Config.NumOfFunctionalDiagnosticProtocols</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:        Number of Protocols reserved for Functional Communication.
        Description:    Allow to configure the number of diagnostic protocols used for functional communication.
        Notes:        Must be smaller than the number of parallel diagnostic protocols.
        Type:        Integer
        Range:        0 .. 253
        Default value    0
      </description>
      <tags>
        <tag>Configuration Specification</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_MainFunction_No_Module_Init</srcid><srcstatus/><internalId>374</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

    <specobject>
      <id>Dccm.Config.Buffer_Streaming</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name:      Enable Buffer Streaming (DCCM_BUFFER_STREAMING)
        Description:  Buffer Streaming within the Dccm module shall be
                configurable (ON/OFF) at pre-compile time. The switch DCCM_BUFFER_STREAMING
                shall activate or deactivate the ability to send data in smaller buffers.
                Buffer streaming need to be activated when must be send a large amount of data but is not enough memory available of ECU.
                Enabling this will allow the client to provide a smaller buffer when calling the Dccm_SendRequest function and after
                that buffer data was provided to PduR then Dccm will request the next chunk of data from the client.
      </description>
      <tags>
        <tag>General Requirement</tag>
        <tag>Configuration Specification</tag>
        <tag>Dccm interfacing</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATE_BUFFERSTREAMINGCALLBACK_NOT_NULL_POINTER</srcid><srcstatus/><internalId>191</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_NO_RETRY_WRONG_LENGTH_10_4</srcid><srcstatus/><internalId>280</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_10_4_OUTPUT</srcid><srcstatus/><internalId>282</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_CheckBufferSuppressBit_WrongParameter</srcid><srcstatus/><internalId>375</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

    <specobject>
      <id>Dccm.Api.AllocateDiagnosticProtocol.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_AllocateDiagnosticProtocol
        Syntax: Std_ReturnType Dccm_AllocateDiagnosticProtocol(
                        uint16 TxPduId,
                        uint16 RxPduId,
                        uint8* ProtocolId,
                        uint8 AddressingType,
                        Dccm_CallbackType Callback,
                        Dccm_BufferStreamingCallbackType BufferStreamingCallback
                        )
        Service ID[hex]:
        Synchronicity:        Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
          TxPduId:          The PduId that will be used for sending data
          RxPduId:          The PduId that will be used for receiving data
          AddressingType:        The protocol is allocated for physical or functional communication.
                                   Expected values: PHYSICAL_ADDRESSING or FUNCTIONAL_ADDRESSING.
          Callback:          The callback function that will be used by the Dccm to notify the client application.
          BufferStreamingCallback:  The callback function that will be used by the Dccm to ask the next data packet from
                        the client application in the use-case with buffer streaming.
                        If BufferStreaming is not activated the parameter BufferStreamingCallback shall be null pointer.
        Parameters (inout):
        Parameters (out):
          ProtocolId:          The ID of the protocol will be returned to the caller of the function
        Return value: Std_ReturnType  E_OK: The protocol was allocated
                        E_NOT_OK: There was an error related with the parameters provided to the function.
                              The ProtocolId OUT parameter contains a value that is not valid (INVALID_PROTOCOL_ID).
                              The maximum number of diagnostic protocols used for physical communication has been reached.
                        DCCM_STD_E_BUSY: The protocols vector no longer has available places for assigning protocols,
                                 all positions are already occupied.  After a protocol will be
                                 released by the client application, it can be allocated again.
        Description:        Dccm_AllocateDiagnosticProtocol is used to allocate a diagnostic protocol.
      </description>
      <tags>
        <tag>Dccm Service AllocateDiagnosticProtocol</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_NO_CALLBACK_PROVIDED</srcid><srcstatus/><internalId>183</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_WRONG_TARGETTXPDUID</srcid><srcstatus/><internalId>185</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_AND_RELEASEDIAGNOSTICPROTOCOL_TOO_MANY_PROTOCOLS</srcid><srcstatus/><internalId>186</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

    <specobject>
      <id>Dccm.Api.AllocateDiagnosticProtocol.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function Dccm_AllocateDiagnosticProtocol is used to allocate a diagnostic protocol. The application that is the client of Dccm can not
        communicate with a sever without first allocating a diagnostic protocol.
      </description>
      <tags>
        <tag>Dccm Service AllocateDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_NO_PROTOCOL_ID_PROVIDED</srcid><srcstatus/><internalId>184</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_TOO_MANY_PROTOCOLS</srcid><srcstatus/><internalId>327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>Dccm.BufferStreamingCallback.Fails</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If BufferStreamingCallback() returns E_NOT_OK, Dccm_MainFunction() shall not change the protocol status and
        wait until a positive response is received.
      </description>
      <tags>
        <tag>Dccm BufferStreamingCallback</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_PROTOCOL_BUFFERSTREAMINGCALLBACK_NOT_OK</srcid><srcstatus/><internalId>281</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>Dccm.Api.AllocateDiagnosticProtocol.InvalidAddressingType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_AllocatedDiagnosticProtocol function shall send an error if the AddressingType parameter has a value other than the expected one:
        PHYSICAL_ADDRESSING or FUNCTIONAL_ADDRESSING.
      </description>
      <tags>
        <tag>Dccm Service AllocateDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATE_DIAGNOSTIC_PROTOCOL_INVALID_ADDRESSING_TYPE</srcid><srcstatus/><internalId>189</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>Dccm.Api.AllocateDiagnosticProtocol.ModuleNotInitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_AllocatedDiagnosticProtocol() function shall send an error if the Dccm module has not been initialized( Dccm_Init() function was not called).
      </description>
      <tags>
        <tag>Dccm Service AllocateDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATE_PROTOCOL_WITHOUT_DCCM_INIT</srcid><srcstatus/><internalId>194</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

    <specobject>
      <id>Dccm.Api.AllocateDiagnosticProtocol.NoFunctionalServers</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_AllocatedDiagnosticProtocol function shall send an error if a functional protocol is allocated but there are no functional servers.
      </description>
      <tags>
        <tag>Dccm Service AllocateDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_FUNCTIONAL_ADDRESSING_NO_FUNCTIONAL_SERVERS</srcid><srcstatus/><internalId>190</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

    <specobject>
      <id>Dccm.Api.AllocateDiagnosticProtocol.ExceedingNrMaxOfPhysicalProtocols</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_AllocatedDiagnosticProtocol function shall send an error 
        if the user asks to allocate a physical protocol, but the maximum number of diagnostic
        protocols used for physical communication has been reached.
      </description>
      <tags>
        <tag>Dccm Service AllocateDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATE_PHYSICAL_PROTOCOLS_EXCEEDING_NR_MAX_OF_PHYSICAL_PROTOCOLS</srcid><srcstatus/><internalId>192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>Dccm.Api.AllocateDiagnosticProtocol.ExceedingNrMaxOfFunctionalProtocols</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_AllocatedDiagnosticProtocol function shall send an error if a functional protocol is allocated but the maximum
        number of diagnostic protocols used for functional communication has been reached.
      </description>
      <tags>
        <tag>Dccm Service AllocateDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATE_FUNCTIONAL_PROTOCOLS_NO_FREE_DIAGNOTIC_PROTOCOL</srcid><srcstatus/><internalId>193</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_TOO_MANY_PROTOCOLS</srcid><srcstatus/><internalId>327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>Dccm.Api.AllocateDiagnosticProtocol.TxPduIdOrRxPduIdNotPreconfigured</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function Dccm_AllocatedDiagnosticProtocol() shall return an error
        if the values of the parameters TxPduId or RxPduId can not be found
        in the list of diagnostic servers that are configured for Dccm.
      </description>
      <tags>
        <tag>Dccm Service AllocateDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_AllocateDiagnosticProtocol_NoServersConfigured</srcid><srcstatus/><internalId>380</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ReleaseDiagnosticProtocol.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_ReleaseDiagnosticProtocol
        Syntax: Std_ReturnType Dccm_ReleaseDiagnosticProtocol(
                        uint8 ProtocolId
                      )

        Service ID[hex]:
        Synchronicity:        Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
            ProtocolId      Release the protocol with this ID.
        Parameters (inout):
        Parameters (out):
        Return value: Std_ReturnType  E_OK: The protocol was released
                        E_NOT_OK: The ProtocolID is outside of the pre-configured range of values, or the protocol
                        identified with this ProtocolID is in one of the following states: UNUSED, RELEASE, ALLOCATING.
        Description:        ReleaseDiagnosticProtocol is used to release a specific protocol. It does not matter the protocol type, may be physical or functional.
      </description>
      <tags>
        <tag>Dccm Service ReleaseDiagnosticProtocol</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_AND_RELEASEDIAGNOSTICPROTOCOL_TOO_MANY_PROTOCOLS</srcid><srcstatus/><internalId>186</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_RELEASE_PROTOCOL_ALREADY_RELEASED</srcid><srcstatus/><internalId>188</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WRONG_BUFFER_MESSAGE</srcid><srcstatus/><internalId>313</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ReleaseDiagnosticProtocol.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
         The function Dccm_ReleaseDiagnosticProtocol is used to release a diagnostic protocol, even if it is physical or functional.It shall be called when there is no need for communication over the specific PduId.
      </description>
      <tags>
        <tag>Dccm Service ReleaseDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_TP_DATARETRY_ON_CONFIRMED_BYTES</srcid><srcstatus/><internalId>311</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RETRY_SUPPORT_WRONG_TPDATASTATE</srcid><srcstatus/><internalId>312</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RETRY_TP_CONFPENDING_SEND_WRONG_BUFFER_MESSAGE</srcid><srcstatus/><internalId>314</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ReleaseDiagnosticProtocol.ModuleNotInitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_ReleaseDiagnosticProtocol() function shall send an error if the Dccm module has not been initialized( Dccm_Init() function was not called).
      </description>
      <tags>
        <tag>Dccm Service ReleaseDiagnosticProtocol</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_RELEASE_DIAGNOSTIC_PROTOCOLS_WITHOUT_DCCM_INIT</srcid><srcstatus/><internalId>195</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ReleaseAllDiagnosticProtocols.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_ReleaseAllDiagnosticProtocols
        Syntax: Std_ReturnType Dccm_ReleaseAllDiagnosticProtocols (
                      void
                      )

        Service ID[hex]:
        Synchronicity:        Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
        Parameters (inout):
        Parameters (out):
        Return value: Std_ReturnType  E_OK: All the diagnostic protocols were properly released
                        E_NOT_OK At least one protocol is still in one of the following states: RELEASE, ALLOCATING.
                        No protocol has been released
        Description:          ReleaseAllDiagnosticProtocols is used to release all protocols.
      </description>
      <tags>
        <tag>Dccm Service ReleaseAllDiagnosticProtocols</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_RELEASE_ALL_DIAGNOSTIC_PROTOCOLS</srcid><srcstatus/><internalId>187</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

    <specobject>
      <id>Dccm.Api.ReleaseAllDiagnosticProtocols.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function Dccm_ReleaseAllDiagnosticProtocols() is used to release all allocated diagnostic protocols
        both physical and functional.It shall be called when there is no need for communication.
      </description>
      <tags>
        <tag>Dccm Service ReleaseAllDiagnosticProtocols</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_RELEASE_ALL_DIAGNOSTIC_PROTOCOLS</srcid><srcstatus/><internalId>187</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_ReleaseAllDiagnosticProtocols_With_Non_Releasable_Protocol</srcid><srcstatus/><internalId>377</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>

    <specobject>
      <id>Dccm.Api.Dccm_ReleaseAllDiagnosticProtocols.ModuleNotInitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_ReleaseAllDiagnosticProtocols() function shall send an error
        if the Dccm module has not been initialized( Dccm_Init() function was not called).
      </description>
      <tags>
        <tag>Dccm Service ReleaseAllDiagnosticProtocols</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_RELEASE_DIAGNOSTIC_PROTOCOLS_WITHOUT_DCCM_INIT</srcid><srcstatus/><internalId>195</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SetCommunicationTimeoutParameters.P2Client.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      The following service definition shall be used by Dccm in case the configuration parameter
      DccmP2Client is set to the value enabled:

        Service name: Dccm_SetCommunicationTimeoutParameters
        Syntax: Std_ReturnType Dccm_SetCommunicationTimeoutParameters(
                        Dccm_ProtocolIdType ProtocolId,
                        Dccm_TimeoutType P2ClientConfigurationValue,
                        Dccm_TimeoutType InternalTimeout,
                        Dccm_TimeoutType P2StarClientConfigurationValue,
                        )
        Service ID[hex]:
        Synchronicity:        Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
          ProtocolId:               The ID of the Dccm protocol.
          P2ClientConfigurationValue:    The value to be used for the start of P2Client timeout.
          InternalTimeout:        The value to be used for the start of internal timeout.
                    P2StarClientConfigurationValue: The value to be used for the start of P2StarClient timeout.
        Parameters (inout):
        Parameters (out):
        Return value: Std_ReturnType  E_OK:    Diagnostic Protocol communication parameters were successfully updated
                        E_NOT_OK: The ProtocolId is not valid or not in the DCCM_DIAGNOSTIC_PROTOCOL_STATUS_READY
        Description:  Dccm_SetCommunicationTimeoutParameters is used to set the timeout parameters for a specific diagnostic protocol.
      </description>
      <tags>
        <tag>Dccm Service SetCommunicationTimeoutParameters</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SETCOMMUNICATIONTIMEOUTPARAMETERS_NEGATIVE</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SetCommunicationTimeoutParameters.P6Client.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
      The following service definition shall be used by Dccm in case the configuration parameter
      DccmP6Client is set to the value enabled:

        Service name: Dccm_SetCommunicationTimeoutParameters
        Syntax: Std_ReturnType Dccm_SetCommunicationTimeoutParameters(
                        Dccm_ProtocolIdType ProtocolId,
                        Dccm_TimeoutType P6ClientConfigurationValue,
                        Dccm_TimeoutType InternalTimeout,
                        Dccm_TimeoutType P6StarClientConfigurationValue,
                        )
        Service ID[hex]:
        Synchronicity:        Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
          ProtocolId:               The ID of the Dccm protocol.
          P6ClientConfigurationValue:    The value to be used for the start of P6Client timeout.
          InternalTimeout:        The value to be used for the start of internal timeout.
                    P6StarClientConfigurationValue: The value to be used for the start of P6StarClient timeout.
        Parameters (inout):
        Parameters (out):
        Return value: Std_ReturnType  E_OK:    Diagnostic Protocol communication parameters were successfully updated
                        E_NOT_OK: The ProtocolId is not valid or not in the DCCM_DIAGNOSTIC_PROTOCOL_STATUS_READY
        Description:  Dccm_SetCommunicationTimeoutParameters is used to set the timeout parameters for a specific diagnostic protocol.
      </description>
      <tags>
        <tag>Dccm Service SetCommunicationTimeoutParameters</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_P6CLIENT_OUTPUT</srcid><srcstatus/><internalId>297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SetCommunicationTimeoutParameters.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function Dccm_SetCommunicationTimeoutParameters is used to set the timeout communication parameters
        for a specific diagnostic protocol. This API will allow the update of the timers only when the protocol 
        is in the state DCCM_DIAGNOSTIC_PROTOCOL_STATUS_READY.
      </description>
      <tags>
        <tag>Dccm Service SetCommunicationTimeoutParameters</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SETCOMMUNICATIONTIMEOUTPARAMETERS_NEGATIVE</srcid><srcstatus/><internalId>288</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SendRequest.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_SendRequest
        Syntax: Std_ReturnType Dccm_SendRequest(
                    uint8 ProtocolId,
                    uint8* Buffer,
                    uint16 BufferLength,
                    uint16* DataLengthPtr
                    )

        Service ID[hex]:
        Sync/Async:          Asynchronous
        Reentrancy:          Non reentrant
        Parameters (in):
            ProtocolId:      The Protocol ID that will be used in the communication with the server.
            BufferLength:    Number of bytes that can be stored in the Buffer.
        Parameters (inout):
            Buffer:        A pointer to the start of the buffer where the data received from the server will be stored.
            DataLengthPtr    IN: The number of bytes that will be sent to the server.
                      OUT: A pointer to return the number of bytes received from the server.
        Parameters (out):
        Return value: Std_ReturnType  E_OK: service request has been accepted
                        E_NOT_OK: service request was not accepted due to input values: ProtocolId not correct,
                        buffer is too short, Buffer is null or DataLengthPtr is null.
                        DCCM_STD_E_BUSY: A request is active.
        Description:        Dccm_SendRequest is used to send an UDS payload over a Diagnostic Protocol
      </description>
      <tags>
        <tag>Dccm Service SendRequest</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TWO_DIAGNOSTIC_PROTOCOLS_OUTPUT</srcid><srcstatus/><internalId>201</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_NO_BUFFER_PROVIDED</srcid><srcstatus/><internalId>217</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_REJECT_SECOND_CALL_WHEN_JUST_STARTED_PROCCESSING</srcid><srcstatus/><internalId>221</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_DataLengthPtr_WithValueZero</srcid><srcstatus/><internalId>224</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_DataLengthPtr_WithValueOne</srcid><srcstatus/><internalId>225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SendRequest.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm_SendRequest is used to initiate the sending of the UDS payload over a Diagnostic Protocol.
        The Diagnostic Protocol should be in the READY state otherwise the call will return with error.
      </description>
      <tags>
        <tag>Dccm Service SendRequest</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TWO_DIAGNOSTIC_PROTOCOLS_OUTPUT</srcid><srcstatus/><internalId>201</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_OUTPUT</srcid><srcstatus/><internalId>226</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TWO_MESSAGES_OUTPUT</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_ONE_PROTOCOL_4_ECUS</srcid><srcstatus/><internalId>230</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SendRequest.WrongProtocolId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_SendRequest function shall send an error if the call is made with a ProtocolId over
        the range of allowed values.
      </description>
      <tags>
        <tag>Dccm Service SendRequest</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WRONG_PROTOCOL_ID</srcid><srcstatus/><internalId>219</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SendRequest.WrongPduRRx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_SendRequest function shall return error when the provided Rx PduId is invalid.
      </description>
      <tags>
        <tag>Dccm Service SendRequest</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WRONG_PDU_RX_CALLS</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>

    <specobject>
      <id>Dccm.Api.CopyRxData.NullParameter</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When Dccm_CopyRxData() has a null pointer parameter, the reception shall fail
        and Dccm_CopyRxData() returns error.
      </description>
      <tags>
        <tag>Dccm CopyRxData</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RECEIVING_RX_NULL_AVAILABLE_DATA</srcid><srcstatus/><internalId>238</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RECEIVING_RX_NULL_BUFFER</srcid><srcstatus/><internalId>239</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>

    <specobject>
      <id>Dccm.Api.CopyRxData.InvalidRx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When Dccm_CopyRxData() is called with an incorrect rxPduId parameter,
        the reception shall fail, and Dccm_CopyRxData returns error.
      </description>
      <tags>
        <tag>Dccm CopyRxData</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_RX_DATA_WRONG_RXPDUID</srcid><srcstatus/><internalId>244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

    <specobject>
      <id>Dccm.Api.CopyTxData.WrongBufferMsg</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_CopyTxData shall returns error when it is sent more bytes than the remaining
        bytes in buffer while using TP_CONFPENDING, TP_DATACONF OR TP_DATARETRY.
      </description>
      <tags>
        <tag>Dccm CopyTxData</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RETRY_TP_CONFPENDING_SEND_WRONG_BUFFER_MESSAGE</srcid><srcstatus/><internalId>314</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RETRY_TP_DATACONF_SEND_WRONG_BUFFER_MESSAGE</srcid><srcstatus/><internalId>315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>Dccm.Api.CopyTxData.TesterPresentNullBuffer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm_CopyTxData () shall not perform any processing when the
        TesterPresent request is initiated by Dccm and the TesterPresent buffer is null.
      </description>
      <tags>
        <tag>Dccm CopyTxData</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_CopyTxData_NoBufferAvailable_ToContain_TesterPresent_Request</srcid><srcstatus/><internalId>378</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>

    <specobject>
      <id>Dccm.Api.CopyRxData.WrongBufferSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_CopyRxData() function shall send an error when the received buffer has a different
        length then the expected length.
      </description>
      <tags>
        <tag>Dccm CopyRxData</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_COPY_RX_DATA_WRONG_BUFFERSIZE</srcid><srcstatus/><internalId>247</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_OUTPUT_NEGATIVE_RESPONSE_WRONG_BUFFER_LENGTH</srcid><srcstatus/><internalId>279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>

    <specobject>
      <id>Dccm.Api.CopyRxData.BufferOverflow</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_CopyRxData() function shall stops the processing and return error when it encounters 
        a buffer overflow situation.
      </description>
      <tags>
        <tag>Dccm CopyRxData</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RECEIVING_RX_BUFFER_OVERFLOW</srcid><srcstatus/><internalId>241</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SendRequest.ModuleNotInitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_SendRequest() function shall send an error if the Dccm module has not been initialized( Dccm_Init() function was not called).
      </description>
      <tags>
        <tag>Dccm Service SendRequest</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WITHOUT_DCCM_INIT</srcid><srcstatus/><internalId>223</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>Dccm.BufferStreaming</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall allow the sending of payload with streaming using smaller length buffers.
      </description>
      <tags>
        <tag>Dccm BufferStreaming</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_4_4_OUTPUT</srcid><srcstatus/><internalId>284</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>

    <specobject>
      <id>Dccm.Api.RxIndication.ProcessingANewRequest</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the receiving of the response from the diagnostic server is failing, 
        Dccm shall be able to accept a new request after sending the response code to the client.
      </description>
      <tags>
        <tag>Dccm RxIndication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RECEIVING_RX_INDICATION_FAIL_INVALID_FS</srcid><srcstatus/><internalId>240</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>

    <specobject>
      <id>Dccm.Api.RxIndication.WrongRx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_RxIndication function shall return an error if the input parameter rxPduId is wrong.
      </description>
      <tags>
        <tag>Dccm RxIndication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RXINDICATION_WRONG_RXPDUID</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

    <specobject>
      <id>Dccm.Api.RxIndication.WrongBufferSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_RxIndication function shall send the correct response code
        when the response buffer has an incorrect length.
      </description>
      <tags>
        <tag>Dccm RxIndication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RXINDICATION_RESPONSE_WRONG_BUFFERSIZE</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SendRequest.WrongBufferLenth</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_SendRequest function shall send an error if the call is made
        with a buffer that is too small.
      </description>
      <tags>
        <tag>Dccm Service SendRequest</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WRONG_BUFFER_LENGTH</srcid><srcstatus/><internalId>218</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RECEIVING_RX_BUFFER_TOO_SMALL</srcid><srcstatus/><internalId>236</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>

    <specobject>
      <id>Dccm.Api.SendRequest.WrongPrameters</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_SendRequest function shall send an error if the call is made with all the
        parameters having wrong values.
      </description>
      <tags>
        <tag>Dccm Service SendRequest</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_ALL_PARAM_WRONG</srcid><srcstatus/><internalId>220</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_WRONG_PDU_RX_CALLS</srcid><srcstatus/><internalId>237</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>

    <specobject>
      <id>Dccm.RetrySupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm shall offer support for data retransmission.
      </description>
      <tags>
        <tag>Dccm RetrySupport</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RETRY_SUPPORT_OUTPUT</srcid><srcstatus/><internalId>228</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>

    <specobject>
      <id>Dccm.RequestCorrectlyReceivedResponsePending.WrongSID</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_RxIndication function shall validate the RequestCorrectlyReceivedResponsePending response message
        and send an error if the SID in the response is different from SID in request.
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_RESPONSE_WRONG_SID</srcid><srcstatus/><internalId>233</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

    <specobject>
      <id>Dccm.RequestCorrectlyReceivedResponsePending.OK</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        When Dccm_SendRequest function processes a correct rx response pending message,
        Dccm_SendRequest shall not return an error.
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_SINGLE_TRANSFER_OUTPUT</srcid><srcstatus/><internalId>235</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

    <specobject>
      <id>Dccm.ServiceNotSupported</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm shall accept any request even if the service is not supported.
        Dccm shall not check the content of the buffer.
      </description>
      <tags>
        <tag>Dccm Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_NOT_SUPPORTED_OUTPUT</srcid><srcstatus/><internalId>269</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

    <specobject>
      <id>Dccm.SubFunctionNotSupported</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm shall accept any request even if the sub-function is not supported.
        Dccm shall not check the content of the buffer.
      </description>
      <tags>
        <tag>Dccm Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_SUBFUNCTION_NOT_SUPPORTED_OUTPUT</srcid><srcstatus/><internalId>270</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>

    <specobject>
      <id>Dccm.ReqOutOfRange</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm should not do any special handling when the request is out of range.
      </description>
      <tags>
        <tag>Dccm Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_REQUEST_OUT_OF_RANGE_OUTPUT</srcid><srcstatus/><internalId>271</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>

    <specobject>
      <id>Dccm.Api.Dccm_SendRequest.RejectCall</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_SendRequest function shall rejects a second call if already
        in the middle of processing a previous valid call.
      </description>
      <tags>
        <tag>Dccm Service SendRequest</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_REJECT_SECOND_CALL_AFTER_TRANSMISSION</srcid><srcstatus/><internalId>302</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

    <specobject>
      <id>Dccm.Api.Dccm_SendRequest.RejectCall.FunctionalRequest</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The function Dccm_SendRequest() shall report an error when the SWC (Software Component)
        tries to send a second functional request while Dccm is still processing the previous
        functional request sent by the SWC (this includes the period of time related with
        the processing of the possible responses).
      </description>
      <rationale>
        As specified in UDS ISO 14229, the diagnostic servers can process only one request at a time,
        and will ignore the requests that are received while processing the current request.
        Because of this, Dccm should allow the SWC to send only one functional request at a time (this includes
        the period of time related with the processing of the possible responses).
      </rationale>
      <tags>
        <tag>Dccm Service SendRequest</tag>
        <tag>Functional Communication</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RejectTheSecondFunctionalRequest</srcid><srcstatus/><internalId>222</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

    <specobject>
      <id>Dccm.Api.TxConfirmation.TransmissionFail</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Dccm shall stop the communication and send DCCM_RSP_TX_FAILED
        response code to the client when Dccm_TxConfirmation() receives a
        result other than E_OK.
      </description>
      <tags>
        <tag>Dccm TxConfirmation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TRANSMISSION_FAIL_INVALID_FS</srcid><srcstatus/><internalId>303</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>

    <specobject>
      <id>Dccm.Api.TxConfirmation.WrongTx</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_TxConfirmation function shall send an error when the confirmation
        of transmission is sent to the wrong TxPduId.
      </description>
      <tags>
        <tag>Dccm Service Dccm_TxConfirmation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TXCONFIRMATION_WRONG_TXPDUID</srcid><srcstatus/><internalId>301</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>

    <specobject>
      <id>Dccm.VehicleSpeedIsTooHigh</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm should not do any special handling when vehicle speed is too high. 
      </description>
      <tags>
        <tag>Dccm Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_VEHICLE_SPEED_TOO_HIGH_OUTPUT</srcid><srcstatus/><internalId>277</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

    <specobject>
      <id>Dccm.TemperatureIsTooHigh</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm should not do any special handling when temperature is too high.
      </description>
      <tags>
        <tag>Dccm Services</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_TEMPERATURE_TOO_HIGH_OUTPUT</srcid><srcstatus/><internalId>278</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

    <specobject>
      <id>Dccm.Api.StartOfReception.WrongParameter</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_StartOfReception function shall returns an error in the use-case
        with a wrong parameter.
      </description>
      <tags>
        <tag>Dccm StartOfReception</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_START_OF_RECEPTION_WRONG_RXPDUID</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

    <specobject>
      <id>Dccm.Api.StartOfReception.WrongProtocolStatus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_StartOfReception function shall returns an error if the protocol
        status is incorrect.
      </description>
      <tags>
        <tag>Dccm StartOfReception</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_START_OF_RECEPTION_WRONG_STATUS</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>Dccm.Api.GetDiagnosticProtocolStatus.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_GetDiagnosticProtocolStatus
        Syntax: Std_ReturnType Dccm_GetDiagnosticProtocolStatus (
                      uint8 ProtocolId,
                      uint8* Status
                      )

        Service ID[hex]:
        Sync/Async:            Synchronous
        Reentrancy:            Non reentrant
        Parameters (in):
            ProtocolId:        The status of this protocol ID is queried.
        Parameters (inout):
        Parameters (out):
            Status:          This is the status of the protocol that is returned to the user.
        Return value: Std_ReturnType  E_OK: Status was retrieved and returned to the user
                        E_NOT_OK: ProtocolID is out of the pre-configured range of values, or the Status parameter is null.
        Description:          Returns the status of a Diagnostic Protocol
      </description>
      <tags>
        <tag>Dccm Service GetDiagnosticProtocolStatus</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_GET_DIAGNOSTIC_PROTOCOL_STATUS_NULL_POINTER</srcid><srcstatus/><internalId>181</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_GET_DIAGNOSTIC_PROTOCOL_STATUS_WRONG_PROTOCOL_ID</srcid><srcstatus/><internalId>182</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>

    <specobject>
      <id>Dccm.Api.GetDiagnosticProtocolStatus.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_GetDiagnosticProtocolStatus() function is used to query the status of a specific Diagnostic Protocol.
      </description>
      <tags>
        <tag>Dccm GetDiagnosticProtocolStatus</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_GET_DIAGNOSTIC_PROTOCOL_STATUS_OUTPUT</srcid><srcstatus/><internalId>180</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>

    <specobject>
      <id>Dccm.Api.EnableTesterPresent.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_EnableTesterPresent
        Syntax: Std_ReturnType Dccm_EnableTesterPresent (
                      uint8 ProtocolId,
                      uint8* Buffer,
                      uint16 BufferLength,
                      uint16* DataLengthPtr,
                      Dccm_TimeoutType Interval
                      )

        Service ID[hex]:
        Sync/Async:          Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
            ProtocolId:      The ID of the Dccm protocol.
            BufferLength:    Should be at least 3 bytes length to have enough room for a negative response from the server
            Interval:      The time interval between initiating two consecutive TesterPresent messages.
                      The value should be long enough to permit the proper sending of the messages:
                      - Dccm_MainFunction() must be called a number of times to assure that the protocols switch through a number of states;
                      - PduR must have enough time to call the call-back functions (provided by Dccm) involved in the sending of the messages.
        Parameters (inout):
        Parameters (out):
            Buffer:        The content of buffer is ignored.
            DataLengthPtr:    Will contain the answer from the server (if it is received).

        Return value:        E_OK: Status was retrieved and returned to the user
                      E_NOT_OK: ProtocolId not correct, buffer is too short, Buffer is null, DataLengthPtr is null,
                            BufferLength is smaller than 3, the protocol identified with ProtocolId was not allocated for
                            functional communication.
        Description:        Enable the periodic sending of the TesterPresent message.
      </description>
      <tags>
        <tag>Callout Definitions</tag>
        <tag>Dccm Service EnableTesterPresent</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_CHANGE_PERIODICITY_INITIAL_TOO_SMALL</srcid><srcstatus/><internalId>316</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_NULL_BUFFER</srcid><srcstatus/><internalId>317</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL</srcid><srcstatus/><internalId>318</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL_DELAY_IN_TRANSMISSION</srcid><srcstatus/><internalId>319</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_LOW_BUFFERLENGTH</srcid><srcstatus/><internalId>321</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_PROTOCOL_NOT_ALLOCATED</srcid><srcstatus/><internalId>324</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_BEFORE_MODULE_INITIALIZATION</srcid><srcstatus/><internalId>325</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_Tester_Present_DccmSendTesterPresent_DataLengthPtrNULL</srcid><srcstatus/><internalId>381</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>Dccm.Api.EnableTesterPresent.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The EnableTesterPresent function is used to enable the periodic sending of the TesterPresent message on a specific Dccm protocol.
        In Dccm, the TesterPresent functionality can be used only for functional communication.
        Because of this limitation, the Dccm protocol must be allocated specifically for functional communication.
      </description>
      <tags>
        <tag>Dccm Service EnableTesterPresent</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_CHANGE_PERIODICITY_INITIAL_TOO_SMALL</srcid><srcstatus/><internalId>316</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_NULL_BUFFER</srcid><srcstatus/><internalId>317</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_ENABLE_DISABLE</srcid><srcstatus/><internalId>320</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>Dccm.Api.DisableTesterPresent.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_DisableTesterPresent
        Syntax: Std_ReturnType Dccm_DisableTesterPresent (
                      uint8 ProtocolId
                      )

        Service ID[hex]:
        Sync/Async:          Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
            ProtocolId:      The ID of the Dccm protocol.
        Parameters (inout):
        Parameters (out):
        Return value:        E_OK: TesterPresent functional message was disabled for the Dccm protocol ProtocolId.
                      E_NOT_OK: The sending of the message TesterPresent is not enabled for the ProtocolId provided as input parameter,
                            or the ProtocolId is not valid.
        Description:        Disable the periodic sending of the TesterPresent message.
      </description>
      <tags>
        <tag>Dccm Service DisableTesterPresent</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_Disable_TesterPresent_Zero_NumberOfProtocolIdsForTesterPresentMessages</srcid><srcstatus/><internalId>376</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>Dccm.Api.DisableTesterPresent.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The DisableTesterPresent function is used to disable the periodic sending of TesterPresent message over all the functional addresses defined.
      </description>
      <tags>
        <tag>Dccm Service DisableTesterPresent</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_EXCEED_MAX_NR_OF_PARALLEL_PROTOCOLS</srcid><srcstatus/><internalId>326</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>Dccm.Api.IsTesterPresentEnabled.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_IsTesterPresentEnabled
        Syntax: Std_ReturnType Dccm_IsTesterPresentEnabled (
                      uint8 ProtocolId,
                      boolean* IsTesterPresentEnabled
                      )

        Service ID[hex]:
        Sync/Async:          Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
            ProtocolId:      The ID of the Dccm protocol.
        Parameters (inout):
        Parameters (out):
          IsTesterPresentEnabled:  Will be TRUE if TesterPresent notification is enabled for the protocol with the ID ProtocolId.
        Return value:        E_OK: Status was retrieved and returned to the user
                      E_NOT_OK: The ProtocolId is not valid or IsTesterPresentEnabled is NULL.
        Description:        Check if the TesterPresent is enabled or not.
      </description>
      <tags>
        <tag>Dccm Service IsTesterPresentEnabled</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_EXCEED_MAX_NR_OF_PARALLEL_PROTOCOLS</srcid><srcstatus/><internalId>326</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_NO_FUNCTIONAL_ADDRESSES</srcid><srcstatus/><internalId>328</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_OUTPUT</srcid><srcstatus/><internalId>329</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DIFFERENT_TIMING_OUTPUT</srcid><srcstatus/><internalId>330</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_OUTPUT_NoNotificationToSwc</srcid><srcstatus/><internalId>345</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DIFFERENT_TIMING_OUTPUT_NoNotificationToSwc</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

    <specobject>
      <id>Dccm.Api.IsTesterPresentEnabled.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The IsTesterPresentEnabled function will return the status of TesterPresent for the selected Dccm protocol.
      </description>
      <tags>
        <tag>Dccm Service IsTesterPresentEnabled</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_ON_PHYSICAL_PROTOCOL</srcid><srcstatus/><internalId>322</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_IS_TESTER_PRESENT_ENABLED_IS_NULL_POINTER</srcid><srcstatus/><internalId>323</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_ENABLE_TESTER_PRESENT_NO_FUNCTIONAL_ADDRESSES</srcid><srcstatus/><internalId>328</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

    <specobject>
      <id>Dccm.Api.Dccm_ValidateRespBasedOnRequest.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_ValidateRespBasedOnRequest
        Syntax: Std_ReturnType Dccm_ValidateRespBasedOnRequest (
                        uint8* RequestBuffer,
                        uint32 RequestDataLength,
                        uint8* ResponseBuffer,
                        uint32 ResponseDataLength
                      )
        Service ID[hex]:
        Sync/Async:          Synchronous
        Reentrancy:          Non reentrant
        Parameters (in):
            RequestBuffer:    The request buffer used for validation.
            RequestDataLength:  The length of the request.
            ResponseBuffer:     The response buffer to be validated.
            ResponseDataLength: The length of the response.
        Parameters (inout):
        Parameters (out):
        Return value:        E_OK The response buffer is correct.
                      E_NOT_OK The parameters that the function was called up are invalid or
                                                the minimum length of request required to perform the checks is not met.
                      DCCM_E_INVALID_RESPONSE_LENGTH The positive response may have a fixed length or may be a changeable length.
                                               If the length varies the function will only check the minimum length.
                                               For negative response length should be 3 bytes. If the length does not meet the
                                               requirements stated above, this error will be returned.
                                            DCCM_E_INVALID_RESPONSE_FORMAT The SID from the positive response does not match the SID that should follow the request;
                                               the 2nd byte of the negative response is not the SID in the request;
                                               if the service has a DID, sub-function or a byte that must be echo, those that come in response do not match those in the request.
        Description:         This function validates a response based on request.
      </description>
      <tags>
        <tag>Dccm Service ValidateRespBasedOnRequest</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_VALIDATE_RESPONSE_OUTPUT</srcid><srcstatus/><internalId>347</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>Dccm.Api.Dccm_ValidateRespBasedOnRequest.Functional</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_ValidateRespBasedOnRequest function will validate a response based on the request in terms of length and format.
      </description>
      <tags>
        <tag>Dccm Service ValidateRespBasedOnRequest</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_VALIDATE_RESPONSE_OUTPUT</srcid><srcstatus/><internalId>347</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>Dccm.TransmissionRetry</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm should allow the PDU Router to request the same data several times after transmission problems.
        PDU Router will use the RetryInfoPtr defined in CopyTxData in order to query the data.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_RETRY_SEND_BUFFER_WRONG_STATUS_10_4</srcid><srcstatus/><internalId>286</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_RETRY_SUPPORT_10_4_OUTPUT</srcid><srcstatus/><internalId>287</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>Dccm.TransmissionRetry.BufferStreaming</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Re-transmission of data is possible both with BufferStreaming enabled and with it disabled.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_12_4_OUTPUT</srcid><srcstatus/><internalId>283</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_RETRY_WRONG_LENGTH_10_4</srcid><srcstatus/><internalId>285</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_STREAMING_RETRY_SEND_BUFFER_WRONG_STATUS_10_4</srcid><srcstatus/><internalId>286</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>Dccm.TesterPresent.ConfigurableForEachProtocol</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm should allow to configure individual timings of TesterPresent message for each functional protocol using Dccm_EnableTesterPresent() API.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL</srcid><srcstatus/><internalId>318</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DIFFERENT_TIMING_OUTPUT</srcid><srcstatus/><internalId>330</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_TESTER_PRESENT_DIFFERENT_TIMING_OUTPUT_NoNotificationToSwc</srcid><srcstatus/><internalId>346</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>Dccm.TesterPresent.SendRequestReinitializeTheTesterPresentCounter</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The processing of a request initiated by the user will delay the sending of the TesterPresent message that should be sent on the same Dccm protocol with the number of milliseconds configured between two TesterPresent messages.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL</srcid><srcstatus/><internalId>318</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL_DELAY_IN_TRANSMISSION</srcid><srcstatus/><internalId>319</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

    <specobject>
      <id>Dccm.EB.SuppressPosRspMsgIndicationBit</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall offer suport for SuppressPosRspMsgIndicationBit (SPRMIB) as specified in UDS ISO 14229.
      </description>
      <tags>
        <tag>SuppressPosRspMsgIndicationBit</tag>
        <tag>General Requirement</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>Ts_Dccm_PhysicalComm_SPRMIBTrue_NoResponse</srcid><srcstatus/><internalId>196</internalId></linkedfrom><linkedfrom><srcid>Ts_Dccm_PhysicalComm_SPRMIBTrue_NegativeResponse</srcid><srcstatus/><internalId>197</internalId></linkedfrom><linkedfrom><srcid>Ts_Dccm_PhysicalComm_SPRMIBTrue_ResponsePending2Times_NegativeResponse</srcid><srcstatus/><internalId>198</internalId></linkedfrom><linkedfrom><srcid>Ts_Dccm_PhysicalComm_SPRMIBTrue_ResponsePending_PositiveResponse</srcid><srcstatus/><internalId>199</internalId></linkedfrom><linkedfrom><srcid>Ts_Dccm_PhysicalComm_SPRMIBTrue_ResponsePending_TimeoutP2StarClient</srcid><srcstatus/><internalId>200</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>

    <specobject>
      <id>Dccm.EB.FunctionalCommunication</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall offer suport for functional communication as specified in UDS ISO 14229.
      </description>
      <tags>
        <tag>Functional Communication</tag>
        <tag>General Requirement</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_NegativeResponse_PositiveResponse</srcid><srcstatus/><internalId>210</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_ResponsePendingAndNegativeResponse_PositiveResponse</srcid><srcstatus/><internalId>211</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_4Protocols_2Functional_2Physical_DiagSessionControl_TesterPresent_ResponsePendingAndNegativeResp_PositiveResp</srcid><srcstatus/><internalId>212</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2Physical_NoResponses</srcid><srcstatus/><internalId>213</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2Physical_ResponsePendingAndNegativeResponse_NoResponse</srcid><srcstatus/><internalId>214</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2Physical_ResponsePendingAndNoResponse_NoResponse</srcid><srcstatus/><internalId>215</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>Dccm.EB.FunctionalCommunication.WhileWaitingForResponses.DccmCanSendKeepAliveMessage</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall be able so send the Keep-Alive message (the functionally addressed valid TesterPresent message with SPRMIB=true)
        while waiting for responses related with a functional request.
      </description>
      <tags>
        <tag>Functional Communication</tag>
        <tag>TesterPresent</tag>
        <tag>General Requirement</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_ResponsePendingAndNegativeResp_PositiveResp</srcid><srcstatus/><internalId>204</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_2ndFunctionalRequest_NoResponse_TesterPresentRetrySending</srcid><srcstatus/><internalId>205</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_2ndFunctionalRequest_NoResponse</srcid><srcstatus/><internalId>206</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_ResponsePendingAndNegativeResp_NoResp</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_ResponsePendingAndNoResp_NoResp</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>Dccm.EB.FunctionalCommunication.SuppressPosRspMsgIndicationBit_IsTrue.NotifySwcForPendingPhysicalProtocols.Config</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall offer the possibility to configure if the timeout notification should be sent or not
        to SWC (Software Component) for each pending physical communication protocol,
        when the functional request was sent with SuppressPosRspMsgIndicationBit (SPRMIB) set to TRUE.
      </description>
      <rationale>
        Optimization for higher performance.
        The SWC will take care of each pending physical communication protocol
        when it will receive from Dccm the timeout notification for the functional request.
      </rationale>
      <tags>
        <tag>Functional Communication</tag>
        <tag>Configuration Specification</tag>
        <tag>SuppressPosRspMsgIndicationBit</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2PhysicalNoTimeoutNotification_ResponsePendingAndNegativeResponse_NoResponse</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2PhysicalNoTimeoutNotification_ResponsePendingAndNoResponse_NoResponse</srcid><srcstatus/><internalId>203</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2PhysicalNoTimeoutNotification_NoResponses</srcid><srcstatus/><internalId>216</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_ReceiveFunctionalResponseAfterFunctionalRequestTimeout</srcid><srcstatus/><internalId>379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>Dccm.EB.NotifySwcForKeepAliveLogic.Config</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall offer the possibility to configure whether to send or not a notification
        to SWC (Software Component) after each sending of the Keep-Alive message
        (the functionally addressed valid TesterPresent message with SPRMIB=true).
      </description>
      <rationale>
        Optimization for higher performance.
      </rationale>
      <tags>
        <tag>TesterPresent</tag>
        <tag>Configuration Specification</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_ResponsePendingAndNegativeResp_NoResp</srcid><srcstatus/><internalId>207</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_ResponsePendingAndNoResp_NoResp</srcid><srcstatus/><internalId>208</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.Interfacing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: Dccm_PrepareRxBufferForFuncReq
        Syntax: Std_ReturnType Dccm_PrepareRxBufferForFuncReq(
                        uint8 ProtocolId,
                        uint8* Buffer,
                        uint16 BufferLength,
                        uint16* DataLengthPtr
                      )
        Service ID[hex]:    0x04U
        Sync/Async:         Asynchronous
        Reentrancy:         Non reentrant
        Parameters (in):
          ProtocolId:       The Protocol ID that will be used in the communication with the server.
          BufferLength:     Number of bytes that can be stored in the Buffer.
        Parameters (inout):
        Parameters (out):
          Buffer:           A pointer to the start of the buffer where the data received from the server will be stored.
          DataLengthPtr:    A pointer to return the number of bytes received from the server.
        Return value: Std_ReturnType
          E_OK: Request was successful.
          E_NOT_OK: Request was not successful.
          DCCM_STD_E_BUSY: A request is already active on the communication protocol ProtocolId.
        Description:  Dccm_PrepareRxBufferForFuncReq() is used to prepare a physical Diagnostic Protocol
          to receive a response from the diagnostic server that comes as result of a functional request.
          The Diagnostic Protocol should be in the READY state otherwise the call will return with error.
      </description>
      <tags>
        <tag>Dccm Service Dccm_PrepareRxBufferForFuncReq</tag>
        <tag>Callout Definitions</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_PrepareRxBufferForFuncReq_NO_BUFFER_PROVIDED</srcid><srcstatus/><internalId>174</internalId></linkedfrom><linkedfrom><srcid>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_NegativeResponse_PositiveResponse</srcid><srcstatus/><internalId>210</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

    <specobject>
      <id>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.NullParameters</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_PrepareRxBufferForFuncReq() function shall report an error if
        the call is made with one or more parameters of type pointer
        having the value NULL_PTR.
      </description>
      <tags>
        <tag>Dccm Service Dccm_PrepareRxBufferForFuncReq</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_PrepareRxBufferForFuncReq_NO_BUFFER_PROVIDED</srcid><srcstatus/><internalId>174</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

    <specobject>
      <id>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.WrongProtocolId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_PrepareRxBufferForFuncReq() function shall report an error
        if the call is made with a ProtocolId over the range of allowed values.
      </description>
      <tags>
        <tag>Dccm Service Dccm_PrepareRxBufferForFuncReq</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_PrepareRxBufferForFuncReq_WRONG_PROTOCOL_ID</srcid><srcstatus/><internalId>176</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

    <specobject>
      <id>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.WrongBufferLenth</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_PrepareRxBufferForFuncReq() function shall report an error
        if the call is made with a buffer that is too small.
      </description>
      <tags>
        <tag>Dccm Service Dccm_PrepareRxBufferForFuncReq</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_PrepareRxBufferForFuncReq_WRONG_BUFFER_LENGTH</srcid><srcstatus/><internalId>175</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>

    <specobject>
      <id>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.ModuleNotInitialized</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_PrepareRxBufferForFuncReq() function shall report an error
        if the Dccm module has not been initialized (Dccm_Init() function was not called).
      </description>
      <tags>
        <tag>Dccm Service Dccm_PrepareRxBufferForFuncReq</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_PrepareRxBufferForFuncReq_WITHOUT_DCCM_INIT</srcid><srcstatus/><internalId>179</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>

    <specobject>
      <id>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.WrongAddressingType</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_PrepareRxBufferForFuncReq() function shall report an error
        if the call is made for a Diagnostic Protocol that is not allocated
        for physical addressing.
      </description>
      <tags>
        <tag>Dccm Service Dccm_PrepareRxBufferForFuncReq</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_PrepareRxBufferForFuncReq_OnFunctionalProtocol</srcid><srcstatus/><internalId>178</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

    <specobject>
      <id>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.StatusNotReady</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The Dccm_PrepareRxBufferForFuncReq() function shall return
        DCCM_STD_E_BUSY if the call is made for a Diagnostic Protocol
        that do not have the status "READY".
      </description>
      <tags>
        <tag>Dccm Service Dccm_PrepareRxBufferForFuncReq</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_PrepareRxBufferForFuncReq_REJECT_SECOND_CALL_WHEN_JUST_STARTED_PROCCESSING</srcid><srcstatus/><internalId>177</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.NegativeResponse</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        In case of a negative result, Dccm shall check if the message contains 3 bytes: Negative Response SID (0x7F), Request SID and response code.
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_VALIDATE_NEGATIVE_RESPONSE</srcid><srcstatus/><internalId>349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.InputParameters</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall stop the validation process if RequestBuffer or ResponseBuffer is NULL_PTR or one of the buffer lengths is 0.
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_VALIDATE_INVALID_INPUT_PARAMETERS</srcid><srcstatus/><internalId>348</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>133</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.NonStandardServices</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process only the services defined in ISO_14229-1(2013) standard, for any other services Dccm_ValidateRespBasedOnRequest shall return error.
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_VALIDATE_NON_STANDARD_SERVICE</srcid><srcstatus/><internalId>350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.DiagnosticSessionControl</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for DiagnosticSessionControl service according with ISO_14229-1 (2013) standard:
                  - Table 24 and Table 26
                  - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_DIAGNOSTICSESSIONCONTROL_OUTPUT</srcid><srcstatus/><internalId>263</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_DIAGNOSTIC_SESSION_CONTROL</srcid><srcstatus/><internalId>351</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.ECUReset</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for ECUReset service according with ISO_14229-1 (2013) standard:
                  - Table 33 and Table 35
                  - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_ECURESET_OUTPUT</srcid><srcstatus/><internalId>251</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_ECU_RESET</srcid><srcstatus/><internalId>352</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.SecurityAccess</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for SecurityAccess service according with ISO_14229-1 (2013) standard:
                  - Table 40 and Table 44
                  - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_SECURITYACCESS_OUTPUT</srcid><srcstatus/><internalId>257</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_REQUEST_SEQUENCE_ERROR_OUTPUT</srcid><srcstatus/><internalId>275</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_INVALID_KEY_OUTPUT</srcid><srcstatus/><internalId>276</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_SECURITY_ACCESS</srcid><srcstatus/><internalId>353</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.CommunicationControl</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for CommunicationControl service according with ISO_14229-1 (2013) standard:
                  - Table 53 and Table 56
                  - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_COMMUNICATIONCONTROL_OUTPUT</srcid><srcstatus/><internalId>267</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_COMMUNICATION_CONTROL</srcid><srcstatus/><internalId>354</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.TesterPresent</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for TesterPresent service according with ISO_14229-1 (2013) standard:
                  - Table 65 and Table 67
                  - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_TESTERPRESENT_OUTPUT</srcid><srcstatus/><internalId>250</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT_OUTPUT</srcid><srcstatus/><internalId>274</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_TESTER_PRESENT</srcid><srcstatus/><internalId>355</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.AccessTimingParameter</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for AccessTimingParameter service according with ISO_14229-1 (2013) standard:
                  - Table 73 and Table 76
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_ACCESSTIMINGPARAMETER_OUTPUT</srcid><srcstatus/><internalId>252</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_ACCESS_TIMING_PARAMETER</srcid><srcstatus/><internalId>356</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.SecuredDataTransmission</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for SecuredDataTransmission service according with ISO_14229-1 (2013) standard:
                  - Table 81 and Table 83
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_SECUREDDATATRANSMISSION_OUTPUT</srcid><srcstatus/><internalId>262</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_SECURED_DATA_TRANSMISSION</srcid><srcstatus/><internalId>357</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.ControlDTCSetting</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for ControlDTCSetting service according with ISO_14229-1 (2013) standard:
                  - Table 86 and Table 89
          - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_CONTROLDTCSETTINGS_OUTPUT</srcid><srcstatus/><internalId>253</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_CONTROL_DTC_SETTING</srcid><srcstatus/><internalId>358</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.LinkControl</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for LinkControl service according with ISO_14229-1 (2013) standard:
                  - Table 124 and Table 129
          - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_LINKCONTROL_OUTPUT</srcid><srcstatus/><internalId>258</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_LINK_CONTROL</srcid><srcstatus/><internalId>359</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.ReadDataByIdentifier</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for ReadDataByIdentifier service according with ISO_14229-1 (2013) standard:
                  - Table 142 and Table 144
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_VALIDATE_READ_DATA_BY_IDENTIFIER</srcid><srcstatus/><internalId>360</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.ReadMemoryByAddress</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for ReadMemoryByAddress service according with ISO_14229-1 (2013) standard:
                  - Table 151 and Table 153
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_READMEMORYBYADDRESS_OUTPUT</srcid><srcstatus/><internalId>264</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_READ_MEMORY_BY_ADDRESS</srcid><srcstatus/><internalId>361</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.ReadScalingDataByIdentifier</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for ReadScalingDataByIdentifier service according with ISO_14229-1 (2013) standard:
                  - Table 162 and Table 164
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_READSCALINGDATABYIDENTIFIER_OUTPUT</srcid><srcstatus/><internalId>248</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_READ_SCALING_DATA_BY_IDENTIFIER</srcid><srcstatus/><internalId>362</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.DynamicallyDefineDataIdentifier</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for DynamicallyDefineDataIdentifier service according with ISO_14229-1 (2013) standard:
                  - Table 190 and Table 195
          - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_DYNAMICALLYDEFINEDATAIDENTIFIER_OUTPUT</srcid><srcstatus/><internalId>249</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_DYNAMICALLY_DEFINE_DATA_IDENTIFIER</srcid><srcstatus/><internalId>363</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.WriteDataByIdentifier</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for WriteDataByIdentifier service according with ISO_14229-1 (2013) standard:
                  - Table 231 and Table 233
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_WRITEDATABYIDENTIFIER_OUTPUT</srcid><srcstatus/><internalId>254</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_WRITE_DATA_BY_IDENTIFIER</srcid><srcstatus/><internalId>364</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.WriteMemoryByAddress</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for WriteMemoryByAddress service according with ISO_14229-1 (2013) standard:
                  - Table 238 and Table 240
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_WRITEMEMORYBYADDRESS_OUTPUT</srcid><srcstatus/><internalId>255</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_WRITE_MEMORY_BY_ADDRESS</srcid><srcstatus/><internalId>365</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.ClearDiagnosticInformation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for ClearDiagnosticInformation service according with ISO_14229-1 (2013) standard:
                  - Table 250 and Table 252
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_CLEARDIAGNOSTICINFORMATION_OUTPUT</srcid><srcstatus/><internalId>256</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_CLEAR_DIAGNOSTIC_INFORMATION</srcid><srcstatus/><internalId>366</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.InputOutputControlByIdentifier</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for InputOutputControlByIdentifier service according with ISO_14229-1 (2013) standard:
                  - Table 352 and Table 354
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_INPUTOUTPUTCONTROLBYIDENTIFIER_OUTPUT</srcid><srcstatus/><internalId>259</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_INPUT_OUTPUT_CONTROL_BY_IDENTIFIER</srcid><srcstatus/><internalId>367</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.RoutineControl</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for RoutineControl service according with ISO_14229-1 (2013) standard:
                  - Table 378 and Table 381
          - the value of suppressPosRspMsgIndicationBit from the response sub-function parameter is set to zero (page 31)
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_ROUTINECONTROL_OUTPUT</srcid><srcstatus/><internalId>265</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_SUBFUNCTION_NOT_SUPPORTED_IN_ACTIVE_SESSION_OUTPUT</srcid><srcstatus/><internalId>273</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_ROUTINE_CONTROL</srcid><srcstatus/><internalId>368</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.RequestDownload</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for RequestDownload service according with ISO_14229-1 (2013) standard:
                  - Table 393 and Table 395
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_REQUESTDOWNLOAD_TRANSFERDATA_REQUESTTRANSFEREXIT_OUTPUT</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_REQUEST_DOWNLOAD</srcid><srcstatus/><internalId>369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.RequestUpload</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for RequestUpload service according with ISO_14229-1 (2013) standard:
                  - Table 398 and Table 400
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_REQUESTUPLOAD_TRANSFERDATA_REQUESTTRANSFEREXIT_OUTPUT</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_REQUEST_UPLOAD</srcid><srcstatus/><internalId>370</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.TransferData</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for TransferData service according with ISO_14229-1 (2013) standard:
                  - Table 403 and Table 405
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_REQUESTDOWNLOAD_TRANSFERDATA_REQUESTTRANSFEREXIT_OUTPUT</srcid><srcstatus/><internalId>260</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_REQUESTUPLOAD_TRANSFERDATA_REQUESTTRANSFEREXIT_OUTPUT</srcid><srcstatus/><internalId>266</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_TRANSFER_DATA</srcid><srcstatus/><internalId>371</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.RequestFileTransfer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for RequestFileTransfer service according with ISO_14229-1 (2013) standard:
                  - Table 433 and Table 435
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_REQUESTFILETRANSFER_OUTPUT</srcid><srcstatus/><internalId>261</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_REQUEST_FILE_TRANSFER</srcid><srcstatus/><internalId>372</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.ReadDTCInformation</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Dccm shall perform the validation process for ReadDTCInformation service according with ISO_14229-1 (2013) standard:
                  - for request: Table 256, Table 257,  Table 258,  Table 259,  Table 260,  Table 261, Table 262, Table 263, Table 264, Table 265, Table 266, Table 267, Table 268
          - for response: Table 271, Table 272,  Table 273,  Table 274,  Table 275,  Table 276, Table 277, Table 278, Table 279, Table 280, Table 281, Table 282, Table 283, Table 284
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_SERVICE_READDTCINFORMATION_OUTPUT</srcid><srcstatus/><internalId>268</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_VALIDATE_READ_DTC_INFORMATION</srcid><srcstatus/><internalId>373</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>

    <specobject>
      <id>Dccm.Validate.RequestCorrectlyReceivedResponsePending</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The RequestCorrectlyReceivedResponsePending message is not sent to the client, Dccm shall verify internally the content of the response to be in accordance with ISO_14229-1 (2013) standard.
      </description>
      <tags>
        <tag>Response validation</tag>
      </tags>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_INCOMPLETE_RESPONSE</srcid><srcstatus/><internalId>231</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_RESPONSE_EXCEEDS_BUFFER_LENGTH</srcid><srcstatus/><internalId>232</internalId></linkedfrom><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_RCRRP_MULTIPLE_TRANSFER_OUTPUT</srcid><srcstatus/><internalId>234</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>Dccm.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_Dccm_VerifyCodeStub</srcid><srcstatus/><internalId>162</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>

  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>dsn.Dccm.SchMEnterCS</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/doc/project/design/pdf/Dccm_Design-profiled.xml</sourcefile>
      <sourceline>5754</sourceline>
      <version>2</version>
      <description>
						To enter an exclusive area referred to as &amp;lt;id&amp;gt;, the generated macro SchM_Enter_Dccm_&amp;lt;id&amp;gt; shall be used.
					</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TXCONFIRMATION_WRONG_TXPDUID</srcid><srcstatus/><internalId>301</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Dccm.DataConsistency.SchMUsage</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>
    <specobject>
      <id>dsn.Dccm.SchMLeaveCS</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/doc/project/design/pdf/Dccm_Design-profiled.xml</sourcefile>
      <sourceline>5771</sourceline>
      <version>2</version>
      <description>
						To leave an exclusive area referred to as &amp;lt;id&amp;gt;, the generated macro SchM_Exit_Dccm_&amp;lt;id&amp;gt; shall be used.
					</description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_DCCM_SEND_REQUEST_TXCONFIRMATION_WRONG_TXPDUID</srcid><srcstatus/><internalId>301</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>Dccm.DataConsistency.SchMUsage</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>0</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/build/reqm/common_req/Dccm_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(Dccm.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_DevErrorDetectOff</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_DetOff/source/application/EbTest_Config.h</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that source can be compiled if DccmDevErrorDetect is disabled.
  
Test Description: 
    Verify that source can be compiled if DccmDevErrorDetect is disabled.
  
Test Object: 
    DCCM_DEV_ERROR_DETECT
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Dev_Error_Detect</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_DevErrorDetectOn</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_DetOn/source/application/EbTest_Config.h</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that source can be compiled if DccmDevErrorDetect is enabled.
  
Test Description: 
    Verify that source can be compiled if DccmDevErrorDetect is enabled.
  
Test Object: 
    DCCM_DEV_ERROR_DETECT
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Dev_Error_Detect</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_P2ClientTimeoutDefaultValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsDefaultValues/source/application/EbTest_Config.h</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the P2Client timeout macro value is correctly set as per xdm value.
  
Test Description: 
    Verify that the P2Client timeout macro value is correctly set as per xdm value.
  
Test Object: 
    DCCM_TIMEOUT_P2CLIENT
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>
    <specobject>
      <id>TS_Dccm_InternalTimeoutDefaultValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsDefaultValues/source/application/EbTest_Config.h</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the internal timeout macro value is correctly set as per xdm value.
  
Test Description: 
    Verify that the internal timeout macro value is correctly set as per xdm value.
  
Test Object: 
    DCCM_TIMEOUT_INTERNAL
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>
    <specobject>
      <id>TS_Dccm_P2StarClientTimeoutDefaultValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsDefaultValues/source/application/EbTest_Config.h</sourcefile>
      <sourceline>101</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the default P2*Client timeout macro value is correctly set as per xdm value.
  
Test Description: 
    Verify that the default P2*Client timeout macro value is correctly set as per xdm value.
  
Test Object: 
    DCCM_TIMEOUT_P2STARCLIENT
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_TimeoutDisableInternal</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsDisableInternal/source/application/EbTest_Config.h</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the internal timeout is disabled when users sets 0 as value in the xdm.
  
Test Description: 
    Verify that the internal timeout is disabled when users sets 0 as value in the xdm.
  
Test Object: 
    DCCM_TIMEOUT_INTERNAL
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_P2ClientConfigValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsValues/source/application/EbTest_Config.h</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the default P2CLIENT timeout macro value is correctly set as per xdm value.
  
Test Description: 
    Verify that the default P2CLIENT timeout macro value is correctly set as per xdm value.
  
Test Object: 
    DCCM_TIMEOUT_P2CLIENT
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>
    <specobject>
      <id>TS_Dccm_InternalConfigValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsValues/source/application/EbTest_Config.h</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the internal timeout macro value is correctly set as per xdm value.
  
Test Description: 
    Verify that the internal timeout macro value is correctly set as per xdm value.
  
Test Object: 
    DCCM_TIMEOUT_INTERNAL
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>
    <specobject>
      <id>TS_Dccm_P2StarClientConfigValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsValues/source/application/EbTest_Config.h</sourcefile>
      <sourceline>101</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the default P2STARCLIENT timeout macro value is correctly set as per xdm value.
  
Test Description: 
    Verify that the default P2STARCLIENT timeout macro value is correctly set as per xdm value.
  
Test Object: 
    DCCM_TIMEOUT_P2STARCLIENT
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_P6ClientConfigValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsValues_2/source/application/EbTest_Config.h</sourcefile>
      <sourceline>15</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the default timeout macro value is correctly set as per xdm value.
  
Test Description: 
    Verify that the default timeout macro value is correctly set as per xdm value.
  
Test Object: 
    DCCM_TIMEOUT_P6CLIENT
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>
    <specobject>
      <id>TS_Dccm_P6StarClientConfigValue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Compile/IN/Dccm_ComTest_TimeoutsValues_2/source/application/EbTest_Config.h</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Verify that the default negative timeout macro value is correctly set as per xdm value.
  
Test Description: 
    Verify that the default negative timeout macro value is correctly set as per xdm value.
  
Test Object: 
    DCCM_TIMEOUT_P6STARCLIENT
  
Test Precondition: 
    None.
  
Test Execution: 
    No restrictions.
  
Test Input: 
    Generate the code based on the configuration file.
  
Test Output: 
    Verify that all the APIs are compiling successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_PrepareRxBufferForFuncReq_NO_BUFFER_PROVIDED</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_PrepareRxBufferForFuncReq_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>113</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Negative test for the function Dccm_PrepareRxBufferForFuncReq().
  
Test Description: 
    Test that the function Dccm_PrepareRxBufferForFuncReq() returns an error if 
    no buffer is provided.
  
Test Object: 
    Dccm_PrepareRxBufferForFuncReq()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate a communication protocol and verify that the operation 
        completed as expected.
    03: Call the API Dccm_PrepareRxBufferForFuncReq() without providing a 
        buffer for output data.
    04: Verify that the function returns an error and the communication 
        protocol is left in a correct state.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.NullParameters</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>
    <specobject>
      <id>TS_DCCM_PrepareRxBufferForFuncReq_WRONG_BUFFER_LENGTH</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_PrepareRxBufferForFuncReq_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>209</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Negative test for the function Dccm_PrepareRxBufferForFuncReq().
  
Test Description: 
    Test that the function Dccm_PrepareRxBufferForFuncReq() returns an error if 
    the buffer length is too small.
  
Test Object: 
    Dccm_PrepareRxBufferForFuncReq()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate a communication protocol and verify that the operation 
        completed as expected.
    03: Call the API Dccm_PrepareRxBufferForFuncReq() by providing a shorter 
        buffer than needed.
    04: Verify that the function returns an error and that the communication 
        protocol is left in a correct state.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.WrongBufferLenth</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>
    <specobject>
      <id>TS_DCCM_PrepareRxBufferForFuncReq_WRONG_PROTOCOL_ID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_PrepareRxBufferForFuncReq_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>310</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Negative test for the function Dccm_PrepareRxBufferForFuncReq().
  
Test Description: 
    Test that the function Dccm_PrepareRxBufferForFuncReq() returns an error 
    if the parameter ProtocolId exceeds the range of allowed values.
  
Test Object: 
    Dccm_PrepareRxBufferForFuncReq()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate a communication protocol and verify that the operation 
        completed as expected.
    03: Call the API Dccm_PrepareRxBufferForFuncReq() API providing
        a wrong ProtocolId.
    04: Verify that the function returns an error and the communication 
        protocol is left in a correct state.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.WrongProtocolId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>
    <specobject>
      <id>TS_DCCM_PrepareRxBufferForFuncReq_REJECT_SECOND_CALL_WHEN_JUST_STARTED_PROCCESSING</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_PrepareRxBufferForFuncReq_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>403</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Negative test for the function Dccm_PrepareRxBufferForFuncReq().
  
Test Description: 
    Test that the function Dccm_PrepareRxBufferForFuncReq() rejects a second
    call if already in the middle of processing a previous valid call.
  
Test Object: 
    Dccm_PrepareRxBufferForFuncReq()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate a communication protocol for physical communication and 
        verify that the operation completed as expected.
    03: Allocate a communication protocol for functional communication and 
        verify that the operation completed as expected.
    04: Call Dccm_PrepareRxBufferForFuncReq() for the physical 
        communication protocol and verify the return status.
    05: Call Dccm_SendRequest() for the functional communication protocol and 
        verify the return status.
    06: Simulate the transmission of the functional request
        on the functional communication protocol.
    07: Call again Dccm_PrepareRxBufferForFuncReq() for the physical 
        communication protocol and verify that it returns
        the error code DCCM_STD_E_BUSY.
    08: Simulate the receiving of the "functional response"
        on the physical communication protocol.
    09: Release the communication protocols.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.StatusNotReady</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>
    <specobject>
      <id>TS_DCCM_PrepareRxBufferForFuncReq_OnFunctionalProtocol</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_PrepareRxBufferForFuncReq_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>557</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Negative test for the function Dccm_PrepareRxBufferForFuncReq().
  
Test Description: 
    Test that the function Dccm_PrepareRxBufferForFuncReq() returns an error if 
    the addressing type of the communication protocol
    is not DCCM_E_PHYSICAL_ADDRESSING.
  
Test Object: 
    Dccm_PrepareRxBufferForFuncReq()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate a communication protocol for functional communication and 
        verify that the operation completed as expected.
    03: Call the function Dccm_PrepareRxBufferForFuncReq() for the functional 
        communication protocol and verify that it returs an error.
    04: Release the communication protocol.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.WrongAddressingType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>
    <specobject>
      <id>TS_DCCM_PrepareRxBufferForFuncReq_WITHOUT_DCCM_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_PrepareRxBufferForFuncReq_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>660</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Negative test for the function Dccm_PrepareRxBufferForFuncReq().
  
Test Description: 
    Test that the function Dccm_PrepareRxBufferForFuncReq() returns an error if 
    the Dccm module has not been initialized with a call to the function
    Dccm_Init().
  
Test Object: 
    Dccm_PrepareRxBufferForFuncReq()
  
Test Precondition: 
  
Test Execution: 
    01: Call EbTest_ResetTestVars() to reset the Dccm module and variables.
    02: Call the function Dccm_PrepareRxBufferForFuncReq() and verify that it 
        returs an error.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.ModuleNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_GET_DIAGNOSTIC_PROTOCOL_STATUS_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>90</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_GetDiagnosticProtocolStatus provides the correct status
    for a given ProtocolID.
  
Test Description: 
    The test checks that the Dccm service Dccm_GetDiagnosticProtocolStatus provides the
  correct status for a given ProtocolID that was properly initialized.
  The parameters provided to the function are valid.
  
Test Object: 
    Dccm_GetDiagnosticProtocolStatus()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API and verify the return status and
    the value of the ProtocolId
    03: call the Dccm_GetDiagnosticProtocolStatus() API and verify the return status and
    the value of protocol status
    04: call the Dccm_AllocateDiagnosticProtocol() API and verify the return status and
    the value of the ProtocolId
    05: call the Dccm_GetDiagnosticProtocolStatus() API and verify the return status and
    the value of protocol status
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Id</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.GetDiagnosticProtocolStatus.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>
    <specobject>
      <id>TS_DCCM_GET_DIAGNOSTIC_PROTOCOL_STATUS_NULL_POINTER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>182</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  Test that Dccm service Dccm_GetDiagnosticProtocolStatus returns an error when the
  parameter Status is null.
  
Test Description: 
    The test checks that the Dccm service Dccm_GetDiagnosticProtocolStatus returns an error when
  the parameter Status is null, while the ProtocolId parameter is valid.
  
Test Object: 
    Dccm_GetDiagnosticProtocolStatus()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API and verify the return status and the
    value of the ProtocolId
    03: call the Dccm_GetDiagnosticProtocolStatus() API with a valid ProtocolId parameter
    and with a null Status parameter;
    04: verify the return status and the DET report.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.GetDiagnosticProtocolStatus.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>
    <specobject>
      <id>TS_DCCM_GET_DIAGNOSTIC_PROTOCOL_STATUS_WRONG_PROTOCOL_ID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>259</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  Test that Dccm service Dccm_GetDiagnosticProtocolStatus returns an error
    when the parameter ProtocolId is not correct.
  
Test Description: 
    Test that Dccm service Dccm_GetDiagnosticProtocolStatus returns an error
    when the parameter ProtocolId is not correct, while the Status parameter is not null.
  
Test Object: 
    Dccm_GetDiagnosticProtocolStatus()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_GetDiagnosticProtocolStatus() API with a wrong value for the
    ProtocolId parameter, while the Status parameter is not null.
    03: verify the return status and the DET report.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.GetDiagnosticProtocolStatus.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_NO_CALLBACK_PROVIDED</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>327</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  Test that Dccm service Dccm_AllocateDiagnosticProtocol returns an error if no callback
  is provided.
  
Test Description: 
    The test checks that the Dccm service Dccm_AllocateDiagnosticProtocol returns an error if
  the call is made without providing a pointer to a callback function.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API without providing a callback function
    03: verify that the service returns an error
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.CallbacksNotDefined</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>20</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_NO_PROTOCOL_ID_PROVIDED</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>396</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  Test that Dccm service Dccm_AllocateDiagnosticProtocol returns an error if no ProtocolId
  is provided.
  
Test Description: 
    The test checks that the Dccm service Dccm_AllocateDiagnosticProtocol returns an error if
  the call is made without providing the ProtocolId.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API without providing the ProtocolId
    03: verify that the service returns an error
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_WRONG_TARGETTXPDUID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>463</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  Test that Dccm service Dccm_AllocateDiagnosticProtocol returns an error when the PduId used
  for sending data (targetTxPduId) is wrong
  
Test Description: 
    The test checks that the Dccm service Dccm_AllocateDiagnosticProtocol provides an error for
  a ProtocolID that wasn't properly allocated.
  The parameter targetTxPduId provided to the function is not valid.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API with the targetTxPduId set on a wrong value
    and verify the return status
    03: verify that the service returns an error
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_AND_RELEASEDIAGNOSTICPROTOCOL_TOO_MANY_PROTOCOLS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>538</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_AllocateDiagnosticProtocol and Dccm_ReleaseDiagnosticProtocol()
    return the correct value when we try to allocate too many protocols and release the protocol that
    exceeds the maximum number of protocols.
  
Test Description: 
    The test checks that the Dccm service Dccm_AllocateDiagnosticProtocol and
    Dccm_ReleaseDiagnosticProtocol() return errors when we allocate and release although the
    maximum number of protocols is reached.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
    Dccm_ReleaseDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API with the correct parameters eight
    times to reach the maximum number of protocols
    03: call the Dccm_AllocateDiagnosticProtocol() API with the correct parameters for the
    ninth time and verify that the service returns properly
    04: check if the error if transmitted
    05: call the Dccm_ReleaseDiagnosticProtocol() API with the correct parameters for the
    ninth time and verify that the service returns an error
    06: check if the error if transmitted
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>
    <specobject>
      <id>TS_DCCM_RELEASE_ALL_DIAGNOSTIC_PROTOCOLS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>691</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  Test that Dccm service Dccm_ReleaseAllDiagnosticProtocols() provides the correct status for
  two protocols.
  
Test Description: 
    The test checks that the Dccm service Dccm_ReleaseAllDiagnosticProtocols() works properly
  when we try to release all protocols having different statuses.
  
Test Object: 
    Dccm_ReleaseAllDiagnosticProtocols()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API  and verify the return status and the
    value of ProtocolId 0
    03: call the Dccm_AllocateDiagnosticProtocol() API  and verify the return status and the
    value of ProtocolId 1
    04: call the Dccm_SendRequest() API for ProtocolId 1 and verify the return status
    05: call the Dccm_ReleaseAllDiagnosticProtocols() API  and verify the return status
    06: verify statuses for Protocol 0 and Protocol 1
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseAllDiagnosticProtocols.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ReleaseAllDiagnosticProtocols.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>
    <specobject>
      <id>TS_DCCM_RELEASE_PROTOCOL_ALREADY_RELEASED</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>792</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  Test that Dccm service Dccm_ReleaseDiagnosticProtocol provides the correct status in case
  the protocol was released already.
  
Test Description: 
    The test checks that the Dccm service Dccm_ReleaseDiagnosticProtocol works properly when we
  try to release a protocol which was already released.
  
Test Object: 
    Dccm_ReleaseDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API and verify the return status and the
    value of the ProtocolId
    03: call the Dccm_AllocateDiagnosticProtocol() API for the same ProtocolId and verify
    the return status
    04: check that the status of the protocol remains unchanged after the second call of
    Dccm_AllocateDiagnosticProtocol() API
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATE_DIAGNOSTIC_PROTOCOL_INVALID_ADDRESSING_TYPE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>881</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_AllocateDiagnosticProtocol() works correctly when it is provided an
    invalid addressing type.
  
Test Description: 
    Test that Dccm service Dccm_AllocateDiagnosticProtocol() returns an error in the use case when
    the addressing type has an invalid value.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API with the AddressingType set to a wrong value
    and verify the return status
    03: verify that the service returns the correct error
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.InvalidAddressingType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_FUNCTIONAL_ADDRESSING_NO_FUNCTIONAL_SERVERS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>953</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm_AllocateDiagnosticProtocol() API returns an error when there is no existing
  functional server.
  
Test Description: 
    The test checks that the Dccm_AllocateDiagnosticProtocol() API returns the correct error when
  the protocol AddressingType is Functional and there is no existing functional server.
  
Test Object: 
  Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
  01: Initialize the Dccm module
  02: call the Dccm_AllocateDiagnosticProtocol() API for ProtocolId 0 and verify the return status.
  03: Check that the correct error has been reported
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.NoFunctionalServers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATE_BUFFERSTREAMINGCALLBACK_NOT_NULL_POINTER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management/source/application/Tests.c</sourcefile>
      <sourceline>1034</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm_AllocateDiagnosticProtocol() API returns an error when BufferStreamingCallback
  is not an null pointer and streaming is off.
  
Test Description: 
    The test checks that the Dccm_AllocateDiagnosticProtocol() API returns the correct error when
  buffer streaming is off and the parameter BufferStreamingCallback is not null.
  
Test Object: 
  Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
  01: Initialize the Dccm module
  02: call the Dccm_AllocateDiagnosticProtocol() API for ProtocolId 0 and verify the return status.
  03: Check that the correct error has been reported
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Buffer_Streaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_ALLOCATE_PHYSICAL_PROTOCOLS_EXCEEDING_NR_MAX_OF_PHYSICAL_PROTOCOLS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management_1/source/application/Tests.c</sourcefile>
      <sourceline>85</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_AllocateDiagnosticProtocol returns an error when we try to allocate
    more physical protocols than the maximum number of protocols for physical communication.
  
Test Description: 
    Test that the Dccm service Dccm_AllocateDiagnosticProtocol returns an error if you try to 
	allocate more then 6 protocols for physical communication, when the total number of parallel 
	protocols is 10 and 4 of them are reserved for functional communication. The configuration of
	the test contains 260 PduIds for physical communication and 260 PduIds for functional communication.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API for five protocols (from ProtocolId0 to 
	    ProtocolId4) and verify the return status
    03: call the Dccm_ReleaseDiagnosticProtocol() API for ProtocolId4 and verify the return status
    04: call the Dccm_AllocateDiagnosticProtocol() API for ProtocolId4 and ProtocolId5 and verify 
	    the return status
    05: call the Dccm_AllocateDiagnosticProtocol() API for ProtocolIdOver and verify that the 
	    service returns an error
    06: check if the error is transmitted
    05: call the Dccm_ReleaseAllDiagnosticProtocols() API to release all six protocols
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.Interfacing.Types</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>13</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.ExceedingNrMaxOfPhysicalProtocols</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_ALLOCATE_FUNCTIONAL_PROTOCOLS_NO_FREE_DIAGNOTIC_PROTOCOL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management_2/source/application/Tests.c</sourcefile>
      <sourceline>84</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm_AllocateDiagnosticProtocol API fails when there is no free diagnostic 
	protocol available.
  
Test Description: 
    Test that Dccm service Dccm_AllocateDiagnosticProtocol fails and returns the correct status 
	when we try to allocate a greater number of diagnostic protocols for functional communication
	than the maximum set number of diagnostic protocols (set in this case to 5).
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call the Dccm_AllocateDiagnosticProtocol() API for 6 protocols 
	    (from ProtocolId0 to ProtocolId5)
    03: Verify the return status
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.ExceedingNrMaxOfFunctionalProtocols</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATE_PROTOCOL_WITHOUT_DCCM_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management_2/source/application/Tests.c</sourcefile>
      <sourceline>198</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm_AllocateDiagnosticProtocol API returns an error if the Dccm module has not
	been initialized.
  
Test Description: 
    Test that the Dccm_AllocateDiagnosticProtocol API returns an error if the Dccm module has not 
	been initialized by not calling the Dccm_Init() function at the start of the test.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Call Dccm_AllocateDiagnosticProtocol for ProtocolId and check that it fails
    02: Check that the correct error has been returned
    03: Initialize the Dccm module
    04: Call Dccm_AllocateDiagnosticProtocol for ProtocolId and check that it succeeds
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.Init</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.ModuleNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>
    <specobject>
      <id>TS_DCCM_RELEASE_DIAGNOSTIC_PROTOCOLS_WITHOUT_DCCM_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ProtocolId_Management_2/source/application/Tests.c</sourcefile>
      <sourceline>270</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm_ReleaseDiagnosticProtocol() and Dccm_ReleaseAllDiagnosticProtocols() APIs 
	return errors if the Dccm module has not been initialized.
  
Test Description: 
    Test that the Dccm_ReleaseDiagnosticProtocol() and Dccm_ReleaseAllDiagnosticProtocols() APIs
	return errors if the Dccm module has not been initialized by not calling the Dccm_Init() 
	function at the start of the test.
  
Test Object: 
    Dccm_ReleaseDiagnosticProtocol()
    Dccm_ReleaseAllDiagnosticProtocols()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call the Dccm_AllocateDiagnosticProtocol() API for two protocols (ProtocolId0 and ProtocolId1)
    03: Call EbTest_ResetTestVars() to reset the Dccm module and variables
    04: Call Dccm_ReleaseDiagnosticProtocol() for ProtocolId0, check that it fails and check that the 
	    correct error has been returned
    05: Call Dccm_ReleaseAllDiagnosticProtocols(), check that it fails and check that the correct
	    error has been returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.ModuleNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.Dccm_ReleaseAllDiagnosticProtocols.ModuleNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Ts_Dccm_PhysicalComm_SPRMIBTrue_NoResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SPRMIB_1/source/application/Tests.c</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm handles correctly the requests that are sent with
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
  
Test Description: 
    A request is sent on a physical communication protocol with the bit
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE. The server do not 
    send any response.
    After the P2Client waiting period expires with no response from server, 
    Dccm should notify the client with the response code 
    DCCM_RSP_TIMEOUT_P2CLIENT_SPRMIB_TRUE.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Call the Dccm_SendRequest() API and verify the return status.
    03: Simulate the transmission part and verify if the correct information
        is provided to PduR.
    04: Simulate a timeout by invoking the main function until the timeout is 
        reached.
    05: Verify that Dccm notifies the client with the response code
        DCCM_RSP_TIMEOUT_P2CLIENT_SPRMIB_TRUE.
    06: Initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.SuppressPosRspMsgIndicationBit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
        <provcov>
          <linksto>Dccm.ErrorCodes001</linksto>
          <dstversion>5</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Ts_Dccm_PhysicalComm_SPRMIBTrue_NegativeResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SPRMIB_2/source/application/Tests.c</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm handles correctly the requests that are sent with
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
  
Test Description: 
    A request is sent on a physical communication protocol with the bit
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE. 
    The server answers with a negative response.
    Dccm should notify the client with the response code DCCM_RSP_OK.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Call the Dccm_SendRequest() API for ProtocolId and verify the return 
        status.
    03: Simulate the transmission part for ProtocolId and verify if the 
        correct information is provided to PduR.
    04: Simulate the receiving of data for ProtocolId by using PduR stubs and 
        verify if the information is correctly received and processed by Dccm.
    05: Verify that Dccm notifies the client with the response code DCCM_RSP_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.SuppressPosRspMsgIndicationBit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Ts_Dccm_PhysicalComm_SPRMIBTrue_ResponsePending2Times_NegativeResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SPRMIB_3/source/application/Tests.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm handles correctly the requests that are sent with
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
  
Test Description: 
    A request is sent on a physical communication protocol with the bit
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE. 
    The server answers two times with NRC_78_ResponsePending and after that 
    with the final negative response.
    Dccm should notify the client with the response code DCCM_RSP_OK.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Call the Dccm_SendRequest() API and verify the return status.
    03: Simulate the transmission of the request.
    04: Simulate the receiving of the first response pending.
    05: Simulate the receiving of the second response pending.
    06: Simulate the receiving of the final negative response.
    07: Verify that Dccm notifies the client with the response code DCCM_RSP_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.SuppressPosRspMsgIndicationBit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Ts_Dccm_PhysicalComm_SPRMIBTrue_ResponsePending_PositiveResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SPRMIB_4/source/application/Tests.c</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm handles correctly the requests that are sent with
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
  
Test Description: 
    A request is sent on a physical communication protocol with the bit
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE. 
    The server answers with NRC_78_ResponsePending and after that 
    with the final positive response.
    Dccm should notify the client with the response code DCCM_RSP_OK.
  
Test Object: 
   Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Call the Dccm_SendRequest() API and verify the return status.
    03: Simulate the transmission of the request.
    04: Simulate the receiving of a response pending.
    05: Simulate the receiving of the final positive response.
    06: Verify that Dccm notifies the client with the response code DCCM_RSP_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.SuppressPosRspMsgIndicationBit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>Ts_Dccm_PhysicalComm_SPRMIBTrue_ResponsePending_TimeoutP2StarClient</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SPRMIB_5/source/application/Tests.c</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm handles correctly the requests that are sent with
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
  
Test Description: 
    A request is sent on a physical communication protocol with the bit
    SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE. 
    The server answers with NRC_78_ResponsePending but after that 
    a P2StarClient timeout happens.
    Dccm should notify the client with the response code 
    DCCM_RSP_TIMEOUT_P2CLIENT (e.g. problems with timeout).
  
Test Object: 
   Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Call the Dccm_SendRequest() API and verify the return status.
    03: Simulate the transmission of the request.
    04: Simulate the receiving of a response pending.
    05: Simulate a P2StarClient timeout by invoking the main function.
    06: Verify that Dccm notifies the client
        with the response code DCCM_RSP_TIMEOUT_P2CLIENT.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.SuppressPosRspMsgIndicationBit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_TWO_DIAGNOSTIC_PROTOCOLS_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols/source/application/Tests.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with two ProtocolIds.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value
	received from the PduRouter, in the use-case with two ProtocolIds.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId 0 and verify the return status
    03: call the Dccm_SendRequest() API for ProtocolId 1 and verify the return status
    04: simulate the transmission part for ProtocolId 0 and verify if the correct information
        is provided to the PduR, and that the time-tracking is correctly performed
    05: simulate the transmission part for ProtocolId 1 and verify if the correct information
        is provided to the PduR, and that the time-tracking is correctly performed
    06: simulate the passing of time by calling the Dccm_MainFunction(), and verify that the
        time-tracking is correctly performed for the two diagnostic communication protocols
    07: simulate the receiving of data for ProtocolId 0 by using PduR stubs and verify if the
        information is correctly received and processed by the the Dccm,
        and that the time-tracking is correctly performed
    08: simulate the receiving of data for ProtocolId 1 by using PduR stubs and verify if the
        information is correctly received and processed by the the Dccm,
        and that the time-tracking is correctly performed
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2PhysicalNoTimeoutNotification_ResponsePendingAndNegativeResponse_NoResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_10/source/application/Tests.c</sourcefile>
      <sourceline>122</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.3 Functional communication during defaultSession with enhanced response timing - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The attribute Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols is set to FALSE.
    Because of this, and because the functional request is sent with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE,
    Dccm will not send notifications related with physical protocols
    that are still waiting a response when Dccm sends the notification for the functional protocol.
    
    The test uses three communication protocols: one functional and two physical.
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
    On the first physical communication protocol simulate the receiving of
    a ResponsePending (0x78) and after that, the receiving of a final negative response.
    On the second physical communication protocol simulate that no response is received from the diagnostic server.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
    In the configuration of Dccm, the attribute
    Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols
    is set to FALSE.
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate communication protocols: two physical and one functional.
    03: Prepare the two physical communication protocols to receive a possible 
        "functional response".
    04: Simulate the sending of a functional request with the bit SPRMIB 
        (SuppressPosRspMsgIndicationBit) set to TRUE.
    05: On the first physical communication protocol simulate the receiving of 
        a negative response ResponsePending (0x78).
    06: On the second physical communication protocol simulate that no response
        is received.
    07: On the first physical communication protocol simulate the receiving of 
        a final negative response.
    08: Verify that Dccm sends to SWC one notification for the first physical
        communication protocol.
    09: Verify that Dccm sends no notification to SWC for the second physical
        communication protocol.
    10: Verify that Dccm sends to SWC one notification for the functional
        communication protocol.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.SuppressPosRspMsgIndicationBit_IsTrue.NotifySwcForPendingPhysicalProtocols.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2PhysicalNoTimeoutNotification_ResponsePendingAndNoResponse_NoResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_11/source/application/Tests.c</sourcefile>
      <sourceline>118</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.3 Functional communication during defaultSession with enhanced response timing - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The attribute Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols is set to FALSE.
    Because of this, and because the functional request is sent with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE,
    Dccm will not send notifications related with physical protocols
    that are still waiting a response when Dccm sends the notification for the functional protocol.
    
    The test uses three communication protocols: one functional and two physical.
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
    On the first physical communication protocol simulate the receiving of
    a ResponsePending (0x78) and after that, simulate that no response is received from the diagnostic server.
    On the second physical communication protocol simulate that no response is received from the diagnostic server.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
    In the configuration of Dccm, the attribute
    Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols
    is set to FALSE.
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate communication protocols: two physical and one functional.
    03: Prepare the two physical communication protocols to receive a possible 
        "functional response".
    04: Simulate the sending of a functional request with the bit SPRMIB 
        (SuppressPosRspMsgIndicationBit) set to TRUE.
    05: On the first physical communication protocol simulate the receiving of 
        a negative response ResponsePending (0x78).
    06: Simulate that no other responses are received.
    07: Verify that Dccm do not send notifications to SWC for the physical
        communication protocols.
    08: Verify that Dccm sends one notification to SWC for the functional
        communication protocol.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.SuppressPosRspMsgIndicationBit_IsTrue.NotifySwcForPendingPhysicalProtocols.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_ResponsePendingAndNegativeResp_PositiveResp</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_12/source/application/Tests.c</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.4 Functional communication during non-default session - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The test uses four communication protocols: one functional and two physical
    for "functional responses".
    Prepare the two physical communication protocols to receive a possible "functional response".

    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a positive response.
    On the second physical communication protocol simulate the receiving of a positive response.

    Simulate the sending of a functional TesterPresent on the functional communication protocol.
    
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a ResponsePending (0x78) and after that, the receiving of a final negative response.
    On the second physical communication protocol simulate the receiving of a positive response
    and during this time, simulate the sending of a functional TesterPresent on the functional communication protocol.
    Simulate two times the sending of a functional TesterPresent on the functional communication protocol.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Prepare the two physical communication protocols to receive a possible "functional response".
    03: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    04: On the first physical communication protocol simulate the receiving of a positive response.
    05: On the second physical communication protocol simulate the receiving of a positive response.
    06: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    07: Prepare the two physical communication protocols to receive a possible "functional response".
    08: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    09: On the first physical communication protocol simulate the receiving of a ResponsePending (0x78)
        and after that, the receiving of a final negative response.
    10: On the second physical communication protocol simulate the receiving of a positive response
        and during this time, simulate the sending of a functional TesterPresent on the functional communication protocol.
    11: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    12: Simulate the sending of a functional TesterPresent on the functional communication protocol.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.WhileWaitingForResponses.DccmCanSendKeepAliveMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_2ndFunctionalRequest_NoResponse_TesterPresentRetrySending</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_13/source/application/Tests.c</sourcefile>
      <sourceline>143</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.4 Functional communication during non-default session - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The sending of the second functional request will take very long (can be up to 
    or close to 2000 ms - the InternalTimeout), and during this time Dccm should 
    try to send the functional TesterPresent - it will not be able to do it 
    because the status of the functional protocol will be "sending", and Dccm will 
    retry the sending of the functional TesterPresent (the main purpose of the 
    test).

    The test uses four communication protocols: one functional and two physical
    for "functional responses".
    Prepare the two physical communication protocols to receive a possible "functional response".

    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a positive response.
    On the second physical communication protocol simulate the receiving of a positive response.

    Simulate the sending of a functional TesterPresent on the functional communication protocol.
    
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the physical communication protocols simulate that no responses come from the diagnostic servers.
    Simulate the sending of a functional TesterPresent on the functional communication protocol.
    In Dccm, simulate a timeout for the functional request.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
    In the configuration of Dccm, the attribute
    Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols
    is set to FALSE.
    Note: this setting has no impact in the current test, because both
    functional requests used in this test have
    suppressPosRspMsgIndicationBit SPRMIB = FALSE.
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Prepare the two physical communication protocols to receive a possible "functional response".
    03: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    04: On the first physical communication protocol simulate the receiving of a positive response.
    05: On the second physical communication protocol simulate the receiving of a positive response.
    06: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    07: Prepare the two physical communication protocols to receive a possible "functional response".
    08: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
        Simulate that this sending takes long time - enough for Dccm to try to send without success
        a functional TesterPresent, because the functional protocol is in use.
    09: On the physical communication protocols simulate that no responses come from the diagnostic servers.
    10: Simulate the re-sending of a functional TesterPresent on the functional communication protocol.
        Note: this is the main purpose of the test.
    11: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    12: In Dccm, simulate a timeout for the functional request.
    13: Verify that Dccm sent to SWC 2 notifications for the first physical communication protocol.
    14: Verify that Dccm sent to SWC 2 notifications for the second physical communication protocol.
    15: Verify that Dccm sent to SWC 5 notifications for the functional communication protocol:
        2 for FunctionalRequests initiated by SWC and 3 for TesterPresent requests initiated by Dccm.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.WhileWaitingForResponses.DccmCanSendKeepAliveMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_2ndFunctionalRequest_NoResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_14/source/application/Tests.c</sourcefile>
      <sourceline>140</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.4 Functional communication during non-default session - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The test uses four communication protocols: one functional and two physical
    for "functional responses".
    Prepare the two physical communication protocols to receive a possible "functional response".

    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a positive response.
    On the second physical communication protocol simulate the receiving of a positive response.

    Simulate the sending of a functional TesterPresent on the functional communication protocol.
    
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the physical communication protocols simulate that no responses come from the diagnostic servers.
    Simulate the sending of a functional TesterPresent on the functional communication protocol.
    In Dccm, simulate a timeout for the functional request.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
    In the configuration of Dccm, the attribute
    Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols
    is set to FALSE.
    Note: this setting has no impact in the current test, because both
    functional requests used in this test have
    suppressPosRspMsgIndicationBit SPRMIB = FALSE.
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Prepare the two physical communication protocols to receive a possible "functional response".
    03: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    04: On the first physical communication protocol simulate the receiving of a positive response.
    05: On the second physical communication protocol simulate the receiving of a positive response.
    06: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    07: Prepare the two physical communication protocols to receive a possible "functional response".
    08: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    09: On the physical communication protocols simulate that no responses come from the diagnostic servers.
    10: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    11: In Dccm, simulate a timeout for the functional request.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.WhileWaitingForResponses.DccmCanSendKeepAliveMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_ResponsePendingAndNegativeResp_NoResp</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_15/source/application/Tests.c</sourcefile>
      <sourceline>146</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.4 Functional communication during non-default session - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The test uses four communication protocols: one functional and two physical
    for "functional responses".
    Prepare the two physical communication protocols to receive a possible "functional response".

    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a positive response.
    On the second physical communication protocol simulate the receiving of a positive response.

    Simulate the sending of a functional TesterPresent on the functional communication protocol.
    
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a ResponsePending (0x78) and after that, the receiving of a final negative response.
    On the second physical communication protocol simulate that no response is received from the diagnostic server.

    Simulate three times the sending of a functional TesterPresent on the functional communication protocol.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
    - In the configuration of Dccm, the attribute
      Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols
      is set to FALSE.
      Note: this setting has no impact in the current test, because both
      functional requests used in this test have
      suppressPosRspMsgIndicationBit SPRMIB = FALSE.
    - In the configuration of Dccm, the attribute Dccm_NotifySwcForKeepAliveLogic
      is set to FALSE.
      Note: because of this setting, Dccm will send fewer notifications to SWC.
      In more detail, Dccm will not notify the SWC after sending the functional
      TesterPresent.
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Prepare the two physical communication protocols to receive a possible "functional response".
    03: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    04: On the first physical communication protocol simulate the receiving of a positive response.
    05: On the second physical communication protocol simulate the receiving of a positive response.
    06: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    07: Prepare the two physical communication protocols to receive a possible "functional response".
    08: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    09: On the first physical communication protocol simulate the receiving of a ResponsePending (0x78)
        and after that, the receiving of a final negative response.
    10: On the second physical communication protocol simulate that no response is received from the diagnostic server.
    11: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    12: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    13: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    13: Verify that Dccm sent to SWC 2 notifications for the first physical communication protocol.
    14: Verify that Dccm sent to SWC 2 notifications for the second physical communication protocol.
    15: Verify that Dccm sent to SWC 2 notifications for the functional communication protocol
        (for the 2 FunctionalRequests initiated by the SWC).
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.WhileWaitingForResponses.DccmCanSendKeepAliveMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>Dccm.EB.NotifySwcForKeepAliveLogic.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_DiagSessionControl_TesterPresentOnTheSameProtocol_ResponsePendingAndNoResp_NoResp</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_16/source/application/Tests.c</sourcefile>
      <sourceline>143</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.4 Functional communication during non-default session - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The test uses four communication protocols: one functional and two physical
    for "functional responses".
    Prepare the two physical communication protocols to receive a possible "functional response".

    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a positive response.
    On the second physical communication protocol simulate the receiving of a positive response.

    Simulate the sending of a functional TesterPresent on the functional communication protocol.
    
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of
    a ResponsePending (0x78) and after that, simulate that no response is received from the diagnostic server.
    On the second physical communication protocol simulate that no response is received from the diagnostic server.

    Simulate three times the sending of a functional TesterPresent on the functional communication protocol.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
    - In the configuration of Dccm, the attribute
      Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols
      is set to FALSE.
      Note: this setting has no impact in the current test, because both
      functional requests used in this test have
      suppressPosRspMsgIndicationBit SPRMIB = FALSE.
    - In the configuration of Dccm, the attribute Dccm_NotifySwcForKeepAliveLogic
      is set to FALSE.
      Note: because of this setting, Dccm will send fewer notifications to SWC.
      In more detail, Dccm will not notify the SWC after sending the functional
      TesterPresent.
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Prepare the two physical communication protocols to receive a possible "functional response".
    03: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    04: On the first physical communication protocol simulate the receiving of a positive response.
    05: On the second physical communication protocol simulate the receiving of a positive response.
    06: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    07: Prepare the two physical communication protocols to receive a possible "functional response".
    08: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    09: On the first physical communication protocol simulate the receiving of a ResponsePending (0x78)
        and after that, simulate that no response is received from the diagnostic server.
    10: On the second physical communication protocol simulate that no response is received from the diagnostic server.
    11: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    12: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    13: Simulate the sending of a functional TesterPresent on the functional communication protocol.
    13: Verify that Dccm sent to SWC 2 notifications for the first physical communication protocol.
    14: Verify that Dccm sent to SWC 2 notifications for the second physical communication protocol.
    15: Verify that Dccm sent to SWC 2 notifications for the functional communication protocol
        (for the 2 FunctionalRequests initiated by the SWC).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.WhileWaitingForResponses.DccmCanSendKeepAliveMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>Dccm.EB.NotifySwcForKeepAliveLogic.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_TWO_PROTOCOLS_1_PHYSICAL_1_FUNCTIONAL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_2/source/application/Tests.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    The test checks that the Dccm sends the payloads in the correct order, treating the functional
    communication with priority.
  
Test Description: 
    Test that Dccm sends in the correct order the payloads, treating the functional
    communication with higher priority. The use-case should be configured with two communication
    protocols/channels: one physical and one functional. The Dccm_SendRequest() API is called
    first for the lower priority physical communication protocol, and after that for the
    higher priority functional communication protocol. The Dccm_MainFunction() should send
    first the payload of the functional communication protocol, and only after this it should
    send the payload of the physical communication protocol.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
    - Dccm has configured two communication protocols/channels: one physical and one functional;
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId 0 (physical communication)
        and verify the return status
    03: call the Dccm_SendRequest() API for ProtocolId 1 (functional communication)
        and verify the return status
    04: simulate the transmission part for ProtocolId 1 (functional communication)
        and verify if the correct information is provided to the PduR, and that
        the time-tracking is correctly performed
    05: simulate the transmission part for ProtocolId 0 (physical communication)
        and verify if the correct information is provided to the PduR, and that
        the time-tracking is correctly performed
    06: simulate the passing of time by calling the Dccm_MainFunction(), and verify that the
        time-tracking is correctly performed for the two diagnostic communication protocols
    07: simulate the receiving of data for ProtocolId 0 (physical communication)
        by using PduR stubs and verify if the information is correctly received
        and processed by the the Dccm, and that the time-tracking is correctly performed
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.MainFunction.Transmission_04</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_NegativeResponse_PositiveResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_3/source/application/Tests.c</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.2 Functional communication during defaultSession - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The test uses three communication protocols: one functional and two physical.
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a negative response.
    On the second physical communication protocol simulate the receiving of a positive response.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate communication protocols: two physical and one functional.
    03: Prepare the two physical communication protocols to receive a possible 
        "functional response".
    04: Simulate the sending of a functional request with the bit SPRMIB 
        (SuppressPosRspMsgIndicationBit) set to FALSE.
    05: On the first physical communication protocol simulate the receiving of 
        a negative response.
    06: On the second physical communication protocol simulate the receiving 
        of a positive response.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>Dccm.EB.Api.Dccm_PrepareRxBufferForFuncReq.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_3Protocols_1Functional_2Physical_ResponsePendingAndNegativeResponse_PositiveResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_4/source/application/Tests.c</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.3 Functional communication during defaultSession with enhanced response timing - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.
    
    The test uses three communication protocols: one functional and two physical.
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a ResponsePending (0x78) and after that, the receiving of a final negative response.
    On the second physical communication protocol simulate the receiving of a positive response.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate communication protocols: two physical and one functional.
    03: Prepare the two physical communication protocols to receive a possible 
        "functional response".
    04: Simulate the sending of a functional request with the bit SPRMIB 
        (SuppressPosRspMsgIndicationBit) set to FALSE.
    05: On the first physical communication protocol simulate the receiving of 
        a negative response ResponsePending (0x78).
    06: On the second physical communication protocol simulate the receiving 
        of a positive response.
    07: On the first physical communication protocol simulate the receiving of 
        a final negative response.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_4Protocols_2Functional_2Physical_DiagSessionControl_TesterPresent_ResponsePendingAndNegativeResp_PositiveResp</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_5/source/application/Tests.c</sourcefile>
      <sourceline>151</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.4 Functional communication during non-default session - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The test uses four communication protocols: one functional for normal requests,
    two physical for "functional responses" and one functional for TesterPresent requests.
    Prepare the two physical communication protocols to receive a possible "functional response".

    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a positive response.
    On the second physical communication protocol simulate the receiving of a positive response.

    Simulate the sending of a functional TesterPresent on the second functional communication protocol.
    
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    On the first physical communication protocol simulate the receiving of a ResponsePending (0x78) and after that, the receiving of a final negative response.
    On the second physical communication protocol simulate the receiving of a positive response
    and during this time, simulate the sending of a functional TesterPresent on the second functional communication protocol.
    Simulate two times the sending of a functional TesterPresent on the second functional communication protocol.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Prepare the two physical communication protocols to receive a possible "functional response".
    03: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    04: On the first physical communication protocol simulate the receiving of a positive response.
    05: On the second physical communication protocol simulate the receiving of a positive response.
    06: Simulate the sending of a functional TesterPresent on the second functional communication protocol.
    07: Prepare the two physical communication protocols to receive a possible "functional response".
    08: Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to FALSE.
    09: On the first physical communication protocol simulate the receiving of a ResponsePending (0x78)
        and after that, the receiving of a final negative response.
    10: On the second physical communication protocol simulate the receiving of a positive response
        and during this time, simulate the sending of a functional TesterPresent on the second functional communication protocol.
    11: Simulate the sending of a functional TesterPresent on the second functional communication protocol.
    12: Simulate the sending of a functional TesterPresent on the second functional communication protocol.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2Physical_NoResponses</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_6/source/application/Tests.c</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.2 Functional communication during defaultSession - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The test uses three communication protocols: one functional and two physical.
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
    Simulate that no response is received from the diagnostic servers.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate communication protocols: two physical and one functional.
    03: Prepare the two physical communication protocols to receive a possible 
        "functional response".
    04: Simulate the sending of a functional request with the bit SPRMIB 
        (SuppressPosRspMsgIndicationBit) set to TRUE.
    05: Simulate that no response is received from the diagnostic servers.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2Physical_ResponsePendingAndNegativeResponse_NoResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_7/source/application/Tests.c</sourcefile>
      <sourceline>122</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.3 Functional communication during defaultSession with enhanced response timing - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.
    
    The test uses three communication protocols: one functional and two physical.
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
    On the first physical communication protocol simulate the receiving of
    a ResponsePending (0x78) and after that, the receiving of a final negative response.
    On the second physical communication protocol simulate that no response is received from the diagnostic server.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate communication protocols: two physical and one functional.
    03: Prepare the two physical communication protocols to receive a possible 
        "functional response".
    04: Simulate the sending of a functional request with the bit SPRMIB 
        (SuppressPosRspMsgIndicationBit) set to TRUE.
    05: On the first physical communication protocol simulate the receiving of 
        a negative response ResponsePending (0x78).
    06: On the second physical communication protocol simulate that no response
        is received.
    07: On the first physical communication protocol simulate the receiving of 
        a final negative response.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2Physical_ResponsePendingAndNoResponse_NoResponse</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_8/source/application/Tests.c</sourcefile>
      <sourceline>118</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.3 Functional communication during defaultSession with enhanced response timing - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.
    
    The test uses three communication protocols: one functional and two physical.
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
    On the first physical communication protocol simulate the receiving of
    a ResponsePending (0x78) and after that, simulate that no response is received from the diagnostic server.
    On the second physical communication protocol simulate that no response is received from the diagnostic server.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate communication protocols: two physical and one functional.
    03: Prepare the two physical communication protocols to receive a possible 
        "functional response".
    04: Simulate the sending of a functional request with the bit SPRMIB 
        (SuppressPosRspMsgIndicationBit) set to TRUE.
    05: On the first physical communication protocol simulate the receiving of 
        a negative response ResponsePending (0x78).
    06: Simulate that no other responses are received.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_FunctionalComm_SPRMIbTrue_3Protocols_1Functional_2PhysicalNoTimeoutNotification_NoResponses</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_MultipleDiagnosticProtocols_9/source/application/Tests.c</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test the support provided by Dccm for functional communication.
  
Test Description: 
    The diagram from the chapter "10.2.2 Functional communication during defaultSession - with SOM.ind"
    from the document ISO_14229-2_2021.PDF was used as inspiration for the test.

    The attribute Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols is set to FALSE.
    Because of this, and because the functional request is sent with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE,
    Dccm will not send notifications related with physical protocols
    that are still waiting a response when Dccm sends the notification for the functional protocol.

    The test uses three communication protocols: one functional and two physical.
    Prepare the two physical communication protocols to receive a possible "functional response".
    Simulate the sending of a functional request with the bit SPRMIB (SuppressPosRspMsgIndicationBit) set to TRUE.
    Simulate that no response is received from the diagnostic servers.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
    In the configuration of Dccm, the attribute
    Dccm_FunctionalComm_SPRMIbTrue_TimeoutNotificationOnPhysicalProtocols
    is set to FALSE.
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Allocate communication protocols: two physical and one functional.
    03: Prepare the two physical communication protocols to receive a possible 
        "functional response".
    04: Simulate the sending of a functional request with the bit SPRMIB 
        (SuppressPosRspMsgIndicationBit) set to TRUE.
    05: Simulate that no response is received from the diagnostic servers.
    06: Verify that Dccm do not send notifications to SWC for the physical
        communication protocols.
    07: Verify that Dccm sends one notification to SWC for the functional
        communication protocol.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.SuppressPosRspMsgIndicationBit_IsTrue.NotifySwcForPendingPhysicalProtocols.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_NO_BUFFER_PROVIDED</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>112</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm service Dccm_SendRequest returns an error if no buffer is provided.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns an error if the call is made
    without providing a pointer to a buffer.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: allocate a communication protocol and verify that the operation completed as expected
    03: call the Dccm_SendRequest() API without providing a buffer for output data
    04: verify that the service returns an error and the communication protocol is left in a
		correct state
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_WRONG_BUFFER_LENGTH</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>199</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm service Dccm_SendRequest returns an error if the buffer length is too small
  
Test Description: 
	The test checks that the Dccm service Dccm_SendRequest returns an error if the call is made
	with a buffer that is too small.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: allocate a communication protocol and verify that the operation completed as expected
    02: call the Dccm_SendRequest() API by providing a shorter buffer than needed
    03: verify that the service returns an error and that the communication protocol is left in a
		correct state
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.WrongBufferLenth</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_WRONG_PROTOCOL_ID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>295</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest returns an error if the ProtocolId used to call the
	service exceeds the range
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns an error if the call is made
    with a ProtocolId over the range of allowed values.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: allocate a communication protocol and verify that the operation completed as expected
    03: call the Dccm_SendRequest() API by providing a wrong ProtocolId
    04: verify that the service returns an error and the communication protocol is left in a
		correct state
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.WrongProtocolId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_ALL_PARAM_WRONG</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>384</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest returns an error if all the input parameters have
	wrong values.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns an error if the call is made
    with all the parameters having wrong values.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: allocate a communication protocol and verify that the operation completed as expected
    02: call the Dccm_SendRequest() API with all the parameters having wrong values
    03: verify that the service returns an error and the communication protocol is left in a 
		correct state
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.WrongPrameters</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_REJECT_SECOND_CALL_WHEN_JUST_STARTED_PROCCESSING</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>472</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly rejects a valid call
    if still in the middle of processing.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest rejects a second call
    if already in the middle of processing a previous valid call.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: initiate a second Dccm_SendRequest() API call and verify if
        it is not accepted and that the state of the previous call is not affected
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ParallelProcessing_02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RejectTheSecondFunctionalRequest</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly rejects a valid call
    if still in the middle of processing.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest rejects a second call
    if already in the middle of processing a previous valid call.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: initiate a second Dccm_SendRequest() API call and verify if
        it is not accepted and that the state of the previous call is not affected
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.Dccm_SendRequest.RejectCall.FunctionalRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_WITHOUT_DCCM_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>717</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm service Dccm_SendRequest returns an error if the Dccm module has not been
    initialized.
  
Test Description: 
    Test that the Dccm service Dccm_SendRequest returns an error if the Dccm module has not been
    initialized by not calling the Dccm_Init() function at the start of the test.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call the Dccm_AllocateDiagnosticProtocol() API for ProtocolId and verify the return status
    03: Call EbTest_ResetTestVars() to reset the Dccm module and variables
    04: Call Dccm_SendRequest() for ProtocolId, check that it fails and that the correct error has
        been returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.ModuleNotInitialized</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_DataLengthPtr_WithValueZero</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>805</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly rejects a valid call
    if still in the middle of processing.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest rejects a second call
    if already in the middle of processing a previous valid call.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: initiate a second Dccm_SendRequest() API call and verify if
        it is not accepted and that the state of the previous call is not affected
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ParallelProcessing_02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_DataLengthPtr_WithValueOne</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>907</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly rejects a valid call
    if still in the middle of processing.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest rejects a second call
    if already in the middle of processing a previous valid call.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: initiate a second Dccm_SendRequest() API call and verify if
        it is not accepted and that the state of the previous call is not affected
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ParallelProcessing_02</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>19</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>120</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value
	received from the PduRouter, in the use-case with one ProtocolId.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
    	is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
    	information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>Dccm.EB.BSWMDGeneration_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1</internalId></provcov>
        <provcov>
          <linksto>Dccm.EB.BSWMDGeneration_2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>2</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_TWO_MESSAGES_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>188</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId and two messages sent.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value
	received from the PduRouter, in the use-case with one ProtocolId and two messages sent.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module and allocate a communication protocol
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate transmission of data for ProtocolId and verify if the correct information
		is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm
    05: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    06: simulate the transmission part for ProtocolId and verify if the correct information
		is provided to the PduR
    07: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm
    08: release the diagnostic protocol
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.ModuleId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>12</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RETRY_SUPPORT_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>261</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId. Use support for data retransmission.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value
	received from the PduRouter, in the use-case with one ProtocolId.
	Use support for data retransmission.
	Verify that the function Dccm_CopyTxData() correctly handles the use-case when the parameter
	PduInfoPtr-&gt;SduLength is zero.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status.
        Use a buffer with the length of 10 bytes.
    03: simulate the transmission of data for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffer with the length of 3 bytes.
        Send all the bytes with the TP_CONFPENDING retry parameter.
    04: send the data using the following pattern (indexes): 012, 345, 678, 9 (a total of 10 bytes)
    05: ask to retransmit the last 8 bytes of data: indexes 2-9;
        this is a confirmation for the bytes from the indexes 0-1;
        ask to transmit 3 bytes: the bytes from the indexes 2-4;
    06: confirm the bytes sent until this moment, asking for no data transfer
    07: ask to transmit 2 bytes: the bytes from the indexes 5-6;
        use retry parameter TP_CONFPENDING
    07: ask to transmit 2 bytes: the bytes from the indexes 7-8;
        use retry parameter TP_DATACONF
    08: ask to transmit 1 byte: the bytes from the index 9;
        use retry parameter TP_DATACONF
    09: confirm the bytes sent until this moment, asking for no data transfer
    10: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.RetrySupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_FUNCTIONAL_REQUEST_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>344</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm service Dccm_SendRequest, using functional addressing, correctly returns the
	values received, in the use-case with one ProtocolId.
  
Test Description: 
	The test checks that the Dccm service Dccm_SendRequest, using functional addressing,
	returns the correct value received from the PduRouter, in the use-case with one ProtocolId.
  
Test Object: 
  Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
  01: Initialize the Dccm module
  02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
  03: simulate the transmission part for ProtocolId and verify if the correct information
      is provided to the PduR
  04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
      information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.DccmFunctionalPduIds</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_ONE_PROTOCOL_4_ECUS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm can communicate with 4 different ECUs, in the use-case with one ProtocolId.
  
Test Description: 
    The test checks that the Dccm can communicate with 4 different ECUs one after another,
    in the use-case with one ProtocolId.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: Allocate the communication protocol 0 in order to communicate with ECU 0;
    03: Simulate the communication with ECU 0 (transmit and receive data);
    04: Release the communication protocol 0;
    05: Allocate the communication protocol 0 in order to communicate with ECU 1;
    06: Simulate the communication with ECU 1 (transmit and receive data);
    07: Release the communication protocol 0;
    08: Allocate the communication protocol 0 in order to communicate with ECU 2;
    09: Simulate the communication with ECU 2 (transmit and receive data);
    10: Release the communication protocol 0;
    11: Allocate the communication protocol 0 in order to communicate with ECU 3;
    12: Simulate the communication with ECU 3 (transmit and receive data);
    12: Release the communication protocol 0.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RCRRP_INCOMPLETE_RESPONSE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_RCRRP_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>125</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm service Dccm_SendRequest correctly handles
    the use-case with one ProtocolId, RCRRP (RequestCorrectlyReceivedResponsePending)
    and an incomplete response from the server.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest correctly handles
    the use-case with one ProtocolId, RCRRP (RequestCorrectlyReceivedResponsePending)
    and an incomplete response from the server, followed by a call to Dccm_RxIndication().
    Verify that the functions Dccm_StartOfReception() and Dccm_CopyRxData() correctly handle
    the use-case when the parameter that indicates the length of the message
    (TpTotalLength and respectively PduInfoPtr-&gt;SduLength) is zero.
    For the function Dccm_CopyRxData(), this is a query
    to find out the number of bytes that are still free and available to store
    the next part(s) of the message that will be received.
    For the function Dccm_StartOfReception(),
    this will be the length of the receive buffer, because no bytes are received yet
    for the current message. For Dccm_CopyRxData(), this can be the length of the
    receive buffer (in the moment just after Dccm_StartOfReception(), when the
    receiving of data is announced, but no byte was received yet).
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
		is provided to the PduR
    04: simulate the receiving of a first RequestCorrectlyReceivedResponsePending message
		for ProtocolId by using PduR stubs and verify if the information is correctly
		received and processed by the Dccm
    05: simulate the receiving of a second RequestCorrectlyReceivedResponsePending message
		for ProtocolId by using PduR stubs and verify if the information is correctly
		received and processed by the Dccm
    06: simulate the receiving of data for ProtocolId by using PduR stubs.
		Using the function Dccm_StartOfReception(), announce a 6 bytes response from the server.
		Using the function Dccm_CopyRxData(), provide a 3 bytes response.
		After this, end the reception with a call to Dccm_RxIndication(),
		ignoring to send the remaining 3 bytes from the server response.
		Verify that Dccm correctly reports an error to the client of Dccm.
		Verify that the functions Dccm_StartOfReception() and Dccm_CopyRxData() correctly handle
		the use-case when the parameter that indicates the length of the message
		(TpTotalLength and respectively PduInfoPtr-&gt;SduLength) is zero.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.ErrorCodes001</linksto>
          <dstversion>5</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
        <provcov>
          <linksto>Dccm.Validate.RequestCorrectlyReceivedResponsePending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RCRRP_RESPONSE_EXCEEDS_BUFFER_LENGTH</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_RCRRP_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>224</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly handles
    the use-case with one ProtocolId, RCRRP (RequestCorrectlyReceivedResponsePending)
    and a response that is longer than what was initially announced.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest correctly handles
    the use-case with one ProtocolId, RCRRP (RequestCorrectlyReceivedResponsePending)
    and a response that is longer than what was initially announced.
    Verify that the functions Dccm_StartOfReception() and Dccm_CopyRxData() correctly handle
    the use-case when the parameter that indicates the length of the message
    (TpTotalLength and respectively PduInfoPtr-&gt;SduLength) is zero.
    For the function Dccm_CopyRxData(), this is a query
    to find out the number of bytes that are still free and available to store
    the next part(s) of the message that will be received.
    For the function Dccm_StartOfReception(),
    this will be the length of the receive buffer, because no bytes are received yet
    for the current message. For Dccm_CopyRxData(), this can be the length of the
    receive buffer (in the moment just after Dccm_StartOfReception(), when the
    receiving of data is announced, but no byte was received yet).
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
		is provided to the PduR
    04: simulate the receiving of a first RequestCorrectlyReceivedResponsePending message
		for ProtocolId by using PduR stubs and verify if the information is correctly
		received and processed by the Dccm
    05: simulate the receiving of a second RequestCorrectlyReceivedResponsePending message
		for ProtocolId by using PduR stubs and verify if the information is correctly
		received and processed by the Dccm
    06: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm.
		The server announces that the response will have 6 bytes.
		Receive the response from server as 2 different messages: one of 3 bytes and one of
		4 bytes (too long: (3+4=7) &lt; 6).
		Verify that the functions Dccm_StartOfReception() and Dccm_CopyRxData() correctly handle
		the use-case when the parameter that indicates the length of the message
		(TpTotalLength and respectively PduInfoPtr-&gt;SduLength) is zero.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.DccmMainfunctionCycle</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>Dccm.Validate.RequestCorrectlyReceivedResponsePending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RCRRP_RESPONSE_WRONG_SID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_RCRRP_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>316</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm check the content of the received message.
  
Test Description: 
    The test checks that the Dccm service Dccm_RxIndication validate the content of the
    RCRRP (RequestCorrectlyReceivedResponsePending) response and returns error when the
    SID in the response is different from SID in request.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
		is provided to the PduR
    04: simulate the receiving of a first RequestCorrectlyReceivedResponsePending message
		for ProtocolId by using PduR stubs and verify if the information is correctly
		received and processed by the Dccm
    05: simulate the receiving of a second RequestCorrectlyReceivedResponsePending message
		which contains a wrong SID
	06: check that the correct error was reported to DET and the client receive
	    the correct response code
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.RequestCorrectlyReceivedResponsePending.WrongSID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>93</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RCRRP_MULTIPLE_TRANSFER_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_RCRRP_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>123</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId and RCRRP (RequestCorrectlyReceivedResponsePending).
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId and RCRRP
    (RequestCorrectlyReceivedResponsePending).
    Verify that the functions Dccm_StartOfReception() and Dccm_CopyRxData() correctly handle
    the use-case when the parameter that indicates the length of the message
    (TpTotalLength and respectively PduInfoPtr-&gt;SduLength) is zero.
    For the function Dccm_CopyRxData(), this is a query
    to find out the number of bytes that are still free and available to store
    the next part(s) of the message that will be received.
    For the function Dccm_StartOfReception(),
    this will be the length of the receive buffer, because no bytes are received yet
    for the current message. For Dccm_CopyRxData(), this can be the length of the
    receive buffer (in the moment just after Dccm_StartOfReception(), when the
    receiving of data is announced, but no byte was received yet).
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
		is provided to the PduR
    04: simulate the receiving of a first RequestCorrectlyReceivedResponsePending message
		for ProtocolId by using PduR stubs and verify if the information is correctly
		received and processed by the Dccm
    05: simulate the receiving of a second RequestCorrectlyReceivedResponsePending message
		for ProtocolId by using PduR stubs and verify if the information is correctly
		received and processed by the Dccm
    06: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm.
		Receive the 6 bytes response from the server as 2 different messages, each of 3 bytes.
		Verify that the functions Dccm_StartOfReception() and Dccm_CopyRxData() correctly handle
		the use-case when the parameter that indicates the length of the message
		(TpTotalLength and respectively PduInfoPtr-&gt;SduLength) is zero.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.ErrorCodes002</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>10</internalId></provcov>
        <provcov>
          <linksto>Dccm.Validate.RequestCorrectlyReceivedResponsePending</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RCRRP_SINGLE_TRANSFER_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_RCRRP_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm service SendRequest correctly processes rx response pending message.
  
Test Description: 
    Test that Dccm service SendRequest correctly processes rx response pending message.
  
Test Object: 
   Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API and verify the return status
    03: transmit the data
    04: receive a response pending
    05: receive the "real" rx confirmation.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.DccmMainfunctionCycle</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
        <provcov>
          <linksto>Dccm.RequestCorrectlyReceivedResponsePending.OK</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RECEIVING_RX_BUFFER_TOO_SMALL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>113</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm service Dccm_SendRequest stops the processing if the RX part encounters 
	a problem.
  
Test Description: 
    Test that Dccm service Dccm_SendRequest stops the processing if the RX part encounters
    a problem related to a buffer smaller than the amount of data available.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate a receiving error by providing a wrong buffer 
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.WrongBufferLenth</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>Dccm.API.MainFunction.Receive_03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_WRONG_PDU_RX_CALLS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>235</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that the Dccm service Dccm_SendRequest functions correctly when wrong parameters are used in the
	PduR Rx callbacks.
  
Test Description: 
    Test that the Dccm service Dccm_SendRequest functions correctly when wrong parameters are used in the 
	PduR Rx callbacks.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: transmit the data
    04: receive a start of reception for a wrong PDUID
    05: receive a start of reception with a NULL_PTR
    06: receive a start of reception for a length greater than the Dccm available buffer
    07: receive a normal start of reception
    08: receive CopyRxData request with wrong PDUID
    09: receive a normal CopyRxData request
    10: receive a RxIndication request with wrong PDUID
    11: receive a normal RxIndication request
    12: receive a start of reception call after the RxIndication
    13: receive CopyRxData request after the RxIndication
    10: receive a RxIndication request after the RxIndication
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SendRequest.WrongPrameters</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.SendRequest.WrongPduRRx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RECEIVING_RX_NULL_AVAILABLE_DATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>408</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service SendRequest correctly handles a CopyRxData with a null available data pointer.
  
Test Description: 
    Test that Dccm service SendRequest correctly handles a CopyRxData with a null available data pointer.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate a receiving error by providing a null pointer to the Dccm_CopyRxData
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.CopyRxData.NullParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RECEIVING_RX_NULL_BUFFER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>526</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service SendRequest correctly handles a CopyRxData with a null buffer.
  
Test Description: 
    Test that Dccm service SendRequest correctly handles a CopyRxData with a null buffer.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate a receiving error by providing a wrong buffer to the Dccm_CopyRxData
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.CopyRxData.NullParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RECEIVING_RX_INDICATION_FAIL_INVALID_FS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>639</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service SendRequest works as expected when and after the RxIndication returns
    an error.
  
Test Description: 
    Test that Dccm service SendRequest works as expected when and after the RxIndication returns
    an error.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: perform the transmission and provide rx buffer and set an error return code
        for RxIndication
    04: verify the correct notification of the user function and the state of Dccm
    05: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.RxIndication.ProcessingANewRequest</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RECEIVING_RX_BUFFER_OVERFLOW</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>722</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service SendRequest gracefully stops the processing if the RxProvide 
    encounters a buffer overflow situation.
  
Test Description: 
    Test that Dccm service SendRequest gracefully stops the processing if the RxProvide 
    encounters a buffer overflow situation.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate a buffer overflow situation by providing a higher amount of data to 
        the Dccm_CopyRxData than was signaled in the Start of reception
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.CopyRxData.BufferOverflow</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>84</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_START_OF_RECEPTION_WRONG_RXPDUID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>844</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_StartOfReception correctly returns an error,
    in the use-case with a wrong rxPduId.
  
Test Description: 
    The test checks that the Dccm service Dccm_StartOfReception returns the correct value
    and error when the rxPduId has an incorrect value.
  
Test Object: 
    Dccm_StartOfReception()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate an incorrect receiving of data for ProtocolId by giving an incorrect value
		for rxPduId and verify the return status
    05: check the error returned from reciving of data.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.StartOfReception.WrongParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_START_OF_RECEPTION_WRONG_STATUS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>948</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_StartOfReception returns an error when the protocol
	status is incorrect.
  
Test Description: 
    The test checks that the Dccm service Dccm_StartOfReception returns the correct value
    and error when the protocol status is incorrect.
  
Test Object: 
    Dccm_StartOfReception()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: call the Dccm_ReleaseDiagnosticProtocol() API for ProtocolId to change its status
        to DCCM_DIAGNOSTIC_PROTOCOL_STATUS_UNUSED
    05: simulate an incorrect receiving of data for ProtocolId and verify the return status
    06: check the returned error from the receiving of data.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.StartOfReception.WrongProtocolStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_COPY_RX_DATA_WRONG_RXPDUID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1057</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm service Dccm_CopyRxData returns an error when it is provided an invalid rxPduId.
  
Test Description: 
    The test checks that the Dccm service Dccm_CopyRxData returns an error if the call is made using
    the rxPduId parameter with an incorrect value.
  
Test Object: 
    Dccm_CopyRxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId, call the Dccm_CopyRxData whith the
        parameter rxPduId having a wrong value.
    05: verify that the service returns an error
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.CopyRxData.InvalidRx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>80</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RXINDICATION_WRONG_RXPDUID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1165</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm service Dccm_RxIndication returns an error after sending the successful
	receipt notification using a wrong rxPduId.
  
Test Description: 
    Test that, after the correct reception of data, the Dccm service Dccm_RxIndication returns
	an error after sending the successful receipt notification using a wrong rxPduId.
  
Test Object: 
    Dccm_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    05: simulate a sending of successful receipt notification to a wrong rxPduId(rxPduId1)
		and checks if the error has been transmitted
    06: verify that the protocol has been left in a correct state
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.RxIndication.WrongRx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>88</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RXINDICATION_RESPONSE_WRONG_BUFFERSIZE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1283</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check that the Dccm_RxIndication function works correctly when the response buffer has
    an incorrect length.
  
Test Description: 
    The test checks that the Dccm service Dccm_RxIndication returns the correct response code
    when the response buffer has an incorrect length.
  
Test Object: 
    Dccm_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    05: check that RxIndication correctly modifies the protocol response code to DCCM_RSP_WRONG_BUFFER_SIZE
		after the reception was made using an incorrect buffer length
    06: verify that the protocol has been left in a correct state
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.DccmPhysicalPduIds</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.RxIndication.WrongBufferSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_COPY_RX_DATA_WRONG_BUFFERSIZE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Reception_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1412</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm service Dccm_CopyRxData returns an error in the use-case when attempting
    to copy data longer than the data remaining in the buffer.
  
Test Description: 
    The test checks that the Dccm service Dccm_CopyRxData returns an error on the
    second call when more data is requested than the size of the data remaining in the buffer.
  
Test Object: 
    Dccm_CopyRxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and call the
        Dccm_CopyRxData() API to copy only a part of the message
    05: verify if the information is correctly received
    06: call the Dccm_CopyRxData() API to copy another part of the message by providing a
        wrong buffer size and verify the return status
    07: check that the correct error is transmitted
    08: call the Dccm_CopyRxData() API to copy the rest of the message by providing
        correct parameters
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.DccmPhysicalPduIds</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>6</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.CopyRxData.WrongBufferSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_READSCALINGDATABYIDENTIFIER_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>182</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for the ReadScalingDataByIdentifier service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for the
    ReadScalingDataByIdentifier service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ReadScalingDataByIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_DYNAMICALLYDEFINEDATAIDENTIFIER_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>338</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for the DynamicallyDefineDataIdentifier service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for the
    DynamicallyDefineDataIdentifier service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.DynamicallyDefineDataIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_TESTERPRESENT_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>519</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for TesterPresent service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for TesterPresent 
    service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.TesterPresent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_ECURESET_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>668</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for ECUReset service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for ECUReset service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ECUReset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_ACCESSTIMINGPARAMETER_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>816</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for AccessTimingParameter service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for AccessTimingParameter service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.AccessTimingParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_CONTROLDTCSETTINGS_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>969</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for ControlDTCSetting service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for ControlDTCSetting service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ControlDTCSetting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_WRITEDATABYIDENTIFIER_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>1122</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for WriteDataByIdentifier service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for
	WriteDataByIdentifier service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.WriteDataByIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_WRITEMEMORYBYADDRESS_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>1313</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for WriteMemoryByAddress service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for
	WriteMemoryByAddress service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.WriteMemoryByAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_CLEARDIAGNOSTICINFORMATION_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>1481</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for ClearDiagnosticInformation service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for ClearDiagnosticInformation
	service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ClearDiagnosticInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_SECURITYACCESS_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>1633</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for the SecurityAccess service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value received 
	from the PduRouter, in the use-case with one ProtocolId for the SecurityAccess service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.SecurityAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_LINKCONTROL_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>1785</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for the LinkControl service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for the LinkControl service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    06: call for second time the Dccm_SendRequest() API for ProtocolId and verify the return status
    07: simulate another transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    08: verify that no response is received after the last request
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.LinkControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_INPUTOUTPUTCONTROLBYIDENTIFIER_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>2006</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for InputOutputControlByIdentifier service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for the
	InputOutputControlByIdentifier service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    06: call for second time the Dccm_SendRequest() API for ProtocolId and verify the return status
    07: simulate another transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    08: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.InputOutputControlByIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_REQUESTDOWNLOAD_TRANSFERDATA_REQUESTTRANSFEREXIT_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>2235</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for RequestDownload, TransferData, RequestTransferExit services.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value received from the 
    PduRouter, in the use-case with one ProtocolId for the RequestDownload, TransferData and 
    RequestTransferExit services.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for RequestDownload service and ProtocolId,
		verify the return status
    04: simulate the transmission part for RequestDownload service and ProtocolId ,
		verify if the correct information is provided to the PduR
    05: simulate the receiving of data for ProtocolId and RequestDownload service by
		using PduR stubs and verify if the information is correctly received and processed 
		by the Dccm
    06: call the Dccm_SendRequest() API for TransferData service and ProtocolId,
		verify the return status
    07: simulate the transmission part for TransferData service and ProtocolId,
		verify if the correct information is provided to the PduR
    08: simulate the receiving of data for ProtocolId and TransferData service by
		using PduR stubs and verify if the information is correctly received and processed 
		by the Dccm
    09: call the Dccm_SendRequest() API for RequestTransferExit service and ProtocolId,
		verify the return status
    10: simulate the transmission part for RequestTransferExit service and ProtocolId,
		verify if the correct information is provided to the PduR
    11: simulate the receiving of data for ProtocolId and RequestTransferExit service by
		using PduR stubs and verify if the information is correctly received and processed 
		by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RequestDownload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
        <provcov>
          <linksto>Dccm.Validate.TransferData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_REQUESTFILETRANSFER_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>2541</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for RequestFileTransfer service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for the RequestFileTransfer service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RequestFileTransfer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_SECUREDDATATRANSMISSION_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_1/source/application/Tests.c</sourcefile>
      <sourceline>2726</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for the SecuredDataTransmission service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for the
	SecuredDataTransmission service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.SecuredDataTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_DIAGNOSTICSESSIONCONTROL_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_2/source/application/Tests.c</sourcefile>
      <sourceline>135</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for the DiagnosticSessionControl service.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, when the DiagnosticSessionControl service is used to 
    enable the diagnostic session programmingSession in the server.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.DiagnosticSessionControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_READMEMORYBYADDRESS_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_2/source/application/Tests.c</sourcefile>
      <sourceline>222</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for ReadMemoryByAddress service.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId for the ReadMemoryByAddress service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in a server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ReadMemoryByAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_ROUTINECONTROL_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_2/source/application/Tests.c</sourcefile>
      <sourceline>385</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service correctly returns the values received, in the use-case with one
	ProtocolId for the RoutineControl service.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value received 
	from the PduRouter, in the use-case with one ProtocolId for the RoutineControl service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in a server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RoutineControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_REQUESTUPLOAD_TRANSFERDATA_REQUESTTRANSFEREXIT_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_2/source/application/Tests.c</sourcefile>
      <sourceline>545</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for the RequestUpload, TransferData, RequestTransferExit services.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct values received from the 
    PduRouter, in the use-case with one ProtocolId for the RequestUpload, TransferData and 
    RequestTransferExit services.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in a server.
    03: call the Dccm_SendRequest() API for RequestUpload service and ProtocolId,
		verify the return status
    04: simulate the transmission part for RequestUpload service and ProtocolId,
		verify if the correct information is provided to the PduR
    05: simulate the receiving of data for ProtocolId and RequestUpload service by
		using PduR stubs and verify if the information is correctly received and processed 
		by the Dccm
    06: call the Dccm_SendRequest() API for TransferData service and ProtocolId and
		verify the return status
    07: simulate the transmission part for TransferData service and ProtocolId and
		verify if the correct information is provided to the PduR
    08: simulate the receiving of data for ProtocolId and TransferData service by
		using PduR stubs and verify if the information is correctly received and processed 
		by the Dccm
    09: call the Dccm_SendRequest() API for RequestTransferExit service and ProtocolId and
		verify the return status
    10: simulate the transmission part for RequestTransferExit service and ProtocolId and
		verify if the correct information is provided to the PduR
    11: simulate the receiving of data for ProtocolId and RequestTransferExit service by
		using PduR stubs and verify if the information is correctly received and processed by 
		the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RequestUpload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
        <provcov>
          <linksto>Dccm.Validate.TransferData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_COMMUNICATIONCONTROL_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_2/source/application/Tests.c</sourcefile>
      <sourceline>846</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for CommunicationControl service.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct values
    received from the PduRouter, in the use-case with one ProtocolId for the
	CommunicationControl service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in a server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.CommunicationControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_READDTCINFORMATION_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_2/source/application/Tests.c</sourcefile>
      <sourceline>1002</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId for the ReadDTCInformation service.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value received 
	from the PduRouter, in the use-case with one ProtocolId for the ReadDTCInformation service.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ReadDTCInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_NOT_SUPPORTED_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>181</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case with one ProtocolId
	when it sends a request to a service that is not supported.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct negative response
	code received from the PduRouter, in the use-case when the service is not supported.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Dev_Error_Detect</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
        <provcov>
          <linksto>Dccm.ServiceNotSupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_SUBFUNCTION_NOT_SUPPORTED_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>249</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case with one ProtocolId 
	when it sends a request to a service, providing a sub-function which is not supported.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct negative response
	code received from the PduRouter, in the use-case when the sub-function is not supported.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.SubFunctionNotSupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_REQUEST_OUT_OF_RANGE_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>316</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case with one ProtocolId
	when it sends a request to LinkControl service, providing an invalid identifier.
  
Test Description: 
	The test checks that the Dccm service Dccm_SendRequest returns the correct negative response
	code received from the PduRouter, in the use-case when an identifier within the request 
	message has an invalid value.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
		is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Dev_Error_Detect</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
        <provcov>
          <linksto>Dccm.ReqOutOfRange</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_NOT_SUPPORTED_IN_ACTIVE_SESSION_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>385</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case when the 
    diagnostic session in the server is set to default and it sends a request to a service 
	which is not allowed during the defaultSession
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct negative response
    code received from the PduRouter, when it sends a request to a service which is not
    allowed during the defaultSession
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Dev_Error_Detect</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>4</internalId></provcov>
        <provcov>
          <linksto>Dccm.Config.DccmMainfunctionCycle</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>5</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_SUBFUNCTION_NOT_SUPPORTED_IN_ACTIVE_SESSION_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>454</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly when the sub-function is not
    supported in the current diagnostic session. 
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct negative response
    code received from the PduRouter, when it sends a request during the defaultSession to 
    RoutineControl service (defined in Table 23, ISO14229-1:2013), using the sub-function to 
	startRoutine with the RoutineIdentifier eraseMemory (mentioned in Table F.1, ISO14229-1:2013). 
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RoutineControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_INCORRECT_MESSAGE_LENGTH_OR_INVALID_FORMAT_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>522</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case with one ProtocolId
	when it sends a request to TesterPresent service providing a message with an incorrect length.
  
Test Description: 
   The test checks that the Dccm service Dccm_SendRequest returns the correct negative response
   code received from the PduRouter, in the use-case when the request message has an incorrect length. 
   The TesterPresent service accepts a maximum of two values in the request message.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.TesterPresent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_REQUEST_SEQUENCE_ERROR_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>589</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case with one ProtocolId
	when it sends a request to SecurityAccess service that should be preceded by another request.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct negative response
    code received from the PduRouter, in the use-case when it sends the 'sendKey' sub-function
	to the sever without first sending a 'requestSeed' request message.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.SecurityAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_INVALID_KEY_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>656</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case with one ProtocolId
	when it sends a request to SecurityAccess service providing an incorrect server key.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct  negative response
    code received from the PduRouter, in the use-case when trying to unlock the sever but it
    sends an invalid server key. The key should be 0xC9A9(2's complement of the seed value) but 
    has the value 0x3657(1's complement of the seed value).
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId to request the seed and verify the 
	    return status
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    05: call the Dccm_SendRequest() API for ProtocolId to send the key and verify the
     	return status
    06: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    07: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.SecurityAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
        <provcov>
          <linksto>Dccm.Error_Reporting</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_VEHICLE_SPEED_TOO_HIGH_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>732</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case with one ProtocolId
	when it sends a request but the vehicle speed is too high.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct negative
    response code received from the PduRouter, in the use-case when vehicle speed is too high.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.VehicleSpeedIsTooHigh</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>102</internalId></provcov>
        <provcov>
          <linksto>Dccm.Error_Reporting</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_SERVICE_TEMPERATURE_TOO_HIGH_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>800</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest works correctly in the use-case with one ProtocolId
	when it sends a request to a service but the temperature is too high.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct negative response 
	code received from the PduRouter, in the use-case when temperature is too high.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Enable the diagnostic session programmingSession in server.
    03: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.TemperatureIsTooHigh</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_OUTPUT_NEGATIVE_RESPONSE_WRONG_BUFFER_LENGTH</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Services_NegativeResponses_1/source/application/Tests.c</sourcefile>
      <sourceline>867</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm service SendRequest correctly handles the negative response
    with an incorrect buffer size.
  
Test Description: 
    The test checks that the Dccm service SendRequest correctly handles the negative response
    with an incorrect buffer size received from the PduRouter.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate the transmission part and verify if the correct information
        is provided to the PduR
    04: simulate the receiving of a negative response with wrong buffer size by using PduR stubs
        and verify if the information is correctly received and processed by the Dccm
    05: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.CopyRxData.WrongBufferSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_STREAMING_NO_RETRY_WRONG_LENGTH_10_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Streaming_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>114</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    The test checks that the Dccm service Dccm_SendRequest returns an error when more bytes are 
	requested to be transmitted than are available.
  
Test Description: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received when more bytes 
	are requested to be transmitted than are availablee in the buffer,
    in the use-case with one ProtocolId, with streaming but no retry support.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status;
        send 10 bytes using a buffer of 4 bytes;
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR; transmit the data with the following pattern:
      - transmit 4 bytes
      - transmit the next 4 bytes
      - incorrectly transmit 3 bytes
      - transmit the last 2 bytes, correct trasmission
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Id</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>3</internalId></provcov>
        <provcov>
          <linksto>Dccm.Config.Buffer_Streaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    <specobject>
      <id>TS_DCCM_PROTOCOL_BUFFERSTREAMINGCALLBACK_NOT_OK</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Streaming_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>348</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Allocate a protocol using a BufferStreamingCallback API which returns E_NOT_OK and simulate 
	the transmission flow which should fail because the Dccm_MainFunction() API will not be able
	to change the protocol status.
  
Test Description: 
    Allocate ProtocolId0 using a BufferStreamingCallback API which is E_NOT_OK and simulate the
	transmission flow. When calling the Dccm_MainFunction() API for the second time this should fail
	to change the protocol status from DCCM_DIAGNOSTIC_PROTOCOL_STATUS_TRANSMIT_REQUEST_NEXT_BUFFER.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: Call Dccm_AllocateDiagnosticProtocol() API for ProtocolId using 
		Dccm_BufferStreamingCallback set to return E_NOT_OK
    03: Call the Dccm_SendRequest() API for ProtocolId and verify the return status;
    04: Simulate the transmission, which should fail when attempting to change the protocol 
		status from DCCM_DIAGNOSTIC_PROTOCOL_STATUS_TRANSMIT_REQUEST_NEXT_BUFFER
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.BufferStreamingCallback.Fails</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_STREAMING_10_4_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Streaming_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId and with streaming.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value
	received from the PduRouter, in the use-case with one ProtocolId and with streaming.
	Send 10 bytes using a buffer of 4 bytes. Verify the use-case when the parameter 
	PduInfoPtr-&gt;SduLength of the function Dccm_CopyTxData() is zero.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status;
        send 10 bytes using a buffer of 4 bytes;
    03: simulate the transmission part for ProtocolId and verify if the correct information
    	is provided to the PduR;
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
    	information is correctly received and processed by the Dccm.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Buffer_Streaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_STREAMING_12_4_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Streaming_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>188</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId and with streaming.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId and with streaming.
    Send 12 bytes using a buffer of 4 bytes.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status;
        send 12 bytes using a buffer of 4 bytes;
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR;
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.TransmissionRetry.BufferStreaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_STREAMING_4_4_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Streaming_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>256</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId and with streaming.
  
Test Description: 
    The test checks that the UDS service Dccm_SendRequest returns the correct value
    received from the PduRouter, in the use-case with one ProtocolId and with streaming.
    Send 4 bytes using a buffer of 4 bytes.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status;
        send 4 bytes using a buffer of 4 bytes;
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR;
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.BufferStreaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_STREAMING_RETRY_WRONG_LENGTH_10_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Streaming_RetrySupport_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>117</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    The test checks that the Dccm service Dccm_SendRequest returns an error when more bytes are
	requested to be retransmitted than are available.
  
Test Description: 
	Test that Dccm service Dccm_SendRequest correctly returns the values received, when 
	it happens to request a retransmission of some bytes exceeding the number of 
	bytes available in the buffer, in the use-case with one ProtocolId, with streaming
	and retransmission.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status;
        send 10 bytes using a buffer of 4 bytes;
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR; transmit the data with the following pattern:
      - transmit 4 bytes
      - transmit the next 1 byte
      - transmit the next 3 bytes
      - incorrectly re-transmit 4 bytes: last 1 from the previous transfer, next 2 available and 
	    another one that does not exist
      - re-transmit the last 2 bytes form the previous transfer of 3 bytes
      - transmit the last 2 bytes
      - re-transmit the last byte from the previous transfer of 2 bytes
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.TransmissionRetry.BufferStreaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_STREAMING_RETRY_SEND_BUFFER_WRONG_STATUS_10_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Streaming_RetrySupport_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>197</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
	when the previously transmitted buffer has not yet been processed,
    in the use-case with one ProtocolId, with streaming and retransmission.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct values
    in the use-case with one ProtocolId, with streaming and retransmission, when
    it is attempting to copy unrequested data and the current status is incorrect because 
	the previously transmitted buffer was not processed.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status;
        send 10 bytes using a buffer of 4 bytes;
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR; transmit the data with the following pattern:
      - transmit 4 bytes
      - try to transmit the next 1 byte without calling Dccm_MainFunction() API and verify the
	    return status
      - transmit the next 1 byte correctly
      - transmit the next 3 bytes
      - re-transmit the last 2 bytes form the previous transfer of 3 bytes
      - transmit the last 2 bytes
      - re-transmit the last byte from the previous transfer of 2 bytes
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.TransmissionRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
        <provcov>
          <linksto>Dccm.TransmissionRetry.BufferStreaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_STREAMING_RETRY_SUPPORT_10_4_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Streaming_RetrySupport_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly returns the values received,
    in the use-case with one ProtocolId, with streaming and retransmission.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest returns the correct value
	received from the PduRouter, in the use-case with one ProtocolId, with streaming and
	retransmission. Send 10 bytes using a buffer of 4 bytes.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status;
        send 10 bytes using a buffer of 4 bytes;
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR; transmit the data with the following pattern:
      - transmit 4 bytes
      - transmit the next 1 byte
      - transmit the next 3 bytes
      - re-transmit the last 2 bytes form the previous transfer of 3 bytes
      - transmit the last 2 bytes
      - re-transmit the last byte from the previous transfer of 2 bytes
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.TransmissionRetry</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SETCOMMUNICATIONTIMEOUTPARAMETERS_NEGATIVE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>130</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service SetCommunicationTimeoutParameters return error when some parameters
     are invalid or when is called at a wrong time.
  
Test Description: 
    Test that Dccm service SetCommunicationTimeoutParameters works as expected and returns error when
     the provided are invalid or the protocol status is not ready.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the SetCommunicationTimeoutParameters() API providing an unallocated protocol
      and verify that it returns error
    03: call the Dccm_AllocateDiagnosticProtocol() API to allocate one protocol
    04: call the Dccm_SendRequest() API and verify the return status
    05: call the SetCommunicationTimeoutParameters() API and verify that it returns error
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SetCommunicationTimeoutParameters.P2Client.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.SetCommunicationTimeoutParameters.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SETCOMMUNICATIONTIMEOUTPARAMETERS_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
   Test that Dccm service SetCommunicationTimeoutParameters works correctly when sending
    two requests on a single protocol.
  
Test Description: 
    Test that Dccm service SetCommunicationTimeoutParameters works as expected and timeout values
	  remain unchanged even if multiple requests are sent on the same protocol.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SetCommunicationTimeoutParameters API to set new values for timeouts
    03: call the Dccm_SendRequest() API and verify the return status
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    06: initiate a second Dccm_SendRequest() API call and verify throughout the processing 
    that the timeout values remain the same
        
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts_Runtime_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts_Runtime_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    <specobject>
      <id>TS_DCCM_DISABLE_INTERNAL_TIMEOUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>378</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm InternalTimeout is disabled when its value is set to "0".
  
Test Description: 
    Test that Dccm InternalTimeout is disabled when its value is set to "0".
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SetCommunicationTimeoutParameters API to set new values for timeouts
    03: call the Dccm_SendRequest() API and verify the return status
    04: simulate the transmission part for ProtocolId by calling MainFunction()
    05: verify the value of InternalTimeout, to make sure that it is still disabled
    06: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.Disable_InternalTimeout</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>Dccm.Config.Dccm_Configurable_Timeouts_Runtime_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>
    <specobject>
      <id>TS_DCCM_RX_INTERNALTIMEOUT_NEGATIVE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>500</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm stops the processing of a request when the internal timeout expires.
  
Test Description: 
    Test that Dccm stops the processing if the Dccm_RxIndication call is not received
    before the timeout is reached.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate a timeout by invoking the main function without calling the 
		Dccm_RxIndication until the timeout is reached
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.Internal.Behavior_2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>Dccm.API.MainFunction.Timeout</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TX_INTERNALTIMEOUT_NEGATIVE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>626</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm stops the processing of a request when the internal timeout expires.
  
Test Description: 
    Test that Dccm stops the processing if the Dccm_TxConfirmation call is not received
    before the timeout is reached.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API and verify the return status
	03: simulate a timeout by invoking the main function without calling the 
		Dccm_TxConfirmation until the timeout is reached
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.Internal.Behavior_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    <specobject>
      <id>TS_DCCM_P2CLIENT_TIMEOUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>736</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm stops the processing of a request when the timeout loaded with P2Client expires .
  
Test Description: 
    Test that Dccm stops the processing if the Dccm_StartOfReception call is not received
    before the timeout is reached.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API and verify the return status
	03: simulate the transmission part and verify if the correct information
      is provided to the PduR
    04: simulate a timeout by invoking the main function without calling the 
		Dccm_StartOfReception until the timeout is reached
    05: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.P2Client.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>Dccm.ErrorCodes001</linksto>
          <dstversion>5</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALL_TIMEOUTS_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>846</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that both Dccm timeouts (InternalTimeout and Timeout) works correctly during the processing
	of a request.
  
Test Description: 
    The test checks that the Dccm both timeouts starts and stops properly and the correct configuration
	values are loaded.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module and verify if the status is ready
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate the transmission part and verify if the correct information
      is provided to the PduR
    04: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
    	information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.Internal</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.P2Client</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.P2StarClient</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>38</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.Measurement_unit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.Application_timers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.Application_timer_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.Application_timer_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>
    <specobject>
      <id>TS_DCCM_P2STARCLIENT_TIMEOUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>977</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm stops the processing of a request when the timeout loaded with P2StarClient expires.
  
Test Description: 
    Test that Dccm stops the processing when a ResponsePending message was received and the
	Dccm_StartOfReception call is not received before the timeout is reached.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module and verify if the status is ready
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate the transmission part and verify if the correct information
        is provided to the PduR
	04: simulate the receiving of a RequestCorrectlyReceivedResponsePending message
		for ProtocolId by using PduR stubs and verify if the information is correctly
		received and processed by the Dccm
    05: simulate a timeout by invoking the main function without calling the
		Dccm_StartOfReception until the timeout is reached
    06: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.P2StarClient.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
    <specobject>
      <id>TS_DCCM_P2STARCLIENT_TIMEOUT_RequestLengthOneByte</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_1/source/application/Tests.c</sourcefile>
      <sourceline>1077</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
  Test that Dccm stops the processing of a request when the timeout loaded with P2StarClient expires.
  
Test Description: 
    Test that Dccm stops the processing when a ResponsePending message was received and the
  Dccm_StartOfReception call is not received before the timeout is reached.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module and verify if the status is ready
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate the transmission part and verify if the correct information
        is provided to the PduR
  04: simulate the receiving of a RequestCorrectlyReceivedResponsePending message
    for ProtocolId by using PduR stubs and verify if the information is correctly
    received and processed by the Dccm
    05: simulate a timeout by invoking the main function without calling the
    Dccm_StartOfReception until the timeout is reached
    06: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.P2StarClient.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_P6CLIENT_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_2/source/application/Tests.c</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that both Dccm timeouts (InternalTimeout and Timeout) works correctly during the processing
    of a request when P6Client is configured.
  
Test Description: 
    The test checks that the Dccm both timeouts starts and stops properly and the correct configuration
    values are loaded.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Allocate a communication protocol and verify that the status of the protocol is ready
    03: call the Dccm_SendRequest() API and verify the return status
    04: simulate the transmission part and verify if the correct information
      is provided to the PduR
    05: simulate the receiving of two consecutive ResponsePending messages for ProtocolId by
       using PduR stubs and verify if the information is correctly received and processed by the Dccm
    06: simulate the receiving of the final positive response message for ProtocolId by
       using PduR stubs and verify if the information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SetCommunicationTimeoutParameters.P6Client.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.Application_timer_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.Internal.Behavior_2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
    <specobject>
      <id>TS_DCCM_P6STARCLIENT_EXPIRES</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_2/source/application/Tests.c</sourcefile>
      <sourceline>244</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that the correct response code is sent to the client when the timer P6*Client expires.
  
Test Description: 
    The test checks that the Dccm works properly when P6*Client expires.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, allocate a communication protocol and verify that the status of the protocol is ready
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate the transmission part and verify if the correct information
      is provided to the PduR
    04: simulate the receiving of a ResponsePending messages for ProtocolId by
       using PduR stubs and verify if the information is correctly received and processed by the Dccm
    05: simulate a timeout by invoking the main function without receiving a
       Dccm_RxIndication() until the timeout is reached
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.P6StarClient</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.P6StarClient.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    <specobject>
      <id>TS_DCCM_P6CLIENT_EXPIRES</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_2/source/application/Tests.c</sourcefile>
      <sourceline>366</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that the correct response code is sent to the client when the timer P6Client expires.
  
Test Description: 
    The test checks that the Dccm works properly when P6Client expires.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, allocate a communication protocol and verify that the status of the protocol is ready
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate the transmission part and verify if the correct information
      is provided to the PduR
    04: simulate a timeout by invoking the main function without receiving a
    response until the timeout is reached
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.P6Client</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.P6Client.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    <specobject>
      <id>TS_DCCM_P6CLIENT_EXPIRES_SPRMIbTrue</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Timeout_2/source/application/Tests.c</sourcefile>
      <sourceline>509</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that the correct response code is sent to the client when the timer P6Client expires.
  
Test Description: 
    The test checks that the Dccm works properly when P6Client expires.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, allocate a communication protocol and verify that the status of the protocol is ready
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate the transmission part and verify if the correct information
      is provided to the PduR
    04: simulate a timeout by invoking the main function without receiving a
    response until the timeout is reached
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Timeout.P6Client</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>Dccm.Timeout.P6Client.Behavior</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_TXCONFIRMATION_WRONG_TXPDUID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>144</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm service Dccm_TxConfirmation correctly returns an error, in the use-case with
    one ProtocolId, when the confirmation of transmission is sent to the wrong TxPduId.
  
Test Description: 
    The test checks that the Dccm service Dccm_TxConfirmation returns an error when the confirmation
    of transmission is sent to the wrong TxPduId.
  
Test Object: 
    Dccm_TxConfirmation()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: check the initial counter values for SchM_Enter_Dccm_SCHM_DCCM_EXCLUSIVE_AREA_0() and
        SchM_Exit_Dccm_SCHM_DCCM_EXCLUSIVE_AREA_0() and their values after the first
        Dccm_MainFunction() call
    04: simulate the transmission for ProtocolId and verify if the correct information is
        provided to the PduR
    05: send the transmission confirmation to a wrong TxPduId and verify if the received error
        is correct
    06: send the transmission confirmation to the correct TxPduId to verify that the protocol
        has been left in a correct state
    07: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.TxConfirmation.WrongTx</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>dsn.Dccm.SchMLeaveCS</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>dsn.Dccm.SchMEnterCS</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_REJECT_SECOND_CALL_AFTER_TRANSMISSION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>330</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest correctly rejects a valid call
    if still in the middle of processing.
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest rejects a second call
    if already in the middle of processing a previous valid call.
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: initiate a second Dccm_SendRequest() API call and verify if
        it is not accepted and the state of the previous call is not affected
    04: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR
    05: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.Dccm_SendRequest.RejectCall</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>98</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_TRANSMISSION_FAIL_INVALID_FS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>450</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest stops the processing if the E_NOT_OK
    is received by TxConfirmation
  
Test Description: 
    Test that Dccm service Dccm_SendRequest stops the processing if the E_NOT_OK
    is received by TxConfirmation
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API and verify the return status
    03: call the TxConfirmation with E_NOT_OK and verify if the Dccm correctly
        stops the processing.
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.TxConfirmation.TransmissionFail</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_TRANSMISSION_TX_NULL_BUFFER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>534</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm service SendRequest correctly handles a TxConfirmation with a null buffer
  
Test Description: 
    Test that Dccm service SendRequest correctly handles a TxConfirmation with a null buffer
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate a transmission error by providing a wrong buffer to the Dccm_CopyTxData
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.MainFunction.Transmission_01</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_TRANSMISSION_TX_NULL_AVAILABLE_DATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>613</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that Dccm service SendRequest correctly handles a TxConfirmation with a null
	available data pointer
  
Test Description: 
    Test that Dccm service SendRequest correctly handles a TxConfirmation with a null 
	available data pointer
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate a transmission error by providing a wrong buffer to the Dccm_CopyTxData
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.MainFunction.Transmission_03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>Dccm.ErrorCodes001</linksto>
          <dstversion>5</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>9</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_WRONG_PDU_TX_CALLS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>701</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service SendRequest functions correctly when wrong parameters are used in the
	PduR Tx callbacks
  
Test Description: 
    Test that Dccm service SendRequest functions correctly when wrong parameters are used in the
	PduR Tx callbacks
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the SendRequest() API and verify the return status
    03: receive a CopyTxData with wrong PDUID
    04: receive normal copyTxData calls
    05: receive a TxConfirmation with wrong PDUID
    06: receive normal txConfirmation call
    07: perform the Rx transmission calls
    08: receive a CopyTxData request after the RxIndication
    09: receive a TxConfirmation request after the RxIndication
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.MainFunction</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>Dccm.API.MainFunction.Transmission_01</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_START_TRANSMISSION_FAIL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>873</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_SendRequest stops the processing if no answer is received
    in a specified amount of time
  
Test Description: 
    The test checks that the Dccm service Dccm_SendRequest stops the processing if no answer is
	received in a specified amount of time
  
Test Object: 
    Dccm_SendRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module 
    02: call the Dccm_SendRequest() API and verify the return status
    03: simulate a transmission error verify the correct error handling
    04: initiate a second Dccm_SendRequest() API call and verify if
        it is accepted and the whole processing flow works as expected
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.Init</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>Dccm.API.MainFunction.Transmission_01</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_WRONG_TXPDUID</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>971</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    The test checks that the Dccm service Dccm_CopyTxData returns an error when it is provided
    an invalid PduId.
  
Test Description: 
    Test that Dccm service Dccm_CopyTxData correctly returns an error in the use-case with one ProtocolId
    when, during transmission, the PduId has an incorrect value.
  
Test Object: 
    Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission for ProtocolId and provide a wrong value to txPduId
		in the second call of Dccm_CopyTxData()
    04: check that the correct error is transmitted
    05: call the Dccm_CopyTxData() API providing a correct txPduId and verify the return status
    06: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.MainFunction.Receive_01</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>Dccm.PositiveResponseCodes</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_WRONG_SIZE_FOR_PDUR</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1140</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    The test checks that the Dccm service Dccm_CopyTxData returns an error when it is provided
    the wrong size of transmission information for the PduR.
  
Test Description: 
    Test that Dccm service Dccm_CopyTxData correctly returns an error in the use-case with one ProtocolId
    when the PDUR transmission information is set to an inappropriate size.
  
Test Object: 
    Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status
    03: simulate the transmission for ProtocolId and provide a wrong size
		of transmission information for PduR in the second call of Dccm_CopyTxData()
    04: check that the correct error is transmitted
    05: call the Dccm_CopyTxData() API providing correct parameters and verify the return status
    06: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.MainFunction.Receive_02</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>Dccm.PositiveResponseCodes</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_TP_DATARETRY_WRONG_BUFFER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1311</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_CopyTxData correctly returns an error in the use-case with one ProtocolId,
    using support for data retransmission, when the buffer length is incorrect for TP_DATARETRY.
  
Test Description: 
    The test checks that the UDS service Dccm_CopyTxData returns an error in the use-case with
    one ProtocolId, when it is requested to retry to transmit a number of bytes which exceed
    the buffer length.
  
Test Object: 
    Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status.
        Use a buffer with the length of 5 bytes.
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffer with the length of 4 bytes.
    04: send the first 4 bytes with the TP_CONFPENDING retry parameter.
    05: ask to retransmit 4 bytes: indexes 2, 3, 4 and another byte unavailable and check if the
		correct error message is transmitted;
    06: ask to retransmit the last 1 byte of data: index 3;
        this is a confirmation for the bytes from the indexes 0, 1, 2;
    07: ask to transmit the last 1 byte: the byte from index 4;
        use retry parameter TP_DATACONF
        this is a confirmation for the byte from the index 3;
    08: confirm the bytes sent until this moment, asking for no data transfer
    09: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.MainFunction</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>23</internalId></provcov>
        <provcov>
          <linksto>Dccm.API.MainFunction.Transmission_03</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_COPY_TX_DATA_TP_DATARETRY_ON_CONFIRMED_BYTES</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1532</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_CopyTxData correctly returns an error in the use-case with one ProtocolId
    when it is sent a retry request, using TP_DATARETRY, for 3 bytes that are confirmed.
  
Test Description: 
    The test checks that the UDS service Dccm_CopyTxData returns an error in the use-case with
    one ProtocolId when it is requested to retry to transmit a number of bytes which are confirmed.
  
Test Object: 
    Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status.
        Use a buffer with the length of 5 bytes.
    03: simulate the transmission part for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffer with the length of 2 bytes.
        Send all the bytes with the TP_CONFPENDING retry parameter.(indexes 0, 1)
    04: ask to transmit 1 byte: the byte from the index 2;
        use retry parameter TP_DATACONF
        this is a confirmation for the bytes from the indexes 0 and 1;
    05: ask to retransmit the last 3 bytes of data: indexes 0, 1, 2;
        this should generate an error because the indexes 0, 1 are already confirmed
        check if the correct error is transmitted
    06: ask to retransmit the last 3 bytes of data: indexes 2, 3, 4;
    07: confirm the bytes sent until this moment, asking for no data transfer
    08: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.API.MainFunction.Receive_02</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RETRY_SUPPORT_WRONG_TPDATASTATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1747</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that the Dccm service Dccm_CopyTxData correctly returns an error, in the use-case with
	one ProtocolId, when we transmit the wrong TpDataState.
  
Test Description: 
	The test checks that the UDS service Dccm_CopyTxData returns an error when it is provided a
	wrong TpDataState during transmission. Use the support for data retransmission.
  
Test Object: 
  Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status.
        Use a buffer with the length of 5 bytes.
    03: simulate data transmission for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffered message with the length
        of 3 bytes. Send all the bytes with the TP_CONFPENDING retry parameter.
    04: simulate incorrect data transmission for ProtocolId by providing a wrong WrongTpDataState.
        For data transmission, use a buffer with the length of 2 bytes.
    05: simulate data transmission for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffered message with the length
        of 2 bytes. Send all the bytes with the TP_CONFPENDING retry parameter.
    06: confirm the bytes sent up until this point, asking for no data transfer
    07: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.InputDataValidation</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_WRONG_BUFFER_MESSAGE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1822</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_CopyTxData correctly returns an error, in the use-case
    with one ProtocolId, when it is trying to send more bytes than the remaining bytes in the buffer.
  
Test Description: 
    The test checks that the Dccm service Dccm_CopyTxData returns the correct error when it is sent
    more bytes than the remaining bytes in  buffer.
  
Test Object: 
  Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status.
        Use a buffer with the length of 5 bytes.
    03: simulate data transmission for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffered message with the length of 3 bytes.
    04: simulate incorrect data transmission for ProtocolId by providing a bigger TXDATALENGTH.
        For data transmission, use a buffered message with the length of 3 bytes and verify if the correct
        error is transmitted.
    05: simulate data transmission for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffered message with the length of 2 bytes.
    06: confirm the bytes sent up until this point, asking for no data transfer
    07: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ParallelProcessing_01</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>18</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RETRY_TP_CONFPENDING_SEND_WRONG_BUFFER_MESSAGE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1896</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that the Dccm service Dccm_CopyTxData correctly returns an error, in the use-case
	with one ProtocolId, when it is trying to send more bytes than there are remaining in the buffer,
	using TP_CONFPENDING.
  
Test Description: 
	The test checks that the Dccm service Dccm_CopyTxData returns the correct error when it is sent
	more bytes than the remaining bytes in buffer while using TP_CONFPENDING.
  
Test Object: 
  Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status.
		Use a buffer with the length of 5 bytes.
    03: simulate data transmission for ProtocolId and verify if the correct information
		is provided to the PduR. For data transmission, use a buffered message with the length
		of 3 bytes. Send all the bytes with the TP_CONFPENDING retry parameter.
    04: simulate incorrect data transmission for ProtocolId by providing a bigger TXDATALENGTH.
		Use a buffer with the length of 3 bytes and verify if the correct error is transmitted.
    05: simulate data transmission for ProtocolId and verify if the correct information
		is provided to the PduR. For data transmission, use a buffered message with the length
		of 2 bytes. Send all the bytes with the TP_CONFPENDING retry parameter.
    06: confirm the bytes sent up until this point, asking for no data transfer
    07: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.CopyTxData.WrongBufferMsg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_REQUEST_RETRY_TP_DATACONF_SEND_WRONG_BUFFER_MESSAGE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_SendRequest_Transmission_NegativeTests/source/application/Tests.c</sourcefile>
      <sourceline>1972</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
	Test that the Dccm service Dccm_CopyTxData correctly returns an error, in the use-case
	with one ProtocolId, when it is trying to send more bytes than there are remaining in the buffer,
	using TP_DATACONF
  
Test Description: 
    The test checks that the Dccm service Dccm_CopyTxData returns the correct error when it is sent
    more bytes than the remaining bytes in buffer while using TP_DATACONF.
  
Test Object: 
  Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_SendRequest() API for ProtocolId and verify the return status.
		Use a buffer with the length of 5 bytes.
    03: simulate data transmission for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffered message with the length
		of 3 bytes. Send all the bytes with the TP_DATACONF retry parameter.
    04: simulate incorrect data transmission for ProtocolId by providing a bigger TXDATALENGTH.
		For data transmission, use a buffer with the length of 3 bytes and verify if the correct
		error is transmitted.
    05: simulate data transmission for ProtocolId and verify if the correct information
        is provided to the PduR. For data transmission, use a buffered message with the length
		of 2 bytes. Send all the bytes with the TP_DATACONF retry parameter.
    06: confirm the bytes sent up until this point, asking for no data transfer
    07: simulate the receiving of data for ProtocolId by using PduR stubs and verify if the
		information is correctly received and processed by the Dccm
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.CopyTxData.WrongBufferMsg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_ENABLE_TESTER_PRESENT_CHANGE_PERIODICITY_INITIAL_TOO_SMALL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>147</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_EnableTesterPresent() works correctly when during the processing
    of a small periodicity, the value is changed by a higher one. The change must take place
    only after the processing has finished.
  
Test Description: 
    Test that Dccm service Dccm_EnableTesterPresent() works correctly when the initial periodicity 
    has a lower value than the execution interval of a complete cycle of Dccm_MainFunction() 
    and by re-calling Dccm_EnableTesterPresent() it is attempted to change the periodicity value
    when the transmission process of a TesterPresent message has not been completed.
  
Test Object: 
    Dccm_EnableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    03: call the Dccm_EnableTesterPresent() API with a reactivation period of 3 ms, and verify
	    the return status
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    05: call Dccm_MainFunction(), to trigger the transmission of TesterPresent message
    06: verify that TesterPresentIntervalCounter and TesterPresentInterval have received the 
	    correct values
    06: call the Dccm_EnableTesterPresent() API with a reactivation period of 10 ms, and verify
	    the return status
    07: verify that only TesterPresentInterval have received the new period value
    09: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR
    10: call Dccm_MainFunction() to process the transmission of TesterPresent message,
        and verify the call-backs
    11: call Dccm_MainFunction() to trigger the transmission of another TesterPresent message
    12: verify that TesterPresentIntervalCounter and TesterPresentInterval have received the new values
    13: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ENABLE_TESTER_PRESENT_NULL_BUFFER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>335</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that Dccm service Dccm_EnableTesterPresent() works correctly when is provided a
    null buffer.
  
Test Description: 
    Test that Dccm service Dccm_EnableTesterPresent() returns an error in the use case when
    the buffer is null.
  
Test Object: 
    Dccm_EnableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    03: call the Dccm_EnableTesterPresent() API with a null buffer
    04: check if correct error is transmitted and verify the return status
    05: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    06: call the Dccm_EnableTesterPresent() API with correct parameters and verify the return status
    07: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    08: call the Dccm_ReleaseDiagnosticProtocol() API and verify the return status
    09: verify that only one error was reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>457</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that Dccm service Dccm_SendTesterPresent() works correctly in the use case when
    we have two functional protocols but one of them is unavailable.
  
Test Description: 
    Test that Dccm service Dccm_SendTesterPresent() works correctly in the use case when we
    have two functional protocols, but in the moment when TesterPresent message should be sent
    one of protocols is busy, sending SendRequest.
  
Test Object: 
    Dccm_SendTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    03: call the Dccm_EnableTesterPresent() API with a reactivation period of 3 ms, and verify 
      the return status
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    05: call the Dccm_EnableTesterPresent() API to set a new reactivation period of 11 ms
    05: call Dccm_MainFunction() to process the new reactivation period and trigger the transmission
      of TesterPresent message for both protocols
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR
    07: call Dccm_MainFunction() twice to decrease the TesterPresent counter
    08: call the Dccm_SendRequest() API for ProtocolId0 and verify the return status
    09: verify that the call of Dccm_SendRequest() API for ProtocolId0 also updated the TesterPresentIntervalCounter to 11 ms
    10: call the Dccm_EnableTesterPresent() API to set a new reactivation period of 18 ms
    11: call Dccm_MainFunction() to process the new reactivation period and trigger the transmission
      of TesterPresent, but for ProtocolId0 it will trigger the transmission of SendRequest message and
      only ProtocolId1 will send a TesterPresent message
    12: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR
    13: simulate the receiving of data for ProtocolId 0 by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    14: call Dccm_MainFunction() to notify the Dccm client for ProtocolId 0
    15: call Dccm_MainFunction() to trigger the transmission of TesterPresent message only for
      ProtocolId 0, the message that should be sent in step 11
    16: simulate the transmission part for ProtocolId 0, and verify if the correct information
        is provided to the PduR
    17: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message for
        protocol ProtocolId1
    18: simulate the transmission part for ProtocolId1, and verify if the correct information
        is provided to the PduR
    19: call Dccm_MainFunction() twice to trigger the transmission of the TesterPresent message on protocol ProtocolId0
    20: call Dccm_MainFunction() to send notification for ProtocolId0
    21: verify that both protocols have the status READY
    22: call Dccm_ReleaseAllDiagnosticProtocols() API to release all protocols
    23: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>Dccm.API.MainFunction.SheduledFunctions</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>Dccm.TesterPresent.SendRequestReinitializeTheTesterPresentCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>Dccm.TesterPresent.ConfigurableForEachProtocol</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
    <specobject>
      <id>TS_DCCM_SEND_TESTER_PRESENT_ON_BUSY_PROTOCOL_DELAY_IN_TRANSMISSION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>560</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that the sending of the TesterPresent message is done correctly in the use case when
    the protocol is in use because a call to Dccm_SendTesterPresent().
  
Test Description: 
    Test that the sending of the TesterPresent message is done correctly in the use case when
    the protocol is in use because a call to Dccm_SendTesterPresent(), and the transmission
    of the data related with Dccm_SendTesterPresent() is delayed.
  
Test Object: 
    Dccm_SendTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: call the Dccm_EnableTesterPresent() API to set a new reactivation period of 11 ms
    03: call Dccm_MainFunction() twice to trigger the transmission of TesterPresent message
    04: call the Dccm_SendRequest() API for ProtocolId0 and verify the return status
    05: verify that the call of Dccm_SendRequest() API for ProtocolId0 also updated the TesterPresentIntervalCounter to 11 ms
    06: call Dccm_MainFunction(): for ProtocolId0 it will trigger the transmission of SendRequest message
    07: simulate a delay in the transmission of the request: call Dccm_MainFunction() twice
    08: simulate the transmission part for ProtocolId 0 , and verify if the correct information
        is provided to the PduR
    09: simulate the receiving of data for ProtocolId 0 by using PduR stubs and verify if the
        information is correctly received and processed by the Dccm
    10: call Dccm_MainFunction() to notify the Dccm client for ProtocolId 0
    11: verify that Dccm recorded the fact the a TesterPresent must be sent
    12: call Dccm_MainFunction() to trigger the transmission of TesterPresent message for
        ProtocolId 0, the message that was delayed by the call of Dccm_SendRequest() API
    13: simulate the transmission part for ProtocolId 0, and verify if the correct information
        is provided to the PduR
    14: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message for
        protocol ProtocolId1
    15: simulate the transmission part for ProtocolId1, and verify if the correct information
        is provided to the PduR
    16: call Dccm_MainFunction() to send notification for ProtocolId0
    17: verify that the protocol has the status READY
    18: call Dccm_ReleaseAllDiagnosticProtocols() API to release all protocols
    19: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
        <provcov>
          <linksto>Dccm.API.MainFunction.SheduledFunctions</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>Dccm.TesterPresent.SendRequestReinitializeTheTesterPresentCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_ENABLE_DISABLE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>651</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test checks that the Dccm_EnableTesterPresent() and Dccm_DisableTesterPresent() services work
    correctly in the use case with 10 protocols when some service calls are made at different stages.
  
Test Object: 
    Dccm_EnableTesterPresent()
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: call the Dccm_AllocateDiagnosticProtocol() API to allocate all 10 protocols(0,..,9)
    03: call the Dccm_ReleaseDiagnosticProtocol() API to release 3 protocols(0, 5, 9)
    04: call the Dccm_AllocateDiagnosticProtocol() API to allocate 3 protocols(0, 5, 9)
    05: call the Dccm_EnableTesterPresent() API to enable all 10 protocols(0,..,9)
    06: call the Dccm_ReleaseDiagnosticProtocol() API to release 3 protocols(0, 5, 9)
    07: call the Dccm_AllocateDiagnosticProtocol() API to allocate 3 protocols(0, 5, 9)
    08: call the Dccm_EnableTesterPresent() API to enable 3 protocols(0, 5, 9) and check that
        the order of protocols is correct(1, 2, 3, 4, 6, 7, 8, 0, 5, 9)
    09: call the Dccm_DisableTesterPresent() API to disable the ProtocolId8 from index 6
    10: check that all protocols are find at the correct position, the protocols after ProtocolId8
        are moved with one position and the last position is invalid
    11: call the Dccm_DisableTesterPresent() API to disable the ProtocolId9 from index 8
    12: check that all protocols are find at the correct position, the protocols after ProtocolId9
        are moved with one position and the last two position are invalid
    13: call the Dccm_DisableTesterPresent() API to disable the ProtocolId4 from index 3
    14: check that all protocols are find at the correct position, the protocols after ProtocolId4
        are moved with one position and the last three position are invalid
    15: call the Dccm_DisableTesterPresent() API to disable the ProtocolId2 from index 1
    14: check that all protocols are find at the correct position, the protocols after ProtocolId2
        are moved with one position and the last four position are invalid
    15: call the Dccm_EnableTesterPresent() API to enable ProtocolId9 and check that
        the order of protocols is correct
    16: call the Dccm_EnableTesterPresent() API to enable ProtocolId4 and check that
        the order of protocols is correct
    17: call the Dccm_ReleaseAllDiagnosticProtocols() API to release protocols
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ENABLE_TESTER_PRESENT_LOW_BUFFERLENGTH</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>1162</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check if Dccm_EnableTesterPresent() API returns an error when it is provided a buffer with
    a length less than 3
  
Test Description: 
    Check if Dccm_EnableTesterPresent() API fails when using a lower buffer length than the
    DCCM_NEGATIVE_RESPONSE_LENGTH (3U)
  
Test Object: 
    Dccm_EnableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_EnableTesterPresent() API using a lower buffer length than the
        DCCM_NEGATIVE_RESPONSE_LENGTH (3U)
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ENABLE_TESTER_PRESENT_ON_PHYSICAL_PROTOCOL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>1243</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check if Dccm_EnableTesterPresent() API fails when using a physical protocol
  
Test Description: 
    We're checking if the Dccm_EnableTesterPresent() API fails when using a protocol with a
    PHYSICAL_ADDRESSING addressing type instead of FUNCTIONAL_ADDRESSING.
  
Test Object: 
    Dccm_EnableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call Dccm_AllocateDiagnosticProtocol() API for physical protocol ProtocolId0
    03: call the Dccm_EnableTesterPresent() API using physical protocol ProtocolId0
    04: call the Dccm_IsTesterPresentEnabled() API and check return status
    05: call the Dccm_DisableTesterPresent() API and check return status
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>
    <specobject>
      <id>TS_DCCM_IS_TESTER_PRESENT_ENABLED_IS_NULL_POINTER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>1335</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check if Dccm_IsTesterPresentEnabled() API returns an error when it is provided a NULL POINTER
    instead of the boolean variable IsTesterPresentEnabled address
  
Test Description: 
    Check if Dccm_IsTesterPresentEnabled() API fails and returns an error when the
    IsTesterPresentEnabled boolean variable that is needed to call the API does not exist and we use
    a NULL POINTER instead
  
Test Object: 
    Dccm_IsTesterPresentEnabled()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_EnableTesterPresent() API and check the status
    03: call the Dccm_IsTesterPresentEnabled() API using &amp;NULL_PTR and check the status
    04: check if the correct error has been returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ENABLE_TESTER_PRESENT_PROTOCOL_NOT_ALLOCATED</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>1422</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check if Dccm_EnableTesterPresent() API returns an error when the protocol is not allocated
  
Test Description: 
    Check if Dccm_EnableTesterPresent() API fails and returns an error on the protocol
    that has not been previously allocated.
  
Test Object: 
    Dccm_EnableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_EnableTesterPresent() API and check that it fails
    03: check if the correct error has been returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Error_Reporting</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ENABLE_TESTER_PRESENT_BEFORE_MODULE_INITIALIZATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_1/source/application/Tests.c</sourcefile>
      <sourceline>1495</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check if Dccm_EnableTesterPresent() API returns an error when the module is not initialized
  
Test Description: 
    Check if Dccm_EnableTesterPresent() API fails and returns an error when the API is called
    before the module was initialized.
  
Test Object: 
    Dccm_EnableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: call the Dccm_EnableTesterPresent() API and check that it fails
    02: check if the correct error has been returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Error_Reporting</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>11</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_EXCEED_MAX_NR_OF_PARALLEL_PROTOCOLS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_2/source/application/Tests.c</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check if Dccm_EnableTesterPresent(), Dccm_DisableTesterPresent() and Dccm_IsTesterPresentEnabled()
    APIs fail when using a ProtocolId that exceeds the maximum allowed number of parallel protocols
  
Test Description: 
    We're checking if the Dccm_EnableTesterPresent(), Dccm_DisableTesterPresent() and
    Dccm_IsTesterPresentEnabled() APIs fail when they are called using a 4th ProtocolId ,
    which exceed the maximum allowed number of protocols that has been set to 3
    (Dccm_Num_Of_Parallel_Diagnostic_Protocols = 3U).
  
Test Object: 
    Dccm_IsTesterPresentEnabled()
    Dccm_SendTesterPresent()
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() for 3 diagnostic protocols and verify return status
    03: call the Dccm_IsTesterPresentEnabled() API using the 4th ProtocolId (ProtocolId3), which exceeds
    the number of maximum protocols
    04: call the Dccm_EnableTesterPresent() API for the first 3 protocols and verify the status
    05: call the Dccm_EnableTesterPresent() API using the 4th ProtocolId (ProtocolId3), which exceeds the
    number of maximum protocols
    06: call the Dccm_DisableTesterPresent() API for the first 3 protocols and verify the status
    07: call the Dccm_DisableTesterPresent() API using the 4th ProtocolId (ProtocolId3), which exceeds the
    number of maximum protocols
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.DisableTesterPresent.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>
    <specobject>
      <id>TS_DCCM_ALLOCATEDIAGNOSTICPROTOCOL_TOO_MANY_PROTOCOLS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NegativeTests_2/source/application/Tests.c</sourcefile>
      <sourceline>233</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
   Test that Dccm service Dccm_AllocateDiagnosticProtocol() return the correct value when we try
    to allocate too many protocols that exceeds the maximum number of protocols.
  
Test Description: 
   The test checks that the Dccm service Dccm_AllocateDiagnosticProtocol return errors when we
    allocate although the maximum number of protocols is reached.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_AllocateDiagnosticProtocol() API with the correct parameters four
        times to reach the maximum number of protocols
    03: call last the Dccm_AllocateDiagnosticProtocol() API trying to allocate one more protocol
        over the maximum number of protocols
    04: check if the correct error is returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.ExceedingNrMaxOfFunctionalProtocols</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_ENABLE_TESTER_PRESENT_NO_FUNCTIONAL_ADDRESSES</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_NoFunctionalAddressesDefined_1/source/application/Tests.c</sourcefile>
      <sourceline>79</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm and verify that the service
    Dccm_EnableTesterPresent works correctly when there are no functional addresses.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm and verify that the service
    Dccm_EnableTesterPresent returns the correct value when it is called
    although there are no functional addresses
  
Test Object: 
    Dccm_EnableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module and verify the returned value.
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    03: call the Dccm_EnableTesterPresent() API with a reactivation period of 9 ms,
		and verify the return status
    04: check if correct error is transmitted
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols.
  
Test Object: 
    Dccm_SendTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    03: call the Dccm_EnableTesterPresent() API with a reactivation period of 9 ms, and verify
	    the return status
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
	    information is provided to the PduR
    07: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message,
        and to trigger the calling of the call-backs
    08: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
	    information is provided to the PduR
    09: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        and to trigger the calling of the call-backs
    10: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
	    information is provided to the PduR
    11: call Dccm_MainFunction() once, to trigger the calling of the call-backs
    12: verify that each call-back was called 3 times
    13: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>Dccm.PositiveResponseCodes</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_DIFFERENT_TIMING_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests/source/application/Tests.c</sourcefile>
      <sourceline>187</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The timing for sending the TesterPresent message is different for each protocol.
  
Test Object: 
    Dccm_SendTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: call the Dccm_IsTesterPresentEnabled() API for both protocols and verify the return status
    03: call the Dccm_EnableTesterPresent() API for ProtocolId 0
        with a reactivation period of 9 ms, and verify the return status
    04: call the Dccm_EnableTesterPresent() API for ProtocolId 1
        with a reactivation period of 18 ms, and verify the return status
    05: call the Dccm_IsTesterPresentEnabled() API for both protocols and verify the return status
    06: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        for communication protocol 0
    07: simulate the transmission part for ProtocolId 0, and verify if the correct
      information is provided to the PduR
    08: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        on both communication protocols, and to trigger the calling of the call-backs
    09: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
        information is provided to the PduR
    10: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        for communication protocol 0
    11: simulate the transmission part for ProtocolId 0, and verify if the correct
      information is provided to the PduR
    12: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        on both communication protocols, and to trigger the calling of the call-backs
    13: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
        information is provided to the PduR
    14: call Dccm_MainFunction() once, to trigger the calling of the call-backs
    15: verify that the call-back for ProtocolId 0 was called 4 times
    16: verify that the call-back for ProtocolId 1 was called 2 times
    17: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>Dccm.TesterPresent.ConfigurableForEachProtocol</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>Dccm.PositiveResponseCodes</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_BEFORE_1ST_SENDTESTERPRESENT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>132</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_DisableTesterPresent() after
    the call of Dccm_EnableTesterPresent(), but before the first call of Dccm_SendTesterPresent()
    that is related with the transmission of the TesterPresent message.
  
Test Object: 
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: for each Dccm communication protocol, call Dccm_DisableTesterPresent();
    06: verify that the TesterPresent is disabled for both protocols;
    07: verify that the call-back was not called for any of the protocols;
    08: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.DisableTesterPresent.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_AFTER_1ST_COPYTXDATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>203</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_DisableTesterPresent() after
    the first call of Dccm_CopyTxData().
  
Test Object: 
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call Dccm_CopyTxData(), Dccm_DisableTesterPresent(), and after that, Dccm_CopyTxData() and
        Dccm_TxConfirmation();
    08: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    09: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    10: verify that the TesterPresent is disabled for both protocols;
    11: verify that the call-back was called once for each protocol;
    12: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.DisableTesterPresent.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_BEFORE_TXCONFIRMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>280</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_DisableTesterPresent()
    before the call of Dccm_TxConfirmation().
  
Test Object: 
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call Dccm_CopyTxData() twice, Dccm_DisableTesterPresent(), and after that
        Dccm_TxConfirmation();
    08: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    09: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    10: verify that the TesterPresent is disabled for both protocols;
    11: verify that the call-back was called once for each protocol;
    12: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.DisableTesterPresent.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_AFTER_TXCONFIRMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>357</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_DisableTesterPresent() after
    the call of Dccm_TxConfirmation().
  
Test Object: 
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call twice Dccm_CopyTxData(), and after that, Dccm_TxConfirmation() and
        Dccm_DisableTesterPresent();
    08: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    09: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    10: verify that the TesterPresent is disabled for both protocols;
    11: verify that the call-back was called once for each protocol;
    12: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.DisableTesterPresent.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_AFTER_1ST_NOTIFICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>434</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_DisableTesterPresent() after
    the moment when Dccm should send the first notification to the client about
    the outcome of the TesterPresent sending.
  
Test Object: 
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call Dccm_CopyTxData() twice, and after that, Dccm_TxConfirmation();
    08: call Dccm_MainFunction();
    09: verify that TesterPresent is still enabled for both protocols;
    10: call Dccm_DisableTesterPresent(), in order to actually disable the TesterPresent;
    11: verify that the TesterPresent is disabled for both protocols;
    12: verify that the call-back was called once for each protocol;
    13: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.DisableTesterPresent.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_DISABLETESTERPRESENT_BEFORE_COPYTXDATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>510</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_DisableTesterPresent() after
    the call of PduR_DccmTransmit(), but before the call of Dccm_CopyTxData().
  
Test Object: 
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call Dccm_DisableTesterPresent(), and after that, Dccm_CopyTxData() and
        Dccm_TxConfirmation();
    08: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    09: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    10: verify that the TesterPresent is disabled for both protocols;
    11: verify that the call-back was called once for each protocol;
    12: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.DisableTesterPresent.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>15</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_BEFORE_1ST_SENDTESTERPRESENT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>588</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_ReleaseDiagnosticProtocol() after
    the call of Dccm_EnableTesterPresent(), but before the first call of Dccm_SendTesterPresent()
    that is related with the transmission of the TesterPresent message.
  
Test Object: 
    Dccm_ReleaseDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: for each Dccm communication protocol, call Dccm_ReleaseDiagnosticProtocol();
    06: verify that the TesterPresent is disabled for both protocols;
    07: verify that the call-back was not called for any of the protocols;
    08: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_RELEASEALLDIAGNOSTICPROTOCOLS_BEFORE_1ST_SENDTESTERPRESENT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>659</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_ReleaseAllDiagnosticProtocols() after
    the call of Dccm_EnableTesterPresent(), but before the first call of Dccm_SendTesterPresent()
    that is related with the transmission of the TesterPresent message.
  
Test Object: 
    Dccm_ReleaseAllDiagnosticProtocols()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_ReleaseAllDiagnosticProtocols();
    06: verify that the TesterPresent is disabled for both protocols;
    07: verify that the call-back wasn't called for both protocol;
    08: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseAllDiagnosticProtocols.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_BEFORE_COPYTXDATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>730</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_ReleaseDiagnosticProtocol() after
    the call of PduR_DccmTransmit(), but before the call of Dccm_CopyTxData().
  
Test Object: 
    Dccm_ReleaseDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call Dccm_ReleaseDiagnosticProtocol(), and after that, Dccm_CopyTxData() and
        Dccm_TxConfirmation();
    08: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    09: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    10: verify that the TesterPresent is disabled for both protocols;
    11: release each protocol by calling again Dccm_ReleaseDiagnosticProtocol();
    12: verify that the call-back was called one time for each protocol;
    13: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_RELEASEALLDIAGNOSTICPROTOCOLS_BEFORE_COPYTXDATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>808</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_ReleaseAllDiagnosticProtocols() after
    the call of PduR_DccmTransmit(), but before the call of Dccm_CopyTxData().
  
Test Object: 
    Dccm_ReleaseAllDiagnosticProtocols()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: call Dccm_ReleaseAllDiagnosticProtocols();
    08: for each Dccm communication protocol call Dccm_CopyTxData() and Dccm_TxConfirmation();
    09: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    10: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    11: verify that the TesterPresent is disabled for both protocols;
    12: release both protocols by calling again Dccm_ReleaseAllDiagnosticProtocols();
    13: verify that the call-back was called once for each protocol;
    14: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseAllDiagnosticProtocols.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>17</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_AFTER_1ST_COPYTXDATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>886</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_ReleaseDiagnosticProtocol() after
    the first call of Dccm_CopyTxData().
  
Test Object: 
    Dccm_ReleaseDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call Dccm_CopyTxData(), Dccm_ReleaseDiagnosticProtocol(), and after that, Dccm_CopyTxData() and
        Dccm_TxConfirmation();
    08: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    09: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    10: verify that the TesterPresent is disabled for both protocols;
    11: release each protocol by calling again Dccm_ReleaseDiagnosticProtocol();
    12: verify that the call-back was called once for each protocol;
    13: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_BEFORE_TXCONFIRMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>964</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_ReleaseDiagnosticProtocol()
    before the call of Dccm_TxConfirmation().
  
Test Object: 
    Dccm_ReleaseDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call Dccm_CopyTxData() twice, Dccm_ReleaseDiagnosticProtocol(), and after that
        Dccm_TxConfirmation();
    08: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    09: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    10: verify that the TesterPresent is disabled for both protocols;
    11: release each protocol by calling again Dccm_ReleaseDiagnosticProtocol();
    12: verify that the call-back was called once for each protocol;
    13: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_AFTER_TXCONFIRMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>1042</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_ReleaseDiagnosticProtocol() after
    the call of Dccm_TxConfirmation().
  
Test Object: 
    Dccm_ReleaseDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() API twice with a reactivation period of 9 ms, and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call twice Dccm_CopyTxData(), and after that, Dccm_TxConfirmation() and
        Dccm_ReleaseDiagnosticProtocol();
    08: verify that TesterPresent is still enabled for both protocols, but also that the TesterPresent is marked
        to be disabled for both protocols;
    09: call Dccm_MainFunction(), in order to actually disable the TesterPresent;
    10: verify that the TesterPresent is disabled for both protocols;
    11: release each protocol by calling again Dccm_ReleaseDiagnosticProtocol();
    12: verify that the call-back was called once for each protocol;
    13: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_RELEASEDIAGNOSTICPROTOCOL_AFTER_1ST_NOTIFICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_2/source/application/Tests.c</sourcefile>
      <sourceline>1120</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The user calls Dccm_ReleaseDiagnosticProtocol() after
    the moment when Dccm should send the first notification to the client about
    the outcome of the TesterPresent sending.
  
Test Object: 
    Dccm_ReleaseDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stubs for protocol call-backs;
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    03: call the Dccm_EnableTesterPresent() and verify the return status;
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status;
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message;
    06: simulate the transmission part for ProtocolId 0 and 1, and verify if the correct information
        is provided to the PduR;
    07: for each Dccm communication protocol, call Dccm_CopyTxData() twice, and after that, Dccm_TxConfirmation();
    08: call Dccm_MainFunction();
    09: verify that TesterPresent is still enabled for both protocols;
    10: call Dccm_ReleaseDiagnosticProtocol() for both Dccm communication protocols;
    11: verify that the TesterPresent is disabled for both protocols;
    12: release each protocol by calling again Dccm_ReleaseDiagnosticProtocol();
    13: verify that the call-back was called ones for each protocol;
    14: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.ReleaseDiagnosticProtocol.DuringSendingOfTesterPresentMessage</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>16</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_OUTPUT_NoNotificationToSwc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_3/source/application/Tests.c</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols.
  
Test Object: 
    Dccm_SendTesterPresent()
  
Test Precondition: 
    In the configuration of Dccm, the attribute Dccm_NotifySwcForKeepAliveLogic is set to FALSE.
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: Call the Dccm_IsTesterPresentEnabled() API and verify the return status.
    03: Call the Dccm_EnableTesterPresent() API with a reactivation period of 9 ms, and verify
        the return status.
    04: Call the Dccm_IsTesterPresentEnabled() API and verify the return status.
    05: Call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message.
    06: Simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
        information is provided to the PduR.
    07: Call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message,
        and to trigger the calling of the call-backs.
    08: Simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
        information is provided to the PduR.
    09: Call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        and to trigger the calling of the call-backs.
    10: Simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
        information is provided to the PduR.
    11: Call Dccm_MainFunction() once, to trigger the calling of the call-backs.
    12: Verify that each call-back was called 0 times.
    13: Verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>Dccm.PositiveResponseCodes</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>
    <specobject>
      <id>TS_DCCM_TESTER_PRESENT_DIFFERENT_TIMING_OUTPUT_NoNotificationToSwc</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_TesterPresent_PositiveTests_3/source/application/Tests.c</sourcefile>
      <sourceline>188</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols. The timing for sending the TesterPresent message is different for each protocol.
  
Test Object: 
    Dccm_SendTesterPresent()
  
Test Precondition: 
    In the configuration of Dccm, the attribute Dccm_NotifySwcForKeepAliveLogic is set to FALSE.
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: Call the Dccm_IsTesterPresentEnabled() API for both protocols and verify the return status.
    03: Call the Dccm_EnableTesterPresent() API for ProtocolId 0
        with a reactivation period of 9 ms, and verify the return status.
    04: Call the Dccm_EnableTesterPresent() API for ProtocolId 1
        with a reactivation period of 18 ms, and verify the return status.
    05: Call the Dccm_IsTesterPresentEnabled() API for both protocols and verify the return status.
    06: Call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        for communication protocol 0.
    07: Simulate the transmission part for ProtocolId 0, and verify if the correct
        information is provided to the PduR.
    08: Call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        on both communication protocols, and to trigger the calling of the call-backs.
    09: Simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
        information is provided to the PduR.
    10: Call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        for communication protocol 0.
    11: Simulate the transmission part for ProtocolId 0, and verify if the correct
        information is provided to the PduR.
    12: Call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
        on both communication protocols, and to trigger the calling of the call-backs.
    13: Simulate the transmission part for ProtocolId 0 and 1, and verify if the correct
        information is provided to the PduR.
    14: Call Dccm_MainFunction() once, to trigger the calling of the call-backs.
    15: Verify that the call-back for ProtocolId 0 was called 0 times.
    16: Verify that the call-back for ProtocolId 1 was called 0 times.
    17: Verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.IsTesterPresentEnabled.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>Dccm.TesterPresent.ConfigurableForEachProtocol</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>Dccm.PositiveResponseCodes</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>8</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_DCCM_VALIDATE_RESPONSE_OUTPUT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>537</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test the API ValidateRespBasedOnRequest works properly.
  
Test Description: 
    Test that the API Dccm_ValidateRespBasedOnRequest validates correctly all the supported services.
     For each service are used multiple requests and responses.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API for all supported services using 
	  valid responses and requests buffers 
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.Dccm_ValidateRespBasedOnRequest.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.Dccm_ValidateRespBasedOnRequest.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_INVALID_INPUT_PARAMETERS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>915</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test the ValidateRespBasedOnRequest() function fails when its parameters are NULL_PTR.
  
Test Description: 
    Test the ValidateRespBasedOnRequest() function fails when at least one of its parameters
     are NULL_PTR. Verify if the returned value is correct.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call the Dccm_ValidateRespBasedOnRequest() function with one parameter NULL_PTR
    03: check if the correct returnValue is returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.InputParameters</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_NEGATIVE_RESPONSE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>981</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest validates the negative response.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the 
	negative response is not according with ISO spec.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using different invalid buffers with negative responses
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.NegativeResponse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_NON_STANDARD_SERVICE</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1052</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest reject validation 
	for a service not defined in ISO Standard.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the 
	request is for a service that is not part of the ISO spec.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using a request for an invalid request
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.NonStandardServices</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_DIAGNOSTIC_SESSION_CONTROL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for DiagnosticSessionControl service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	DiagnosticSessionControl service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.DiagnosticSessionControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_ECU_RESET</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1195</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for ECUReset service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	ECUReset service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ECUReset</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_SECURITY_ACCESS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1283</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for SecurityAccess service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	SecurityAccess service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.SecurityAccess</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_COMMUNICATION_CONTROL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1367</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for CommunicationControl service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	CommunicationControl service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.CommunicationControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_TESTER_PRESENT</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1447</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for TesterPresent service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	TesterPresent service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.TesterPresent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_ACCESS_TIMING_PARAMETER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1527</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for AccessTimingParameter service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	AccessTimingParameter service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.AccessTimingParameter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_SECURED_DATA_TRANSMISSION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1616</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for SecuredDataTransmission service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	SecuredDataTransmission service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.SecuredDataTransmission</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_CONTROL_DTC_SETTING</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1688</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for ControlDTCSetting service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	ControlDTCSetting service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ControlDTCSetting</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_LINK_CONTROL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1768</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for LinkControl service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	LinkControl service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.LinkControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_READ_DATA_BY_IDENTIFIER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1848</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for ReadDataByIdentifier service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	ReadDataByIdentifier service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ReadDataByIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_READ_MEMORY_BY_ADDRESS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>1928</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for ReadMemoryByAddress service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	ReadMemoryByAddress service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ReadMemoryByAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_READ_SCALING_DATA_BY_IDENTIFIER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2000</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for ReadScalingDataByIdentifier service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	ReadScalingDataByIdentifier service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ReadScalingDataByIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_DYNAMICALLY_DEFINE_DATA_IDENTIFIER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for DynamicallyDefineDataIdentifier service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	DynamicallyDefineDataIdentifier service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.DynamicallyDefineDataIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_WRITE_DATA_BY_IDENTIFIER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2214</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for WriteDataByIdentifier service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	WriteDataByIdentifier service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.WriteDataByIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_WRITE_MEMORY_BY_ADDRESS</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2294</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for WriteMemoryByAddress service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	WriteMemoryByAddress service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.WriteMemoryByAddress</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_CLEAR_DIAGNOSTIC_INFORMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2386</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for ClearDiagnosticInformation service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	ClearDiagnosticInformation service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ClearDiagnosticInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_INPUT_OUTPUT_CONTROL_BY_IDENTIFIER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2454</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for InputOutputControlByIdentifier service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest returns error when the buffers for
	InputOutputControlByIdentifier service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.InputOutputControlByIdentifier</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_ROUTINE_CONTROL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2535</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for RoutineControl service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	RoutineControl service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RoutineControl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_REQUEST_DOWNLOAD</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2623</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for RequestDownload service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest returns error when the buffers for
	RequestDownload service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RequestDownload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_REQUEST_UPLOAD</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2707</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for RequestUpload service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	RequestUpload service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RequestUpload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_TRANSFER_DATA</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2791</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for TransferData service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest retuns error when the buffers for 
	TransferData service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.TransferData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_REQUEST_FILE_TRANSFER</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2867</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for RequestFileTransfer service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest returns error when the buffers for
	RequestFileTransfer service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.RequestFileTransfer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>
    <specobject>
      <id>TS_DCCM_VALIDATE_READ_DTC_INFORMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Conformance/IN/Dccm_ConTest_ValidateRespBasedOnRequest/source/application/Tests.c</sourcefile>
      <sourceline>2963</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the API Dccm_ValidateRespBasedOnRequest perform the validation process 
	for ReadDTCInformation service.
  
Test Description: 
    Test that the API ValidateRespBasedOnRequest returns error when the buffers for
	ReadDTCInformation service are not valid.
  
Test Object: 
    Dccm_ValidateRespBasedOnRequest()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call of Dccm_ValidateRespBasedOnRequest() API using wrong buffers
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Validate.ReadDTCInformation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_MainFunction_No_Module_Init</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Implementation/IN/Dccm_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    The test checks that a protocol remains in the same state (ready to transmit) if the module is 
	not initialized and we call the main function.
  
Test Description: 
    The test shows that if the module is not initialized previously with a call to Dccm_Init(), 
	the function Dccm_MainFunction() will return immediately without performing any functionality 
	and without raising any errors.
  
Test Object: 
    Dccm_MainFunction()
  
Test Precondition: 
  
Test Execution: 
    01: set the protocol status to ready to transmit
    02: call the Dccm_MainFunction()
    03: verify if the protocol status remains the same, because 
		Dccm_MainFunction() returned without performing any functionality
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.NumOfParallelDiagnosticProtocols</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>Dccm.Config.NumOfFunctionalDiagnosticProtocols</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>Dccm.API.MainFunction.InitCheck</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>
    <specobject>
      <id>TS_Dccm_CheckBufferSuppressBit_WrongParameter</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Implementation/IN/Dccm_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>178</sourceline>
      <version>1</version>
      <description>Test Synopsis: 
	Test that the Dccm function Dccm_CheckBufferSuppressBit() correctly handles an incorrect buffer length
  
Test Description: 
    The test checks that the Dccm function Dccm_CheckBufferSuppressBit() correctly handles a buffer with a length that is
	too small.
  
Test Object: 
    Dccm_CheckBufferSuppressBit()
  
Test Precondition: 
  
Test Execution: 
    01: call the function Dccm_CheckBufferSuppressBit() with the parameter DataLength having the value of 1.
    02: check that the function returns FALSE.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Config.Buffer_Streaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>
    <specobject>
      <id>TS_Dccm_Disable_TesterPresent_Zero_NumberOfProtocolIdsForTesterPresentMessages</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Implementation/IN/Dccm_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>239</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check if the correct value is returned when calling Dccm_DisableTesterPresent() when the
	NumberOfProtocolIdsForTesterPresentMessages is 0.
  
Test Description: 
    Check if the correct value (E_NOT_OK) is returned when calling the Dccm_DisableTesterPresent() API 
	on a protocol without Dccm_EnableTesterPresent() API being formerly called and thus the 
	NumberOfProtocolIdsForTesterPresentMessages remains 0.
  
Test Object: 
    Dccm_DisableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call Dccm_AllocateDiagnosticProtocol() for ProtocoldId0 and check the status
    03: call the Dccm_EnableTesterPresent() API for ProtocolId0 and check the status
    04: manually set the NumberOfProtocolIdsForTesterPresentMessages to 0
    05: call the Dccm_DisableTesterPresent() API for ProtocolId0 and check that it fails
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.DisableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
        <provcov>
          <linksto>Dccm.EB.CustomXPath_unit_tests</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>7</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>
    <specobject>
      <id>TS_Dccm_ReleaseAllDiagnosticProtocols_With_Non_Releasable_Protocol</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Implementation/IN/Dccm_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>326</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that the Dccm_ReleaseAllDiagnosticProtocols API fails when there is a protocol 
    that can not be released.
  
Test Description: 
    Test that Dccm service Dccm_AllocateDiagnosticProtocol fails when there is a protocol 
    that has a status that does not allow release 
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: Call the Dccm_AllocateDiagnosticProtocol() API for 2 protocols (ProtocolId0, ProtocolId1)
    03: Call the Dccm_SendRequest() API for ProtocolId0 to change his status
    04: set ProtocolId2 status to DCCM_DIAGNOSTIC_PROTOCOL_STATUS_ALLOCATING
    05: Call the Dccm_ReleaseAllDiagnosticProtocols() API to try the release and verify the return value
    06: verify that protocols status has not changed
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.SupportedServices</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>14</internalId></provcov>
        <provcov>
          <linksto>Dccm.Api.ReleaseAllDiagnosticProtocols.Functional</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>70</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>
    <specobject>
      <id>TS_Dccm_CopyTxData_NoBufferAvailable_ToContain_TesterPresent_Request</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Implementation/IN/Dccm_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>435</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check that the function Dccm_CopyTxData() do not perform any processing and returns
	'BUFREQ_E_NOT_OK when the value of TesterPresent buffer is 'NULL_PTR' and value of
	TesterPresentInitiatedByDccm is 'TRUE'.
  
Test Description: 
    Check that the function Dccm_CopyTxData() do not perform any processing and returns
	'BUFREQ_E_NOT_OK when the value of TesterPresent buffer is 'NULL_PTR' and value of 
	TesterPresentInitiatedByDccm is 'TRUE'.
  
Test Object: 
    Dccm_CopyTxData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module
    02: call Dccm_AllocateDiagnosticProtocol() for ProtocoldId and check the status;
    03: call the Dccm_EnableTesterPresent() API for ProtocolId and check the status
    04: manually set TesterPresent Buffer and TesterPresentInitiatedByDccm parameters;
    05: call Dccm_CopyTxData() for ProtocoldId and check the status;
    06: call the Dccm_DisableTesterPresent() API for ProtocolId and verify the status.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.CopyTxData.TesterPresentNullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>
    <specobject>
      <id>TS_Dccm_ReceiveFunctionalResponseAfterFunctionalRequestTimeout</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Implementation/IN/Dccm_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>549</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check that Dccm handles correctly the receiving of a functional response
    after the functional request timeout.
  
Test Description: 
    Check that Dccm handles correctly the receiving of a functional response
    after the functional request timeout. Dccm was configured so that
    at the moment of functional request timeout, to not send notifications
    for the pending physical protocols that were prepared for functional responses:
    this is an optimization, and it is the responsibility of the client of Dccm
    to release the respective physical protocols as soon as possible.
  
Test Object: 
    The receiving of a functional response after the functional request timeout.
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module.
    02: Call Dccm_AllocateDiagnosticProtocol() for one physical and
        one functional protocol.
    03: Prepare the physical protocol to receive a functional response.
    04: Send the functional request with the SuppressPosRspMsgIndicationBit
        set to TRUE.
    05: Call Dccm_MainFunction().
    06: Call Dccm_TxConfirmation() to simulate the end of transmission.
    07: Call Dccm_MainFunction() until the functional protocol reaches timeout,
        and reaches the READY status.
    08: Check that the physical protocol has still the RECEIVE status.
    09: Call Dccm_StartOfReception(), Dccm_CopyRxData() and Dccm_RxIndication()
        for the physical protocol and verify that Dccm reports the proper error
        to DET, and does not change the status of the physical protocol.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.EB.FunctionalCommunication.SuppressPosRspMsgIndicationBit_IsTrue.NotifySwcForPendingPhysicalProtocols.Config</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_AllocateDiagnosticProtocol_NoServersConfigured</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Implementation/IN/Dccm_ImpTest_02/source/application/Tests.c</sourcefile>
      <sourceline>88</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Check that the function Dccm_AllocateDiagnosticProtocol() performs correctly
    when no diagnostic servers are configured for Dccm.
  
Test Description: 
    Check that the function Dccm_AllocateDiagnosticProtocol() performs correctly
    when no diagnostic servers are configured for Dccm.
  
Test Object: 
    Dccm_AllocateDiagnosticProtocol()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module;
    02: Call Dccm_AllocateDiagnosticProtocol() and check the status.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.AllocateDiagnosticProtocol.TxPduIdOrRxPduIdNotPreconfigured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_Dccm_Tester_Present_DccmSendTesterPresent_DataLengthPtrNULL</id>
      <status>approved</status>
      <source>EB test case specification (asc_Dccm)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_Dccm/test/ts5/Implementation/IN/Dccm_ImpTest_TesterPresent/source/application/Tests.c</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: 
    Test that uses the TesterPresent functionality of Dccm.
  
Test Description: 
    The test uses the TesterPresent functionality of Dccm, with two functional addresses and
    two communication protocols, when DataLengthPtr is changed to NULL_PTR.
  
Test Object: 
    Dccm_EnableTesterPresent()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize the Dccm module, and use the test stub for protocol call-backs.
    02: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    03: call the Dccm_EnableTesterPresent() API with a reactivation period of 9 ms, and verify
      the return status
    04: call the Dccm_IsTesterPresentEnabled() API and verify the return status
    05: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
    06: verify that nothing was transmitted
    07: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
    08: verify that nothing was transmitted
    09: call Dccm_MainFunction() twice, to trigger the transmission of TesterPresent message
    10: verify that nothing was transmitted
    11: call Dccm_MainFunction() once; in normal situations, this would trigger the calling of the call-backs
    12: verify that no call-back was called
    13: verify that no errors were reported using DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>Dccm.Api.EnableTesterPresent.Interfacing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>108</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
