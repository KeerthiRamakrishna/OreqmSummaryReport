<?xml version="1.0" encoding="UTF-8"?>
<tracingresults>
  <environment>
    <toolname>ReqM2</toolname>
    <toolversion>1.30.0 (stable)</toolversion>
    <toolcopyright>Copyright 2010 - 2018 Elektrobit Automotive GmbH</toolcopyright>
    <libxmlversion>2.0207</libxmlversion>
    <libxml2compileversion>2.9.10</libxml2compileversion>
    <libxml2runtimeversion>20912</libxml2runtimeversion>
    <perlversion>v5.32.1</perlversion>
    <perlptrsize>64</perlptrsize>
    <commandline>-t -q -o asc_CanIf_tracing_cmdb.oreqm -O /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements -c /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml -s approved,rejected --wfatal WDUPLICATEID,WDUPLICATEIDANDVER /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_public_modulereference_integration_req.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_4_0_3.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_4_2_1.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_4_2_2.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_R20-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_R21-11.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_EB_requirements.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_test_Manual_TestSpec.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_DbgInst_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_PbcfgM_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_PduLengthType_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_VerifyStub_EB_Extension.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm /cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</commandline>
    <timestamp>Mon Jun 17 21:32:55 2024</timestamp>
  </environment>
  <cmdline>
    <cmdparam>
      <name>I</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>O</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/TestProtocols/LogBase/requirements</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>c</name>
      <values>
        <value>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_PluginBuildEnv/common/config/AutoCoreReqM2Rules_RMP4_0.xml</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>o</name>
      <values>
        <value>asc_CanIf_tracing_cmdb.oreqm</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>q</name>
    </cmdparam>
    <cmdparam>
      <name>s</name>
      <values>
        <value>approved</value>
        <value>rejected</value>
      </values>
    </cmdparam>
    <cmdparam>
      <name>t</name>
    </cmdparam>
    <cmdparam>
      <name>wfatal</name>
      <values>
        <value>WDUPLICATEID</value>
        <value>WDUPLICATEIDANDVER</value>
      </values>
    </cmdparam>
  </cmdline>
  <inputfiles>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_public_modulereference_integration_req.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_4_0_3.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_4_2_1.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_4_2_2.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_R20-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_CanIf_R21-11.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_requirements_EB_requirements.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_Native/asc_CanIf_Autosar_test_Manual_TestSpec.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_DbgInst_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_PbcfgM_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_PduLengthType_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_VerifyStub_EB_Extension.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_GenericImporter/reqm_DEV.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_GenericImporter/reqm_IMPL.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_GenericImporter/reqm_IMPLXML.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_DocBookImporter/reqm_SWDD.reqm</inputfile>
    <inputfile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/ReqM2_OldCImporter/reqm_SWUTS_LEGACY.reqm</inputfile>
  </inputfiles>
  <configuration>
    <doctypes>
    <regexs>
      <!-- external level -->
      <regex>creq</regex>       <!-- since 10/1018: introduced for updated tracing model-->

      <!-- product line level -->
      <regex>fea</regex>
      <regex>swpad</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swts</regex>

      <!-- bundle level -->
      <regex>swrs</regex>
      <regex>swad</regex>
      <regex>swintts</regex>

      <!-- module level -->
      <regex>swdd</regex>
      <regex>swurs</regex>      <!-- since 10/1018: introduced for updated tracing model-->
      <regex>swmts</regex>      <!-- since 01/1010: introduced for updated tracing model RMP4.0-->
      <regex>swuts</regex>
      <regex>impl</regex>

      <!-- legacy items -->
      <regex>dev</regex>
      <regex>man</regex>
      <regex>lim</regex>
    </regexs>
  </doctypes>
    <rules>
    <!-- The Ruleset for RMP4.0 is currently identical to the previous rule set. This rule is
        intoduce to show that the right file is uses. It will be removed when the RMP4.0 rule set is
    reworked -->
    <rule>
      <name>INFO.Rule set RMP4.0</name>
      <description>This rules indicates that RMP4.0 rule set is used.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>WRN.general.doctypes</name>
      <description>The used doctype is not part of the tracing model</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobjects/@doctype</applyto>
          <condition>((. != 'creq') or (. != 'fea') or (. != 'swpad') or (. != 'swts') or (. != 'swrs') or (. !='swad') or (. != 'swintts') or (.!= 'swdd') or (. != 'swurs') or (. != 'swmts') or (. != 'swuts') or (. != 'impl') or (. != 'dev') or (. != 'man') or (. != 'lim'))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.status</name>
      <description>All specification objects must be either in status=approved or in status=rejected. Other
        statuses are not allowed. How to fix: Set status to rejected or approved.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status!='approved') and (./status!='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected</name>
      <description>Status status=rejected is only allowed for requirements. How to fix: set to approved for specification object that are not requirements.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype!='swrs')  and (../@doctype!='swmrs') and (../@doctype!='swurs') and (./status='rejected')]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.comment</name>
      <description>Specification objects with status=rejected shall have a comment or rationale that
        starts with on of the following texts: "This requirement is informational only", "This requirement is not applicable".
        How to fix: Add some text starting with "This requirement is informational only"
        or "This requirement is not applicable" to either the comment or to the rationale.
        Comment: Implementation of check checks for contains instead of starts-with since there is
        no trim function in the used XPATH engine.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>contains(./comment,"This requirement is informational only") or contains(./rationale,"This requirement is informational only") or contains(./comment,"This requirement is not applicable") or contains(./rationale,"This requirement is not applicable")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.general.rejected.coverage</name>
      <description>Specification objects with status=rejected shall not need coverage. How to fix: remove need for coverage.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(./status='rejected')]</applyto>
          <condition>count(./needscoverage)=0</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.count</name>
      <description>Unit requirements with status=approved need to be covered, exceptions from
      this rule: configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") and requirements with
      a comment starting with "The adherence to this requirement is ensured by the following
      release check (URL to the checklist template plus ID of the check):".
      How to fix: Provide a needsobj element for those specobjects or comment according to the rule.
      </description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and count(./fulfilledby/ffbObj)=0]</applyto>
          <!--This condition is false if the id of a specification object does not end with '_Conf' or '_CONF' or does not start with ECUC_ -->
          <condition>substring-after(./id,"ECUC_")!="" or substring-before(./id,"_Conf")!="" or substring-before(./id,"_CONF")!="" or contains(./comment,"The adherence to this requirement is ensured by the following release check (URL to the checklist template plus ID of the check):")</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swurs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.rationale</name>
      <description>Requirements with status=approved and without coverage needs that are
        configuration requirements (postfix "_CONF" or "_Conf" or prefix "ECUC_") shall have a comment or rationale
        with the following text: "This is a configuration parameter requirement without functional
        specification.". How to fix: Add some text starting with "This is a configuration parameter
        requirements without functional specification" to either the comment or to the rationale.</description>
      <regexchecks>
        <regexcheck>
          <applyto>//specobject[(../@doctype='swrs') and (./status='approved') and count(./needscoverage/needsobj)=0 and (substring-after(./id,"ECUC_")!="" or substring-before(./id,"_CONF")!="" or substring-before(./id,"_Conf")!="")]</applyto>
          <regex>This is a configuration parameter requirement without functional specification.</regex>
        </regexcheck>
      </regexchecks>
    </rule>

    <rule>
      <name>ERR.swurs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.releases</name>
      <description>Requirements which originates from AUTOSAR (source tag contains term 'AUTOSAR_SWS', 'AUTOSAR_TPS',
        'AUTOSAR_ASWS' or 'AUTOSAR_TR') shall have their release tag set to 'AUTOSAR {major}.{minor}.{patch}' (e.g. 'AUTOSAR 4.3.0').
        Other requirements (including refinements of AUTOSAR requirements) must not contain any of the listed prefixes as
        part of the source tag.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs') and (contains(./source,'AUTOSAR_SWS') or contains(./source,'AUTOSAR_TPS') or contains(./source,'AUTOSAR_ASWS') or contains(./source,'AUTOSAR_TR'))]</applyto>
          <condition>contains(./releases/release,'AUTOSAR')</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.count</name>
      <description>Design elements with status=approved need to be covered.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd') and (./status='approved') and count(./needscoverage/needsobj)=0]</applyto>
          <condition>false()</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swurs.needscoverage.doctypes</name>
      <description>Requirements can be covered only by swurs, swad, dev, lim, swdd, impl, swuts, swmts, or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swurs')]</applyto>
          <condition>(./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="dev" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swrs.needscoverage.doctypes</name>
      <description>Requirements of type swrs can be covered only by swrs, swurs, swad, swintts or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swrs')]</applyto>
          <condition>(./needscoverage/needsobj="swrs" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="swad" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swintts" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swdd.needscoverage.doctypes</name>
      <description>Design elements of type swdd can only be covered by swdd, swurs, impl, swuts, lim or man</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swdd')]</applyto>
          <condition>(./needscoverage/needsobj="swdd" or ./needscoverage/needsobj="swurs" or ./needscoverage/needsobj="impl" or ./needscoverage/needsobj="swuts" or ./needscoverage/needsobj="swmts" or ./needscoverage/needsobj="lim" or ./needscoverage/needsobj="man" or (count(./needscoverage/needsobj)=0))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.dev.needscoverage.count</name>
      <description>Deviations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='dev')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swuts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swmts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swintts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swts.needscoverage.count</name>
      <description>Test case sepecifications shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.needscoverage.count</name>
      <description>Manual test cases shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.impl.needscoverage.count</name>
      <description>Source code shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='impl')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.lim.needscoverage.count</name>
      <description>Limitations shall not need/receive coverage</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='lim')]</applyto>
          <condition>(count(./needscoverage/needsobj)=0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.fea.needscoverage.test</name>
      <description>Features shall be tested by software test ('swts') or manuel test ('man'). If no test is planned a justification shall be given.
                   A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>(
               ./needscoverage/needsobj="swts" or ./needscoverage/needsobj="man" or ./fulfilledby/ffbObj/ffbType="swts" or ./fulfilledby/ffbObj/ffbType="man" or contains(./furtherinfo,"fea.needscoverage.test") or contains(./furtherinfo,"fea.needscoverage.doctypes"))</condition>
        </conditioncheck>
      </conditionchecks>
          </rule>

    <rule>
      <name>WRN.fea.needscoverage.impl</name>
      <description>Features shall be covered by implementation fea, swrs, swad, swpad, swurs, man and swts. For lagacy features a justification is acceppted. A justification can be given in the futherinfo tag. The justification shall start with this rule name.</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='fea')]</applyto>
          <condition>( ./needscoverage/needsobj="swrs" or ./fulfilledby/ffbObj/ffbType="swrs" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swpad" or ./fulfilledby/ffbObj/ffbType="swpad" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="fea" or ./fulfilledby/ffbObj/ffbType="fea" or contains(./furtherinfo,"fea.needscoverage.impl"))</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>


    <rule>
      <name>ERR.swad.fulfilledby.doctypes</name>
      <description>Architectural design objects of type swad can only be covered by swurs, swad, swdd, swintts, man, otherwise they should be refined with swrs</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swad')]</applyto>
          <condition>(./fulfilledby/ffbObj/ffbType="swurs" or ./needscoverage/needsobj="swurs" or ./fulfilledby/ffbObj/ffbType="req" or ./needscoverage/needsobj="req" or ./fulfilledby/ffbObj/ffbType="swad" or ./needscoverage/needsobj="swad" or ./fulfilledby/ffbObj/ffbType="swdd" or ./fulfilledby/ffbObj/ffbType="swintts" or ./needscoverage/needsobj="swintts" or ./fulfilledby/ffbObj/ffbType="man" or ./needscoverage/needsobj="man") </condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.swmts.providescoverage.doctypes</name>
      <description>Test case specifications (tcs) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='tcs')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

    <rule>
      <name>ERR.man.providescoverage.doctypes</name>
      <description>Manual test case specification (man) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='man')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swuts.providescoverage.doctypes</name>
      <description>Software unit test case specification (swuts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swuts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swintts.providescoverage.doctypes</name>
      <description>Software integration test case specification (swintts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swintts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

   <rule>
      <name>ERR.swts.providescoverage.doctypes</name>
      <description>Software test case specification (swts) shall cover at least one other spec object</description>
      <conditionchecks>
        <conditioncheck>
          <applyto>//specobject[(../@doctype='swts')]</applyto>
          <condition>(count(./providescoverage/provcov)&gt;0)</condition>
        </conditioncheck>
      </conditionchecks>
    </rule>

  </rules>
    <oreqmRules>

        <rule>
            <name>WRN.swts.needscoverage.count</name>
            <description>Violated if there are more than 10 swts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.man.needscoverage.count</name>
            <description>Violated if there are more than 10 man specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='man']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>man.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swintts.needscoverage.count</name>
            <description>Violated if there are more than 10 swintts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swintts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swintts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
        <rule>
            <name>WRN.swmts.needscoverage.count</name>
            <description>Violated if there are more than 10 swmts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swmts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swmts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swuts.needscoverage.count</name>
            <description>Violated if there are more than 10 swuts specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swuts']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swuts.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swpad.needscoverage.count</name>
            <description>Violated if there are more than 10 swpad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swpad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swpad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.needscoverage.count</name>
            <description>Violated if there are more than 10 swrs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swrs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.needscoverage.count</name>
            <description>Violated if there are more than 10 swad specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swad']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.needscoverage.count</name>
            <description>Violated if there are more than 10 swurs specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swurs']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.needscoverage.count</name>
            <description>Violated if there are more than 10 swdd specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='swdd']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.impl.needscoverage.count</name>
            <description>Violated if there are more than 10 impl specobjects covering one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./needscoverage/needscov[needsobj='impl']/coveredby/linkedfrom)) &gt; 10]/furtherinfo</applyto>
                                        <regex>impl.needscoverage.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swrs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swrs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swrs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swrs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swad.fulfilledby.count</name>
            <description>Violated if there are more than 10 swad specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swad'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swad.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swurs.fulfilledby.count</name>
            <description>Violated if there are more than 10 swurs specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swurs'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swurs.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>

        <rule>
            <name>WRN.swdd.fulfilledby.count</name>
            <description>Violated if there are more than 10 swdd specobjects as fulfilledby link to one specobject and no appropriate information is provided in furtherinfo. The justification in furtherinfo must contain the rule name.</description>
            <conditionchecks>
                <conditioncheck>
                    <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]</applyto>
                    <condition>false() or (count(./furtherinfo) &gt; 0)</condition>
                </conditioncheck>
            </conditionchecks>
                        <regexchecks>
                                <regexcheck>
                                        <applyto>//specobject[(count(./fulfilledby/ffbObj[ffbType='swdd'])) &gt; 10]/furtherinfo</applyto>
                                        <regex>swdd.fulfilledby.count</regex>
                                </regexcheck>
                        </regexchecks>
        </rule>
  </oreqmRules>
  </configuration>
  <specdocument>
    <specobjects doctype="lim">
    <specobject>
      <!-- Data Copying Mechanism in RX Indication Function -->
      <id>lim.CanIf.EB_INTREQ_CanIf_0001</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      Data copying mechanism in Rx indication code
      <code>CanIf_RxIndication()</code> does not copy the data
      provided by the CAN driver. Instead the data pointer is directly
      propagated to the upper layer.<pre>
NOTE:
For dynamic length PDU reception, upper layers might expect that
always a buffer with the maximum possible PDU size is provided.
Since CanIf does not perform buffering it is the Can drivers
responsibility to fulfil this requirement.</pre>
      </description>
      <rationale>
      The data is copied in the different upper layers. The CanIf does not
      copy it as well to reduce runtime overhead.
      </rationale>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanIf.Interaction1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1311</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>0</internalId></specobject>

    <!-- Solitary execution of CanIf_CheckWakeup -->
    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0002</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
      <code>CanIf_CheckWakeup()</code> must not preempt or be preempted by
      <code>CanIf_SetControllerMode()</code>
      The integrator must assure that <code>CanIf_SetControllerMode()</code> cannot
      preempt <code>CanIf_CheckWakeup()</code>. The integrator also must assure that
      <code>CanIf_CheckWakeup()</code> does not preempt
      <code>CanIf_SetControllerMode()</code>.
      </description>
      <rationale>
      This limitation reduces code size and execution time by eliminating the need for extensive
      use of exclusive areas.
      </rationale>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanIf.Preemption1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1309</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0003</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        CanIf controller mode might differ from Can controller hardware mode
        The CanIf software controller mode is always changed if an according event on the
        hardware is detected.
        These events are the following:<pre>
-  Call of CanIf_ControllerModeIndication() (CANIF_CS_STOPPED, CANIF_CS_STA-
RTED, CANIF_CS_SLEEP)
-  Call of CanIf_ControllerBusOff() (CANIF_CS_STOPPED)
-  Wakeup detection by calling Can_CheckWakeup() (CANIF_CS_STOPPED)
        </pre>
        The state is always set to the latest detected/reported event. The result
        therefore is strongly dependent from the actual Can driver module behavior.
        Possible inconsistencies:<pre>
-  Can_SetControllerMode(CAN_T_START) (current state is CANIF_CS_STARTED)
-  CanIf_ControllerBusOff() -&gt; controller mode is changed to CANIF_CS_STOPPED 
both in CanIF SW and HW.
-  CanIf_ControllerModeIndication(CANIF_CS_STARTED) -&gt; controller mode is cha-
nged to CANIF_CS_STARTED in CanIf SW although hardware stays stopped.
-  Can_SetControllerMode(CAN_T_SLEEP) (current state is CANIF_CS_STOPPED)
-  CanIf_CheckWakeup() reports wakeup event -&gt; controller mode is changed to 
CANIF_CS_STOPPED both in CanIf SW and HW.
-  CanIf_ControllerModeIndication(CAN_T_SLEEP) -&gt; controller mode is changed to
CAN_T_SLEEP in CanIf SW although hardware stays stopped.</pre>
      </description>
      <rationale/>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanIf.Interaction2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1312</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>2</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0004</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Bus Mirroring is enabled the signature of the 
      functions <code>CanIf_GetTrcvMode()</code> and <code>CanIf_GetControllerMode()</code>
      is according to the AR4.4 specs.
      As these are called from integration code / CDDs, the correct order and type of the
      parameters has to be ensured.
      </description>
      <rationale>
      Changing the signature of the functions guarantees interoperability with the Bus Mirroring
      module while maintaining backwards compatibility when the feature is off.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>3</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0005</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        Starting with ACG-8.7.2, CanIf supports compatibility with CAN driver ASR 4.3 and 4.4.
      During this development, CanIfEnableCanRel422Compatibility and CanIfEnableCanRev2Compatibility
      were removed and replaced with CanIfCanDriverCompatibility. After updating to this ACG version,
      replacing the obsolete parameters with the new one shall be taken into account. This will make
      the tests that used both CanIfEnableCanRel422Compatibility and CanIfEnableCanRev2Compatibility
      unusable, considering that a driver cannot be ASR 4.2.2 and ASR 4.0.2 at the same time anyway.
      </description>
      <rationale>
      Using this new paramenter CanIfCanDriverCompatibility, it is easier to specify the version of
      CAN driver the CAN Interface will be referring to.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>4</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0006</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD callbacks (defined via
      CanIfNumberOfEnqueuedRxPdusApiName, CanIfNumberOfRxPdusExceedingQueueApiName,
      CanIfNumberOfEnqueuedTxPdusApiName or CanIfNumberOfTxPdusExceedingQueueApiName parameters) for
      Decoupled processing queue size measurement support must be concurrently callable from different
      partitions/cores for different MainFunction Ids.
      </description>
      <rationale>
      Assuring that the CDD callbacks can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>5</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0007</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD callbacks (defined via
      CanIfHookOnReceptionFunctionName parameter) for the Custom Hook support must be concurrently callable
      from different partitions/cores for different PDU Ids.
      </description>
      <rationale>
      Assuring that the CDD callbacks can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>6</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0008</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, all PDUs corresponding to the J1939 stack must be mapped
      on the same core (the same one on which the J1939 stack is located) if the CAN stack is Multi-core distributed
      along network boundaries. This includes all the resources corresponding to those PDUs: interrupts, main
      functions, etc.
      </description>
      <rationale>
      The J1939 stack has no Multicore distribution capabilities.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>7</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0009</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD RxIndication callback (defined via
      CanIfRxPduUserRxIndicationName parameter) must be concurrently callable from different
      partitions/cores for different PDU Ids.
      </description>
      <rationale>
      Assuring that the CDD callback can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>8</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0010</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD TxConfirmation callback (defined via
      CanIfTxPduUserTxConfirmationName parameter) must be concurrently callable from different
      partitions/cores for different PDU Ids.
      </description>
      <rationale>
      Assuring that the CDD callback can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>9</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0011</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the <code>Can_SetControllerMode()</code>,
      <code>Can_SetBaudrate()</code> and <code>Can_CheckWakeup()</code> APIs must be concurrently
      callable from different partitions/cores for different controller Ids.
      </description>
      <rationale>
      Assuring that the MCAL driver can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>10</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0012</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the <code>Can_Write()</code> API must be concurrently
      callable from different partitions/cores for different hardware objects.
      </description>
      <rationale>
      Assuring that the MCAL driver can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>11</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0013</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the <code>CanTrcv_SetOpMode()</code>,
      <code>CanTrcv_GetOpMode()</code>, <code>CanTrcv_GetBusWuReason()</code>,
      <code>CanTrcv_SetWakeupMode()</code>, <code>CanTrcv_CheckWakeup()</code> and <code>CanTrcv_CheckWakeFlag()</code>
      APIs must be concurrently callable from different partitions/cores for different transceiver Ids.
      </description>
      <rationale>
      Assuring that the transceiver driver can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>12</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0014</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD ControllerBusOff callback (defined via
      CanIfDispatchUserCtrlBusOffName parameter) must be concurrently callable from different
      partitions/cores for different controller Ids.
      </description>
      <rationale>
      Assuring that the CDD callback can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>13</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0015</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD ControllerModeIndication callback (defined via
      CanIfDispatchUserCtrlModeIndicationName parameter) must be concurrently callable from different
      partitions/cores for different controller Ids.
      </description>
      <rationale>
      Assuring that the CDD callback can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>14</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0016</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD TransceiverModeIndication callback (defined via
      CanIfDispatchUserTrcvModeIndicationName parameter) must be concurrently callable from different
      partitions/cores for different transceiver Ids.
      </description>
      <rationale>
      Assuring that the CDD callback can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>15</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0017</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD ConfirmPnAvailability callback (defined via
      CanIfDispatchUserConfirmPnAvailabilityName parameter) must be concurrently callable from different
      partitions/cores for different transceiver Ids.
      </description>
      <rationale>
      Assuring that the CDD callback can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>16</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0018</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD ClearTrcvWufFlagIndication callback (defined via
      CanIfDispatchUserClearTrcvWufFlagIndicationName parameter) must be concurrently callable from different
      partitions/cores for different transceiver Ids.
      </description>
      <rationale>
      Assuring that the CDD callback can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>17</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0019</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the CDD CheckTransceiverWakeFlagIndication callback (defined via
      CanIfDispatchUserCheckTrcvWakeFlagIndicationName parameter) must be concurrently callable from different
      partitions/cores for different transceiver Ids.
      </description>
      <rationale>
      Assuring that the CDD callback can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>18</internalId></specobject>

    <specobject>
      <id>lim.CanIf.EB_INTREQ_CanIf_0020</id>
      <status>approved</status>
      <source>EB integration requirement</source>
      <version>1</version>
      <description>
        When the support for Multicore is enabled, the <code>Can_GetControllerTxErrorCounter()</code>,
      and <code>Can_GetControllerErrorState()</code> APIs must be concurrently
      callable from different partitions/cores for different controller Ids.
      </description>
      <rationale>
      Assuring that the MCAL driver can operate on Multicore processors.
      </rationale>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>19</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>CanIf.ASR40.ECUC_CanIf_00522</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Name: CanIfPublicCancelTransmitSupport
        Parameter Type: Boolean
        Parent Containers: CanIfPublicCfg,
        Description: Configuration parameter to enable/disable dummy API for upper layer modules which 
        allows to request the cancellation of an I-PDU.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Functional behaviour is specified in CanIf.ASR40.SWS_CanIf_00521.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>20</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00229</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        Service name: CanIf_GetControllerMode
      Syntax: Std_ReturnType CanIf_GetControllerMode
        (uint8 ControllerId, CanIf_ControllerModeType* ControllerModePtr)
      Service ID[hex]: 0x04
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
         ControllerId Abstracted CanIf ControllerId which is assigned to a CAN controller,
           which is requested for current operation mode.
         ControllerModePtr Pointer to a memory location, where the current mode of the
           CAN controller will be stored.
      Parameters (inout):None
      Parameters (out): None
      Return value: Std_ReturnType
        E_OK: Controller mode request has been accepted.
        E_NOT_OK: Controller mode request has not been accepted.
      Description: This service
        reports about the current status of the requested CAN controller. (BSW01028)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</srcid><srcstatus/><internalId>956</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.GetControllerModeSignature</srcid><srcstatus/><internalId>1090</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>21</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.ECUC_CanIf_00591</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Name: CanIfTxPduId
        Parameter Type: Integer
        Parent Containers: CanIfTxPduCfg,
        Description: ECU wide unique, symbolic handle for transmit CAN L-PDU. The CanIfTxPduId is 
        configurable at pre-compile and post-built time.
        Introduction: Range: 0..max. number of CantTxPduIds
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: true
        Max-Value: 4294967295 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SymbolicNameValues</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00591</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>22</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.ECUC_CanIf_00640</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Name: CanIfCtrlDrvTxCancellation
        Parameter Type: Boolean
        Parent Containers: CanIfCtrlDrvCfg,
        Description: Selects whether transmit cancellation is supported and if the appropriate callback 
        will be provided to the CAN Driver module.
        Introduction: True: Enabled
        False: Disabled
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Functional specification in requirement CanIf.ASR40.SWS_CanIf_00428.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>23</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.ECUC_CanIf_00654</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Name: CanIfTrcvId
        Parameter Type: Integer
        Parent Containers: CanIfTrcvCfg,
        Description: This parameter abstracts from the CAN Transceiver Driver specific parameter 
        Transceiver. Each transceiver of all connected CAN Transceiver Driver modules shall be assigned 
        to one specific TransceiverId of the CanIf.
        Introduction: Range: 0..number of configured transceivers of all CAN Transceiver Driver modules
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: true
        Max-Value: 65535 (Type:
        Min-Value: 0 (Type:
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SymbolicNameValues</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00654</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>24</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.ECUC_CanIf_00820</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Name: CanIfDispatchUserConfirmPnAvailabilityUL
        Parameter Type: Enumeration
        Parent Containers: CanIfDispatchCfg,
        Description: This parameter defines the upper layer module to which the ConfirmPnAvailability 
        notification from the Driver modules have to be routed. If CANIF_PUBLIC_PN_SUPPORT equals False,
        this parameter shall not be configurable.
        Lower Multiplicity: 1
        Upper Multiplicity: 1
        Origin: AUTOSAR_ECUC
        Symbolic-Name-Value: false
        Enumeration Literal: CAN_SM, AUTOSAR_ECUC
        Enumeration Literal: CDD, AUTOSAR_ECUC
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00820</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>25</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name:            CanIf_Transmit
        Syntax:                  Std_ReturnType    CanIf_Transmit(
        PduIdType   CanTxPduId,
        const    PduInfoType*    PduInfoPtr
        Service ID[hex]:         0x05
        Sync/Async:              Synchronous
        Reentrancy:              Reentrant
        CanTxPduId        L-PDU handle of CAN L-PDU to be transmitted.
        Parameters (in):                           This handle specifies the corresponding CAN L-PDU ID 
        and
        implicitly the CAN Driver instance as well as the corresponding
        CAN controller device.
        PduInfoPtr    Pointer to a structure with CAN L-PDU related data: DLC and
        pointer to CAN L-SDU buffer
        Parameters         None
        inout)
        Parameters (out):  None
        Return value:      Std_ReturnTypeE_OK: Transmit request has been accepted
        E_NOT_OK: Transmit request has not been accepted
        Description:       This service initiates a request for transmission of the CAN L-PDU specified 
        by the
        CanTxPduId and CAN related data in the L-PDU structure.
        BSW01008)
        Note:      The  corresponding  CAN  controller  and   HTH     have  to      be  resolved  by  
        the
        CanTxPduId.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30843</srcid><srcstatus/><internalId>1445</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30244</srcid><srcstatus/><internalId>1463</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30245</srcid><srcstatus/><internalId>1464</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Transmit300Hths</srcid><srcstatus/><internalId>1544</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30368</srcid><srcstatus/><internalId>1560</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31190</srcid><srcstatus/><internalId>1586</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30317</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30342</srcid><srcstatus/><internalId>1725</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>26</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00018</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The detection of development errors is configurable (ON / OFF) at pre-compile time. The switch 
        CANIF_PUBLIC_DEV_ERROR_DETECT  shall activate or deactivate the detection of all development 
        errors.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31352</srcid><srcstatus/><internalId>1329</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31391</srcid><srcstatus/><internalId>1330</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30352</srcid><srcstatus/><internalId>1698</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30391</srcid><srcstatus/><internalId>1699</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00019</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>28</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>27</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00019</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the CANIF_PUBLIC_DEV_ERROR_DETECT switch is enabled, API checking is enabled. The detailed 
        description of the detected errors can be found in chapter [X7.26X XError classificationX] and 
        chapter [X8X XAPI specificationX]
      </description>
      <comment>
        Duplicate. See CANIF018
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00018</srcid><srcstatus/><internalId>27</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>28</internalId></specobject>

    <specobject>
         <id>CanIf.ASR40.PduIdUsage.Apis</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      For transmission request and transmission/reception polling API the upper
      layer module uses the CAN L-PDU Id defined by the CanIf as parameter.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30317</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30298</srcid><srcstatus/><internalId>1731</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30205</srcid><srcstatus/><internalId>1732</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30206</srcid><srcstatus/><internalId>1733</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>29</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.PduIdUsage.Calls</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      For all callback APIs, which are invoked by the CanIf at upper layer
      modules, the CanIf passes the target PduId defined by each upper layer
      module as parameter.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>30</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00054</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        When CanIf_CancelTxConfirmation() is called, the CanIf shall check if it is possible to buffer 
        the canceled CanIf Tx L-PDU, which is referenced in parameter PduInfoPtr of 
        CanIf_CancelTxConfirmation(), inside a CanIfTxBuffer.
      </description>
      <comment>
        Meaning:
        When callback notification service CanIf_CancelTxConfirmation() is called, the
        CanIf shall store the aborted old L-PDU, which is referenced in parameter
        PduInfoPtr of CanIf_CancelTxConfirmation(), inside its transmit L-PDU
        buffer as long it is configured and free.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_1</srcid><srcstatus/><internalId>1570</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_2</srcid><srcstatus/><internalId>1571</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_3</srcid><srcstatus/><internalId>1572</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_4</srcid><srcstatus/><internalId>1573</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_5</srcid><srcstatus/><internalId>1574</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_6</srcid><srcstatus/><internalId>1575</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31195</srcid><srcstatus/><internalId>1588</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>31</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00057</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall not provide buffers to store SDUs but it shall use the SDU buffers provided by 
        upper layer modules.
      </description>
      <comment>
        Hint for testing: check if payload pointer passed into CanIf and provided by CanIf is
        the same.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31144</srcid><srcstatus/><internalId>1556</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>32</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00101</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name:          CanIf_CancelTxConfirmation
        Syntax:                void   CanIf_CancelTxConfirmation(
        PduIdType  CanTxPduId,
        const  PduInfoType*    PduInfoPtr
        Service ID[hex]:            0x15
        Sync/Async:                 Synchronous
        Reentrancy:                 Non Reentrant
        CanTxPduIdID of the L-PDU which shall be buffered in CanIf and replaced by a
        Parameters (in):                         new pending L-PDU with a higher priority.
        PduInfoPtr   Pointer to struct which contains the address of the HTH in which the
        L-PDU is located and the length of the L-PDU.
        Parameters                  None
        inout)
        Parameters (out):           None
        Return value:               None
        Description:                This service informs CanIf that a L-PDU shall be buffered in CanIf 
        Txbuffer from
        CAN hardware object to avoid priority inversion.
        Note: The service CanIf_CancelTxConfirmation()                                is implemented in 
        the CanIf
        and called by the CanDrv after a previous request for cancellation of a pending L-
        PDU transmit request was successfully performed.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>33</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00116</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall offer a header file CanIf.h, which contains the declaration of the CanIf API.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>34</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00121</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall provide a header file CanIf_Cbk.h, which declares the callback functions called by the CanDrv.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30353</srcid><srcstatus/><internalId>1323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>35</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00122</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shal include necessary configuration data by the header files:
        CanIf.h                for declaration of the provided interface functions
        CanIf_Cfg.h            for pre-compile time configurable parameters and
        CanIf_Lcfg.h           for link build time configurable parameters
        CanIf_PBcfg.h          for post build time configurable parameters
        BSW00381, BSW00412)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00122_1</srcid><srcstatus/><internalId>37</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00122_2</srcid><srcstatus/><internalId>38</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>36</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00122_1</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall include necessary configuration data by the header files:
    CanIf_Api.h - for declaration of the provided interface functions
    CanIf_Cfg.h - for pre-compile time configurable parameters and
    CanIf_Lcfg.h - for link build time configurable parameters
    </description>
       <comment>
    CanIf does not follow the strict inclusion guidelines of the SWS.
    Interface declarations are provided in CanIf_Api.h instead of
    CanIf.h. From extern view the important point is that CanIf.h
    exports the API declaration which means that CanIf.h shall
    include CanIf_Api.h.
    Note: The term CanIf described the implementation file CanIf.c.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       <providescoverage>
          <provcov>
             <linksto>CanIf.ASR40.SWS_CanIf_00122</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>37</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00122_2</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The implementation file CanIf.c shall include necessary
    configuration data by the header files:
    CanIf_PBcfg.h - for post build time configurable parameters
    (BSW00381, BSW00412)
    </description>
       <comment>
    This requirement is not applicable.
    This is an error in the CanIf SWS.
    To make it possible that the modules' PostBuild part translates
    separately, only CanIf_PBcfc.c is allowed to include CanIf_PBcfg.h.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <providescoverage>
          <provcov>
             <linksto>CanIf.ASR40.SWS_CanIf_00122</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>36</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>38</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00122.PBcfg</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The implementation file CanIf.c must not include CanIf_PBcfg.h.
    </description>
       <comment>
    This requirement is contrary to CanIf.ASR40.SWS_CanIf_00122.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>39</internalId></specobject>
      
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00124</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        If multiple CanDrvs are assigned to a CanIf, then that CanIf shall provide a separate set of 
        callback function for each CanDrv, in which the callback function names has to follow the 
        naming convention specified in BSW00347.
        The naming convention is as follows:
        &lt;CAN Driver module name&gt;_&lt;vendorID&gt;_&lt;Vendor specific API name&gt;&lt;driver abbreviation&gt;()
        E.g.:
        Can_99_Ext1
        Can_99_Ext2
        The additional affixes within the function names shall be derived from configuration reference CANIF_DRIVER_NAME_REF.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MULTIDRV_TRANSMIT</srcid><srcstatus/><internalId>1547</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CONTROLLERBUSOFF</srcid><srcstatus/><internalId>1554</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_OFFSETTXBUFF</srcid><srcstatus/><internalId>1555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>40</internalId></specobject>

    <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_CANID</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_CANID
      value (dec): 10
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00417</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00353</srcid><srcstatus/><internalId>524</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>41</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_DLC</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_DLC
      value (dec): 11
      Relevance: Development
      Type of error: API service called with invalid DLC value
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00418</srcid><srcstatus/><internalId>89</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>42</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_HRH</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_HRH
      value (dec): 12
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00416</srcid><srcstatus/><internalId>220</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>43</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_LPDU</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_LPDU
      value (dec): 13
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00424</srcid><srcstatus/><internalId>94</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00410</srcid><srcstatus/><internalId>554</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>44</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_CONTROLLER</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_CONTROLLER
      value (dec): 14
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00429</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00700</srcid><srcstatus/><internalId>651</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>45</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_CONTROLLERID</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_CONTROLLERID
      value (dec): 15
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00311</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00313</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00341</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00346</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00736</srcid><srcstatus/><internalId>662</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>46</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_WAKEUPSOURCE</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_WAKEUPSOURCE
      value (dec): 16
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00398</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00404</srcid><srcstatus/><internalId>552</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>47</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_TRCV</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_TRCV
      value (dec): 17
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00364</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00535</srcid><srcstatus/><internalId>596</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00537</srcid><srcstatus/><internalId>598</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00538</srcid><srcstatus/><internalId>599</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00706</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00769</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00770</srcid><srcstatus/><internalId>680</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00805</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00809</srcid><srcstatus/><internalId>697</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00816</srcid><srcstatus/><internalId>703</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>48</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_TRCVMODE</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_TRCVMODE
      value (dec): 18
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <comment>
      The CanTrcv Driver also performs a parameter check of the API service
      and provides a DET error code.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00648</srcid><srcstatus/><internalId>617</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>49</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_TRCVWAKEUPMODE</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_TRCVWAKEUPMODE
      value (dec): 19
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <comment>
      The CanTrcv Driver also performs a parameter check of the API service
      and provides a DET error code.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00536</srcid><srcstatus/><internalId>597</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>50</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_CTRLMODE</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_CTRLMODE
      value (dec): 21
      Relevance: Development
      Type of error: API service called with invalid parameter
      </description>
         <comment>
      The CanTrcv Driver also performs a parameter check of the API service
      and provides a DET error code.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00774</srcid><srcstatus/><internalId>682</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>51</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_PARAM_POINTER</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_PARAM_POINTER
      value (dec): 20
      Relevance: Development
      Type of error: API service called with invalid pointer
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00302</srcid><srcstatus/><internalId>69</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00419</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00658</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00320</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00326</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00419_1</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00419_2</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00649</srcid><srcstatus/><internalId>618</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00650</srcid><srcstatus/><internalId>619</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00656</srcid><srcstatus/><internalId>622</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00657</srcid><srcstatus/><internalId>623</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>52</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_UNINIT</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_UNINIT
      value (dec): 30
      Relevance: Development
      Type of error: API service used without module initialization
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661</srcid><srcstatus/><internalId>133</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>53</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_INVALID_TXPDUID</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_INVALID_TXPDUID
      value (dec): 50
      Relevance: Development
      Type of error: Transmit PDU ID invalid
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00652</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00319</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00331</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00352</srcid><srcstatus/><internalId>523</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>54</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_INVALID_RXPDUID</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_INVALID_RXPDUID
      value (dec): 60
      Relevance: Development
      Type of error: Receive PDU ID invalid
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00325</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00336</srcid><srcstatus/><internalId>516</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>55</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_INVALID_DLC</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_INVALID_DLC
      value (dec): 61
      Relevance: Development
      Type of error: Failed DLC Check
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00168</srcid><srcstatus/><internalId>222</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>56</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_STOPPED</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_STOPPED
      value (dec): 70
      Relevance: Development
      Type of error: CAN Interface controller mode state machine is in mode
      CANIF_CS_STOPPED
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CANIF_E_STOPPED</srcid><srcstatus/><internalId>1086</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>57</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.CANIF_E_NOT_SLEEP</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      The CanIf shall provide the following error code:
      symbolic name: CANIF_E_NOT_SLEEP
      value (dec): 71
      Relevance: Development
      Type of error: CAN Interface controller mode state machine is not in mode
      CANIF_CS_SLEEP
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.CANIF679_1</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.CANIF679_2</srcid><srcstatus/><internalId>170</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>58</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00156</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Detected development errors shall only be reported to Det_ReportError service of the DET, if 
        the pre-processor switch CANIF_PUBLIC_DEV_ERROR_DETECT is set to True 
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00302</srcid><srcstatus/><internalId>69</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00418</srcid><srcstatus/><internalId>89</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00419</srcid><srcstatus/><internalId>90</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00424</srcid><srcstatus/><internalId>94</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00652</srcid><srcstatus/><internalId>131</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00658</srcid><srcstatus/><internalId>132</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661</srcid><srcstatus/><internalId>133</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.CANIF679_1</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.CANIF679_2</srcid><srcstatus/><internalId>170</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00416</srcid><srcstatus/><internalId>220</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00168</srcid><srcstatus/><internalId>222</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00417</srcid><srcstatus/><internalId>227</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00311</srcid><srcstatus/><internalId>498</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00313</srcid><srcstatus/><internalId>499</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00319</srcid><srcstatus/><internalId>502</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00320</srcid><srcstatus/><internalId>503</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00325</srcid><srcstatus/><internalId>508</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00326</srcid><srcstatus/><internalId>509</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00331</srcid><srcstatus/><internalId>512</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00336</srcid><srcstatus/><internalId>516</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00341</srcid><srcstatus/><internalId>521</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00346</srcid><srcstatus/><internalId>522</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00352</srcid><srcstatus/><internalId>523</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00353</srcid><srcstatus/><internalId>524</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00364</srcid><srcstatus/><internalId>530</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00398</srcid><srcstatus/><internalId>551</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00404</srcid><srcstatus/><internalId>552</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00410</srcid><srcstatus/><internalId>554</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00419_1</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00419_2</srcid><srcstatus/><internalId>563</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00429</srcid><srcstatus/><internalId>566</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00535</srcid><srcstatus/><internalId>596</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00536</srcid><srcstatus/><internalId>597</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00537</srcid><srcstatus/><internalId>598</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00538</srcid><srcstatus/><internalId>599</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00648</srcid><srcstatus/><internalId>617</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00649</srcid><srcstatus/><internalId>618</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00650</srcid><srcstatus/><internalId>619</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00656</srcid><srcstatus/><internalId>622</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00657</srcid><srcstatus/><internalId>623</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00700</srcid><srcstatus/><internalId>651</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00706</srcid><srcstatus/><internalId>653</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00736</srcid><srcstatus/><internalId>662</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00769</srcid><srcstatus/><internalId>679</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00770</srcid><srcstatus/><internalId>680</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00805</srcid><srcstatus/><internalId>694</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00809</srcid><srcstatus/><internalId>697</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00816</srcid><srcstatus/><internalId>703</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>59</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00176</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall only store an aborted transmit L-PDU in a CanIfTxBuffer, if it does not contain 
        a newer pending transmit L-PDUs with the same L-PDU handle (refer to 7.11.2.1Storage of L-PDUs 
        in the transmit L-PDU buffer)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_ExtFdTxCancel</srcid><srcstatus/><internalId>1411</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_StdFdTxCancel</srcid><srcstatus/><internalId>1412</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30203</srcid><srcstatus/><internalId>1750</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>60</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00194</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name:           CanIf_ReadRxPduData
        Syntax:                 Std_ReturnType       CanIf_ReadRxPduData(
        PduIdType    CanRxPduId,
        PduInfoType*   PduInfoPtr
        Service ID[hex]:        0x06
        Sync/Async:             Synchronous
        Reentrancy:             Non Reentrant
        CanRxPduId      Receive L-PDU handle of CAN L-PDU.
        Parameters (in):                        This handle specifies the corresponding CAN L-PDU ID 
        and
        implicitly the CAN Driver instance as well as the corresponding
        CAN controller device.
        Parameters              None
        inout)
        Parameters (out):       PduInfoPtr      Pointer to a structure with CAN L-PDU related data: DLC 
        and
        pointer to CAN L-SDU buffer
        Return value:           Std_ReturnTypeE_OK: Request for L-PDU data has been accepted
        E_NOT_OK: No valid data has been received
        Description:            This service provides the CAN DLC and the received data of the 
        requested
        CanRxPduId to the calling upper layer.
        BSW01125, BSW01129, BSW01129)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30842</srcid><srcstatus/><internalId>1446</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30246</srcid><srcstatus/><internalId>1466</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30247</srcid><srcstatus/><internalId>1467</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30298</srcid><srcstatus/><internalId>1731</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>61</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00208</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall include the following header files &lt;Module&gt;_CanIf.h
        of those upper layer modules, from which declarations of only CanIf specific API
        services or type definitions are needed:
        PduR_CanIf.h           for services and callback declarations of the PduR
        SchM_CanIf.h          for services and callback declarations of the SchM
        (BSW00415)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>62</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00224</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If only one CanDrv is assigned to a CanIf, then that CanIf shall provide the set of callback 
        functions for that CanDrv as defined in chapter 8.4.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31352</srcid><srcstatus/><internalId>1329</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31391</srcid><srcstatus/><internalId>1330</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30352</srcid><srcstatus/><internalId>1698</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30391</srcid><srcstatus/><internalId>1699</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>63</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00233</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        The CanIf shall include the following header files &lt;Module&gt;_Cbk.h
        which the callback functions called by the CanIf at the upper layers are declared:
        CanSM_Cbk.h            for callback declarations of the CanSm
        CanNm_Cbk.h            for callback declarations of the CanNm
        CanTp_Cbk.h            for callback declarations of the CanTp
        EcuM_Cbk.h            for callback declarations of the EcuM
        CDD&gt;_Cbk.h           for callback declarations of CDD; &lt;CDD&gt; is
        configurable via parameter
        CANIF_CDD_HEADERFILE 
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.CANIF233</srcid><srcstatus/><internalId>915</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>64</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00278</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall include the file MemMap.h in case the mapping of code and data
        to specific memory sections via memory mapping file is needed for CanIf
        implementation.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00278_1</srcid><srcstatus/><internalId>66</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>65</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00278_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        MemMap.h inclusion at the beginning of a section shall be preceded by a &lt;MODULE&gt;_START_SEC_&lt;TYPE_PROPERTIES&gt; macro.
        MemMap.h inclusion at the end of a section shall be preceded by a &lt;MODULE&gt;_STOP_SEC_&lt;TYPE_PROPERTIES&gt; macro.
        &lt;MODULE&gt;_START_SEC_&lt;TYPE_PROPERTIES&gt; and &lt;MODULE&gt;_STOP_SEC_&lt;TYPE_PROPERTIES&gt; must be balanced.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00278</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>65</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>66</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00278_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Particular symbols (functions, global variables) shall be mapped to memory sections according to the
        respective symbol property, including:
        - constness
        - variable size
        - initializationcharacteristics
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.MemMap</srcid><srcstatus/><internalId>1053</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>67</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00298</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM equals CANIF_CS_INIT when function CanIf_ControllerBusOff(ControllerId) is called 
        with parameter ControllerId referencing that CCMSM, then the CCMSM shall be changed to 
        CANIF_CS_STOPPED.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>68</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00302</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter ConfigPtr of CanIf_Init() has an invalid value, the CanIf shall report development 
        error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the DET module only for post 
        build use cases, when CanIf_Init() is called.
      </description>
      <comment>
        This applies only if PbcfgM is not configured. Otherwise, CanIf.EB.PBCFGM110 applies.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_Init_INVALID_PTR</srcid><srcstatus/><internalId>1462</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>69</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00339</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ReadRxNotifStatus(
        The CanIf must be initialized after Power ON.
      </description>
      <comment>
        This requirement is informational only.
        This is no requirement for the CanIf (to be handled by application)
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>70</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00339.CanIf_ReadRxNotifStatus.Caveat</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ReadRxNotifStatus():
      - This API must not be used for CanRxPduIds, which are defined to receive multiple
        CAN-Ids (range reception)
      </description>
      <comment>
        CanRxPduIds with multiple CAN IDs are prohibited for function
        CanIf_ReadRxPduData(). In this way, we implicitly fulfill parts of
        CanIf.ASR40.CANIF336_2 that were already fulfilled by older
        specifications.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_1434</srcid><srcstatus/><internalId>1261</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>71</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00350</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The function CanIf_GetVersionInfo() shall return the version information of the called CanIf 
        module. The version information includes:
        Module Id
        Vendor Id
        Vendor specific version numbers (BSW00407)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30209</srcid><srcstatus/><internalId>1743</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>72</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00351</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Configuration of CanIf_GetVersionInfo(): This function shall be pre compile time configurable 
        On/Off by the configuration parameter CANIF_PUBLIC_VERSION_INFO_API 
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31868</srcid><srcstatus/><internalId>1335</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30868</srcid><srcstatus/><internalId>1704</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>73</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00362</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Configuration of CanIf_SetTrcvMode(): The number of supported transceiver types for each 
        network is set up in the configuration phase . If no transceiver is used, this function shall 
        not be provided.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_TrcvAvailability</srcid><srcstatus/><internalId>1351</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOf_403_and_422_Trcv_UsedTrcv</srcid><srcstatus/><internalId>1416</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOfUsedTrcv</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_ParametersRelatedTo_PnSupport_SetTo_FALSE</srcid><srcstatus/><internalId>1569</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>528</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>74</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00367</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Configuration of CanIf_GetTrcvMode(): The number of supported transceiver types for each 
        network is set up in the configuration phase . If no transceiver is used, this function shall 
        not be provided.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_TrcvAvailability</srcid><srcstatus/><internalId>1351</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOf_403_and_422_Trcv_UsedTrcv</srcid><srcstatus/><internalId>1416</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOfUsedTrcv</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_ParametersRelatedTo_PnSupport_SetTo_FALSE</srcid><srcstatus/><internalId>1569</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>531</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>75</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00371</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Configuration of CanIf_GetTrcvWakeupReason(): The number of supported transceiver types for 
        each network is set up in the configuration phase . If no transceiver is used, this function 
        shall not be provided.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_TrcvAvailability</srcid><srcstatus/><internalId>1351</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOf_403_and_422_Trcv_UsedTrcv</srcid><srcstatus/><internalId>1416</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOfUsedTrcv</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_ParametersRelatedTo_PnSupport_SetTo_FALSE</srcid><srcstatus/><internalId>1569</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>533</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>76</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00373</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Configuration of CanIf_SetTrcvWakeupMode(): The number of supported transceiver types for each 
        network is set up in the configuration phase . If no transceiver is used, this function shall 
        not be provided.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_TrcvAvailability</srcid><srcstatus/><internalId>1351</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOf_403_and_422_Trcv_UsedTrcv</srcid><srcstatus/><internalId>1416</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOfUsedTrcv</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_ParametersRelatedTo_PnSupport_SetTo_FALSE</srcid><srcstatus/><internalId>1569</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>535</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>77</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00401</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_CheckWakeup(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00401_1</srcid><srcstatus/><internalId>79</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00401_2</srcid><srcstatus/><internalId>80</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>78</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00401_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_CheckWakeup(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanIf.ASR40.SWS_CanIf_00401</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
     </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>79</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00401_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_CheckWakeup(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
        This is no requirement for the CanIf. It is up to the application to perform this.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
          <provcov>
             <linksto>CanIf.ASR40.SWS_CanIf_00401</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>78</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>80</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00402</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Configuration of CanIf_CheckWakeup(): This wake-up service is configurable by 
        CANIF_CTRL_WAKEUP_SUPPORT  and/or CANIF_TRCV_WAKEUP_SUPPORT , which depends on the used CAN 
        controller / transceiver type and the used wake-up strategy. This function may not be supported,
        if no wake-up shall be used.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00180</srcid><srcstatus/><internalId>458</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>81</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00407</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_CheckValidation(
        The CAN Interface module must be initialized after Power ON.
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The corresponding CAN controller and transceiver must be switched on via CanTrcv_SetOpMode(
        Transceiver, CANTRCV_TRCVMODE_NORMAL) and Can_SetControllerMode(Controller, CAN_T_START)and the 
        corresponding mode indications must have been called.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00407_1</srcid><srcstatus/><internalId>83</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00407_2</srcid><srcstatus/><internalId>84</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>82</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00407_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The call context of CanIf_CheckValidation() is either on interrupt
        level (interrupt mode) or on task level (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
         <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
            <linksto>CanIf.ASR40.SWS_CanIf_00407</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>83</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00407_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        - The CAN Interface module must be initialized after Power ON.
        - The corresponding underlying CAN Driver and CAN Transceiver Driver module
        must be switched on via CanTrcv_SetOpMode(STARTED, transceiver) and
        Can_SetControllerMode(controller, STARTED)
      </description>
         <comment>
      This requirement is informational only.
      This is no requirement for the CanIf
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
         <provcov>
            <linksto>CanIf.ASR40.SWS_CanIf_00407</linksto>
            <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>82</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>84</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00409</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The function prototypes of the CAN Interface module's callback functions shall be provided in 
        the file CanIf_Cbk.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30353</srcid><srcstatus/><internalId>1323</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>85</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00413</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The call context is either on interrupt level (interrupt mode) or on task level
        polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00413_1</srcid><srcstatus/><internalId>87</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00413_2</srcid><srcstatus/><internalId>88</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>86</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00413_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The call context of CanIf_TxConfirmation() is either on interrupt
        level (interrupt mode) or on task level  (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
          <provcov>
             <linksto>CanIf.ASR40.SWS_CanIf_00413</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>87</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00413_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
        This is no requirement for the CanIf. It has to be performed by the application.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
          <provcov>
             <linksto>CanIf.ASR40.SWS_CanIf_00413</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>86</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>88</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00418</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter CanDlc of CanIf_RxIndication() has an invalid value, the CanIf shall report 
        development error code CANIF_E_PARAM_DLC to the Det_ReportError service of the DET module, when 
        CanIf_RxIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31218</srcid><srcstatus/><internalId>1389</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30260</srcid><srcstatus/><internalId>1490</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_DLC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>42</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>89</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00419</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter CanSduPtr of CanIf_RxIndication() has an invalid value, the CanIf shall report 
        development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the DET module, 
        when CanIf_RxIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30261</srcid><srcstatus/><internalId>1491</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>90</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00422</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_RxIndication(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00422_1</srcid><srcstatus/><internalId>92</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00422_2</srcid><srcstatus/><internalId>93</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>91</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00422_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The call context of CanIf_RxIndication() is either on interrupt
        level (interrupt mode) or on task level  (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00422</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>92</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00422_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
        This is no requirement for the CanIf. It has to be performed by the application.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00422</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>91</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>93</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00424</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter CanTxPduId of CanIf_CancelTxConfirmation() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_LPDU to the Det_ReportError service of the DET 
        module, when CanIf_CancelTxConfirmation() is called.
      </description>
      <comment>
        As CanIf_CancelTxConfirmation() has no parameter CanTxPduId but a
      corresponding parameter PduInfoPtr-&gt;swPduHandle, the requirement is read
      as if CanTxPduId is replaced by PduInfoPtr-&gt;swPduHandle.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_InvalidPduId</srcid><srcstatus/><internalId>1437</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30262</srcid><srcstatus/><internalId>1492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_LPDU</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>94</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00426</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the CanIf was not initialized before calling CanIf_CancelTxConfirmation(),the CanIf shall 
        not execute Tx cancellation handling, when CanIf_CancelTxConfirmation() is called.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CancelTxConfirmationBeforeInit</srcid><srcstatus/><internalId>1712</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>95</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00427</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_CancelTxConfirmation(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00427_1</srcid><srcstatus/><internalId>97</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00427_2</srcid><srcstatus/><internalId>98</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>96</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00427_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The call context of CanIf_CancelTxConfirmation() is either on
      interrupt level (interrupt mode) or on task level  (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00427</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>97</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00427_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
      This is no requirement for the CanIf. It has to be performed by the application.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00427</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>96</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>98</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00428</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Configuration of CanIf_CancelTxConfirmation(): This function shall be pre compile time 
        configurable On/Off by the configuration parameter CANIF_CTRLDRV_TX_CANCELLATION 
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30885</srcid><srcstatus/><internalId>1343</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>99</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00432</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ControllerBusOff(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00432_1</srcid><srcstatus/><internalId>101</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00432_2</srcid><srcstatus/><internalId>102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>100</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00432_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ControllerBusOff(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00432</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>101</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00432_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ControllerBusOff(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
        This is no requirement for the CanIf. It has to be performed by the application.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00432</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>100</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>102</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00460</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Variant 1: Only pre compile time parameters.
      </description>
      <comment>
        Implementation config variant pre compile is not supported
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PostBuildOnly</srcid><srcstatus/><internalId>1078</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>103</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00461</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Variant 2: Mix of pre compile- and link time parameters.
      </description>
      <comment>
        We do not support link time parameters
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PostBuildOnly</srcid><srcstatus/><internalId>1078</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>104</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00462</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Variant 3: Mix of pre compile-, link time and post build time parameters.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>105</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00463</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        Can_&lt;vendorID&gt;_&lt;Vendor         specific  name&gt;&lt;driver
        abbreviation&gt;.h
        for services and type definitions of the CanDrv
        e.g.: Can_99_Ext1.h,       Can_99_Ext2.h)
        CanTrcv_&lt;vendorID&gt;_&lt;Vendor     specific         name&gt;&lt;driver
        abbreviation&gt;.h
        for services and type definitions of the CanTrcv
        e.g.: CanTrcv_99_Ext1.h)
        Dem.h                  for services of the DEM
        Can_GeneralTypes.h     for CanDrv generic definitions used by the CanIf
        ComStack_Types.h      -  for COM related type definitions
        MemMap.h               for accessing the module specific functionality
        provided by the BSW Memory Mapping
        BSW00436)
        Note: The following header files are indirectly included by ComStack_Types.h:
        Std_Types.h            for AUTOSAR standard types
        Platform_Types.h       for platform specific types
        Compiler.h             for compiler specific language extensions
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00463_1</srcid><srcstatus/><internalId>107</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00463_2</srcid><srcstatus/><internalId>108</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>106</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00463_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        The CanIf include the following header files &lt;Module&gt;.h:
        CanTrcv.h  - for services and type definitions of the CanTrcv
        Can_GeneralTypes.h - for CanDrv generic definitions used by the CanIf
        ComStack_Types.h - for COM related type definitions
        MemMap.h - for accessing the module specific functionality provided by the BSW
      Memory Mapping (BSW00436)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00463</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>107</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00463_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        The CanIf include the following header files &lt;Module&gt;.h:
      Dem.h - for services of the DEM
      </description>
         <comment>
        This requirement is not applicable.
        CanIf does not report to Dem.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00463</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>106</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>108</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00464</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        Det.h                  for services of the DET(
      </description>
      <comment>
        Coding Guideline - t.b.d. (inclusion of foreign interface header file)
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_89</srcid><srcstatus/><internalId>1121</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>109</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00465</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Each CanRxPduId shall be assigned to one or multiple HRHs. Thus the assignment of single CanIds 
        to multiple HRHs is possible.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31144</srcid><srcstatus/><internalId>1556</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxRange_1</srcid><srcstatus/><internalId>1557</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>110</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00475</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If during function CanIf_SetControllerMode() the call of Can_SetControllerMode()returns with 
        CAN_NOT_OK, CanIf_SetControllerMode() returns E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30201</srcid><srcstatus/><internalId>1719</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>111</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00476</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_UNINIT when the function CanIf_Init() is called, then the CanIf 
        shall take the CCMSM for every assigned CAN controller to state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30293</srcid><srcstatus/><internalId>1713</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>112</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00477</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the CCMSM is in state CANIF_CS_INIT for every assigned CAN controller when the function 
        CanIf_Init() is called, then the CAN Interface module shall take the CCMSM for every assigned 
        CAN controller to state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30367</srcid><srcstatus/><internalId>1714</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>113</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00478</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the state CANIF_CS_INIT of a CCMSM is entered, then the CanIf shall take that CCMSM to sub 
        state CANIF_CS_STOPPED of state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31184</srcid><srcstatus/><internalId>1584</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30293</srcid><srcstatus/><internalId>1713</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30367</srcid><srcstatus/><internalId>1714</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>114</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00479</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM enters state CANIF_CS_INIT, then the CanIf shall clear all temporarily stored wakeup 
        events corresponding to that state machine.
      </description>
      <comment>
        The original text of the requirement is:
      "If a CCMSM enters state CANIF_CS_INIT, then the CanIf shall clear all
      temporarily stored wakeup events corresponding to that state machine."
      But this requirement is derived from figure 12, which is erroneous
      and not up-to-data.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupEventClear_OnInit</srcid><srcstatus/><internalId>1621</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupEventClear_OnInit_1</srcid><srcstatus/><internalId>1622</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>115</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00480</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STOPPED, when the function CanIf_SetControllerMode(ControllerId,
        CANIF_CS_STOPPED) is called with parameter ControllerId referencing that CCMSM, then the CanIf 
        shall call Can_SetControllerMode(Controller, CAN_T_STOP)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>116</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00481</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STOPPED when the function CanIf_SetControllerMode(ControllerId,
        CANIF_CS_STARTED) is called with parameter ControllerId referencing that CCMSM, then the CanIf 
        shall call Can_SetControllerMode(Controller, CAN_T_START)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>117</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00482</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STOPPED when the function CanIf_SetControllerMode(ControllerId,
        CANIF_CS_SLEEP) is called with parameter ControllerId referencing that CCMSM, then the CAN 
        Interface module shall call Can_SetControllerMode(Controller, CAN_T_SLEEP)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>118</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00486</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_SLEEP when the function CanIf_SetControllerMode(ControllerId, 
        CANIF_CS_SLEEP) is called with parameter ControllerId referencing that CCMSM, then the CanIf 
        shall call Can_SetControllerMode(Controller, CAN_T_SLEEP)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>119</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00487</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        If a CCMSM is in state CANIF_CS_SLEEP when the function CanIf_SetControllerMode(ControllerId, 
        CANIF_CS_STOPPED) is called with parameter ControllerId referencing that CCMSM, then the CanIf 
        shall call Can_SetControllerMode(Controller, CAN_T_WAKEUP)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.CANIF487</srcid><srcstatus/><internalId>121</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>120</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.CANIF487</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If CanIfCanDriverCompatibility is set to ASR402, ASR 4.0.3 or ASR 4.2.2 and a CCMSM is in state CANIF_CS_SLEEP when the function
        CanIf_SetControllerMode(ControllerId, CANIF_CS_STOPPED) is called with
        parameter ControllerId referencing that CCMSM, then the CanIf shall call
        Can_SetControllerMode(Controller, CAN_T_WAKEUP).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4871</srcid><srcstatus/><internalId>1169</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_40185</srcid><srcstatus/><internalId>1695</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MulticoreDriverWakeup</srcid><srcstatus/><internalId>1696</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00487</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>120</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>121</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00488</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM equals CANIF_CS_STARTED when function CanIf_ControllerBusOff (ControllerId) is 
        called with parameter ControllerId referencing that CCMSM, then the CCMSM shall be changed to 
        CANIF_CS_STOPPED
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30217</srcid><srcstatus/><internalId>1762</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>122</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00520</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name:       CanIf_CancelTransmit
        Syntax:             Std_ReturnType    CanIf_CancelTransmit(
        PduIdType   CanTxPduId
        Service ID[hex]:    0x18
        Sync/Async:         Synchronous
        Reentrancy:         Non Reentrant
        CanTxPduId     L-PDU handle of CAN L-PDU to be transmitted.
        Parameters (in):                   This handle specifies the corresponding CAN L-PDU ID and
        implicitly the CAN Driver instance as well as the corresponding
        CAN controller device.
        Parameters          None
        inout)
        Parameters (out):   None
        Return value:       Std_ReturnTypeAlways return E_OK
        Description:        This is a dummy method introduced for interface compatibility.
        Note: The service CanIf_CancelTransmit() has no functionality and is called by
        the AUTOSAR PduR to achieve bus agnostic behavior.
      </description>
      <comment>
        In case of a development error (compare CanIf.ASR40.SWS_CanIf_00652 and CanIf.ASR40.SWS_CanIf_00661) the value
      is returned to the caller to be consistent with the handling of the
      development error checks in the other CanIf functions.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CancelTransmit</srcid><srcstatus/><internalId>1730</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>123</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00521</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The service CanIf_CancelTransmit() shall be pre-compile time configurable On/Off by the 
        configuration parameter CANIF_PUBLIC_CANCEL_TRANSMIT_SUPPORT. It shall be configured ON if 
        PduRComCancelTransmitSupport is configured as ON.
      </description>
      <comment>
        Instead of a possible PduR parameter, the CanIf parameter
      CanIfPublicCancelTransmitSupport is used to define if the API is
      provided.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>124</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00541</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The service CanIf_GetControllerMode shall return the mode of the requested CAN controller. This 
        mode is the mode which is buffered within the CAN Interface module 
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_E_NOT_SLEEP_DET</srcid><srcstatus/><internalId>1432</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_DetWuCtrlNotSleep</srcid><srcstatus/><internalId>1610</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30217</srcid><srcstatus/><internalId>1762</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>125</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00584</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STARTED when the function CanIf_SetControllerMode(ControllerId,
        CANIF_CS_STARTED) is called with parameter ControllerId referencing that CCMSM, then the CanIf 
        shall call Can_SetControllerMode(Controller, CAN_T_START)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>126</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00585</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STARTED when the function CanIf_SetControllerMode(ControllerId,
        CANIF_CS_STOPPED) is called with parameter ControllerId referencing that CCMSM, then the CanIf 
        shall call Can_SetControllerMode(Controller, CAN_T_STOP)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>127</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00643</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The generic type definitions of the CanIf which are described in chapter 8.2
      shall be performed in the header file CanIf_Types.h. This file has to be
      included in the header file CanIf.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00643_1</srcid><srcstatus/><internalId>129</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00643_2</srcid><srcstatus/><internalId>130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>128</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00643_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The generic type definitions of the CanIf which are described in chapter 8.2
      shall be defined if including the header file CanIf.h.
      It is of no relevance if the types are defined directly in CanIf.h or in
      other header files included by CanIf.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00643</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>129</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00643_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        This file (CanIf_Types.h) has to be included in the header file CanIf.h.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00643</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>128</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>130</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00652</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter CanTxPduId of CanIf_CancelTransmit() has an invalid value, the CanIf shall report 
        development error code CANIF_E_INVALID_TXPDUID to the Det_ReportError service of the DET, when 
        CanIf_CancelTransmit() is called.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CancelTransmitInvPduId</srcid><srcstatus/><internalId>1465</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_INVALID_TXPDUID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>131</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00658</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter VersionInfo of CanIf_GetVersionInfo() has an invalid value, the CanIf shall report 
        development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the DET module, 
        when CanIf_GetVersionInfo() is called.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30856</srcid><srcstatus/><internalId>1474</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>132</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled, all CanIf API services other than 
        CanIf_Init() and CanIf_GetVersion() shall:
        not execute their normal operation
        report to the DET (using CANIF_E_UNINIT)
        and return E_NOT_OK
        unless the CanIf has been initialized with a preceding call of CanIf_Init(
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ChangeBaudrate</srcid><srcstatus/><internalId>134</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckBaudrate</srcid><srcstatus/><internalId>135</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetControllerMode</srcid><srcstatus/><internalId>136</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerMode</srcid><srcstatus/><internalId>137</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_Transmit</srcid><srcstatus/><internalId>138</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_CancelTransmit</srcid><srcstatus/><internalId>139</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadRxPduData</srcid><srcstatus/><internalId>140</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadTxNotifStatus</srcid><srcstatus/><internalId>141</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadRxNotifStatus</srcid><srcstatus/><internalId>142</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetPduMode</srcid><srcstatus/><internalId>143</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetPduMode</srcid><srcstatus/><internalId>144</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetDynamicTxId</srcid><srcstatus/><internalId>145</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetTrcvMode</srcid><srcstatus/><internalId>146</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTrcvMode</srcid><srcstatus/><internalId>147</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTrcvWakeupReason</srcid><srcstatus/><internalId>148</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetTrcvWakeupMode</srcid><srcstatus/><internalId>149</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckWakeup</srcid><srcstatus/><internalId>150</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckValidation</srcid><srcstatus/><internalId>151</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTxConfirmationState</srcid><srcstatus/><internalId>152</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ClearTrcvWufFlag</srcid><srcstatus/><internalId>153</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckTrcvWakeFlag</srcid><srcstatus/><internalId>154</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_TxConfirmation</srcid><srcstatus/><internalId>155</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_RxIndication</srcid><srcstatus/><internalId>156</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_CancelTxConfirmation</srcid><srcstatus/><internalId>157</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ControllerBusOff</srcid><srcstatus/><internalId>158</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ConfirmPnAvailability</srcid><srcstatus/><internalId>159</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ClearTrcvWufFlagIndication</srcid><srcstatus/><internalId>160</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckTrcvWakeFlagIndication</srcid><srcstatus/><internalId>161</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_ControllerModeIndication</srcid><srcstatus/><internalId>162</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_TrcvModeIndication</srcid><srcstatus/><internalId>163</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetBaudrate</srcid><srcstatus/><internalId>164</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_EnableBusMirroring</srcid><srcstatus/><internalId>165</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerErrorState</srcid><srcstatus/><internalId>166</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerTxErrorCounter</srcid><srcstatus/><internalId>167</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.SWS_CANIF_91009.CanIf_ErrorNotification</srcid><srcstatus/><internalId>1030</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.SWS_CANIF_91008.CanIf_ControllerErrorStatePassive</srcid><srcstatus/><internalId>1031</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_UNINIT</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>53</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>625</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swurs.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>133</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ChangeBaudrate</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
    (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ChangeBaudrate(),
    then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       <providescoverage>
          <provcov>
             <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>134</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckBaudrate</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
    (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_CheckBaudrate(),
    then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       <providescoverage>
          <provcov>
             <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
             <dstversion>1</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>135</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetControllerMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
        (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_SetControllerMode(),
        then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30844</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>136</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_GetControllerMode(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30844</srcid><srcstatus/><internalId>1438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>137</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_Transmit</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_Transmit(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30843</srcid><srcstatus/><internalId>1445</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>138</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_CancelTransmit</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_CancelTransmit(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30843</srcid><srcstatus/><internalId>1445</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>139</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadRxPduData</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ReadRxPduData(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30842</srcid><srcstatus/><internalId>1446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>140</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadTxNotifStatus</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ReadTxNotifStatus(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30842</srcid><srcstatus/><internalId>1446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>141</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadRxNotifStatus</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ReadRxNotifStatus(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30842</srcid><srcstatus/><internalId>1446</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>142</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetPduMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_SetPduMode(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30841</srcid><srcstatus/><internalId>1447</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>143</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetPduMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_GetPduMode(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30841</srcid><srcstatus/><internalId>1447</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>144</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetDynamicTxId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_SetDynamicTxId(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30840</srcid><srcstatus/><internalId>1448</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>145</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetTrcvMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_SetTrcvMode(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30839</srcid><srcstatus/><internalId>1449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>146</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTrcvMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_GetTrcvMode(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30839</srcid><srcstatus/><internalId>1449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>147</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTrcvWakeupReason</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_GetTrcvWakeupReason(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30839</srcid><srcstatus/><internalId>1449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>148</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetTrcvWakeupMode</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_SetTrcvWakeupMode(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30839</srcid><srcstatus/><internalId>1449</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>149</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckWakeup</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_CheckWakeup(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30838</srcid><srcstatus/><internalId>1450</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>150</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckValidation</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_CheckValidation(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30838</srcid><srcstatus/><internalId>1450</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>151</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTxConfirmationState</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_GetTxConfirmationState(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetTxConfStateDetUninit</srcid><srcstatus/><internalId>1452</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>152</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ClearTrcvWufFlag</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ClearTrcvWufFlag(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ClearTrcvWufFlag_NOINIT</srcid><srcstatus/><internalId>1439</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>153</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckTrcvWakeFlag</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_CheckTrcvWakeFlag(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlag_NOINIT</srcid><srcstatus/><internalId>1440</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>154</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_TxConfirmation</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_TxConfirmation(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>155</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_RxIndication</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_RxIndication(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>156</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_CancelTxConfirmation</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_CancelTxConfirmation(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>157</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ControllerBusOff</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ControllerBusOff(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>158</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ConfirmPnAvailability</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ConfirmPnAvailability(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIf_ConfirmPnAvailability_NOINIT</srcid><srcstatus/><internalId>1443</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>159</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ClearTrcvWufFlagIndication</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ClearTrcvWufFlagIndication(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ClearTrcvWufFlagIndication_NOINIT</srcid><srcstatus/><internalId>1441</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>160</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckTrcvWakeFlagIndication</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_CheckTrcvWakeFlagIndication(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlagIndication_NOINIT</srcid><srcstatus/><internalId>1442</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>161</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_ControllerModeIndication</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ControllerModeIndication(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>162</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_TrcvModeIndication</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_TrcvModeIndication(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>163</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetBaudrate</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_SetBaudrate(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIf_SetBaudrate_NOINIT</srcid><srcstatus/><internalId>1444</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>164</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_EnableBusMirroring</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_EnableBusMirroring(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_EnableBusMirroringDetUninit</srcid><srcstatus/><internalId>1453</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>165</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerErrorState</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_GetControllerErrorState(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetControllerErrorStateDetUninit</srcid><srcstatus/><internalId>1454</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>166</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerTxErrorCounter</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_GetControllerTxErrorCounter(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetControllerTxErrorCounterDetUninit</srcid><srcstatus/><internalId>1455</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>167</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00679</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        If the CCMSM  of the CAN controller, which shall be checked for a wake-up event via 
        CanIf_CheckWakeup(), is not in mode CANIF_CS_SLEEP, the CanIf shall report the development 
        error code CANIF_E_NOT_SLEEP to the Det_ReportError service of the DET module and 
        CanIf_CheckWakeup() shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.CANIF679_1</srcid><srcstatus/><internalId>169</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.CANIF679_2</srcid><srcstatus/><internalId>170</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>168</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.CANIF679_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If CanIfCanDriverCompatibility is set to ASR402 and the CCMSM (see chapter 7.19)
        of the CAN controller, which shall be checked for a wake-up event via CanIf_CheckWakeup(),
        is not in mode CANIF_CS_SLEEP, the CanIf shall report the development error code
        CANIF_E_NOT_SLEEP to the Det_ReportError service of the DET module and
        CanIf_CheckWakeup() shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DetWuCtrlNotSleep</srcid><srcstatus/><internalId>1610</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3127</srcid><srcstatus/><internalId>1137</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.CANIF_E_NOT_SLEEP</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00679</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>169</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.CANIF679_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If CanIfCanDriverCompatibility is set to ASR403 and the CCMSM (see chapter 7.19)
        of the CAN controller, which shall be checked for a wake-up event via CanIf_CheckWakeup(),
        is not in mode CANIF_CS_SLEEP, the CanIf shall report the development error code
        CANIF_E_NOT_SLEEP to the Det_ReportError service of the DET module and
        CanIf_CheckWakeup() shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_E_NOT_SLEEP_DET</srcid><srcstatus/><internalId>1432</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3128</srcid><srcstatus/><internalId>1138</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.CANIF_E_NOT_SLEEP</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>58</internalId></provcov>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00679</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>168</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>170</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00681.2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a wake-up event is not validated for the corresponding WakeupSource (see
      CanIf.ASR40.CANIF179), then a function call of CanIf_CheckValidation(WakeupSource)
      must not result in a call to the function &lt;User__ValidateWakeupEvent&gt;(sources).
      </description>
         <comment>
        This requirement replaces CanIf.ASR40.SWS_CanIf_00681.
        CanIf must not call EcuM with a non-validated wake-up event.
        Rationale: The call stops the EcuMValidationTimeout.
        Therefore the EcuM does not detect that no valid wakeup was detected.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31203</srcid><srcstatus/><internalId>1591</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NmWuValidWithPduRPdu</srcid><srcstatus/><internalId>1593</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RepeatedWuValid</srcid><srcstatus/><internalId>1616</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>171</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00688</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ControllerModeIndication&gt;
        The CanDrv must be initialized after Power ON.
        The call context is either on task level (polling mode)
        This callback service is in general re-entrant for multiple CAN controller usage, but not for 
        the same CAN controller.
      </description>
      <comment>
        This requirement is informational only.
        This is no requirement for the CanIf
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>172</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00703</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ControllerModeIndication(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00703_1</srcid><srcstatus/><internalId>174</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00703_2</srcid><srcstatus/><internalId>175</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>173</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00703_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The call context of CanIf_ControllerModeIndication() is either on interrupt level
      (interrupt mode) or on task level (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00703</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>174</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00703_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
      This is no requirement for the CanIf. It has to be performed by the application
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00703</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>173</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>175</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00704</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Configuration of CanIf_ControllerModeIndication(): ID of the CAN controller is published inside 
        the configuration description of the CanIf 
      </description>
      <comment>
        According to the SWS chapter 7.5 (compare CANIF653 and the text after
      CANIF655), the value passed in parameter Controller to CanIf_ControllerModeIndication() is
      the controller ID defined in the CAN driver.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SymbolicNameValues</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>176</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00709</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_TrcvModeIndication(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00709_1</srcid><srcstatus/><internalId>178</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00709_2</srcid><srcstatus/><internalId>179</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>177</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00709_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The call context of CanIf_TrcvModeIndication() is either on
      interrupt level (interrupt mode) or on task level (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00709</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>178</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00709_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
      This is no requirement for the CanIf. It has to be performed by the application.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00709</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>177</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>179</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00713</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STOPPED, when function CanIf_ControllerModeIndication(
        Controller, ControllerMode) is called with parameter Controller referencing that CCMSM and 
        ControllerMode equals CANIF_CS_STOPPED, then the CanIf shall take the CCMSM to sub state 
        CANIF_CS_STOPPED of state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_40185</srcid><srcstatus/><internalId>1695</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MulticoreDriverWakeup</srcid><srcstatus/><internalId>1696</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>180</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00714</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STOPPED, when function CanIf_ControllerModeIndication(
        Controller, ControllerMode) is called with parameter Controller referencing that CCMSM and 
        ControllerMode equals CANIF_CS_STARTED, then the CanIf shall take the CCMSM to sub state 
        CANIF_CS_STARTED of state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>181</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00715</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STOPPED, when function CanIf_ControllerModeIndication(
        Controller, ControllerMode) is called with parameter Controller referencing that CCMSM and 
        ControllerMode equals CANIF_CS_SLEEP, then the CanIf shall take the CCMSM to sub state 
        CANIF_CS_SLEEP of state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>182</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00716</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STARTED, when function CanIf_ControllerModeIndication(
        Controller, ControllerMode) is called with parameter Controller referencing that CCMSM and 
        ControllerMode equals CANIF_CS_STARTED, then the CanIf shall leave the CCMSM in sub state 
        CANIF_CS_STARTED of state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>183</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00717</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_STARTED, when function CanIf_ControllerModeIndication(
        Controller, ControllerMode) is called with parameter Controller referencing that CCMSM and 
        ControllerMode equals CANIF_CS_STOPPED, then the CanIf shall take the CCMSM to sub state 
        CANIF_CS_STOPPED of state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>184</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00718</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_SLEEP, when function CanIf_ControllerModeIndication(Controller,
        ControllerMode) is called with parameter Controller referencing that CCMSM and ControllerMode 
        equals CANIF_CS_SLEEP, then the CanIf shall leave the CCMSM in sub state CANIF_CS_SLEEP of 
        state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>185</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00719</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If a CCMSM is in state CANIF_CS_SLEEP, when function CanIf_ControllerModeIndication(Controller,
        ControllerMode) is called with parameter Controller referencing that CCMSM and ControllerMode 
        equals CANIF_CS_STOPPED, then the CanIf shall take the CCMSM to sub state CANIF_CS_STOPPED of 
        state CANIF_CS_INIT.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DelayedControllerModeIndications</srcid><srcstatus/><internalId>1717</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>186</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00723</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If an L-PDU is requested to be transmitted via a CAN controller, whose CCMSM  equals 
        CANIF_CS_STOPPED, the CanIf shall report the development error code CANIF_E_STOPPED to the 
        Det_ReportError service of the DET and CanIf_Transmit() shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CANIF_E_STOPPED</srcid><srcstatus/><internalId>1086</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>187</internalId></specobject>
    
    <specobject>
         <id>CanIf.EB.CANIF723</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
           If an L-PDU is requested to be transmitted via a CAN controller, whose CCMSM
           (see chapter 7.19) equals CANIF_CS_STOPPED, CanIf_Transmit() shall return E_NOT_OK.
         </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30320</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00317</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>188</internalId></specobject>
    
    <specobject>
         <id>CanIf.EB.SleepModeEStopped</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      If an L-PDU is requested to be transmitted via a CAN controller, whose CCMSM
      (see chapter 7.19) equals CANIF_CS_SLEEP, CanIf_Transmit() shall
      return E_NOT_OK.
      </description>
         <comment>
      This requirement was added analog to CanIf.EB.CANIF723 because if the controller
      is in sleep mode, it is "stopped" as well.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30364</srcid><srcstatus/><internalId>1729</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00317</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>189</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00725</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The standardized common published parameters as required by BSW00402 in the General 
        Requirements on Basic Software Modules [3] shall be published within the header file of this 
        module and need to be provided in the BSW Module Description. The according module abbreviation 
        can be found in the List of Basic Software Modules [1]
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_VersionCheck</srcid><srcstatus/><internalId>1744</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00726</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>191</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00727</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>192</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00728</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>193</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>190</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00726</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall provide a readable module vendor identification in its published parameters . 
        The naming convention of this module vendor identification for CanIf is CANIF_VENDOR_ID. This 
        parameter shall be represented in uint16 (16 bit)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00725</srcid><srcstatus/><internalId>190</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>191</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00727</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall provide a module identifier in its published parameters . The naming convention 
        of this module identifier for CanIf is CANIF_MODULE_ID. This parameter shall be represented in 
        uint16 (16 bit) and it shall be set to the value of CanIf from Basic Software Module list 
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00725</srcid><srcstatus/><internalId>190</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>192</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00728</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The CanIf shall provide the following version numbers with the following naming convention  in 
        its published parameters 
        CANIF_SW_MAJOR_VERSION
        CANIF_SW_MINOR_VERSION
        CANIF_SW_PATCH_VERSION
        CANIF_AR_RELEASE_MAJOR_VERSION
        CANIF_AR_RELEASE_MINOR_VERSION
        CANIF_AR_RELEASE_REVISION_VERSION
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00725</srcid><srcstatus/><internalId>190</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>193</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00729</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The numbering of CANIF_SW_MAJOR_VERSION, CANIF_SW_NINOR_VERSION and CANIF_SW_PATCH_VERSION from 
        CANIF728 shall be vendor specific, but it shall follow requirement BSW00321 from General 
        Requirements on Basic Software Modules [3]
      </description>
      <comment>
        This requirement is not applicable.
        We use the EB versioning scheme instead. Which is, in fact,
        quite similar to BSW00321
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>194</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00737</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_GetTxConfirmationState(
        The call context is on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <comment>
        This requirement is informational only.
        This is no requirement for the CanIf (to be handled by application)
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>195</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00793</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ClearTrcvWufFlagIndication&gt;
        The CanTrcvDrv must be initialized after Power ON.
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        This callback service is in general re-entrant for multiple CAN transceiver usage, but not for 
        the same CAN transceiver.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00793_1</srcid><srcstatus/><internalId>197</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>196</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00793_1</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ClearTrcvWufFlagIndication&gt;():
      -The CanTrcvDrv must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00793</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>196</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>197</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00793_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ClearTrcvWufFlagIndication&gt;():
      -The call context is either on interrupt level (interrupt mode) or on task level (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>198</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00793_3</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ClearTrcvWufFlagIndication&gt;():
        -This callback service is in general re-entrant for multiple CAN transceiver usage, but not for the same CAN transceiver.
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>199</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00799</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_CheckTrcvWakeFlagIndication&gt;
        The CanTrcvDrv must be initialized after Power ON.
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        This callback service is in general re-entrant for multiple CAN transceiver usage, but not for 
        the same CAN transceiver.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00799_1</srcid><srcstatus/><internalId>201</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00799_2</srcid><srcstatus/><internalId>202</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00799_3</srcid><srcstatus/><internalId>203</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>200</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00799_1</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_CheckTrcvWakeFlagIndication&gt;():
      - The CanTrcvDrv must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00799</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>201</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00799_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_CheckTrcvWakeFlagIndication&gt;():
       - The call context is either on interrupt level (interrupt mode) or on task level (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00799</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>202</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00799_3</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_CheckTrcvWakeFlagIndication&gt;():
      - This callback service is in general re-entrant for multiple CAN transceiver usage, but not for the same CAN transceiver.?()
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00799</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>200</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>203</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00807</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ClearTrcvWufFlagIndication(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00807_1</srcid><srcstatus/><internalId>205</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00807_2</srcid><srcstatus/><internalId>206</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>204</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00807_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ClearTrcvWufFlagIndication():
      - The call context is either on interrupt level (interrupt mode) or on task level (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00807</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>205</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00807_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ClearTrcvWufFlagIndication():
      - The CanIf must be initialized after Power ON.
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00807</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>204</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>206</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00811</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_CheckTrcvWakeFlagIndication(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00811_1</srcid><srcstatus/><internalId>208</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00811_2</srcid><srcstatus/><internalId>209</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>207</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00811_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_CheckTrcvWakeFlagIndication():
      - The call context is either on interrupt level (interrupt mode) or on task level (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00811</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>208</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00811_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_CheckTrcvWakeFlagIndication():
      - The CanIf must be initialized after Power ON.?()
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00811</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>207</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>209</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00818</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ConfirmPnAvailability(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00818_1</srcid><srcstatus/><internalId>211</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00818_2</srcid><srcstatus/><internalId>212</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>210</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00818_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ConfirmPnAvailability(
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        The CanIf must be initialized after Power ON.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00818</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>211</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00818_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of CanIf_ConfirmPnAvailability():
      - The CanIf must be initialized after Power ON
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00818</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>210</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>212</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00822</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ConfirmPnAvailability&gt;
        The CanTrcvDrv must be initialized after Power ON.
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        This callback service is in general re-entrant for multiple CAN transceiver usage, but not for 
        the same CAN transceiver.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00822_1</srcid><srcstatus/><internalId>214</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00822_2</srcid><srcstatus/><internalId>215</internalId></linkedfrom><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00822_3</srcid><srcstatus/><internalId>216</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>213</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00822_1</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ConfirmPnAvailability&gt;
        The CanTrcvDrv must be initialized after Power ON.
        The call context is either on interrupt level (interrupt mode) or on task level (polling mode)
        This callback service is in general re-entrant for multiple CAN transceiver usage, but not for 
        the same CAN transceiver.
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00822</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>214</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00822_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ConfirmPnAvailability&gt;():
      - The call context is either on interrupt level (interrupt mode) or on task level (polling mode).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.InterruptContext</srcid><srcstatus/><internalId>1051</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00822</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>215</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00822_3</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_ConfirmPnAvailability&gt;():
      - This callback service is in general re-entrant for multiple CAN transceiver usage, but not for the same CAN transceiver.()
      </description>
         <comment>
        This requirement is informational only.
      </comment>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00822</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>213</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>216</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00828</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter PduInfoPtr of CanIf_CancelTxConfirmation() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the DET 
        module, when CanIf_CancelTxConfirmation() is called.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30262</srcid><srcstatus/><internalId>1492</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>217</internalId></specobject>

    <specobject>
      <id>CanIf.ASR40.ECUC_CanIf_00819</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Name CanIfDispatchUserConfirmPnAvailabilityName
        CANIF_DISPATCH_USERCONFIRMPNAVAILABILITY_NAME} Description This
        parameter defines the name of &lt;User_ConfirmPnAvailability&gt;. If
        CANIF_DISPATCH_USERCONFIRMPNAVAILABILITY_UL equals CAN_SM  the name of
        User_ConfirmPnAvailability&gt; is fixed. If it equals CDD, the name  is
        selectable. If CANIF_PUBLIC_PN_SUPPORT equals False, this parameter
        shall not be configurable. Multiplicity 1 Type EcucFunctionNameDef
        Default value -maxLength -minLength -regularExpression
        ConfigurationClass Pre-compile time X VARIANT-PRE-COMPILE  Link time X
        VARIANT-LINK-TIME, VARIANT POST-BUILD  Post-build time -Scope 
        Dependency dependency: CANIF_DISPATCH_USERCONFIRMPNAVAILABILITY_UL,
        CANIF_PUBLIC_PN_SUPPORT}
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00819</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>796</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>218</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00699</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name: CanIf_ControllerModeIndication
        Syntax: void CanIf_ControllerModeIndication
        (uint8 ControllerId, CanIf_ControllerModeType ControllerMode)
        Service ID[hex]: 0x17
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in):
        ControllerId CAN controller, which state has been transitioned.
        ControllerMode Mode to which the CAN controller transitioned
        Parameters (inout): None
        Parameters (out): None
        Return value: None
        Description: This service indicates a controller state transition
        referring to the corresponding CAN controller.
      </description>
      <comment>
        Changed 'Reentrancy' from
        'Reentrant' to 'Reentrant for different controllers'
        Reason:
        This simplification reduces the need for critical sections.
        It is very reasonable simplification, since controller mode changes are performed only
        sequentially.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>219</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00416</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter Hrh of CanIf_RxIndication() has an invalid value, the CanIf
      shall report development error code CANIF_E_PARAM_HRH to the
      Det_ReportError service of the DET module, when CanIf_RxIndication() is
      called.(BSW00323)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30258</srcid><srcstatus/><internalId>1488</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Det_E_PARAM_HRH</srcid><srcstatus/><internalId>1753</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanIf.ASR40.CANIF_E_PARAM_HRH</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>43</internalId></provcov>
        <provcov>
           <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
     </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>220</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name: CanIf_RxIndication
      Syntax: void CanIf_RxIndication
        (Can_HwHandleType Hrh, Can_IdType CanId, uint8 CanDlc, const uint8* CanSduPtr)
      Service ID[hex]: 0x14
      Sync/Async: Synchronous
      Reentrancy: Reentrant
      Parameters (in):
        Hrh     ID of the corresponding Hardware Object Range: 0..(total number of HRH -1)
        CanId   Standard/Extended CAN ID of CAN L-PDU that has been successfully received
        CanDlc  Data Length Code (length of CAN L-PDU payload)
        CanSduPtr Pointer to received L-SDU (payload)
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service indicates a successful reception
        of a received CAN Rx L-PDU to the CanIf after passing all filters and
        validation checks.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ReceiveDuplicateId</srcid><srcstatus/><internalId>1423</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Receive300Hrhs</srcid><srcstatus/><internalId>1543</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31186</srcid><srcstatus/><internalId>1585</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30335</srcid><srcstatus/><internalId>1760</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>221</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00168</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If the DLC check rejects a received L-PDU (see CanIf.ASR40.CANIF026),
        the CanIf shall report development error code CANIF_E_INVALID_DLC to the
        Det_ReportError() service of the DET module.
      </description>
      <comment>
        If the DLC-check is enabled and ... (see description) ... .
        Perform this error reporting only If CanIfDevErrorDetect is enabled.
      </comment>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30846</srcid><srcstatus/><internalId>1497</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_InvalidDLC</srcid><srcstatus/><internalId>1498</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.CANIF_E_INVALID_DLC</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>56</internalId></provcov>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>222</internalId></specobject>
    
    <specobject>
         <id>CanIf.ASR40.DlcCheck.NoRxIndication</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      If DLC check fails, the LPdu is discarded and no further processed.
       - No &lt;UL&gt;_RxIndication() is called
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30846</srcid><srcstatus/><internalId>1497</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30334</srcid><srcstatus/><internalId>1759</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>223</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.DlcCheck.NoRxBuffer</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      If DLC check fails, the LPdu is discarded and no further processed.
       - L-PDU payload is not saved in internal memory (CanIfRxPduReadData is true)
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30846</srcid><srcstatus/><internalId>1497</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>224</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00288</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>2</version>
      <description>
        Service name: CanIf_GetTrcvMode
      Syntax: Std_ReturnType CanIf_GetTrcvMode
        (CanTrcv_TrcvModeType* TransceiverModePtr, uint8 TransceiverId)
      Service ID[hex]: 0x0e
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
        TransceiverId Abstracted CanIf TransceiverId, which is assigned to a CAN
           transceiver, which is requested for current operation mode.
      Parameters (inout): None
      Parameters (out):
        TransceiverModePtr Requested mode of requested network the Transceiver
          is connected to.
      Return value: Std_ReturnType
        E_OK: Transceiver mode request has been accepted.
        E_NOT_OK: Transceiver mode request has not been accepted.
      Description: This function invokes CanTrcv_GetOpMode and updates the
        parameter TransceiverModePtr with the value OpMode provided by CanTrcv.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.GetTrcvModeSignature</srcid><srcstatus/><internalId>1091</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</srcid><srcstatus/><internalId>226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>225</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name: CanIf_GetTrcvMode
      Syntax: Std_ReturnType CanIf_GetTrcvMode
        (CanTrcv_TrcvModeType* TransceiverModePtr, uint8 TransceiverId)
      Service ID[hex]: 0x0e
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
        TransceiverId Abstracted CanIf TransceiverId, which is assigned to a CAN
           transceiver, which is requested for current operation mode.
      Parameters (inout): None
      Parameters (out):
        TransceiverModePtr Requested mode of requested network the Transceiver
          is connected to.
      Return value: Std_ReturnType
        E_OK: Transceiver mode request has been accepted.
        E_NOT_OK: Transceiver mode request has not been accepted.
      Description: This function invokes CanTrcv_GetOpMode and updates the
        parameter TransceiverModePtr with the value OpMode provided by CanTrcv.
      </description>
        <comment>
          When Mirroring is disabled the API is exposed as stated in the AR4.0.3 SWS.
        </comment>
        <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30428_MultiIds</srcid><srcstatus/><internalId>1355</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30428_1Trcv</srcid><srcstatus/><internalId>1372</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30428</srcid><srcstatus/><internalId>1380</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30839</srcid><srcstatus/><internalId>1449</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30851</srcid><srcstatus/><internalId>1479</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTrcvModeNullPtr</srcid><srcstatus/><internalId>1480</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
          <provcov>
            <linksto>CanIf.ASR40.SWS_CanIf_00288</linksto>
            <dstversion>2</dstversion>
          <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>226</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00417</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If parameter CanId of CanIf_RxIndication() has an invalid value, the CanIf
      shall report development error code CANIF_E_PARAM_CANID to the
      Det_ReportError service of the DET module, when CanIf_RxIndication() is
      called.(BSW00323)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30259</srcid><srcstatus/><internalId>1489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.CANIF_E_PARAM_CANID</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>227</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00131</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        The consistency of the configuration must be checked by the configuration tool
      at configuration time. Configuration rules and constraints for
      plausibility checks shall be performed during configuration time, where
      possible.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.ConfigurationConsistency</srcid><srcstatus/><internalId>1050</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>228</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.TxCancelCheck</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        At configuration time it must be prevented, that transmit cancellation can be enabled,
        whenever transmit L-PDU buffer configuration is disabled, as specified in field
        "Dependency" of configuration parameter CANIF_TX_CANCELLATION (see CANIF640_Conf).
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_111</srcid><srcstatus/><internalId>1251</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>229</internalId></specobject>
    
    <specobject>
         <id>CanIf.ASR40.SoftwareFilter.RejectPdu</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      Not all L-PDUs, which may pass the hardware acceptance filter and
      therefore are successful received in BasicCAN hardware objects, are
      defined as receive L-PDUs and thus needed from the corresponding ECU.
      The CanIf optionally filters out these L-PDUs and prohibits further
      software processing.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31099</srcid><srcstatus/><internalId>1383</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_HRH_NOT_USED</srcid><srcstatus/><internalId>1515</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_SW_FILTERING_SUPPORTED_HRH_NOT_USED</srcid><srcstatus/><internalId>1563</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30333</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>230</internalId></specobject>
      
      <specobject>
         <id>CanIf.ASR40.ControllerModeType</id>
         <status>approved</status>
         <source>AUTOSAR</source>
         <version>1</version>
         <description>
      CanIf_ControllerModeType
      Type: Enumeration
      Range:
      - CANIF_CS_UNINIT = 0
        UNINIT mode. Default mode of the CAN Driver and all CAN controllers
        connected to one CAN network after power on.
      - CANIF_CS_SLEEP
        SLEEP mode. At least one of all CAN controllers connected to one CAN
        network are set into the SLEEP mode and can be woken up by request of the
        CAN Driver or by a network event (must be supported by CAN hardware)
      - CANIF_CS_STARTED
        STARTED mode. All CAN controllers connected to one CAN network are
        started by the CAN Driver and in full-operational mode.
      - CANIF_CS_STOPPED
        STOPPED mode. At least one of all CAN controllers connected to one CAN
        network is halted and does not operate on the network.
      Description: Operating modes of the CAN network and CAN Driver.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CONTROLLERMODETYPE</srcid><srcstatus/><internalId>1425</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>231</internalId></specobject>
      
      <specobject>
         <id>CanIf.ASR40.ECUC_CanIf_00590</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
      Name CanIfTxPduCanIdType {CANIF_TXPDU_CANIDTYPE} Description Type of CAN
      Identifier of the transmit CAN L-PDU used by the CAN Driver  module for
      CAN L-PDU transmission. Multiplicity 1 Type EcucEnumerationParamDef Range
      EXTENDED_CAN The CANID is of type Extended (29  bits)  STANDARD_CAN The
      CANID is of type Standard (11  bits) ConfigurationClass Pre-compile time
      X VARIANT-PRE-COMPILE  Link time X VARIANT-LINK-TIME  Post-build time X
      VARIANT-POST-BUILD Scope / Dependency scope: Network
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CANFD_BIT_EXTENDED_ADDR</srcid><srcstatus/><internalId>1428</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CANFD_BIT_STANDARD_ADDR</srcid><srcstatus/><internalId>1546</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31229</srcid><srcstatus/><internalId>1774</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31230</srcid><srcstatus/><internalId>1775</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31233</srcid><srcstatus/><internalId>1776</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.ECUC_CanIf_00590</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>348</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>232</internalId></specobject>
      
      <specobject>
         <id>CanIf.EB.CANIF680</id>
         <status>approved</status>
         <source>EB</source>
         <version>2</version>
         <description>
      If CanIfValidateWakeupOnStartedCtrlOnly is set to OFF and CanIf_RxIndication() is called for a CAN
      controller, which CCMSM equals CANIF_CS_STARTED or CANIF_CS_STOPPED and a wake up event is
      stored for that CAN controller (This includes that CANIF_PUBLIC_WAKEUP_CHECK_VALIDATION_SUPPORT
      is enabled.), this wake up validation event shall be stored within CanIf for that CAN controller.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NmWuValidWithCanNmPdu</srcid><srcstatus/><internalId>1592</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30338</srcid><srcstatus/><internalId>1611</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_WuValidInStopMode</srcid><srcstatus/><internalId>1615</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_WuValidWithoutWu</srcid><srcstatus/><internalId>1617</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00286</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>233</internalId></specobject>
      
      <specobject>
         <id>CanIf.ASR40.SleepToStart</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>1</version>
         <description>
       As per CAN411 and CAN Controller State Diagram (see [8] Specification of AN Driver) a direct
       transition from mode CAN_T_SLEEP to CAN_T_START is not allowed.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30847</srcid><srcstatus/><internalId>1608</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>234</internalId></specobject>
      
      <specobject>
         <id>CanIf.ASR40.WakeupValidationPduMode</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>2</version>
         <description>
        CanIf shall continue normal operation if CCMSM has been transitioned to CANIF_CS_STARTED
        and the PDU channel mode has been set to CANIF_ONLINE, after wakeup.
        If wakeup validation is required, the PDU channel mode shall not be set to
        CANIF_ONLINE.
      </description>
         <comment>
        Adapted from "Attention:" in page 72 of the SWS.
      </comment>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30802</srcid><srcstatus/><internalId>1613</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>235</internalId></specobject>
      
      <specobject>
         <id>CanIf.ASR40.SWS_CanIf_00011</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
         <version>2</version>
         <description>
      Service name: &lt;User_TxConfirmation&gt;
      Syntax: void &lt;User_TxConfirmation&gt;(PduIdType TxPduId)
      Sync/Async: Synchronous
      Reentrancy: Reentrant for different PduIds. Non reentrant for the same PduId.
      Parameters (in):
         TxPduId ID of the I-PDU that has been transmitted.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: The lower layer communication module confirms the
        transmission of an I-PDU.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.User_TxConfirmation.Signature.Result.OFF</srcid><srcstatus/><internalId>959</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>236</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.SWS_CanIf_00011_1</id>
         <status>approved</status>
         <source>AUTOSAR_TPS_ECUConfiguration.pdf, V3.2.0</source>
         <version>1</version>
         <description>
      When calling CanNm_TxConfirmation(), the TxPduId passed shall be read from configuration
      parameter CanNmTxConfirmationPduId if the related CanIfTxPduRef and CanNmTxPduRef reference the
      same EcuC Pdu-container.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>237</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.SWS_CanIf_00011_2</id>
         <status>approved</status>
         <source>AUTOSAR_TPS_ECUConfiguration.pdf, V3.2.0</source>
         <version>1</version>
         <description>
      When calling CanTp_TxConfirmation(), the TxPduId passed shall be read from configuration
      parameter CanTpTxNPduConfirmationPduId if the related CanIfPduRef and CanTpTxNPduRef reference the
      same EcuC Pdu-container.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>238</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.SWS_CanIf_00011_3</id>
         <status>approved</status>
         <source>AUTOSAR_TPS_ECUConfiguration.pdf, V3.2.0</source>
         <version>1</version>
         <description>
      When calling CanTp_TxConfirmation(), the TxPduId passed shall be read from configuration
      parameter CanTpTxFcNPduConfirmationPduId if the related CanIfPduRef and CanTpTxFcNPduRef reference the
      same EcuC Pdu-container.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>239</internalId></specobject>

      <specobject>
         <id>CanIf.ASR40.SWS_CanIf_00011_4</id>
         <status>approved</status>
         <source>AUTOSAR_TPS_ECUConfiguration.pdf, V3.2.0</source>
         <version>1</version>
         <description>
      When calling PduR_CanIfTxConfirmation(), the TxPduId passed shall be read from configuration
      parameter PduRDestPduHandleId if the related CanIfPduRef and PduRDestPduRef reference the
      same EcuC Pdu-container.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>240</internalId></specobject>
      
      <specobject>
         <id>CanIf.ASR40.SWS_CanIf_00739</id>
         <status>approved</status>
         <source>AUTOSAR_TPS_ECUConfiguration.pdf, V3.2.0</source>
         <version>1</version>
         <description>
      If CANIF_PUBLIC_TXCONFIRM_POLLING_SUPPORT (see CanIf.ASR40.CANIF733_Conf)
      is enabled, the CanIf shall clear the information about a TxConfirmation
      (see CanIf.ASR40.CANIF740), when callback CanIf_ControllerBusOff(ControllerId)
      is called.
      </description>
         <releases>
            <release>AUTOSAR 4.0.3</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetTxConfStateBusOff</srcid><srcstatus/><internalId>1766</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>241</internalId></specobject>
      
      <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00189</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name: CanIf_SetDynamicTxId
      Syntax: void CanIf_SetDynamicTxId(PduIdType CanTxPduId, Can_IdType CanId)
      Service ID[hex]: 0x0c
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
        CanTxPduId L-PDU
          handle of CAN L-PDU for transmission. This ID specifies the
          corresponding CAN L-PDU ID and implicitly the CAN
          Driver instance as well as the corresponding CAN controller device.
        CanId Standard/Extended CAN ID of CAN L-PDU that shall be transmitted.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service reconfigures the corresponding CAN identifier
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30840</srcid><srcstatus/><internalId>1448</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30210</srcid><srcstatus/><internalId>1742</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>242</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00202</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name: CanIf_ReadTxNotifStatus
      Syntax: CanIf_NotifStatusType CanIf_ReadTxNotifStatus(  PduIdType CanTxPduId  )
      Service ID[hex]: 0x07
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
        CanTxPduId L-PDU handle of CAN L-PDU to be transmitted.  This handle specifies the
              corresponding CAN L-PDU ID and implicitly the CAN
              Driver instance as well as the corresponding CAN controller device.
      Parameters (inout): None
      Parameters (out): None
      Return value: CanIf_NotifStatusType
               Current confirmation status of the corresponding CAN Tx L  PDU.
      Description: This service returns the confirmation status
           (confirmation occured of not) of a  specific static or dynamic CAN Tx
           L-PDU, requested by the CanTxPduId. (BSW01130)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30842</srcid><srcstatus/><internalId>1446</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30205</srcid><srcstatus/><internalId>1732</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>243</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00230</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name: CanIf_ReadRxNotifStatus
      Syntax: CanIf_NotifStatusType CanIf_ReadRxNotifStatus(PduIdType CanRxPduId)
      Service ID[hex]: 0x08
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
        CanRxPduId L-PDU handle of CAN L-PDU to be received. This handle specifies the
           corresponding CAN L-PDU ID and implicitly the CAN
           Driver instance as well as the corresponding CAN controller device.
      Parameters (inout): None
      Parameters (out): None
      Return value: CanIf_NotifStatusType
        Current indication status of the corresponding CAN Rx L PDU.
      Description: This service returns the indication status (indication
        occurred or not) of a specific CAN Rx L-PDU, requested by the CanRxPduId.
     (BSW01130, BSW01131)
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30842</srcid><srcstatus/><internalId>1446</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_SW_FILTERING_SUPPORTED_READRXNOTIFYSTATUS</srcid><srcstatus/><internalId>1561</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30206</srcid><srcstatus/><internalId>1733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>485</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>244</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00764</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        Service name: CanIf_TrcvModeIndication
      Syntax: void CanIf_TrcvModeIndication
        (uint8 TransceiverId, CanTrcv_TrcvModeType TransceiverMode)
      ServiceID[hex]: 0x18
      Sync/Async: Synchronous
      Reentrancy: Reentrant
      Parameters (in):
        TransceiverId CAN transceiver, which state has been transitioned.
        TransceiverMode Mode to which the CAN transceiver transitioned
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service indicates a transceiver state
        transition referring to the corresponding CAN transceiver.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndication_InvTrcv</srcid><srcstatus/><internalId>1478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00764</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>676</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>245</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00678</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If all calls of Can_CheckWakeup() or CanTrcv_CheckWakeup() return (CAN_NOT_OK /
        E_NOT_OK) to the CanIf, then CanIf_CheckWakeup() shall return
        E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_E_NOT_SLEEP_DET</srcid><srcstatus/><internalId>1432</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CheckWakeUp</srcid><srcstatus/><internalId>1606</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CheckWakeUpOnStartedCtrl</srcid><srcstatus/><internalId>1627</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00678</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>635</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>246</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00720</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
        If at least one function call of Can_CheckWakeup() or CanTrcv_CheckWakeup()
        returns (CAN_OK / E_OK) to the CanIf, then CanIf_CheckWakeup() shall
        return E_OK.
      </description>
      <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30339</srcid><srcstatus/><internalId>1604</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30831</srcid><srcstatus/><internalId>1605</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupEvent</srcid><srcstatus/><internalId>1620</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MulticoreTrcvWakeup</srcid><srcstatus/><internalId>1697</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00720</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>658</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>247</internalId></specobject>
    
    <specobject>
      <id>CanIf.ASR40.SWS_CanIf_00687</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
      <version>1</version>
      <description>
      Service name: &lt;User_ControllerModeIndication&gt;
      Syntax: void &lt;User_ControllerModeIndication&gt;
        (uint8 ControllerId, CanIf_ControllerModeType ControllerMode)
      Sync/Async: Synchronous
      Reentrancy: Non Reentrant
      Parameters (in):
        ControllerId Abstracted CanIf ControllerId which is assigned to a CAN controller,
          at which a controller state transition occurred.
        ControllerMode Notified CAN controller mode
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service indicates a CAN controller
        state transition to the corresponding upper layer module (mainly the CAN
        State Manager module).
      </description>
         <releases>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserControllerModeIndication</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>248</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00021</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall perform Inter Module Checks to avoid integration of incompatible
    files. The imported included files shall be checked by preprocessing
    directives. (BSW004)
    The following version numbers shall be verified (see CanIf.ASR40.CANIF728) :
    - &lt;MODULENAME&gt;_AR_RELEASE_MAJOR_VERSION
    - &lt;MODULENAME&gt;_AR_RELEASE_MINOR_VERSION
    Where &lt;MODULENAME&gt; is the module short name of the other (external) modules
    which provide header files included by the CanIf.
    If the values are not identical to the expected values, an error shall be reported.
    </description>
       <comment>
    According to Autosar SRS BSW General BSW004 intramodule checks are not explicitly
    required and intermodule checks shall be performed by the configuration tool.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ConsChck</srcid><srcstatus/><internalId>1073</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>249</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00565</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Each variable that shall be accessible by AUTOSAR Debugging, shall be defined
    as global variable.
    </description>
       <comment>
    Our implementation does not support the debugging mechanisms as described
    in the SWS specification
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.DebugAndTrace</srcid><srcstatus/><internalId>1075</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>250</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00566</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    All type definitions of variables which shall be debugged, shall be accessible
    by the header file CanIf.h.
    </description>
       <comment>
    Our implementation does not support the debugging mechanisms as described
    in the SWS specification
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.DebugAndTrace</srcid><srcstatus/><internalId>1075</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>251</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00567</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The declaration of variables in the header file shall be such that it is
    possible to calculate the size of the variables by C-"sizeof" operation.
    </description>
       <comment>
    Our implementation does not support the debugging mechanisms as described
    in the SWS specification
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.DebugAndTrace</srcid><srcstatus/><internalId>1075</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>252</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00568</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Variables available for debugging shall be described in the respective Basic
    Software Module Description.
    </description>
       <comment>
    Our implementation does not support the debugging mechanisms as described
    in the SWS specification
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.DebugAndTrace</srcid><srcstatus/><internalId>1075</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>253</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00301</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If a NULL pointer is passed in ConfigPtr to the service CanIf_Init(), the
    CanIf shall use the default configuration for the function CanIf_Init().
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.Init</srcid><srcstatus/><internalId>1076</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>254</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00775</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Service name: CanIf_CheckBaudrate
    Syntax: Std_ReturnType CanIf_CheckBaudrate(uint8 ControllerId, const uint16 Baudrate)
    Service ID[hex]: 0x1a
    Sync/Async: Synchronous
    Reentrancy: Reentrant
    Parameters (in):
      ControllerId CAN Controller to check for the support of a certain baudrate
      Baudrate Baudrate to check in kbp
    Parameters (inout): None
    Parameters (out): None
    Return value: Std_ReturnType
      E_OK: Baudrate supported by the CAN Controller
      E_NOT_OK: Baudrate not supported / invalid CAN controller
    Description: This service shall check, if a certain CAN
      controller supports a requested  baudrate.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>255</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00786</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The service CanIf_CheckBaudrate() shall call Can_CheckBaudrate(Controller,
    Baudrate) for the requested CAN controller.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>256</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00778</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If parameter ControllerId of CanIf_CheckBaudrate() has an invalid value, the
    CanIf shall report development error code CANIF_E_PARAM_CONTROLLERID to
    the Det_ReportError service of the DET module, when CanIf_CheckBaudrate()
    is called.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>257</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00779</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_CheckBaudrate():
    The call context is on task level (polling mode).
    The CanIf must be initialized after Power ON.()
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>258</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00780</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Configuration of CanIf_CheckBaudrate(): If CanIf supports changing of the
    baudrate and thus this service, shall be configurable via
    CANIF_PUBLIC_CHANGE_BAUDRATE_SUPPORT (see CANIF785_Conf).
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>259</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00776</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Service name: CanIf_ChangeBaudrate
    Syntax: Std_ReturnType CanIf_ChangeBaudrate(uint8 ControllerId, const uint16 Baudrate)
    Service ID[hex]: 0x1b
    Sync/Async: Asynchronous
    Reentrancy: Reentrant
    Parameters (in):
      ControllerId  CAN Controller, whose baudrate shall be changed
      Baudrate Requested baudrate in kbps
    Parameters (inout): None
    Parameters (out): None
    Return value: Std_ReturnType
      E_OK: Service request accepted, baudrate change started
      E_NOT_OK: Service request not accepted
    Description: This service shall change the baudrate of the CAN
      controller.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>260</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00787</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The service CanIf_ChangeBaudrate() shall call Can_ChangeBaudrate(Controller,
    Baudrate) for the requested CAN controller.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>261</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00782</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If parameter ControllerId of CanIf_ChangeBaudrate() has an invalid value, the
    CanIf shall report development error code CANIF_E_PARAM_CONTROLLERID to
    the Det_ReportError service of the DET module, when
    CanIf_ChangeBaudrate() is called.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>262</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00783</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_ChangeBaudrate():
    The call context is on task level (polling mode).
    The CanIf must be initialized after Power ON.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>263</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00784</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Configuration of CanIf_ChangeBaudrate():If CanIf supports changing of the
    baudrate and thus this service, shall be configurable via
    CANIF_PUBLIC_CHANGE_BAUDRATE_SUPPORT (see CANIF785_Conf).
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>264</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00294_Baudrate</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
     <description>
        API function              Description
        Can_ChangeBaudrate        This service shall change the baudrate
                                  of the CAN controller.
        Can_CheckBaudrate         This service shall check, if a certain CAN controller
                                  supports a requested baudrate
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BaudRate</srcid><srcstatus/><internalId>1077</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>265</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00046</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall assign each L-PDU handle to one CAN controller only. Thus, the
    assignment of single L-PDU handles to more than one CAN controller is
    prohibited.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.LPdu2ControllerAssignment</srcid><srcstatus/><internalId>1085</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>266</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00681</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If a wake-up event is not validated for the corresponding WakeupSource (see
    CanIf.ASR40.CANIF179), then a function call of CanIf_CheckValidation(WakeupSource)
    shall call the function &lt;User__ValidateWakeupEvent&gt;(sources), whereas all
    bits of sources shall be cleared.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.InvalidatedWakeupSource</srcid><srcstatus/><internalId>1087</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>267</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00490</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>2</version>
       <description>
    After function CanIf_SetPduMode(ControllerId, CANIF_SET_RX_OFFLINE) has been
    called, the CanIf shall deal with the receive LPDUSs, which are assigned
    to the physical channel (defined by ControllerId ,refer to CanIf.ASR40.CANIF382) as
    follows:
    prevent invocation of receive indication callback services
    of the upper layer  modules.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.UseCanIfPduModeTypeInsteadCanIf_PduSetModeTypeAndCanIf_PduGetModeType</srcid><srcstatus/><internalId>1089</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>268</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00491</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>2</version>
       <description>
    When function CanIf_SetPduMode(ControllerId, CANIF_SET_TX_ONLINE) has been
    called, the CanIf shall deal with the transmit LPDUSs, which are assigned
    to the physical channel (defined by ControllerId ,refer to CanIf.ASR40.CANIF382) as
    follows:
    - enable forwarding of the transmit request calls
    CanIf_Transmit()to the  CanDrv,
    - enable invocation of transmit
    confirmation callback services of the upper layer  modules.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.UseCanIfPduModeTypeInsteadCanIf_PduSetModeTypeAndCanIf_PduGetModeType</srcid><srcstatus/><internalId>1089</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>269</internalId></specobject>


    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00492</id>
       <status>approved</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>2</version>
       <description>
    When function CanIf_SetPduMode(ControllerId, CANIF_SET_RX_ONLINE) has been
    called, the CanIf shall deal with the receive LPDUSs, which are assigned
    to the physical channel (defined by ControllerId ,refer to CanIf.ASR40.CANIF382) as
    follows:
    enable invocation of receive indication callback services
    of the upper layer  modules.
    </description>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
       <needscoverage>
          <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.UseCanIfPduModeTypeInsteadCanIf_PduSetModeTypeAndCanIf_PduGetModeType</srcid><srcstatus/><internalId>1089</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>270</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00374</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The code file structure shall not be defined within this specification
    completely. Here it shall be pointed out that the code-file structure
    shall include the following files named:
    CanIf_Lcfg.c - for link time configurable parameters.
    CanIf_PBcfg.c - for post build time configurable parameters. These files shall
    contain all link time and post-build time configurable parameters.(BSW00380)
    </description>
       <comment>
      This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>271</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00375</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The code-file structure shall include CanIf_&lt;X&gt;.c - for implementation of the
    provided functionality. The extension &lt;X&gt; is optional for usage of
    multiple C-files.
    </description>
       <comment>
      This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>272</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00376</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The code-file structure shall include CanIf_Cfg.c - for pre-compile time
    configurable parameters.(BSW00380, BSW00419)
    </description>
       <comment>
      This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>273</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00377_2</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall access the location of the API of all used underlying CanDrvs
    for pre-compile time configuration by using of external
    declaration in CanIf_Cfg.c.
    </description>
       <comment>
      This requirement is informational only.
      The original requriement provides 2 options which are seperated into
      CanIf.ASR40.CANIF377_1 and CanIf.ASR40.CANIF377_2, where CanIf.ASR40.CANIF377_1
      ist choosen for implementation.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>274</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00280</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>2</version>
       <description>
    The CanIf shall include the following header files &lt;Module&gt;_Cfg.h, which
    contain the configuration data used by the CanIf:
    Can_&lt;vendorID&gt;_&lt;Vendor specific name&gt;&lt;driver abbreviation&gt;_Cfg.h -
    for configuration data of the CanDrv (e.g.: Can_99_Ext1_Cfg.h)
    CanTrcv_&lt;Vendor Id&gt;_&lt;Vendor specific name&gt;&lt;driver abbreviation&gt;_Cfg.h
    - for configuration data of the CanTrcv (e.g.: CanTrcv_99_Ext1_Cfg.h)
    PduR_Cfg.h - for PduR configuration data (e.g. PduR target PDU Ids)
    CanNm_Cfg.h - for CanNm configuration data (e.g. CanNm target PDU Ids)
    CanTp_Cfg.h - for CanTp configuration data (e.g. CanTp target PDU Ids)
    Xcp_Cfg.h - for XCP configuration data (e.g. XCP target PDU Ids)
    </description>
       <comment>
      This requirement is informational only.
      CanIf may need the information provided in this files, but the other module itself must
      provide this information via the original module header file.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>275</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00150</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall include the file Dem.h.
    </description>
       <comment>
      This requirement is not applicable.
      CanIf does not report to Dem.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>276</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00023</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall avoid direct access to hardware specific communication buffers
    and shall access it exclusively via the CanDrv interface services.(BSW01001)
    </description>
       <comment>
      This requirement is informational only.
      This is an requirement onto the SWS itself.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>277</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00662</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall use two types of HOHs to enable access to the CanDrv:
    Hardware Transmit Handle (HTH) and
    Hardware Receive Handle (HRH).
    </description>
       <comment>
      This requirement is informational only.
      Descriptive text, no requirement.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>278</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00291</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Definition of HRH: The HRH shall be a handle referencing a logical hardware
    receive object of the CAN controller mailbox.
    </description>
       <comment>
      This requirement is informational only.
      Descriptive text, no requirement.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>279</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00665</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The HRH shall enable the CanIf to use BasicCAN or a FullCAN reception method of
    the referenced reception unit and to indicate a received L-PDU to a
    target upper layer module.
    </description>
       <comment>
      This requirement is informational only.
      Descriptive text, no requirement
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>280</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00664</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If multiple HRHs are used, each HRH shall belong at least to a single or fixed
    group of Rx L-PDU handles (CanRxPduIds).
    </description>
       <comment>
    This requirement is informational only.
    Since there is no API to change the assignment at runtime, this requirement is
    fulfilled by the SWS itself.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>281</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00292</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Definition of HTH: The HTH shall be a handle referencing a logical hardware
    transmit object of the CAN controller mailbox.
    </description>
       <comment>
    This requirement is informational only.
    Descriptive text, no requirement
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>282</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00666</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The HTH shall enable the CanIf to use BasicCAN or a FullCAN transmission method
    of the referenced transmission unit and to confirm a transmitted L-PDU to
    a target upper layer module.
    </description>
       <comment>
    This requirement is informational only.
    Descriptive text, no requirement
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>283</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00667</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If multiple HTHs are used, each HTH shall belong to a single or fixed group of
    Tx L-PDU handles (CanTxPduIds).
    </description>
       <comment>
    This requirement is informational only.
    Since there is no API to change the assignment at runtime, this requirement is
    fulfilled by the SWS itself.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>284</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00467</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall configure and store an order on HTHs and HRHs for all HOHs
    derived from the configuration containers CanIfHthCfg
    (see CanIf.ASR40.ECUC_SWS_CanIf_00258) and CanIfHrhCfg
    (see CanIf.ASR40.ECUC_SWS_CanIf_00259).
    </description>
       <comment>
      This requirement is informational only.
      This is just a rationale why config parameters CanIfHthCfg and CanIfHrhCfg exist.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>285</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00468</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf shall reference a hardware acceptance filter for each HOH derived
    from the configuration parameters CANIF_HTH_Id_SYMREF
    (see CanIf.ASR40.ECUC_SWS_CanIf_00627) and CANIF_HRH_ID_SYMREF
    (see CanIf.ASR40.ECUC_SWS_CanIf_00634).
    </description>
       <comment>
      This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>286</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00070</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CAN Interface module shall transmit L-PDUs stored in the transmit L-PDU
    buffers in priority order (see[18]) per each HTH.
    </description>
       <comment>
      This requirement is informational only.
      Already covered by CanIf.ASR40.CANIF668.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>287</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00058</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If the CanIf's environment reads data from the CanIf controlled memory areas
    initiated by calling one of the functions CanIf_Transmit(),
    CanIf_TxConfirmation(), CanIf_CancelTxConfirmation(), and
    CanIf_ReadRxPduData(), the CanIf shall guarantee that the provided values
    are the most recently acquired values.
    </description>
       <comment>
      This requirement is informational only.
      As CanIf does not specify any queuing or other data aging mechanism, the information read
      is always the most recent information.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>288</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00474</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CAN Interface module shall not contain any complete CAN controller state
    machine.
    </description>
       <comment>
      This requirement is informational only.
      The CanIf shall not implement a complete state machine. It does this however
      as far as necessary to provide the required functionality
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>289</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00153</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Values for production code Event Ids are assigned externally by the
    configuration of the Dem. They are published in the file Dem_IntErrId.h
    and included via Dem.h.(BSW00409)
    </description>
       <comment>
    This requirement is not applicable.
    CanIf does not report to Dem.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>290</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00154</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Development error values are of type uint8.
    </description>
       <comment>
    This requirement is informational only.
    This is a requriement on the SWS itself and on the Det module providing the API
    Det_ReportErrorStatus().
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>291</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00155</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The detection of production code errors cannot be switched off.
    </description>
       <comment>
      This requirement is not applicable.
      There are no more DEM events defined so this requirement does not make sense.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>292</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00020</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Production errors shall be reported to the Dem.(BSW00339)
    </description>
       <comment>
      This requirement is not applicable.
      No Production errors are defined.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>293</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00223</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    For all defined production errors it is only required to report the event, when
    an error or diagnostic relevant event (e.g. state changes, no L-PDU
    events) occurs. Any status has not to be reported.
    </description>
       <comment>
      This requirement is not applicable.
      No Production errors are defined.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>294</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00119</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Additional errors that are detected because of specific implementation and/or
    specific hardware properties shall be added in the CanIf specific
    implementation specification. For doing that, the classification and
    enumeration listed above can be extended with incremented enumerations.
    </description>
       <comment>
      This requirement is not applicable.
      No further errors are defined.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>295</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00142</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Module Imported Type
    Can    Can_HwHandleType
           Can_IdType
           Can_ReturnType
           Can_StateTransitionType
           Can_PduType
    Can_GeneralTypes
           CanTrcv_TrcvModeType
           CanTrcv_TrcvWakeupModeType
           CanTrcv_TrcvWakeupReasonType
    ComStack_Types
           PduIdType
           PduInfoType
    Dem    Dem_EventIdType
           Dem_EventStatusType
    EcuM   EcuM_WakeupSourceType
    Std_Types
           Std_ReturnType
           Std_VersionInfoType
    </description>
       <comment>
      This requirement is informational only.
      Just a list of imported type definitions.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>296</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00523</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The initialization data structure for a specific CanIf CanIf_ConfigType shall
    include the definition of canIf public parameters and the definition for
    each L-PDU handle.
    </description>
       <comment>
      This requirement is informational only.
      We do not need to include all public parameters to the initialization data
      structure. E.g. the parameter for Development error detection is provided as #define
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>297</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00312</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_SetControllerMode():
    - The CAN Driver module must be initialized after Power ON.
    - The CAN Interface module must be initialized after Power ON.
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf (to be handled by application)
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>298</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00316</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_GetControllerMode:
    - The CanDrv must be initialized after Power ON.
    - The CanIf must be initialized after Power ON.
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf (to be handled by application)
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>299</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00323</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_Transmit():  During the call of this API the buffer of
    PduInfoPtr is controlled by the CanIf  and this buffer should not be
    accessed for read/write from another call context.  After return of this
    call the ownership changes to the upper layer.
    The CanIf must be initialized after Power ON.
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>300</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00329</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_ReadRxPduData():
    - During the call of this API the buffer of PduInfoPtr is controlled by the CanIf
      and this buffer should not be accessed for read/write from another call context.
      After return of this call the ownership changes to the upper layer
    - This API must not be used for CanRxPduIds, which are defined to receive multiple
      CAN-Ids (range reception)
    - The CanIf must be initialized after Power ON
    </description>
       <comment>
      This requirement is informational only.
      This is not a requirement for the CanIf. It has to be covered by the upper layer
      caller functions.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>301</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00334</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_ReadTxNotifyStatus():
    The CanIf must be initialized after Power ON.
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf (to be handled by application)
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>302</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00336_2</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If Status for CanRxPduId was requested whereas CANIF_READRXPDU_DATA_API is
    disabled and if development error detection is enabled (i.e.
    CANIF_DEV_ERROR_DETECT equals ON), then the function
    CanIf_ReadRxNotifStatus() shall report development error code
    CANIF_E_INVALID_RXPDUID to the Det_ReportError service of the DET.
    </description>
       <comment>
    This requirement is not applicable.
    CanIf_ReadRxNotifStatus() and CanIf_ReadRxPduData() can be configured
    independent from each other. There is no need for implementing this restriction listed here.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>303</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00344</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_SetPduMode():
    The CanIf must be initialized after Power ON.
    </description>
       <comment>
      This requirement is informational only.
    This is no requirement for the CanIf (to be handled by application)
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>304</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00349</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_SetPduMode():
    The CanIf must be initialized after Power ON.
    </description>
       <comment>
      This requirement is informational only.
    This is no requirement for the CanIf (to be handled by application)
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>305</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00356</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of CanIf_SetDynamicTxId():
    The CanIf must be initialized after Power ON.
    This function may not be interrupted by CanIf_Transmit(),
    if the same L PDU ID is handled.
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf (refers to CanTp)
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>306</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00414</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Configuration of CanIf_TxConfirmation(): Each CAN Tx L-PDU (see
    CanIf.ASR40.ECUC_SWS_CanIf_00248) has to be configured with a corresponding transmit
    confirmation service of an upper layer module (see CanIf.ASR40.CANIF011) which is
    called in CanIf_TxConfirmation().
    </description>
       <comment>
      This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>307</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00423</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Configuration of CanIf_RxIndication(): Each CAN Rx L-PDU (see CanIf.ASR40.ECUC_SWS_CanIf_00249)
    has to be configured with a corresponding receive indication service of
    an upper layer module (see CanIf.ASR40.CANIF012) which is called in
    CanIf_RxIndication().
    </description>
       <comment>
      This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>308</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00040</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    API function                    Description
    Can_SetControllerMode           This function performs software
                                    triggered state transitions of the CAN controller
                                    State machine.
    Can_Write                       -
    SchM_Enter_CanIf_&lt;ExclusiveArea&gt; Invokes
                                    the SchM_Enter function to enter a module local
                                    exclusive area.
    SchM_Exit_CanIf_&lt;ExclusiveArea&gt; Invokes the SchM_Exit function to exit an
                                    exclusive area.
    </description>
       <comment>
      This requirement is informational only.
      This is just a list of mandatory interfaces provided by other modules.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>309</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00437</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of &lt;User_TxConfirmation&gt;(): The call context is either on interrupt
    level (interrupt mode) or on task level (polling mode).
    </description>
       <comment>
      This requirement is informational only.
    No Requirement for CanIf (to be handled by application)
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>310</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00440_1</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Until &lt;User_RxIndication&gt; returns the CanIf will
    not access &lt;PduInfoPtr&gt;. The  &lt;PduInfoPtr&gt; is only valid and can be used
    by upper layers until the indication  returns. The CanIf guarantees that
    the number of configured bytes for this  &lt;PduInfoPtr&gt; is valid.
    </description>
       <comment>
    This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>311</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00440_2</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    - The CAN Driver module must be initialized after Power ON.
    - The call context is either on interrupt level (interrupt mode) or on task level
    (polling mode).
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>312</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00449_1</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Before re-initialization/restart during BusOff
    recovery is executed &lt;User_ControllerBusOff&gt;() is performed only once in
    case of multiple BusOff events at CAN controller.
    </description>
       <comment>
    This requirement is informational only.
    In a "standard" CAN driver, the bus off event is only notified once.
    Therefore the CanIf need not take additional means to protect this
    function.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>313</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00449_2</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    - The CanDrv must be initialized after Power ON.
    - The call context is either on interrupt level (interrupt
    mode) or on task level  (polling mode).
    - This callback service is in
    general re-entrant for multiple CAN controller usage, but not for the
    same CAN controller.
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>314</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00797_2</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Configuration of &lt;User_ClearTrcvWufFlagIndication&gt;(): If CANIF_DISPATCH_USERCLEARTRCVWUFFLAGINDICATION_UL is set to CAN_SM, the following is prescribed:
    -function parameter of type uint8 has to be named as TransceiverId
    </description>
       <comment>
      This requirement is informational only.
      Type uint8 is checked by the compiler which would otherwise issue a warning when calling
      CanSM_ClearTrcvWufFlagIndication. The parameter name is an irrelevant implementation detail.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>315</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00803_2</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Configuration of &lt;User_CheckTrcvWakeFlagIndication&gt;(): If CANIF_DISPATCH_USERCHECKRCVWAKEFLAGINDICATION_UL is set to CAN_SM, the following is prescribed:
    -	function parameter of type uint8 has to be named as TransceiverId
    </description>
       <comment>
      This requirement is informational only.
      Type uint8 is checked by the compiler which would otherwise issue a warning when calling
      CanSM_CheckTrcvWakeFlagIndication. The parameter name is an irrelevant implementation detail.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>316</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00455</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of &lt;User_ValidateWakeupEvent&gt;:
    - The CanDrv must be initialized after Power ON.
    - The call context is either on interrupt level (interrupt
    mode) or on task level  (polling mode).
    - This callback service is in
    general re-entrant for multiple CAN controller usage,  but not for the
    same CAN controller.
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>317</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00456_1</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Configuration of &lt;User_ValidateWakeupEvent&gt;: The upper layer module which
    provides this callback service has to be configured by
    CANIF_DISPATCH_USERVALIDATEWAKEUPEVENT_UL (see CanIf.ASR40.ECUC_SWS_CanIf_00549)
    </description>
       <comment>
      This requirement is informational only.
      For a more detailed config parameter specification
      see CanIf.ASR40.ECUC_SWS_CanIf_00549.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>318</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00694</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    Caveats of &lt;User_TrcvModeIndication&gt;():
    - The CanTrcv must be initialized after Power ON.
    - The call context is either on task level (polling mode).
    - This callback service is in general re-entrant for multiple
    CAN transceiver usage,  but not for the same CAN transceiver.
    </description>
       <comment>
      This requirement is informational only.
      This is no requirement for the CanIf
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>319</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00695_2</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    If no upper layer modules are configured for transceiver mode indications
    using &lt;User_TrcvModeIndication&gt;(), no transceiver mode indication needs
    to be configured. CANIF_DISPATCH_USERTRCVMODEINDICATION_UL needs not to
    be configured.
    </description>
       <comment>
      This requirement is informational only.
      This is a configuration hint in order to optimize resource consumption.
      This is no requirement for the implementation.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>320</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00104</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The listed configuration items can be derived from a network description
    database, which is based on the EcuConfigurationTemplate. The
    configuration tool shall extract all information to configure the CanIf.
    (BSW01015)
    </description>
       <comment>
      This requirement is informational only.
      Requirement for the configuration tool
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>321</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00066</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    The CanIf has access to the CanDrv configuration data. All public CanDrv
    configuration data are described in [8] Specification of CAN Driver.
    </description>
       <comment>
      This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>322</internalId></specobject>

    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00132</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    These dependencies between CanDrv and CanIf configuration must be provided at
    configuration time by the configuration tools.
    </description>
       <comment>
      This requirement is informational only.
      Requirement for the configuration tool
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>323</internalId></specobject>
    
    <specobject>
       <id>CanIf.ASR40.SWS_CanIf_00999</id>
       <status>rejected</status>
       <source>AUTOSAR_SWS_CANInterface.pdf, V5.0.0</source>
       <version>1</version>
       <description>
    These requirements are not applicable to this specification.
    (BSW159, BSW167, BSW170, BSW00416, BSW168, BSW00423, BSW00424, BSW00425, BSW00426,
    BSW00427, BSW00428, BSW00429, BSW00431, BSW00432, BSW00433, BSW00434,
    BSW00336, BSW00417, BSW164, BSW00326, BSW007, BSW00307, BSW00373,
    BSW00435, BSW00328, BSW00378, BSW00306, BSW00308, BSW00309, BSW00376,
    BSW00330, BSW172, BSW010, BSW00341, BSW00334, BSW01139, BSW01014,
    BSW01024)
    </description>
       <comment>
      This requirement is informational only.
    </comment>
       <releases>
          <release>AUTOSAR 4.0.3</release>
       </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>324</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

  </specobjects>
    <specobjects doctype="swurs">
    <specobject>
      <id>CanIf.ASR42.SWS_CanIf_00168</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_ CanIf_4_2_2.xml</source>
      <version>2</version>
      <description>
        If the DLC check rejects a received L-PDU , CanIf shall report development error code "
        CANIF_E_INVALID_DLC" to the "Det_ReportError()" service of the DET module.
      </description>
      <releases>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30846</srcid><srcstatus/><internalId>1497</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_InvalidDLC</srcid><srcstatus/><internalId>1498</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>325</internalId></specobject>
  </specobjects>
    <specobjects doctype="swurs">
    
    <specobject>
      <id>CanIf.ECUC_CanIf_00245</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfPrivateCfg
        Parent Container | CanIf 
        Description | This container contains the private configuration (parameters) of the CAN 
        Interface.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>326</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00246</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfPublicCfg
        Parent Container | CanIf 
        Description | This container contains the public configuration (parameters) of the CAN 
        Interface.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>327</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00247</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfInitCfg
        Parent Container | CanIf 
        Description | This container contains the init parameters of the CAN Interface.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>328</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00248</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfTxPduCfg
        Parent Container | CanIfInitCfg 
        Description | This container contains the configuration (parameters) of a transmit CAN L-PDU. 
        It has to be configured as often as a transmit CAN L-PDU is needed. The SHORT-NAME of "
        CanIfTxPduConfig" container represents the symolic name of Transmit L-PDU. This L-SDU consumes 
        a meta data item of type CAN_ID_32.
        Post-Build Variant Multiplicity | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>329</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00249</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfRxPduCfg
        Parent Container | CanIfInitCfg 
        Description | This container contains the configuration (parameters) of each receive CAN L-PDU.
        The SHORT-NAME of "CanIfRxPduConfig" container itself represents the symolic name of Receive L-
        PDU. This L-SDU produces a meta data item of type CAN_ID_32.
        Post-Build Variant Multiplicity | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIfRxPduCfg</srcid><srcstatus/><internalId>1103</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>330</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00250</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfDispatchCfg
        Parent Container | CanIf 
        Description | Callback functions provided by upper layer modules of the CanIf. The callback 
        functions defined in this container are common to all configured CAN Driver / CAN Transceiver 
        Driver modules.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>331</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00253</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfCtrlDrvCfg
        Parent Container | CanIf 
        Description | Configuration parameters for all the underlying CAN Driver modules are aggregated 
        under this container. For each CAN Driver module a seperate instance of this container has to 
        be provided.
        Post-Build Variant Multiplicity | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE, VARIANT-LINK-
        TIME, VARIANT-POST-BUILD 
        Link time 
        Post-build time 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>332</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00257</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfInitHohCfg
        Parent Container | CanIfInitCfg 
        Description | This container contains the references to the configuration setup of each 
        underlying CAN Driver.
        Post-Build Variant Multiplicity | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE, VARIANT-LINK-
        TIME, VARIANT-POST-BUILD 
        Link time 
        Post-build time 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>333</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00258</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfHthCfg
        Parent Container | CanIfInitHohCfg 
        Description | This container contains parameters related to each HTH.
        Post-Build Variant Multiplicity | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>334</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00259</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfHrhCfg
        Parent Container | CanIfInitHohCfg 
        Description | This container contains configuration parameters for each hardware receive object 
        HRH)
        Post-Build Variant Multiplicity | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>335</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00273</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfTrcvDrvCfg
        Parent Container | CanIf 
        Description | This container contains the configuration (parameters) of all addressed CAN 
        transceivers by each underlying CAN Transceiver Driver module. For each CAN transceiver Driver 
        a seperate instance of this container shall be provided.
        Post-Build Variant Multiplicity | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE, VARIANT-LINK-
        TIME, VARIANT-POST-BUILD 
        Link time 
        Post-build time 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>336</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00525</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserCtrlBusOffName 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the name of &lt;User_ControllerBusOff&gt;.This parameter depends 
        on the parameter CanIfDispatchUserCtrlBusOffUL. If CanIfDispatchUserCtrlBusOffUL equals CAN_SM 
        the name of &lt;User_ControllerBusOff&gt; is fixed. If CanIfDispatchUserCtrlBusOffUL equals CDD, the 
        name of &lt;User_ControllerBusOff&gt; is selectable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfDispatchUserCtrlBusOffUL 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30444</srcid><srcstatus/><internalId>1420</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>337</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00527</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduUserTxConfirmationUL 
        Parent Container | CanIfTxPduCfg 
        Description | This parameter defines the upper layer (UL) module to which the confirmation of 
        the successfully transmitted CanTxPduId has to be routed via the &lt;User_TxConfirmation&gt;.This &lt;
        User_TxConfirmation&gt; has to be invoked when the confirmation of the configured CanTxPduId will 
        be received by a Tx confirmation event from the CAN Driver module.If no upper layer (UL) module 
        is configured, no &lt;User_TxConfirmation&gt; has to be called in case of a Tx confirmation event of 
        the CanTxPduId from the CAN Driver module.
        Multiplicity | 0..1 
        Type | EcucEnumerationParamDef 
        Range | CAN_NMCanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL.CAN_NM | CAN NM 
        CAN_TPCanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL.CAN_TP | CAN TP 
        CAN_TSYNCanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL.CAN_TSYN | Global Time Synchronization 
        over CAN 
        CDDCanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL.CDD | Complex Driver 
        J1939NMCanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL.J1939NM | J1939Nm 
        J1939TPCanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL.J1939TP | J1939Tp 
        PDURCanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL.PDUR | PDU Router 
        XCPCanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL.XCP | Extended Calibration Protocol 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>338</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00528</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>2</version>
      <description>
        Name | CanIfTxPduUserTxConfirmationName 
        Parent Container | CanIfTxPduCfg 
        Description | This parameter defines the name of the &lt;User_TxConfirmation&gt;.This parameter 
        depends on the parameter CanIfTxPduUserTxConfirmationUL.If CanIfTxPduUserTxConfirmationUL 
        equals CAN_TP, CAN_NM, PDUR, XCP, CAN_TSYN, J1939NM or J1939TP, the name of the &lt;
        User_TxConfirmation&gt; is fixed. IfCanIfTxPduUserTxConfirmationUL equals CDD, the name of the&lt;
        User_TxConfirmation&gt; is selectable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
    <comment>
      Requirement was replaced by CanIf.EB.ECUC_CanIf_00528.
      This requirement is not applicable.
    </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>339</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00529</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduUserRxIndicationUL 
        Parent Container | CanIfRxPduCfg 
        Description | This parameter defines the upper layer (UL) module to which the indication of the 
        successfully received CANRXPDUID has to be routed via &lt;User_RxIndication&gt;. This &lt;
        User_RxIndication&gt; has to be invoked when the indication of the configured CANRXPDUID will be 
        received by an Rx indication event from the CAN Driver module. If no upper layer (UL) module is 
        configured, no &lt;User_RxIndication&gt; has to be called in case of an Rx indication event of the 
        CANRXPDUID from the CAN Driver module.
        Multiplicity | 0..1 
        Type | EcucEnumerationParamDef 
        Range | CAN_NMCanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.CAN_NM | CAN NM 
        CAN_TPCanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.CAN_TP | CAN TP 
        CAN_TSYNCanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.CAN_TSYN | Global Time Synchronization over 
        CAN 
        CDDCanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.CDD | Complex Driver 
        J1939NMCanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.J1939NM | J1939Nm 
        J1939TPCanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.J1939TP | J1939Tp 
        PDURCanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.PDUR | PDU Router 
        XCPCanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.XCP | Extended Calibration Protocol 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>340</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00530</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>2</version>
      <description>
        Name | CanIfRxPduUserRxIndicationName 
        Parent Container | CanIfRxPduCfg 
        Description | This parameter defines the name of the &lt;User_RxIndication&gt;.This parameter depends 
        on the parameter CanIfRxPduUserRxIndicationUL.If CanIfRxPduUserRxIndicationUL equals CAN_TP, 
        CAN_NM, PDUR, XCP, CAN_TSYN, J1939NM or J1939TP, the name of the &lt;User_RxIndication&gt; is fixed. 
        If CanIfRxPduUserRxIndicationUL equals CDD, the name of the &lt;User_RxIndication&gt; is selectable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        Requirement was replaced by CanIf.EB.ECUC_CanIf_00530.
        This requirement is not applicable.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>341</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00531</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserValidateWakeupEventName 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the name of &lt;User_ValidateWakeupEvent&gt;. This parameter 
        depends on the parameter CanIfDispatchUserValidateWakeupEventUL. If 
        CanIfDispatchUserValidateWakeupEventUL equals ECUM, the name of &lt;User_ValidateWakeupEvent&gt; is 
        fixed. If CanIfDispatchUserValidateWakeupEventUL equals CDD, the name of &lt;
        User_ValidateWakeupEvent&gt; is selectable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfDispatchUserValidateWakeupEventUL 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30442</srcid><srcstatus/><internalId>1419</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>342</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00546</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfCtrlCfg 
        Parent Container | CanIfCtrlDrvCfg 
        Description | This container contains the configuration (parameters) of an adressed CAN 
        controller by an underlying CAN Driver module. This container is configurable per CAN 
        controller.
        Post-Build Variant Multiplicity | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE, VARIANT-LINK-
        TIME, VARIANT-POST-BUILD 
        Link time 
        Post-build time 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>343</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00547</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserCtrlBusOffUL 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the upper layer (UL) module to which the notifications of 
        all ControllerBusOff events from the CAN Driver modules have to be routed via &lt;
        User_ControllerBusOff&gt;.There is no possibility to configure no upper layer (UL) module as the 
        provider of &lt;User_ControllerBusOff&gt;
        Multiplicity | 1 
        Type | EcucEnumerationParamDef 
        Range | CAN_SMCanIfDispatchCfg.CanIfDispatchUserCtrlBusOffUL.CAN_SM | CAN State Manager 
        CDDCanIfDispatchCfg.CanIfDispatchUserCtrlBusOffUL.CDD | Complex Driver 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30444</srcid><srcstatus/><internalId>1420</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>344</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00549</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserValidateWakeupEventUL 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the upper layer (UL) module to which the notifications 
        about positive former requested wake up sources have to be routed via &lt;User_ValidateWakeupEvent&gt;
        Multiplicity | 0..1 
        Type | EcucEnumerationParamDef 
        Range | CDDCanIfDispatchCfg.CanIfDispatchUserValidateWakeupEventUL.CDD | Complex Driver 
        ECUMCanIfDispatchCfg.CanIfDispatchUserValidateWakeupEventUL.ECUM | ECU State Manager 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30442</srcid><srcstatus/><internalId>1419</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>345</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00587</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfTrcvCfg
        Parent Container | CanIfTrcvDrvCfg 
        Description | This container contains the configuration (parameters) of one addressed CAN 
        transceiver by the underlying CAN Transceiver Driver module. For each CAN transceiver a 
        seperate instance of this container has to be provided.
        Post-Build Variant Multiplicity | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE, VARIANT-LINK-
        TIME, VARIANT-POST-BUILD 
        Link time 
        Post-build time 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>346</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00589</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduReadNotifyStatus 
        Parent Container | CanIfTxPduCfg 
        Description | Enables and disables transmit confirmation for each transmit CAN L-SDU for 
        reading its notification status. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local dependency: CanIfPublicReadTxPduNotifyStatusApi must be 
        enabled.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>347</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00590</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduCanIdType 
        Parent Container | CanIfTxPduCfg 
        Description | Type of CAN Identifier of the transmit CAN L-PDU used by the CAN Driver module 
        for CAN L-PDU transmission.
        Multiplicity | 1 
        Type | EcucEnumerationParamDef 
        Range | EXTENDED_CANCanIfTxPduCfg.CanIfTxPduCanIdType.EXTENDED_CAN | CAN frame with extended 
        identifier (29 bits)
        EXTENDED_FD_CANCanIfTxPduCfg.CanIfTxPduCanIdType.EXTENDED_FD_CAN | CAN FD frame with extended 
        identifier (29 bits)
        STANDARD_CANCanIfTxPduCfg.CanIfTxPduCanIdType.STANDARD_CAN | CAN frame with standard identifier 
        11 bits)
        STANDARD_FD_CANCanIfTxPduCfg.CanIfTxPduCanIdType.STANDARD_FD_CAN | CAN FD frame with standard 
        identifier (11 bits)
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.ECUC_CanIf_00590</srcid><srcstatus/><internalId>232</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>348</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00591</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduId 
        Parent Container | CanIfTxPduCfg 
        Description | ECU wide unique, symbolic handle for transmit CAN L-SDU. Range: 0..max. number of 
        CantTxPduIds 
        Multiplicity | 1 
        Type | EcucIntegerParamDef (Symbolic Name generated for this parameter)
        Range | 0.. 4294967295 
        Default value 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIfPBVariantValue</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.ECUC_CanIf_00591</srcid><srcstatus/><internalId>22</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>349</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00592</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduCanId 
        Parent Container | CanIfTxPduCfg 
        Description | CAN Identifier of transmit CAN L-PDUs used by the CAN Driver for CAN L-PDU 
        transmission. Range: 11 Bit For Standard CAN Identifier... 29 Bit For Extended CAN identifier 
        The CAN Identifier may be omitted for dynamic transmit L-PDUs.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PBVariantValue</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>350</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00593</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduType 
        Parent Container | CanIfTxPduCfg 
        Description | Defines the type of each transmit CAN L-PDU.
        Multiplicity | 1 
        Type | EcucEnumerationParamDef 
        Range | DYNAMICCanIfTxPduCfg.CanIfTxPduType.DYNAMIC | CAN ID is defined at runtime.
        STATICCanIfTxPduCfg.CanIfTxPduType.STATIC | CAN ID is defined at compile-time.
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31232</srcid><srcstatus/><internalId>1596</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>351</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00595</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduReadNotifyStatus 
        Parent Container | CanIfRxPduCfg 
        Description | Enables and disables receive indication for each receive CAN L-SDU for reading 
        its notification status. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local dependency: CanIfPublicReadRxPduNotifyStatusApi must be 
        enabled.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>352</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00596</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduCanIdType 
        Parent Container | CanIfRxPduCfg 
        Description | CAN Identifier of receive CAN L-PDUs used by the CAN Driver for CAN L-PDU 
        reception.
        Multiplicity | 1 
        Type | EcucEnumerationParamDef 
        Range | EXTENDED_CANCanIfRxPduCfg.CanIfRxPduCanIdType.EXTENDED_CAN | CAN 2.0 or CAN FD frame 
        with extended identifier (29 bits)
        EXTENDED_FD_CANCanIfRxPduCfg.CanIfRxPduCanIdType.EXTENDED_FD_CAN | CAN FD frame with extended 
        identifier (29 bits)
        EXTENDED_NO_FD_CANCanIfRxPduCfg.CanIfRxPduCanIdType.EXTENDED_NO_FD_CAN | CAN 2.0 frame with 
        extended identifier (29 bits)
        STANDARD_CANCanIfRxPduCfg.CanIfRxPduCanIdType.STANDARD_CAN | CAN 2.0 or CAN FD frame with 
        standard identifier (11 bits)
        STANDARD_FD_CANCanIfRxPduCfg.CanIfRxPduCanIdType.STANDARD_FD_CAN | CAN FD frame with standard 
        identifier (11 bits)
        STANDARD_NO_FD_CANCanIfRxPduCfg.CanIfRxPduCanIdType.STANDARD_NO_FD_CAN | CAN 2.0 frame with 
        standard identifier (11 bits)
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.1</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_ExtCanId</srcid><srcstatus/><internalId>1398</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_StdCanId</srcid><srcstatus/><internalId>1399</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_ExtFdCanId</srcid><srcstatus/><internalId>1400</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_StdFdCanId</srcid><srcstatus/><internalId>1401</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_ExtNoFdCanId</srcid><srcstatus/><internalId>1402</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_StdNoFdCanId</srcid><srcstatus/><internalId>1403</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>353</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00597</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduId 
        Parent Container | CanIfRxPduCfg 
        Description | ECU wide unique, symbolic handle for receive CAN L-SDU. It shall fulfill ANSI/
        AUTOSAR definitions for constant defines. Range: 0..max. number of defined CanRxPduIds 
        Multiplicity | 1 
        Type | EcucIntegerParamDef (Symbolic Name generated for this parameter)
        Range | 0.. 4294967295 
        Default value 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SymbolicNameValues</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>354</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00598</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduCanId 
        Parent Container | CanIfRxPduCfg 
        Description | CAN Identifier of Receive CAN L-PDUs used by the CAN Interface. Exa: Software 
        Filtering. This parameter is used if exactly one Can Identifier is assigned to the Pdu. If a 
        range is assigned then the CanIfRxPduCanIdRange parameter shall be used. Range: 11 Bit For 
        Standard CAN Identifier... 29 Bit For Extended CAN identifier 
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31226</srcid><srcstatus/><internalId>1769</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31227</srcid><srcstatus/><internalId>1770</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>355</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00599</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduDataLength 
        Parent Container | CanIfRxPduCfg 
        Description | Data length of the received CAN L-PDUs used by the CAN Interface.This information 
        is used for Data Length Check. Additionally it might specify the valid bits in case of the 
        discrete DLC for CAN FD L-PDUs &gt; 8 bytes. The data area size of a CAN L-PDU can have a range 
        from 0 to 64 bytes.
        Multiplicity | 1 
        Type | EcucIntegerParamDef 
        Range | 0.. 64 
        Default value 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU dependency: If CanIfRxPduDataLength &gt; 8 then 
        CanIfRxPduCanIdType must not be STANDARD_NO_FD_CAN or EXTENDED_NO_FD_CAN 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_FdDlcCheckFailed</srcid><srcstatus/><internalId>1404</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30335</srcid><srcstatus/><internalId>1760</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PBVariantValue</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>356</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00600</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduReadData 
        Parent Container | CanIfRxPduCfg 
        Description | Enables and disables the Rx buffering for reading of received L-SDU data. True: 
        EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>357</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00601</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduRef 
        Parent Container | CanIfRxPduCfg 
        Description | Reference to the "global" Pdu structure to allow harmonization of handle IDs in 
        the COM-Stack.
        Multiplicity | 1 
        Type | Reference to [ Pdu 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>AUTOSAR R20-11 comment: The CanIf module only supports configuration variant VARIANT-POST-BUILD. VARIANT-PRE-COMPILE and VARIANT-LINK-TIME are not supported.;
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfRxIndication</srcid><srcstatus/><internalId>1577</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>358</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00602</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduHrhIdRef 
        Parent Container | CanIfRxPduCfg 
        Description | The HRH to which Rx L-PDU belongs to, is referred through this parameter.
        Multiplicity | 1 
        Type | Reference to [ CanIfHrhCfg 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local dependency: This information has to be derived from the CAN 
        Driver configuration.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfRxIndication</srcid><srcstatus/><internalId>1577</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>359</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00603</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduRef 
        Parent Container | CanIfTxPduCfg 
        Description | Reference to the "global" Pdu structure to allow harmonization of handle IDs in 
        the COM-Stack.
        Multiplicity | 1 
        Type | Reference to [ Pdu 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>AUTOSAR R20-11 comment: The CanIf module only supports configuration variant VARIANT-POST-BUILD. VARIANT-PRE-COMPILE and VARIANT-LINK-TIME are not supported.;
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfTransmit</srcid><srcstatus/><internalId>1576</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>360</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00605</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTrcvCanTrcvRef 
        Parent Container | CanIfTrcvCfg 
        Description | This parameter references to the logical handle of the underlying CANtransceiver 
        from the CAN transceiver driver module to be served by the CAN Interface module. Range: 0..max.
        number of underlying supported CAN transceivers 
        Multiplicity | 1 
        Type | Symbolic name reference to [ CanTrcvChannel 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: amount of CAN transceivers 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfTrcvModeIndication</srcid><srcstatus/><internalId>1578</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>361</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00606</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTrcvWakeupSupport 
        Parent Container | CanIfTrcvCfg 
        Description | This parameter defines if a respective transceiver of the referenced CAN 
        Transceiver Driver modules is queriable for wake up events. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>362</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00607</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicReadRxPduDataApi 
        Parent Container | CanIfPublicCfg 
        Description | Enables / Disables the API CanIf_ReadRxPduData() for reading received L-SDU data.
        True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>363</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00608</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicReadRxPduNotifyStatusApi 
        Parent Container | CanIfPublicCfg 
        Description | Enables and disables the API for reading the notification status of receive L-
        PDUs. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>364</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00609</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicReadTxPduNotifyStatusApi 
        Parent Container | CanIfPublicCfg 
        Description | Enables and disables the API for reading the notification status of transmit L-
        PDUs. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>365</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00610</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicSetDynamicTxIdApi 
        Parent Container | CanIfPublicCfg 
        Description | Enables and disables the API for reconfiguration of the CAN Identifier for each 
        Transmit L-PDU. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>366</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00611</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicWakeupCheckValidSupport 
        Parent Container | CanIfPublicCfg 
        Description | Selects support for wake up validation True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>367</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00612</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicMultipleDrvSupport 
        Parent Container | CanIfPublicCfg 
        Description | Selects support for multiple CAN Drivers. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | true 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MULTIDRV_TRANSMIT</srcid><srcstatus/><internalId>1547</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_RXINDICATION</srcid><srcstatus/><internalId>1548</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_SETBAUDRATE</srcid><srcstatus/><internalId>1549</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CHECKWAKEUP</srcid><srcstatus/><internalId>1550</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1551</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1552</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CANCELTXCONFIRMATION</srcid><srcstatus/><internalId>1553</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CONTROLLERBUSOFF</srcid><srcstatus/><internalId>1554</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_OFFSETTXBUFF</srcid><srcstatus/><internalId>1555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>368</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00613</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfVersionInfoApi 
        Parent Container | CanIfPublicCfg 
        Description | Enables and disables the API for reading the version information about the CAN 
        Interface. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Functional specification in requriement CanIf.ASR40.SWS_CanIf_00351.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3115</srcid><srcstatus/><internalId>1271</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>369</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00614</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDevErrorDetect 
        Parent Container | CanIfPublicCfg 
        Description | Switches the development error detection and notification on or off.
        true: detection and notification is enabled.
        false: detection and notification is disabled.
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Functional behaviour is specified in CanIf.ASR40.SWS_CanIf_00018.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_2787</srcid><srcstatus/><internalId>1269</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>370</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00617</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPrivateDataLengthCheck 
        Parent Container | CanIfPrivateCfg 
        Description | Selects whether Data Length Check is supported. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | true 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30416</srcid><srcstatus/><internalId>1559</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30876</srcid><srcstatus/><internalId>1761</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>371</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00618</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicTxBuffering 
        Parent Container | CanIfPublicCfg 
        Description | Enables and disables the buffering of transmit L-PDUs (rejected by the CanDrv) 
        within the CAN Interface module. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>372</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00619</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPrivateSoftwareFilterType 
        Parent Container | CanIfPrivateCfg 
        Description | Selects the desired software filter mechanism for reception only.Each implemented 
        software filtering method is identified by this enumeration number. Range: Types implemented 
        software filtering methods 
        Multiplicity | 1 
        Type | EcucEnumerationParamDef 
        Range | BINARYCanIfPrivateCfg.CanIfPrivateSoftwareFilterType.BINARY | Selects Binary Filter 
        method.
        INDEXCanIfPrivateCfg.CanIfPrivateSoftwareFilterType.INDEX | Selects Index Filter method.
        LINEARCanIfPrivateCfg.CanIfPrivateSoftwareFilterType.LINEAR | Selects Linear Filter method.
        TABLECanIfPrivateCfg.CanIfPrivateSoftwareFilterType.TABLE | Selects Table Filter method.
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local dependency: BasicCAN reception must be enabled by referenced 
        parameter CanHandleType of the CAN Driver module via CanIfHrhIdSymRef for at least one HRH.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.SoftwareFilterType</srcid><srcstatus/><internalId>1079</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>373</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00623</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfInitCfgSet 
        Parent Container | CanIfInitCfg 
        Description | Selects the CAN Interface specific configuration setup. This type of the external 
        data structure shall contain the post build initialization data for the CAN Interface for all 
        underlying CAN Drivers. constant to CanIf_ConfigType 
        Multiplicity | 1 
        Type | EcucStringParamDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PBVariantValue</srcid><srcstatus/><internalId>1112</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>374</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00625</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHthCanCtrlIdRef 
        Parent Container | CanIfHthCfg 
        Description | Reference to controller Id to which the HTH belongs to. A controller can contain 
        one or more HTHs.
        Multiplicity | 1 
        Type | Reference to [ CanIfCtrlCfg 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>375</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00627</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHthIdSymRef 
        Parent Container | CanIfHthCfg 
        Description | The parameter refers to a particular HTH object in the CanDrv configuration .
        CanIf receives the following information of the CanDrv module by this reference:
        CanHandleType 
        CanObjectId 
        Multiplicity | 1 
        Type | Symbolic name reference to [ CanHardwareObject 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>AUTOSAR R20-11 comment: The CanIf module only supports configuration variant VARIANT-POST-BUILD. VARIANT-PRE-COMPILE and VARIANT-LINK-TIME are not supported.;
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfTransmit</srcid><srcstatus/><internalId>1576</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01023_Err_Invalid_CanIfInitHohCfgExpression</srcid><srcstatus/><internalId>1651</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>376</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00628</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfHrhRangeCfg
        Parent Container | CanIfHrhCfg 
        Description | Defines the parameters required for configurating multiple CANID ranges for a 
        given same HRH.
        Post-Build Variant Multiplicity | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>377</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00629</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHrhRangeRxPduLowerCanId 
        Parent Container | CanIfHrhRangeCfg 
        Description | Lower CAN Identifier of a receive CAN L-PDU for identifier range definition, in 
        which all CAN Ids shall pass the software filtering.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>378</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00630</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHrhRangeRxPduUpperCanId 
        Parent Container | CanIfHrhRangeCfg 
        Description | Upper CAN Identifier of a receive CAN L-PDU for identifier range definition, in 
        which all CAN Ids shall pass the software filtering.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>379</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00631</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHrhCanCtrlIdRef 
        Parent Container | CanIfHrhCfg 
        Description | Reference to controller Id to which the HRH belongs to. A controller can contain 
        one or more HRHs.
        Multiplicity | 1 
        Type | Reference to [ CanIfCtrlCfg 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>380</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00632</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHrhSoftwareFilter 
        Parent Container | CanIfHrhCfg 
        Description | Selects the hardware receive objects by using the HRH range/list from CAN Driver 
        configuration to define, for which HRH a software filtering has to be performed at during 
        receive processing. True: Software filtering is enabledFalse: Software filtering is enabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | true 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_NO_SW_FILTERING_1</srcid><srcstatus/><internalId>1513</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_NO_SW_FILTERING_2</srcid><srcstatus/><internalId>1514</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31144</srcid><srcstatus/><internalId>1556</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_SW_FILTERING_SUPPORTED</srcid><srcstatus/><internalId>1562</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00469</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>583</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>381</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00634</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHrhIdSymRef 
        Parent Container | CanIfHrhCfg 
        Description | The parameter refers to a particular HRH object in the CanDrv configuration .
        CanIf receives the following information of the CanDrv module by this reference:
        CanHandleType 
        CanObjectId 
        Multiplicity | 1 
        Type | Symbolic name reference to [ CanHardwareObject 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfRxIndication</srcid><srcstatus/><internalId>1577</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01023_Err_Invalid_CanIfInitHohCfgExpression</srcid><srcstatus/><internalId>1651</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>382</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00636</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfCtrlCanCtrlRef 
        Parent Container | CanIfCtrlCfg 
        Description | This parameter references to the logical handle of the underlying CAN controller 
        from the CAN Driver module to be served by the CAN Interface module. The following parameters 
        of CanController config container shall be referenced by this link: CanControllerId, 
        CanWakeupSourceRef Range: 0..max. number of underlying supported CAN controllers 
        Multiplicity | 1 
        Type | Symbolic name reference to [ CanController 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: amount of CAN controllers 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfTransmit</srcid><srcstatus/><internalId>1576</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanIfRxIndication</srcid><srcstatus/><internalId>1577</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>383</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00637</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfCtrlWakeupSupport 
        Parent Container | CanIfCtrlCfg 
        Description | This parameter defines if a respective controller of the referenced CAN Driver 
        modules is queriable for wake up events. True: EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>384</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00638</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfCtrlDrvNameRef 
        Parent Container | CanIfCtrlDrvCfg 
        Description | CAN Interface Driver Reference. This reference can be used to get any information 
        Ex. Driver Name, Vendor ID) from the CAN driver. The CAN Driver name can be derived from the 
        ShortName of the CAN driver module.
        Multiplicity | 1 
        Type | Reference to [ CanGeneral 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>385</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00642</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfCtrlDrvInitHohConfigRef 
        Parent Container | CanIfCtrlDrvCfg 
        Description | Reference to the Init Hoh Configuration 
        Multiplicity | 1 
        Type | Reference to [ CanIfInitHohCfg 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>386</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00644</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHrhRangeRxPduRangeCanIdType 
        Parent Container | CanIfHrhRangeCfg 
        Description | Specifies whether a configured Range of CAN Ids shall only consider standard CAN 
        Ids or extended CAN Ids.
        Multiplicity | 1 
        Type | EcucEnumerationParamDef 
        Range | EXTENDEDCanIfHrhRangeCfg.CanIfHrhRangeRxPduRangeCanIdType.EXTENDED | All the CANIDs are 
        of type extended only (29 bit)
        STANDARDCanIfHrhRangeCfg.CanIfHrhRangeRxPduRangeCanIdType.STANDARD | All the CANIDs are of type 
        standard only (11bit)
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>387</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00647</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfCtrlId 
        Parent Container | CanIfCtrlCfg 
        Description | This parameter abstracts from the CAN Driver specific parameter Controller. Each 
        controller of all connected CAN Driver modules shall be assigned to one specific ControllerId 
        of the CanIf. Range: 0..number of configured controllers of all CAN Driver modules 
        Multiplicity | 1 
        Type | EcucIntegerParamDef (Symbolic Name generated for this parameter)
        Range | 0.. 255 
        Default value 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIfPBVariantValue</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SymbolicNameValues</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>388</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00654</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTrcvId 
        Parent Container | CanIfTrcvCfg 
        Description | This parameter abstracts from the CAN Transceiver Driver specific parameter 
        Transceiver. Each transceiver of all connected CAN Transceiver Driver modules shall be assigned 
        to one specific TransceiverId of the CanIf. Range: 0..number of configured transceivers of all 
        CAN Transceiver Driver modules 
        Multiplicity | 1 
        Type | EcucIntegerParamDef (Symbolic Name generated for this parameter)
        Range | 0.. 255 
        Default value 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIfPBVariantValue</srcid><srcstatus/><internalId>1098</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.ECUC_CanIf_00654</srcid><srcstatus/><internalId>24</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>389</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00671</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicCddHeaderFile 
        Parent Container | CanIfPublicCfg 
        Description | Defines header files for callback functions which shall be included in case of 
        CDDs. Range of characters is 1.. 32.
        Multiplicity | 0..*
        Type | EcucStringParamDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>390</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00675</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfSupportTTCAN 
        Parent Container | CanIfPrivateCfg 
        Description | Defines whether TTCAN is supported. TRUE: TTCAN is supported.FALSE: TTCAN is not 
        supported, only normal CAN communication is possible.
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.NoTTCanSupport</srcid><srcstatus/><internalId>1080</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>391</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00683</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserCtrlModeIndicationName 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the name of &lt;User_ControllerModeIndication&gt;.This parameter 
        depends on the parameter CanIfDispatchUserCtrlModeIndicationUL. If 
        CanIfDispatchUserCtrlModeIndicationUL equals CAN_SM the name of &lt;User_ControllerModeIndication&gt;
        is fixed. If CanIfDispatchUserCtrlModeIndicationUL equals CDD, the name of &lt;
        User_ControllerModeIndication&gt; is selectable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfDispatchUserCtrlModeIndicationUL 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserControllerModeIndication</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>392</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00684</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserCtrlModeIndicationUL 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the upper layer (UL) module to which the notifications of 
        all ControllerTransition events from the CAN Driver modules have to be routedvia &lt;
        User_ControllerModeIndication&gt;
        Multiplicity | 1 
        Type | EcucEnumerationParamDef 
        Range | CAN_SMCanIfDispatchCfg.CanIfDispatchUserCtrlModeIndicationUL.CAN_SM | CAN State Manager 
        CDDCanIfDispatchCfg.CanIfDispatchUserCtrlModeIndicationUL.CDD | Complex Driver 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserControllerModeIndication</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>393</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00685</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserTrcvModeIndicationName 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the name of &lt;User_TrcvModeIndication&gt;.This parameter 
        depends on the parameter CanIfDispatchUserTrcvModeIndicationUL. If 
        CanIfDispatchUserTrcvModeIndicationUL equals CAN_SM the name of &lt;User_TrcvModeIndication&gt; is 
        fixed. If CanIfDispatchUserTrcvModeIndicationUL equals CDD, the name of &lt;
        User_TrcvModeIndication&gt; is selectable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfDispatchUserTrcvModeIndicationUL 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserTrcvModeIndication</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>394</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00686</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserTrcvModeIndicationUL 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the upper layer (UL) module to which the notifications of 
        all TransceiverTransition events from the CAN Transceiver Driver modules have to be routed via 
        User_TrcvModeIndication&gt;. If no UL module is configured, no upper layer callback function will 
        be called.
        Multiplicity | 0..1 
        Type | EcucEnumerationParamDef 
        Range | CAN_SMCanIfDispatchCfg.CanIfDispatchUserTrcvModeIndicationUL.CAN_SM | CAN State Manager 
        CDDCanIfDispatchCfg.CanIfDispatchUserTrcvModeIndicationUL.CDD | Complex Driver 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanSM_Cbk</srcid><srcstatus/><internalId>1322</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UserTrcvModeIndication</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>395</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00733</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicTxConfirmPollingSupport 
        Parent Container | CanIfPublicCfg 
        Description | Configuration parameter to enable/disable the API to poll for Tx Confirmation 
        state.
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local dependency: CAN State Manager module 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>396</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00741</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicWakeupCheckValidByNM 
        Parent Container | CanIfPublicCfg 
        Description | If enabled, only NM messages shall validate a detected wake-up event in CanIf. If 
        disabled, all received messages corresponding to a configured Rx PDU shall validate such a wake-
        up event.This parameter depends on CanIfPublicWakeupCheckValidSupport and shall only be 
        configurable, if it is enabled. True: EnabledFalse: Disabled 
        Multiplicity | 0..1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfPublicWakeupCheckValidSupport 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NmWuValidWithCanNmPdu</srcid><srcstatus/><internalId>1592</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NmWuValidWithPduRPdu</srcid><srcstatus/><internalId>1593</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>397</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00742</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicHandleTypeEnum 
        Parent Container | CanIfPublicCfg 
        Description | This parameter is used to configure the Can_HwHandleType. The Can_HwHandleType 
        represents the hardware object handles of a CAN hardware unit. For CAN hardware units with more 
        than 255 HW objects the extended range shall be used (UINT16)
        Multiplicity | 1 
        Type | EcucEnumerationParamDef 
        Range | UINT16CanIfPublicCfg.CanIfPublicHandleTypeEnum.UINT16 
        UINT8CanIfPublicCfg.CanIfPublicHandleTypeEnum.UINT8 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: Can_HwHandleType 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>398</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00743</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfRxPduCanIdRange
        Parent Container | CanIfRxPduCfg 
        Description | Optional container that allows to map a range of CAN Ids to one PduId.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>399</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00744</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduCanIdRangeUpperCanId 
        Parent Container | CanIfRxPduCanIdRange 
        Description | Upper CAN Identifier of a receive CAN L-PDU for identifier range definition, in 
        which all CAN Ids are mapped to one PduId.
        Multiplicity | 1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30795</srcid><srcstatus/><internalId>1755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>400</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00745</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduCanIdRangeLowerCanId 
        Parent Container | CanIfRxPduCanIdRange 
        Description | Lower CAN Identifier of a receive CAN L-PDU for identifier range definition, in 
        which all CAN Ids are mapped to one PduId.
        Multiplicity | 1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30795</srcid><srcstatus/><internalId>1755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>401</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00772</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfPublicPnSupport 
        Parent Container | CanIfPublicCfg 
        Description | Selects support of Partial Network features in CanIf.
        True: Enabled False: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31352</srcid><srcstatus/><internalId>1329</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_POLLING_SUPPORT</srcid><srcstatus/><internalId>1341</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_PnFilterBlocksTxPdu</srcid><srcstatus/><internalId>1564</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_PnFilterAllowsTxPdu</srcid><srcstatus/><internalId>1565</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterAfterTxConf</srcid><srcstatus/><internalId>1566</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterWithoutTxPdu</srcid><srcstatus/><internalId>1567</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30352</srcid><srcstatus/><internalId>1698</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30317</srcid><srcstatus/><internalId>1721</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>402</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00773</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduPnFilterPdu 
        Parent Container | CanIfTxPduCfg 
        Description | If CanIfPublicPnFilterSupport is enabled, by this parameter PDUs could be 
        configured which will pass the CanIfPnFilter.
        If there is no CanIfTxPduPnFilterPdu configured per controller, the corresponding controller 
        applies no CanIfPnFilter.
        Multiplicity | 0..1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local dependency: This parameter shall only be configurable if 
        CanIfPublicPnSupport equals True.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>403</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00820</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserConfirmPnAvailabilityUL 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the upper layer module to which the ConfirmPnAvailability 
        notification from the Driver modules have to be routed. If CanIfPublicPnSupport equals False, 
        this parameter shall not be configurable.
        Multiplicity | 0..1 
        Type | EcucEnumerationParamDef 
        Range | CAN_SMCanIfDispatchCfg.CanIfDispatchUserConfirmPnAvailabilityUL.CAN_SM | CAN State 
        Manager 
        CDDCanIfDispatchCfg.CanIfDispatchUserConfirmPnAvailabilityUL.CDD | Complex Driver 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfPublicPnSupport 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ParameterMultiplicity</srcid><srcstatus/><internalId>1099</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.ECUC_CanIf_00820</srcid><srcstatus/><internalId>25</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>404</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00831</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduBufferRef 
        Parent Container | CanIfTxPduCfg 
        Description | Configurable reference to a CanIf buffer configuration.
        Multiplicity | 1 
        Type | Reference to [ CanIfBufferCfg 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30318</srcid><srcstatus/><internalId>1722</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00466</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>580</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>405</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00832</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfBufferCfg
        Parent Container | CanIfInitCfg 
        Description | This container contains the Txbuffer configuration. Multiple buffers with 
        different sizes could be configured. If CanIfBufferSize (ECUC_CanIf_00834) equals 0, the CanIf 
        Tx L-PDU only refers via this CanIfBufferCfg the corresponding CanIfHthCfg.
        Post-Build Variant Multiplicity | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>406</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00833</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfBufferHthRef 
        Parent Container | CanIfBufferCfg 
        Description | Reference to HTH, that defines the hardware object or the pool of hardware 
        objects configured for transmission. All the CanIf Tx L-PDUs refer via the CanIfBufferCfg and 
        this parameter to the HTHs if TxBuffering is enabled, or not. Each HTH shall not be assigned to 
        more than one buffer.
        Multiplicity | 1 
        Type | Reference to [ CanIfHthCfg 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TxBuffer</srcid><srcstatus/><internalId>1081</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>407</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00834</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfBufferSize 
        Parent Container | CanIfBufferCfg 
        Description | This parameter defines the number of CanIf Tx L-PDUs which can be buffered in one 
        Txbuffer. If this value equals 0, the CanIf does not perform Txbuffering for the CanIf Tx L-
        PDUs which are assigned to this Txbuffer. If CanIfPublicTxBuffering equals False, this 
        parameter equals 0 for all TxBuffer. If the CanHandleType of the referred HTH equals FULL, this 
        parameter equals 0 for this TxBuffer.
        Multiplicity | 1 
        Type | EcucIntegerParamDef 
        Range | 0.. 255 
        Default value | 0 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local dependency: CanIfPublicTxBuffering, CanHandleType 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TxBuffer</srcid><srcstatus/><internalId>1081</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>408</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_Init 
        Syntax 
        void CanIf_Init (const CanIf_ConfigType* ConfigPtr)
        Service ID [hex] | 0x01 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | ConfigPtr | Pointer to configuration parameter set, used e.g. for post build 
        parameters 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service Initializes internal and external interfaces of the CAN Interface 
        for the further processing.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31184</srcid><srcstatus/><internalId>1584</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30293</srcid><srcstatus/><internalId>1713</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30367</srcid><srcstatus/><internalId>1714</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30881</srcid><srcstatus/><internalId>1715</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>409</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_SetControllerMode 
        Syntax 
        Std_ReturnType CanIf_SetControllerMode (uint8 ControllerId, Can_ControllerStateType 
        ControllerMode)
        Service ID [hex] | 0x03 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant (Not for the same controller)
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller, which is requested for mode transition.
        ControllerMode | Requested mode transition 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Controller mode request has been acceptedE_NOT_OK: 
        Controller mode request has not been accepted 
        Description | This service calls the corresponding CAN Driver service for changing of the CAN 
        controller mode.
        Available via | CanIf.h 
      </description>
      <comment>
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30844</srcid><srcstatus/><internalId>1438</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30240</srcid><srcstatus/><internalId>1456</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30241</srcid><srcstatus/><internalId>1457</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31180</srcid><srcstatus/><internalId>1582</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30201</srcid><srcstatus/><internalId>1719</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>410</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_Transmit 
        Syntax 
        Std_ReturnType CanIf_Transmit (PduIdType TxPduId, const PduInfoType* PduInfoPtr)
        Service ID [hex] | 0x49 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | TxPduId | Identifier of the PDU to be transmitted 
        PduInfoPtr | Length of and pointer to the PDU data and pointer to MetaData.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Transmit request has been accepted.E_NOT_OK: Transmit 
        request has not been accepted.
        Description | Requests transmission of a PDU.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.Changed_ServiceID</srcid><srcstatus/><internalId>1101</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00005</srcid><srcstatus/><internalId>26</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>411</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_RxIndication 
        Syntax 
        void CanIf_RxIndication (const Can_HwType* Mailbox, const PduInfoType* PduInfoPtr)
        Service ID [hex] | 0x14 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | Mailbox | Identifies the HRH and its corresponding CAN Controller 
        PduInfoPtr | Pointer to the received L-PDU 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates a successful reception of a received CAN Rx L-PDU to the 
        CanIf after passing all filters and validation checks.
        Available via | CanIf_Can.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Receive300Hrhs</srcid><srcstatus/><internalId>1543</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31186</srcid><srcstatus/><internalId>1585</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30335</srcid><srcstatus/><internalId>1760</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>412</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_TxConfirmation 
        Syntax 
        void CanIf_TxConfirmation (PduIdType CanTxPduId)
        Service ID [hex] | 0x13 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | CanTxPduId | L-PDU handle of CAN L-PDU successfully transmitted. This ID 
        specifies the corresponding CAN L-PDU ID and implicitly the CAN Driver instance as well as the 
        corresponding CAN controller device.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service confirms a previously successfully processed transmission of a CAN 
        TxPDU.
        Available via | CanIf_Can.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Transmit300Hths</srcid><srcstatus/><internalId>1544</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31192</srcid><srcstatus/><internalId>1587</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30213</srcid><srcstatus/><internalId>1745</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>413</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_SetPduMode 
        Syntax 
        Std_ReturnType CanIf_SetPduMode (uint8 ControllerId, CanIf_PduModeType PduModeRequest)
        Service ID [hex] | 0x09 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | ControllerId | All PDUs of the own ECU connected to the corresponding CanIf 
        ControllerId, which is assigned to a physical CAN controller are addressed.
        PduModeRequest | Requested PDU mode change 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request for mode transition has been accepted.E_NOT_OK: 
        Request for mode transition has not been accepted.
        Description | This service sets the requested mode at the L-PDUs of a predefined logical PDU 
        channel.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30841</srcid><srcstatus/><internalId>1447</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30250</srcid><srcstatus/><internalId>1470</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31181</srcid><srcstatus/><internalId>1583</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30307</srcid><srcstatus/><internalId>1734</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>414</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetPduMode 
        Syntax 
        Std_ReturnType CanIf_GetPduMode (uint8 ControllerId, CanIf_PduModeType* PduModePtr)
        Service ID [hex] | 0x0a 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant (Not for the same channel)
        Parameters (in) | ControllerId | All PDUs of the own ECU connected to the corresponding CanIf 
        ControllerId, which is assigned to a physical CAN controller are addressed.
        Parameters (inout) | None 
        Parameters (out) | PduModePtr | Pointer to a memory location, where the current mode of the 
        logical PDU channel will be stored.
        Return value | Std_ReturnType | E_OK: PDU mode request has been acceptedE_NOT_OK: PDU mode 
        request has not been accepted 
        Description | This service reports the current mode of a requested PDU channel.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30841</srcid><srcstatus/><internalId>1447</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30252</srcid><srcstatus/><internalId>1472</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30266</srcid><srcstatus/><internalId>1473</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31178</srcid><srcstatus/><internalId>1581</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30307</srcid><srcstatus/><internalId>1734</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>415</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_TxConfirmation&gt;
        Syntax 
        void &lt;User_TxConfirmation&gt; (PduIdType TxPduId, Std_ReturnType result)
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | TxPduId | ID of the PDU that has been transmitted.
        result | E_OK: The PDU was transmitted. E_NOT_OK: Transmission of the PDU failed.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | The lower layer communication interface module confirms the transmission of a PDU,
        or the failure to transmit a PDU.
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.User_TxConfirmation.Signature.Result.ON</srcid><srcstatus/><internalId>958</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>416</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_RxIndication&gt;
        Syntax 
        void &lt;User_RxIndication&gt; (PduIdType RxPduId, const PduInfoType* PduInfoPtr)
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | RxPduId | ID of the received PDU.
        PduInfoPtr | Contains the length (SduLength) of the received PDU, a pointer to a buffer (
        SduDataPtr) containing the PDU, and the MetaData related to this PDU.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | Indication of a received PDU from a lower layer communication interface module.
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ReceiveDuplicateId</srcid><srcstatus/><internalId>1423</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Receive300Hrhs</srcid><srcstatus/><internalId>1543</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31186</srcid><srcstatus/><internalId>1585</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>417</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_ControllerBusOff&gt;
        Syntax 
        void &lt;User_ControllerBusOff&gt; (uint8 ControllerId)
        Sync/Async | (defined within providing upper layer module)
        Reentrancy | (defined within providing upper layer module)
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller, at which a BusOff occurred.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates a bus-off event to the corresponding upper layer module (
        mainly the CAN State Manager module)
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30217</srcid><srcstatus/><internalId>1762</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>418</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00023</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall avoid direct access to hardware specific communication buffers and shall access it 
        exclusively via CanDrv interface services.
      </description>
      <comment>
        This requirement is informational only.
        This is an requirement onto the SWS itself.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>419</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00026</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall accept all received L-PDUs  with a Data Length value equal or greater then the 
        configured Data Length value 
      </description>
      <comment>
        Clarification: If DLC-check is enabled, then the CanIf accepts only received L-PDUs with a
                       received DLC equal or greater than the configured DLC value.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30846</srcid><srcstatus/><internalId>1497</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_InvalidDLC</srcid><srcstatus/><internalId>1498</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30334</srcid><srcstatus/><internalId>1759</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30335</srcid><srcstatus/><internalId>1760</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>420</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00030</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanId of the received L-PDU in the HRH is configured to be received, then CanIf shall 
        accept this L-PDU and the software filtering algorithm shall derive the corresponding Receive L-
        PDU from the found CanId.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00030_1</srcid><srcstatus/><internalId>422</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00030_2</srcid><srcstatus/><internalId>423</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00030_3</srcid><srcstatus/><internalId>424</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>421</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00030_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanIf has found the CanId of the received L-PDU in the list of receive
        CanIds (CanIfRxPduCanIds) for the HRH of the received L-PDU, then the CanIf shall accept
        this LPDU and the software filtering algorithm shall derive the receive
        L-PDU handle from the found CanId.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31144</srcid><srcstatus/><internalId>1556</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00030</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>422</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00030_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanIf has found the CanId of the received L-PDU in the list of receive
        CanId ranges (CanIfRxPduCanIdRange) for the HRH of the received L-PDU, then the CanIf shall accept
        this LPDU and the software filtering algorithm shall derive the receive
        L-PDU handle from the found CanId.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31144</srcid><srcstatus/><internalId>1556</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00030</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>423</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00030_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanId of the received L-PDU has been found in both CanId List (CanIfRxPduCanIds)
        and CaId range List (CanIfRxPduCanIdRange), then match in CanIfRxPduCanIds shall take precedence
        over CanIfRxPduCanIdRange.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31144</srcid><srcstatus/><internalId>1556</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00030</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>421</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>424</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00033</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall protect against concurrent access to Transmit L-PDU Buffer for transmit L-PDU and 
        Transmit Request.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.CanIf.DataProtection</srcid><srcstatus/><internalId>1315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>425</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00040</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        API Function | Header File | Description 
        Can_GetControllerErrorState | Can.h | This service obtains the error state of the CAN 
        controller.
        Can_GetControllerRxErrorCounter | Can.h | Returns the Rx error counter for a CAN controller. 
        This value might not be available for all CAN controllers, in which case E_NOT_OK would be 
        returned. Please note that the value of the counter might not be correct at the moment the API 
        returns it, because the Rx counter is handled asynchronously in hardware. Applications should 
        not trust this value for any assumption about the current bus state.
        Can_GetControllerTxErrorCounter | Can.h | Returns the Tx error counter for a CAN controller. 
        This value might not be available for all CAN controllers, in which case E_NOT_OK would be 
        returned. Please note that the value of the counter might not be correct at the moment the API 
        returns it, because the Tx counter is handled asynchronously in hardware. Applications should 
        not trust this value for any assumption about the current bus state.
        Can_SetControllerMode | Can.h | This function performs software triggered state transitions of 
        the CAN controller State machine.
        Can_Write | Can.h | This function is called by CanIf to pass a CAN message to CanDrv for 
        transmission.
        Det_ReportRuntimeError | Det.h | Service to report runtime errors. If a callout has been 
        configured then this callout shall be called.
        SchM_Enter_CanIf | SchM_&lt;Mip&gt;.h | Invokes the SchM_Enter function to enter a module local 
        exclusive area.
        SchM_Exit_CanIf | SchM_&lt;Mip&gt;.h | Invokes the SchM_Exit function to exit an exclusive area.
      </description>
      <comment>
        This requirement is informational only.
        This is just a list of mandatory interfaces provided by other modules.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>426</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00056</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf accepts a L-PDU received via CanIf_RxIndication() during Data Length Check , CanIf 
        shall identify if a target upper layer module was configured  to be called with its providing 
        receive indication service for the received L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00135</srcid><srcstatus/><internalId>452</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>427</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00063</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanIf shall support buffering of a CAN L-PDU for BasicCAN transmission in the CanIf, if 
        parameter CanIfPublicCfg.CanIfPublicTxBuffering  is enabled.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxBufferCancel300Hths</srcid><srcstatus/><internalId>1545</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30318</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31235</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoBufferingFullCanHth</srcid><srcstatus/><internalId>1724</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>428</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00064</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall protect preemptive events, which access shared resources, that could be changed 
        during CanIf's event handling, against each other.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.CanIf.DataProtection</srcid><srcstatus/><internalId>1315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>429</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00068</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If it is possible to buffer a CanIf Tx L-PDU or a Transmit Request, because the buffer size of 
        the assigned CanIfTxBuffer is bigger than zero , CanIf shall overwrite direct transmitted CanIf 
        Tx L-PDU in the assigned CanIfTxBuffer, if the CanIf Tx L-PDU is already buffered in the 
        CanIfTxBuffer when Can_Write() returns CAN_BUSY.
      </description>
      <comment>
        No overwrite of pending (buffered) dynamic transmit L-PDUs with the same L-PDU IDs
        and different CAN IDs occurs.
      AUTOSAR R20-11 comment: Unchanged until CanIf_TriggerTransmit() will be implemented.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_FdBufferOverwrite</srcid><srcstatus/><internalId>1410</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30318</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30408</srcid><srcstatus/><internalId>1726</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30409</srcid><srcstatus/><internalId>1727</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>430</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00070</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall transmit L-PDU or Transmit Request stored in the Transmit L-PDU Buffer in priority 
        order  per each HTH. CanIf shall not differentiate between L-PDU and Transmit Request.
      </description>
      <comment>
        This requirement is informational only.
        Already covered by CanIf.SWS_CanIf_00668.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>431</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00072</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For every L-PDU assigned to a channel which is in CANIF_TX_OFFLINE_ACTIVE mode CanIf shall call 
        the transmit confirmation callback services of the upper layer modules immediately instead of 
        buffering or forwarding of the L-PDU to CanDrv during the call of CanIf_Transmit(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30311</srcid><srcstatus/><internalId>1739</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30312</srcid><srcstatus/><internalId>1740</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00317</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>432</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00073</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For Physical Channel switching to CANIF_OFFLINE mode CanIf shall:
        prevent forwarding of transmit requests CanIf_Transmit() of associated L-PDU to CanDrv (return 
        E_NOT_OK to the calling upper layer modules)
        clear the corresponding CanIf transmit buffers,
        prevent invocation of receive indication callback services of the upper layer modules,
        prevent invocation of transmit confirmation callback services of the upper layer modules.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00073_1</srcid><srcstatus/><internalId>434</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00073_2</srcid><srcstatus/><internalId>435</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00073_3</srcid><srcstatus/><internalId>436</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00073_4</srcid><srcstatus/><internalId>437</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00073.PendingConfirmations</srcid><srcstatus/><internalId>438</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>433</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00073_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        After function CanIf_SetPduMode(ControllerId, CANIF_OFFLINE) has been
        called, the CanIf shall prevent forwarding of the transmit request calls 
        CanIf_Transmit() to the CanDrv (returning E_NOT_OK to the calling upper layer modules).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30308</srcid><srcstatus/><internalId>1735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
         <provcov>
           <linksto>CanIf.SWS_CanIf_00073</linksto>
           <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
         <provcov>
           <linksto>CanIf.SWS_CanIf_00317</linksto>
           <dstversion>1</dstversion>
         <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>434</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00073_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
         After function CanIf_SetPduMode(ControllerId, CANIF_OFFLINE) has been
         called, the CanIf shall deal with all L-PDUSs, which are assigned to the
         physical channel as follows clear the corresponding CanIf transmit buffers.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30308</srcid><srcstatus/><internalId>1735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanIf.SWS_CanIf_00073</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>435</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00073_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
         After function CanIf_SetPduMode(ControllerId, CANIF_OFFLINE) has been
         called, the CanIf shall prevent invocation of receive
         indication callback services of the upper layer  modules.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30308</srcid><srcstatus/><internalId>1735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanIf.SWS_CanIf_00073</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>436</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00073_4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
         After function CanIf_SetPduMode(ControllerId, CANIF_OFFLINE) has been
         called, the CanIf shall deal with all L-PDUSs, which are assigned to the
         physical channel as follows prevent invocation of transmit 
         confirmation callback services of the upper layer modules.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BlockTxConfirmation</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>dev.UseCanIfPduModeTypeInsteadCanIf_PduSetModeTypeAndCanIf_PduGetModeType</srcid><srcstatus/><internalId>1089</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanIf.SWS_CanIf_00073</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>437</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00073.PendingConfirmations</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
      After function CanIf_SetPduMode(ControllerId, CANIF_OFFLINE) has been
      called, the CanIf shall deal with all L-PDUSs, which are assigned to the
      physical channel as follows:
      - forward transmit confirmations to the upper layer module for all pending
        confirmations (LPDUs transmitted before Pdu mode set to CANIF_OFFLINE).
      - prevent invocation of transmit confirmation callback services of the
        upper layer modules for all other LPDUs.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30808</srcid><srcstatus/><internalId>1748</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanIf.SWS_CanIf_00073</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>433</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>438</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00075</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For Physical Channel switching to CANIF_ONLINE mode CanIf shall:
        enable forwarding of transmit requests CanIf_Transmit() of associated L-PDU to CanDrv,
        enable invocation of receive indication callback services of the upper layer modules,
        enable invocation of transmit confirmation callback services of the upper layer modules.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00075_1</srcid><srcstatus/><internalId>440</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00075_2</srcid><srcstatus/><internalId>441</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00075_3</srcid><srcstatus/><internalId>442</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>439</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00075_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For Physical Channels switching to CANIF_ONLINE mode CanIf shall:
          -enable forwarding of transmit requests CanIf_Transmit() of associated LPDUs to CanDrv
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30309</srcid><srcstatus/><internalId>1736</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30310</srcid><srcstatus/><internalId>1738</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>440</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00075_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For Physical Channels switching to CANIF_ONLINE mode CanIf shall:
          -enable invocation of receive indication callback services of the upper layer modules
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30310</srcid><srcstatus/><internalId>1738</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>441</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00075_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For Physical Channels switching to CANIF_ONLINE mode CanIf shall:
          -enable invocation of transmit confirmation callback services of the upper layer modules
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30321</srcid><srcstatus/><internalId>1737</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30310</srcid><srcstatus/><internalId>1738</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00075</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>439</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>442</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00085</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The service CanIf_Init() shall initialize the global variables and data structures of the CanIf 
        including flags and buffers.
      </description>
      <comment>
        - all controller shall be in CANIF_OFFLINE
        - all Tx-Buffers shall be empty
        - Tx/Rx notifications shall be inactive
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31184</srcid><srcstatus/><internalId>1584</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30293</srcid><srcstatus/><internalId>1713</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30367</srcid><srcstatus/><internalId>1714</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30881</srcid><srcstatus/><internalId>1715</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30407</srcid><srcstatus/><internalId>1716</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>443</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00115</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall be able to use all HRH and HTH of one CanDrv as common, single numbering area 
        starting with zero.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00115.HohIdDerivedFromCan</srcid><srcstatus/><internalId>445</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>444</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00115.HohIdDerivedFromCan</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The dedicated HRH and HTHs are derived from the configuration set of the CanDrv.
      The definition of HTH/HRH inside the numbering area and hardware objects is up to
      the CanDrv.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_Transmit300Hths</srcid><srcstatus/><internalId>1544</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00115</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>444</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>445</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00115.OverlapNumberArea</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        It has to be ensured by configuration, that no overlapping of several
      numbering areas of multiple CanDrvs is allowed.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MULTIDRV_TRANSMIT</srcid><srcstatus/><internalId>1547</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_RXINDICATION</srcid><srcstatus/><internalId>1548</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_SETBAUDRATE</srcid><srcstatus/><internalId>1549</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CHECKWAKEUP</srcid><srcstatus/><internalId>1550</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1551</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1552</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CANCELTXCONFIRMATION</srcid><srcstatus/><internalId>1553</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CONTROLLERBUSOFF</srcid><srcstatus/><internalId>1554</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_OFFSETTXBUFF</srcid><srcstatus/><internalId>1555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>446</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00118</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If those Transmit L-PDU, which are already waiting for transmission in the CAN Transmit 
        Hardware Object, will be transmitted immediately after change to CANIF_TX_OFFLINE or 
        CANIF_OFFLINE mode and a subsequent BusOff event occurs, CanIf does not prohibit execution of 
        the BusOff notification &lt;User_ControllerBusOff&gt;(ControllerId)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00118_1</srcid><srcstatus/><internalId>449</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00118_2</srcid><srcstatus/><internalId>450</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>447</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00118.PduMode.WakeupNotification</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The wake up notification is not affected concerning mode PDU channel changes.
      </description>
         <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30806</srcid><srcstatus/><internalId>1609</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>448</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00118_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If those transmit L-PDUs, which are already waiting for transmission in the CAN
        hardware transmit object, will be transmitted immediately after change to
        CANIF_TX_OFFLINE  mode and a subsequent BusOff
        event occurs, the CanIf does not prohibit execution of the BusOff
        notification &lt;User_ControllerBusOff&gt;(ControllerId).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30805</srcid><srcstatus/><internalId>1763</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00118</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>449</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00118_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If those transmit L-PDUs, which are already waiting for transmission in the CAN
        hardware transmit object, will be transmitted immediately after change to
        CANIF_OFFLINE mode and a subsequent BusOff event occurs, the CanIf does not prohibit execution of the BusOff
        notification &lt;User_ControllerBusOff&gt;(ControllerId).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30805</srcid><srcstatus/><internalId>1763</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00118</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>447</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>450</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00119</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Additional errors that are detected because of specific implementation and/or specific hardware 
        properties shall be added in the CanIf specific implementation specification. For doing that, 
        the classification and enumeration listed below can be extended with incremented enumerations.
      </description>
      <comment>
        This requirement is not applicable.
        No further errors are defined.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>451</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00135</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If a target upper layer module was configured to be called with its providing receive 
        indication service , the CanIf shall call this configured receive indication callback service  
        and shall provide the parameters required for upper layer notification callback functions  
        based on the parameters of CanIf_RxIndication(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ReceiveDuplicateId</srcid><srcstatus/><internalId>1423</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Receive300Hrhs</srcid><srcstatus/><internalId>1543</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31186</srcid><srcstatus/><internalId>1585</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00056</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>427</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>452</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00142</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Module | Header File | Imported Type 
        Can | Can_GeneralTypes.h | Can_ControllerStateType 
        Can_GeneralTypes.h | Can_ErrorStateType 
        Can_GeneralTypes.h | Can_ErrorType 
        Can_GeneralTypes.h | Can_HwHandleType 
        Can_GeneralTypes.h | Can_HwType 
        Can_GeneralTypes.h | Can_IdType 
        Can_GeneralTypes.h | Can_PduType 
        CanTrcv | Can_GeneralTypes.h | CanTrcv_TrcvModeType 
        Can_GeneralTypes.h | CanTrcv_TrcvWakeupModeType 
        Can_GeneralTypes.h | CanTrcv_TrcvWakeupReasonType 
        ComStack_Types | ComStack_Types.h | PduIdType 
        ComStack_Types.h | PduInfoType 
        ComStack_Types.h | PduLengthType 
        EcuM | EcuM.h | EcuM_WakeupSourceType 
        IdsM | IdsM_Types.h | IdsM_SecurityEventIdType 
        Std | Std_Types.h | Std_ReturnType 
        Std_Types.h | Std_VersionInfoType 
      </description>
      <comment>
        This requirement is informational only.
        Just a list of imported type definitions.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>453</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00158</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetVersionInfo 
        Syntax 
        void CanIf_GetVersionInfo (Std_VersionInfoType* VersionInfo)
        Service ID [hex] | 0x0b 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | VersionInfo | Pointer to where to store the version information of this 
        module.
        Return value | None 
        Description | This service returns the version information of the called CAN Interface module.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30856</srcid><srcstatus/><internalId>1474</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30209</srcid><srcstatus/><internalId>1743</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>454</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00168</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the Data Length Check rejects a received L-PDU , CanIf shall report runtime error code 
        CANIF_E_INVALID_DATA_LENGTH to the Det_ReportRuntimeError() service of the DET module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PartiallyImplemented</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR42.SWS_CanIf_00168</srcid><srcstatus/><internalId>325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>455</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00178</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_CheckValidation 
        Syntax 
        Std_ReturnType CanIf_CheckValidation (EcuM_WakeupSourceType WakeupSource)
        Service ID [hex] | 0x12 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | WakeupSource | Source device which initiated the wake-up event and which has 
        to be validated: CAN controller or CAN transceiver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Will be returned, if the check validation request has 
        been accepted.E_NOT_OK: Will be returned, if the check validation request has not been accepted.
        Description | This service is performed to validate a previous wakeup event.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30838</srcid><srcstatus/><internalId>1450</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30854</srcid><srcstatus/><internalId>1485</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31203</srcid><srcstatus/><internalId>1591</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NmWuValidWithCanNmPdu</srcid><srcstatus/><internalId>1592</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NmWuValidWithPduRPdu</srcid><srcstatus/><internalId>1593</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30338</srcid><srcstatus/><internalId>1611</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30834</srcid><srcstatus/><internalId>1612</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>456</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00179</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        User_ValidateWakeupEvent&gt;(sources) shall be called during CanIf_CheckValidation(WakeupSource), 
        whereas sources is set to WakeupSource, if the event of the first called CanIf_RxIndication() 
        is stored in CanIf at the corresponding CAN Controller.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NmWuValidWithCanNmPdu</srcid><srcstatus/><internalId>1592</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30338</srcid><srcstatus/><internalId>1611</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RepeatedWuValid</srcid><srcstatus/><internalId>1616</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>457</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00180</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall provide wake-up service CanIf_CheckWakeup() only, if
        - underlying CAN Controller provides wake-up support and wake-up is enabled by the parameter 
          CanIfCtrlCfg.CanIfCtrlWakeupSupport and by CanDrv configuration.
        - and/or underlying CAN Transceiver provides wake-up support and wake-up is enabled by the 
          parameter CanIfTrcvCfg.CanIfTrcvWakeupSupport and by CanTrcv configuration.
        - and configuration parameter CanIfPublicCfg.CanIfWakeupSupport is enabled.
      </description>
      <comment>
        PB-Issue: existence of CanIf_CheckWakeup() (pre-compile) depends on
                  CANIF_CONTROLLER_WAKEUP_SUPPORT (post-build) and CanDrv config (unknown class).
        PB-Issue: existence of CanIf_CheckWakeup() (pre-compile) depends on
                  CANIF_TRANSCEIVER_WAKEUP_SUPPORT (post-build) and CanDrv config (unknown class).
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00180_1</srcid><srcstatus/><internalId>459</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00180_2</srcid><srcstatus/><internalId>460</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00180_3</srcid><srcstatus/><internalId>461</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00180_4</srcid><srcstatus/><internalId>462</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00180_5</srcid><srcstatus/><internalId>463</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00180_6</srcid><srcstatus/><internalId>464</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00402</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>81</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>458</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00180_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanIf shall provide wake-up service CanIf_CheckWakeup(), if
      wake-up is enabled by the parameter CanIfCtrlWakeupSupport (see CanIf.ECUC_CanIf_00637)
      for at least a single configured Can controller.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00180</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>459</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00180_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanIf shall provide wake-up service CanIf_CheckWakeup(), if
      wake-up is enabled by the parameter CanIfTrcvWakeupSupport (see CanIf.ECUC_CanIf_00606)
      for any configured Can transceiver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_TrcvAvailability</srcid><srcstatus/><internalId>1351</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOf_403_and_422_Trcv_UsedTrcv</srcid><srcstatus/><internalId>1416</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOfUsedTrcv</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_ParametersRelatedTo_PnSupport_SetTo_FALSE</srcid><srcstatus/><internalId>1569</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00180</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>460</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00180_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanIf shall not provide wake-up service CanIf_CheckWakeup(), if
      - wake-up is disabled by the parameter CanIfCtrlWakeupSupport (see CanIf.ECUC_CanIf_00637)
        for all configured Can controllers
      AND
      - wake-up is disabled by the parameter CanIfTrcvWakeupSupport (see CanIf.ECUC_CanIf_00606)
        for all configured Can transceivers
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ComTest_NoWuCheck</srcid><srcstatus/><internalId>1334</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_NoCheckWu</srcid><srcstatus/><internalId>1703</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00180</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>461</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00180_4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
          Check that the CanTrcv wakeup configuration (enabled, disabled) is consistent with
          the CanIf configuration parameter CanIfTrcvWakeupSupport
          for each particular configured transceiver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3484</srcid><srcstatus/><internalId>1280</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3493</srcid><srcstatus/><internalId>1281</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00180</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>462</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00180_5</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
          Check that the CanDrv wakeup configuration (enabled, disabled) is consistent with
          the CanIf configuration parameter CanIfCtrlWakeupSupport
          for each particular configured controller.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_260</srcid><srcstatus/><internalId>1252</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00180</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>463</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00180_6</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanIf shall provide wake-up service CanIf_CheckWakeup(), if
      configuration parameter CanIfPublicCfg.CanIfWakeupSupport is enabled.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIfWakeupSupport</srcid><srcstatus/><internalId>1096</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00180</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>458</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>464</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00183</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When CanIf calls the function Can_Write() for prioritized L-PDU and Transmit Request stored in 
        CanIfTxBuffer and the return value of Can_Write() is E_OK, then CanIf shall remove this L-PDU 
        or Transmit Request from the Transmit L-PDU Buffer immediately, before the transmit 
        confirmation returns.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxBufferCancel300Hths</srcid><srcstatus/><internalId>1545</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30318</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31235</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30332</srcid><srcstatus/><internalId>1746</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30343</srcid><srcstatus/><internalId>1747</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30344</srcid><srcstatus/><internalId>1752</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>465</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00188</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall process the two most significant bits of the CanId  to determine which type of 
        CanId is used and thus how the dynamic Transmit L-PDU shall be transmitted.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00188_1</srcid><srcstatus/><internalId>467</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00188_2</srcid><srcstatus/><internalId>468</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>466</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00188_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The most significant bit of variables of type Can_IdType contains the identifier extension flag.
      If this MSb is set to 1, then the CanId is extended (29bit), otherwise a standard CanId (11bit).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_FdBuffering</srcid><srcstatus/><internalId>1409</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31229</srcid><srcstatus/><internalId>1774</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31230</srcid><srcstatus/><internalId>1775</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00188</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>467</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00188_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The second most significant bit of variables of type Can_IdType contain the identifier CAN-FD/CAN-2.0 flags.
        If the second MSb is set to 1, then the CanId is CAN-FD, otherwise a CAN-2.0 CanId.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_FdBuffering</srcid><srcstatus/><internalId>1409</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00188</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>466</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>468</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00189</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_SetDynamicTxId 
        Syntax 
        void CanIf_SetDynamicTxId (PduIdType CanIfTxSduId, Can_IdType CanId)
        Service ID [hex] | 0x0c 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CanIfTxSduId | L-SDU handle to be transmitted. This handle specifies the 
        corresponding CAN L-SDU ID and implicitly the CAN Driver instance as well as the corresponding 
        CAN controller device.
        CanId | Standard/Extended CAN ID of CAN L-SDU that shall be transmitted as FD or conventional 
        CAN frame.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service reconfigures the corresponding CAN identifier of the requested CAN L-
        PDU.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00189</srcid><srcstatus/><internalId>242</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ChangedParameters</srcid><srcstatus/><internalId>1102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>469</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00194</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ReadRxPduData 
        Syntax 
        Std_ReturnType CanIf_ReadRxPduData (PduIdType CanIfRxSduId, PduInfoType* CanIfRxInfoPtr)
        Service ID [hex] | 0x06 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CanIfRxSduId | Receive L-SDU handle specifying the corresponding CAN L-SDU ID 
        and implicitly the CAN Driver instance as well as the corresponding CAN controller device.
        Parameters (inout) | None 
        Parameters (out) | CanIfRxInfoPtr | Contains the length (SduLength) of the received PDU, a 
        pointer to a buffer (SduDataPtr) containing the PDU, and the MetaData related to this PDU.
        Return value | Std_ReturnType | E_OK: Request for L-SDU data has been acceptedE_NOT_OK: No 
        valid data has been received 
        Description | This service provides the Data Length and the received data of the requested 
        CanIfRxSduId to the calling upper layer.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ChangedParameters</srcid><srcstatus/><internalId>1102</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00194</srcid><srcstatus/><internalId>61</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>470</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00198</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the configuration parameter CanIfPublicCfg.CanIfPublicReadRxPduDataApi is set to TRUE, CanIf 
        shall store each received L-SDU, at which CanIfRxPduCfg.CanIfRxPduReadData is enabled, into a 
        receive L-SDU buffer. This means that if the configuration parameter CanIfRxPduCfg.
        CanIfRxPduReadData is set to TRUE, CanIf has to allocate a receive L-SDU buffer for this 
        receive L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30298</srcid><srcstatus/><internalId>1731</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>471</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00198_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_ReadRxPduData() makes reading out data without dependence of reception
        event (RxIndication) possible.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_40180</srcid><srcstatus/><internalId>1685</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>472</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00199</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        After call of CanIf_RxIndication() and passing of software filtering and Data Length Check, 
        CanIf shall store the received L-SDU in this receive L-SDU buffer. During the call of 
        CanIf_ReadRxPduData() the assigned receive L-SDU buffer containing a recently received L-SDU, 
        CanIf shall avoid preemptive receive L-SDU buffer access events (refer toSWS_CANIF_00064) to 
        that receive L-SDU buffer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00199_1</srcid><srcstatus/><internalId>474</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00199_2</srcid><srcstatus/><internalId>475</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>473</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00199_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        After call of CanIf_RxIndication() and passing of software filtering and DLC
      check, the CanIf shall store the received L-PDU in this receive L-PDU
      buffer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30298</srcid><srcstatus/><internalId>1731</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00199</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>473</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>474</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00199_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        During the call of CanIf_ReadRxPduData() the assigned receive
      L-PDU buffer containing a recently received L-PDU, the CanIf shall avoid
      preemptive receive L-PDU buffer access events (refer to CanIf.SWS_CanIf_00064)
      to that receive L-PDU buffer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.CanIf.DataProtection</srcid><srcstatus/><internalId>1315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00199</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>473</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>475</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00202</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ReadTxNotifStatus 
        Syntax 
        CanIf_NotifStatusType CanIf_ReadTxNotifStatus (PduIdType CanIfTxSduId)
        Service ID [hex] | 0x07 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CanIfTxSduId | L-SDU handle to be transmitted. This handle specifies the 
        corresponding CAN L-SDU ID and implicitly the CAN Driver instance as well as the corresponding 
        CAN controller device.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | CanIf_NotifStatusType | Current confirmation status of the corresponding CAN Tx 
        L-PDU.
        Description | This service returns the confirmation status (confirmation occurred or not) of a 
        specific static or dynamic CAN Tx L-PDU, requested by the CanIfTxSduId.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00202</srcid><srcstatus/><internalId>243</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ChangedParameters</srcid><srcstatus/><internalId>1102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>476</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00211</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall execute the software acceptance filter from SWS_CANIF_00469 for the HRH passed by 
        callback function CanIf_RxIndication(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_RX_CANID</srcid><srcstatus/><internalId>1511</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30333</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>477</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00218</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ControllerBusOff 
        Syntax 
        void CanIf_ControllerBusOff (uint8 ControllerId)
        Service ID [hex] | 0x16 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | ControllerId | Abstract CanIf ControllerId which is assigned to a CAN 
        controller, where a BusOff occured.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates a Controller BusOff event referring to the corresponding 
        CAN Controller with the abstract CanIf ControllerId.
        Available via | CanIf_Can.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30217</srcid><srcstatus/><internalId>1762</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>478</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00219</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_CheckWakeup 
        Syntax 
        Std_ReturnType CanIf_CheckWakeup (EcuM_WakeupSourceType WakeupSource)
        Service ID [hex] | 0x11 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant 
        Parameters (in) | WakeupSource | Source device, which initiated the wake up event: CAN 
        controller or CAN transceiver 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Will be returned, if the check wake up request has been 
        acceptedE_NOT_OK: Will be returned, if the check wake up request has not been accepted 
        Description | This service checks, whether an underlying CAN driver or a CAN transceiver driver 
        already signals a wakeup event.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>479</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00223</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For all defined production errors it is only required to report the event, when an error or 
        diagnostic relevant event (e.g. state changes, no L-PDU events) occurs. Any status has not to 
        be reported.
      </description>
      <comment>
        This requirement is not applicable.
        No Production errors are defined.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>480</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00226</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall provide wake-up service CanIf_CheckValidation() only, if
        underlying CAN Controller provides wake-up support and wake-up is enabled by the parameter 
        CanIfCtrlCfg.CanIfCtrlWakeupSupport and by CanDrv configuration
        and/or underlying CAN Transceiver provides wake-up support and wake-up is enabled by the 
        parameter CanIfTrcvCfg.CanIfTrcvWakeupSupport and by CanTrcv configuration
        and configuration parameter CanIfPublicCfg.CanIfPublicWakeupCheckValidSupport is enabled.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00226_1</srcid><srcstatus/><internalId>482</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00226_2</srcid><srcstatus/><internalId>483</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00408</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>553</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>481</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00226_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanIf shall provide wake-up service CanIf_CheckValidation(), if
      - configuration parameter CanIfPublicWakeupCheckValidSupport
        (see CanIf.ECUC_CanIf_00611) is enabled.
      AND
        - CanIfCtrlWakeupSupport (see CanIf.ECUC_CanIf_00637) is enabled for a single controller
        OR
        - CanIfTrcvWakeupSupport (see CanIf.ECUC_CanIf_00606) is enabled for a single transceiver
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00226</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>482</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00226_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
      The CanIf shall not provide wake-up service CanIf_CheckValidation(), if
      - configuration parameter CanIfPublicWakeupCheckValidSupport
        (see CanIf.ECUC_CanIf_00611) is disabled.
      AND
      - CanIfCtrlWakeupSupport/CanIfTrcvWakeupSupport is disabled for all
        controllers/transceivers.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ComTest_NoValidWu</srcid><srcstatus/><internalId>1333</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_NoWuValid</srcid><srcstatus/><internalId>1702</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00226</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>481</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>483</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00229</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetControllerMode 
        Syntax 
        Std_ReturnType CanIf_GetControllerMode (uint8 ControllerId, Can_ControllerStateType* 
        ControllerModePtr)
        Service ID [hex] | 0x04 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller, which is requested for current operation mode.
        Parameters (inout) | None 
        Parameters (out) | ControllerModePtr | Pointer to a memory location, where the current mode of 
        the CAN controller will be stored.
        Return value | Std_ReturnType | E_OK: Controller mode request has been accepted.E_NOT_OK: 
        Controller mode request has not been accepted.
        Description | This service calls the corresponding CAN Driver service for obtaining the current 
        status of the CAN controller.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.GetControllerMode.Signature.Mirroring.ON</srcid><srcstatus/><internalId>957</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>484</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00230</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ReadRxNotifStatus 
        Syntax 
        CanIf_NotifStatusType CanIf_ReadRxNotifStatus (PduIdType CanIfRxSduId)
        Service ID [hex] | 0x08 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | CanIfRxSduId | Receive L-SDU handle specifying the corresponding CAN L-SDU ID 
        and implicitly the CAN Driver instance as well as the corresponding CAN controller device.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | CanIf_NotifStatusType | Current indication status of the corresponding CAN Rx L-
        PDU.
        Description | This service returns the indication status (indication occurred or not) of a 
        specific CAN Rx L-PDU, requested by the CanIfRxSduId.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00230</srcid><srcstatus/><internalId>244</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ChangedParameters</srcid><srcstatus/><internalId>1102</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>485</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00243</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall set the two most significant bits ('IDentifier Extension flag'  and 'CAN FD flag') 
        of the CanId (PduInfoPtr-&gt;id) before CanIf passes the predefined CanId to CanDrv at call of 
        Can_Write() . The CanId format type of each CAN L-PDU can be configured by CanIfTxPduCfg.
        CanIfTxPduCanIdType, refer to CanIfTxPduCfg.CanIfTxPduCanIdType.
      </description>
      <comment>
        CanIf cannot set the IDE bit as this is in the hand of Can driver. This requriement is
          interpreted the following way in accordance with Can driver SWS (requirement CAN423):
          - If the Can-frame is configured for tx as extended Can-Id,
            set the MSB of Can_Write() argument CanId to 1.
          - If the Can-frame is configured for tx as standard CanId,
            set the MSB of Can_Write() argument CanId to 0.
          - If the Can-Frame is configured for tx as CAN-FD frame,
            set the second MSB of Can_Write() argument CanId to 1.
          - If the Can-Frame is configured for tx as CAN-2.0 frame,
            set the second MSB of Can_Write() argument CanId to 0.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CANFD_BIT_EXTENDED_ADDR</srcid><srcstatus/><internalId>1428</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CANFD_BIT_STANDARD_ADDR</srcid><srcstatus/><internalId>1546</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31229</srcid><srcstatus/><internalId>1774</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31230</srcid><srcstatus/><internalId>1775</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31233</srcid><srcstatus/><internalId>1776</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>486</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00281</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall accept and handle StandardCAN IDs and ExtendedCAN IDs on the same Physical Channel 
        mixed mode operation)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30795</srcid><srcstatus/><internalId>1755</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>487</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00287</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_SetTrcvMode 
        Syntax 
        Std_ReturnType CanIf_SetTrcvMode (uint8 TransceiverId, CanTrcv_TrcvModeType TransceiverMode)
        Service ID [hex] | 0x0d 
        Sync/Async | Asynchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TransceiverId | Abstracted CanIf TransceiverId, which is assigned to a CAN 
        transceiver, which is requested for mode transition 
        TransceiverMode | Requested mode transition 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Transceiver mode request has been accepted.E_NOT_OK: 
        Transceiver mode request has not been accepted.
        Description | This service changes the operation mode of the tansceiver TransceiverId, via 
        calling the corresponding CAN Transceiver Driver service.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30420_MultiIds</srcid><srcstatus/><internalId>1354</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30420_1Trcv</srcid><srcstatus/><internalId>1371</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30420</srcid><srcstatus/><internalId>1379</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30839</srcid><srcstatus/><internalId>1449</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30848</srcid><srcstatus/><internalId>1477</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>488</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00288</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetTrcvMode 
        Syntax 
        Std_ReturnType CanIf_GetTrcvMode (uint8 TransceiverId, CanTrcv_TrcvModeType* TransceiverModePtr)
        Service ID [hex] | 0x0e 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TransceiverId | Abstracted CanIf TransceiverId, which is assigned to a CAN 
        transceiver, which is requested for current operation mode.
        Parameters (inout) | None 
        Parameters (out) | TransceiverModePtr | Requested mode of requested network the Transceiver is 
        connected to.
        Return value | Std_ReturnType | E_OK: Transceiver mode request has been accepted.E_NOT_OK: 
        Transceiver mode request has not been accepted.
        Description | This function invokes CanTrcv_GetOpMode and updates the parameter 
        TransceiverModePtr with the value OpMode provided by CanTrcv.
        Available via | CanIf.h 
      </description>
      <comment>
        When Mirroring is enabled the API is exposed as stated in the AR4.4.0 SWS.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00288.MirroringEnabled</srcid><srcstatus/><internalId>490</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.GetTrcvModeSignature</srcid><srcstatus/><internalId>1091</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>489</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00288.MirroringEnabled</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service name: CanIf_GetTrcvMode
        Syntax: Std_ReturnType CanIf_GetTrcvMode(
                  uint8 TransceiverId,
                  CanTrcv_TrcvModeType * TransceiverModePtr
                )
        Service ID[hex]: 0x0e
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): TransceiverId Abstracted CanIf TransceiverId, which is assigned
                         to a CAN transceiver, which is requested for current operation mode.
        Parameters (inout): None
        Parameters (out): TransceiverModePtr Requested mode of requested network the
                          Transceiver is connected to.
        Return value: Std_ReturnType E_OK: Transceiver mode request has been accepted.
                                     E_NOT_OK: Transceiver mode request has not been accepted.
        Description: This function invokes CanTrcv_GetOpMode and updates the parameter
                     TransceiverModePtr with the value OpMode provided by CanTrcv.
        Available via: CanIf.h
      </description>
      <comment>
        When Mirroring is enabled the API is exposed as stated in the AR4.4.0 SWS.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_APIS_MIRROR</srcid><srcstatus/><internalId>1327</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00288</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>489</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>490</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00289</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetTrcvWakeupReason 
        Syntax 
        Std_ReturnType CanIf_GetTrcvWakeupReason (uint8 TransceiverId, CanTrcv_TrcvWakeupReasonType* 
        TrcvWuReasonPtr)
        Service ID [hex] | 0x0f 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TransceiverId | Abstracted CanIf TransceiverId, which is assigned to a CAN 
        transceiver, which is requested for wake up reason.
        Parameters (inout) | None 
        Parameters (out) | TrcvWuReasonPtr | provided pointer to where the requested transceiver wake 
        up reason shall be returned 
        Return value | Std_ReturnType | E_OK: Transceiver wake up reason request has been accepted.
        E_NOT_OK: Transceiver wake up reason request has not been accepted.
        Description | This service returns the reason for the wake up of the transceiver TransceiverId,
        via calling the corresponding CAN Transceiver Driver service.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30430_MultiIds</srcid><srcstatus/><internalId>1356</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30430_1Trcv</srcid><srcstatus/><internalId>1373</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30430</srcid><srcstatus/><internalId>1381</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30839</srcid><srcstatus/><internalId>1449</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30850</srcid><srcstatus/><internalId>1481</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTrcvWuReasonNullPtr</srcid><srcstatus/><internalId>1482</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>491</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00290</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_SetTrcvWakeupMode 
        Syntax 
        Std_ReturnType CanIf_SetTrcvWakeupMode (uint8 TransceiverId, CanTrcv_TrcvWakeupModeType 
        TrcvWakeupMode)
        Service ID [hex] | 0x10 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TransceiverId | Abstracted CanIf TransceiverId, which is assigned to a CAN 
        transceiver, which is requested for wake up notification mode transition.
        TrcvWakeupMode | Requested transceiver wake up notification mode 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Will be returned, if the wake up notifications state has 
        been changed to the requested mode.E_NOT_OK: Will be returned, if the wake up notifications 
        state change has failed or the parameter is out of the allowed range. The previous state has 
        not been changed.
        Description | This function shall call CanTrcv_SetTrcvWakeupMode.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30432_MultiIds</srcid><srcstatus/><internalId>1357</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30432_1Trcv</srcid><srcstatus/><internalId>1374</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30432</srcid><srcstatus/><internalId>1382</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30839</srcid><srcstatus/><internalId>1449</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30849</srcid><srcstatus/><internalId>1483</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>492</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00291</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Definition of HRH: The HRH shall be a handle referencing a logical Hardware Receive Object of 
        the CAN Controller mailbox.
      </description>
      <comment>
        This requirement is informational only.
        Descriptive text, no requirement.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>493</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00292</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Definition of HTH: The HTH shall be a handle referencing a logical Hardware Transmit Object of 
        the CAN Controller mailbox.
      </description>
      <comment>
        This requirement is informational only.
      Descriptive text, no requirement
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>494</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00294</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        API Function | Header File | Description 
        Can_CheckWakeup | Can.h | This function checks if a wakeup has occurred for the given 
        controller.
        Can_SetBaudrate | Can.h | This service shall set the baud rate configuration of the CAN 
        controller. Depending on necessary baud rate modifications the controller might have to reset.
        CanNm_RxIndication | J1939Nm.h | Indication of a received PDU from a lower layer communication 
        interface module.
        CanNm_TxConfirmation | J1939Nm.h | The lower layer communication interface module confirms the 
        transmission of a PDU, or the failure to transmit a PDU.
        CanSM_CheckTransceiverWakeFlagIndication | CanSM_CanIf.h | This callback function indicates the 
        CanIf_CheckTrcvWakeFlag API process end for the notified CAN Transceiver.
        CanSM_ClearTrcvWufFlagIndication | CanSM_CanIf.h | This callback function shall indicate the 
        CanIf_ClearTrcvWufFlag API process end for the notified CAN Transceiver.
        CanSM_ConfirmPnAvailability | CanSM_CanIf.h | This callback function indicates that the 
        transceiver is running in PN communication mode.
        CanSM_ControllerBusOff | CanSM_CanIf.h | This callback function notifies the CanSM about a bus-
        off event on a certain CAN controller, which needs to be considered with the specified bus-off 
        recovery handling for the impacted CAN network.
        CanSM_ControllerModeIndication | CanSM_CanIf.h | This callback shall notify the CanSM module 
        about a CAN controller mode change.
        CanSM_TransceiverModeIndication | CanSM_CanIf.h | This callback shall notify the CanSM module 
        about a CAN transceiver mode change.
        CanTp_RxIndication | J1939Nm.h | Indication of a received PDU from a lower layer communication 
        interface module.
        CanTp_TxConfirmation | J1939Nm.h | The lower layer communication interface module confirms the 
        transmission of a PDU, or the failure to transmit a PDU.
        CanTrcv_CheckWakeFlag | CanTrcv.h | Requests to check the status of the wakeup flag from the 
        transceiver hardware.
        CanTrcv_CheckWakeup | CanTrcv.h | Service is called by underlying CANIF in case a wake up 
        interrupt is detected.
        CanTrcv_GetBusWuReason | CanTrcv.h | Gets the wakeup reason for the Transceiver and returns it 
        in parameter Reason.
        CanTrcv_GetOpMode | CanTrcv.h | Gets the mode of the Transceiver and returns it in OpMode.
        CanTrcv_SetOpMode | CanTrcv.h | Sets the mode of the Transceiver to the value OpMode.
        CanTrcv_SetWakeupMode | CanTrcv.h | Enables, disables or clears wake-up events of the 
        Transceiver according to TrcvWakeupMode.
        CanTSyn_RxIndication | CanTSyn.h | Indication of a received PDU from a lower layer 
        communication interface module.
        CanTSyn_TxConfirmation | CanTSyn.h | The lower layer communication interface module confirms 
        the transmission of a PDU, or the failure to transmit a PDU.
        Det_ReportError | Det.h | Service to report development errors.
        EcuM_ValidateWakeupEvent | EcuM.h | After wakeup, the ECU State Manager will stop the process 
        during the WAKEUP VALIDATION state/sequence to wait for validation of the wakeup event.This API 
        service is used to indicate to the ECU Manager module that the wakeup events indicated in the 
        sources parameter have been validated.
        IdsM_SetSecurityEventWithContextData | IdsM.h | This API is the application interface to report 
        security events with context data to the IdsM.
        J1939Nm_RxIndication | J1939Nm.h | Indication of a received PDU from a lower layer 
        communication interface module.
        J1939Nm_TxConfirmation | J1939Nm.h | The lower layer communication interface module confirms 
        the transmission of a PDU, or the failure to transmit a PDU.
        J1939Tp_RxIndication | J1939Nm.h | Indication of a received PDU from a lower layer 
        communication interface module.
        J1939Tp_TxConfirmation | J1939Nm.h | The lower layer communication interface module confirms 
        the transmission of a PDU, or the failure to transmit a PDU.
        Mirror_ReportCanFrame | Mirror.h | Reports a received or transmitted CAN frame. All received 
        CAN frames that pass the hardware acceptance filter are reported, independent of the software 
        filter configuration. Transmitted CAN frames are reported when the transmission is confirmed.
        PduR_CanIfRxIndication | PduR_CanIf.h | Indication of a received PDU from a lower layer 
        communication interface module.
        PduR_CanIfTxConfirmation | PduR_CanIf.h | The lower layer communication interface module 
        confirms the transmission of a PDU, or the failure to transmit a PDU.
        Xcp_CanIfRxIndication | Xcp.h | Indication of a received PDU from a lower layer communication 
        interface module.
        Xcp_CanIfTxConfirmation | Xcp.h | The lower layer communication interface module confirms the 
        transmission of a PDU, or the failure to transmit a PDU.
      </description>
      <comment>
        This requirement is informational only.
        This is just a list of mandatory interfaces provided by other modules.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>495</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00297</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf has accepted a L-PDU received via CanIf_RxIndication() during Data Length Check , 
        CanIf shall copy the number of bytes according to the configured Data Length  to the static 
        receive buffer, if configured for that L-PDU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ReadReceivedData</srcid><srcstatus/><internalId>1367</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>496</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00308</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The service CanIf_SetControllerMode() shall call Can_SetControllerMode(Controller, Transition) 
        for the requested CAN controller.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_SetControllerMode</srcid><srcstatus/><internalId>1368</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>497</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00311</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_SetControllerMode() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the 
        DET module, when CanIf_SetControllerMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30240</srcid><srcstatus/><internalId>1456</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31180</srcid><srcstatus/><internalId>1582</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CONTROLLERID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>498</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00313</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_GetControllerMode() has an invalid, the CanIf shall report 
        development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the DET, 
        when CanIf_GetControllerMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30242</srcid><srcstatus/><internalId>1460</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31176</srcid><srcstatus/><internalId>1579</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CONTROLLERID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>499</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00317</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The service CanIf_Transmit() shall not accept a transmit request, if the controller mode 
        referenced by ControllerId is different to CAN_CS_STARTED and the channel mode at least for the 
        transmit path is not online or offline active.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ControllerMode</srcid><srcstatus/><internalId>1104</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.CANIF723</srcid><srcstatus/><internalId>188</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.SleepModeEStopped</srcid><srcstatus/><internalId>189</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00072</srcid><srcstatus/><internalId>432</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00073_1</srcid><srcstatus/><internalId>434</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.CANIF382</srcid><srcstatus/><internalId>539</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00489</srcid><srcstatus/><internalId>587</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00489_1</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00677</srcid><srcstatus/><internalId>634</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>500</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00318</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf_Transmit() shall call Can_Write() with the hardware transmit handle corresponding to the 
        provided TxPduId and a Can_PduType structure where:
        swPduHandle is set to the CanTxPduId used in the corresponding CanIf_TxConfirmation() call
        length is set to the value provided as PduInfoPtr-&gt;SduLength, possibly reduced according to 
        SWS_CANIF_00894
        id is set to the CAN ID associated with the TxPduId
        sdu is set to the pointer provided as PduInfoPtr-&gt;SduDataPtr
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_Transmit300Hths</srcid><srcstatus/><internalId>1544</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30317</srcid><srcstatus/><internalId>1721</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>501</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00319</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TxPduId of CanIf_Transmit() has an invalid value, CanIf shall report development 
        error code CANIF_E_INVALID_TXPDUID to the Det_ReportError service of the DET, when 
        CanIf_Transmit() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30244</srcid><srcstatus/><internalId>1463</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_INVALID_TXPDUID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>502</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00320</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter PduInfoPtr of CanIf_Transmit() has an invalid value, CanIf shall report 
        development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the DET module, 
        when CanIf_Transmit() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30245</srcid><srcstatus/><internalId>1464</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>503</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00324</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_ReadRxPduData() shall not accept a request and return E_NOT_OK, if the 
        corresponding controller mode refrenced by ControllerId is different to CAN_CS_STARTED and the 
        channel mode is in the receive path online.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00324_1</srcid><srcstatus/><internalId>505</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00324_2</srcid><srcstatus/><internalId>506</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00324.ApiAcceptance</srcid><srcstatus/><internalId>507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>504</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00324_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_ReadRxPduData() shall not accept a request and return
      E_NOT_OK, if the corresponding CCMSM does not equal CANIF_CS_STARTED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ReadRxPduDataAcceptance</srcid><srcstatus/><internalId>1084</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00324</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>505</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00324_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_ReadRxPduData() shall not accept a request and return
      E_NOT_OK, if the channel mode is not in the receive path online.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ReadRxPduDataAcceptance</srcid><srcstatus/><internalId>1084</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00324</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>506</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00324.ApiAcceptance</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_ReadRxPduData() shall accept a request and return
      E_OK, regardless of the corresponding CCMSM or channel mode.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ReadReceivedData</srcid><srcstatus/><internalId>1367</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00324</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>504</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>507</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00325</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanIfRxSduId of CanIf_ReadRxPduData() has an invalid value, e.g. not configured to 
        be stored within CanIf via CanIfRxPduCfg.CanIfRxPduReadData, CanIf shall report development 
        error code CANIF_E_INVALID_RXPDUID to the Det_ReportError service of the DET, when 
        CanIf_ReadRxPduData() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30246</srcid><srcstatus/><internalId>1466</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_INVALID_RXPDUID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>508</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00326</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanIfRxInfoPtr of CanIf_ReadRxPduData() has an invalid value, CanIf shall report 
        development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the DET module, 
        when CanIf_ReadRxPduData() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30247</srcid><srcstatus/><internalId>1467</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>509</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00329</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf_ReadRxPduData() shall not be used for CanIfRxSduId, which are defined to receive multiple 
        CAN-Ids (range reception)
      </description>
      <comment>
        This requirement is informational only.
        This is not a requirement for the CanIf. It has to be covered by the upper layer
        caller functions.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>510</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00330</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_ReadRxPduData(): This API can be enabled or disabled at pre-compile time 
        configuration by the configuration parameter CanIfPublicCfg.CanIfPublicReadRxPduDataApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>511</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00331</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanIfTxSduId of CanIf_ReadTxNotifStatus() is out of range or if no status 
        information was configured for this CAN Tx L-SDU, CanIf shall report development error code 
        CANIF_E_INVALID_TXPDUID to the Det_ReportError service of the DET when CanIf_ReadTxNotifStatus(
        is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00331_1</srcid><srcstatus/><internalId>513</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00331_2</srcid><srcstatus/><internalId>514</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_INVALID_TXPDUID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>512</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00331_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanIfTxSduId of CanIf_ReadTxNotifStatus() is out of range and if
        development error detection is enabled (i.e. CANIF_DEV_ERROR_DETECT
        equals ON), then the function CanIf_ReadTxNotifStatus() shall report
        development error code CANIF_E_INVALID_TXPDUID to the Det_ReportError
        service of the DET.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30248</srcid><srcstatus/><internalId>1468</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00331</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>513</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00331_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no status information was configured for this CAN Tx L-PDU and if
        development error detection is enabled (i.e. CANIF_DEV_ERROR_DETECT
        equals ON), then the function CanIf_ReadTxNotifStatus() shall report
        development error code CANIF_E_INVALID_TXPDUID to the Det_ReportError
        service of the DET.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30248</srcid><srcstatus/><internalId>1468</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00331</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>512</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>514</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00335</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_ReadTxNotifyStatus(): This API can be enabled or disabled at pre-compile 
        time configuration globally by the parameter CanIfPublicCfg.CanIfPublicReadTxPduNotifyStatusApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>515</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00336</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanIfRxSduId of CanIf_ReadRxNotifStatus() is out of range or if status for 
        CanRxPduId was requested whereas CanIfRxPduCfg.CanIfRxPduReadData is disabled or if no status 
        information was configured for this CAN Rx L-SDU, CanIf shall report development error code 
        CANIF_E_INVALID_RXPDUID to the Det_ReportError service of the DET, when CanIf_ReadRxNotifStatus(
        is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00336_1</srcid><srcstatus/><internalId>517</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00336_2</srcid><srcstatus/><internalId>518</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00336_3</srcid><srcstatus/><internalId>519</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_INVALID_RXPDUID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>55</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>516</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00336_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanIfRxSduId of CanIf_ReadRxNotifStatus() is out of range
        and if development error detection is enabled (i.e.
        CANIF_DEV_ERROR_DETECT equals ON), then the function
        CanIf_ReadRxNotifStatus() shall report development error code
        CANIF_E_INVALID_RXPDUID to the Det_ReportError service of the DET.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30249</srcid><srcstatus/><internalId>1469</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>516</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>517</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00336_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If Status for CanRxPduId was requested whereas CANIF_READRXPDU_DATA_API is
        disabled and if development error detection is enabled (i.e.
        CANIF_DEV_ERROR_DETECT equals ON), then the function
        CanIf_ReadRxNotifStatus() shall report development error code
        CANIF_E_INVALID_RXPDUID to the Det_ReportError service of the DET.
      </description>
      <comment>
        This requirement is not applicable.
        CanIf_ReadRxNotifStatus() and CanIf_ReadRxPduData() can be configured
        independent from each other. There is no need for implementing this restriction listed here.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>516</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>518</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00336_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no status information was configured for this CAN Rx L-PDU
        and if development error detection is enabled (i.e.
        CANIF_DEV_ERROR_DETECT equals ON), then the function
        CanIf_ReadRxNotifStatus() shall report development error code
        CANIF_E_INVALID_RXPDUID to the Det_ReportError service of the DET.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckRxNotifyFlagsMulticoreReportInvalidNotifIdx</srcid><srcstatus/><internalId>1377</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30249</srcid><srcstatus/><internalId>1469</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00336</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>516</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>519</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00340</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_ReadRxNotifStatus(): This API can be enabled or disabled at pre-compile 
        time configuration globally by the parameter CanIfPublicCfg.CanIfPublicReadRxPduNotifyStatusApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>520</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00341</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_SetPduMode() is called with invalid ControllerId, CanIf shall report development error 
        code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the DET module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30250</srcid><srcstatus/><internalId>1470</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31181</srcid><srcstatus/><internalId>1583</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CONTROLLERID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>521</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00346</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_GetPduMode() is called with invalid ControllerId, CanIf shall report development error 
        code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the DET module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30252</srcid><srcstatus/><internalId>1472</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31178</srcid><srcstatus/><internalId>1581</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CONTROLLERID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>522</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00352</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanIfTxSduId of CanIf_SetDynamicTxId() has an invalid value, CanIf shall report 
        development error code CANIF_E_INVALID_TXPDUID to the Det_ReportError service of the DET module,
        when CanIf_SetDynamicTxId() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30254</srcid><srcstatus/><internalId>1475</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_INVALID_TXPDUID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>54</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>523</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00353</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanId of CanIf_SetDynamicTxId() has an invalid value, CanIf shall report 
        development error code CANIF_E_PARAM_CANID to the Det_ReportError service of the DET module, 
        when CanIf_SetDynamicTxId() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30255</srcid><srcstatus/><internalId>1476</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>41</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>524</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00355</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf was not initialized before calling CanIf_SetDynamicTxId(), then the function 
        CanIf_SetDynamicTxId() shall not execute a reconfiguration of Tx CanId.
      </description>
      <comment>
        This is implicitly covered by the requirements CanIf.ASR40.SWS_CanIf_00354 and
      CanIf.SWS_CanIf_00085 because the call is rejected and the dynamic CAN IDs
      will be re-initialized by the CanIf_Init() call.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31223</srcid><srcstatus/><internalId>1595</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>525</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00357</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_SetDynamicTxId(): This function shall be pre compile time configurable 
        On/Off by the configuration parameter CanIfPublicCfg.CanIfPublicSetDynamicTxIdApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30885</srcid><srcstatus/><internalId>1343</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>526</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00358</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_SetTrcvMode() shall call the function CanTrcv_SetOpMode(Transceiver, OpMode)
        on the corresponding requested CAN Transceiver Driver module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30420_1Trcv</srcid><srcstatus/><internalId>1371</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30420</srcid><srcstatus/><internalId>1379</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>527</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00362</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_SetTrcvMode(): The number of supported transceiver types for each 
        network is set up in the configuration phase . If no transceiver is used, this function may be 
        omitted. Therefore, if no transceiver is configured in LT or PB class the API shall return with 
        E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.NoTransceiverConfigured</srcid><srcstatus/><internalId>1105</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00362</srcid><srcstatus/><internalId>74</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>528</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00363</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_GetTrcvMode() shall call the function CanTrcv_GetOpMode(Transceiver, OpMode)
        on the corresponding requested CAN Transceiver Driver module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30428_1Trcv</srcid><srcstatus/><internalId>1372</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30428</srcid><srcstatus/><internalId>1380</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>529</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00364</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_GetTrcvMode() has an invalid value, the CanIf shall report 
        development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the DET module, 
        when CanIf_GetTrcvMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvApiInvalidTrcvId</srcid><srcstatus/><internalId>1358</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30851</srcid><srcstatus/><internalId>1479</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>530</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00367</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_GetTrcvMode(): The number of supported transceiver types for each 
        network is set up in the configuration phase . If no transceiver is used, this function may be 
        omitted. Therefore, if no transceiver is configured in LT or PB class the API shall return with 
        E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.NoTransceiverConfigured</srcid><srcstatus/><internalId>1105</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00367</srcid><srcstatus/><internalId>75</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>531</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00368</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_GetTrcvWakeupReason() shall call CanTrcv_GetBusWuReason(Transceiver, Reason)
        on the corresponding requested CanTrcv.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30430_1Trcv</srcid><srcstatus/><internalId>1373</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30430</srcid><srcstatus/><internalId>1381</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>532</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00371</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_GetTrcvWakeupReason(): The number of supported transceiver types for 
        each network is set up in the configuration phase (see CanIfTrcvCfg and CanIfTrcvDrvCfg). If no transceiver is used, this function 
        may be omitted. Therefore, if no transceiver is configured in LT or PB class the API shall 
        return with E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.NoTransceiverConfigured</srcid><srcstatus/><internalId>1105</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00371</srcid><srcstatus/><internalId>76</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>533</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00372</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_SetTrcvWakeupMode() shall call CanTrcv_SetWakeupMode(Transceiver, 
        TrcvWakeupMode) on the corresponding requested CanTrcv.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30432_1Trcv</srcid><srcstatus/><internalId>1374</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30432</srcid><srcstatus/><internalId>1382</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>534</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00373</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_SetTrcvWakeupMode(): The number of supported transceiver types for each 
        network is set up in the configuration phase . If no transceiver is used, this function may be 
        omitted. Therefore, if no transceiver is configured in LT or PB class the API shall return with 
        E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.NoTransceiverConfigured</srcid><srcstatus/><internalId>1105</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00373</srcid><srcstatus/><internalId>77</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>535</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00378</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall access the location of the API of all used underlying CanDrv for link time 
        configuration by a set of function pointers for each CanDrv.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MULTIDRV_TRANSMIT</srcid><srcstatus/><internalId>1547</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_RXINDICATION</srcid><srcstatus/><internalId>1548</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_SETBAUDRATE</srcid><srcstatus/><internalId>1549</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CHECKWAKEUP</srcid><srcstatus/><internalId>1550</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1551</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1552</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CANCELTXCONFIRMATION</srcid><srcstatus/><internalId>1553</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CONTROLLERBUSOFF</srcid><srcstatus/><internalId>1554</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_OFFSETTXBUFF</srcid><srcstatus/><internalId>1555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>536</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00381</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If transmit buffering is enabled  and if the call of Can_Write() for a PDU configured for 
        direct transmission returns with CAN_BUSY, CanIf shall check if it is possible to buffer the 
        CanIf Tx L-PDU, which was requested to be transmitted via Can_Write() in a CanIfTxBuffer.
      </description>
      <comment>
        Requirement understanding:
        If TxBuffering is enabled (CANIF_TX_BUFFERING equals True) and if the call of
        Can_Write()returns with CAN_BUSY, the CanIf shall insert the complete
        CanIf Tx L-PDU (which has been requested for BasicCAN transmission)
        including the L-SDU in the appropriate CanIfTxBuffer.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31195</srcid><srcstatus/><internalId>1588</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>537</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00382</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If an L-PDU is requested to be transmitted via a PDU channel mode, which equals CANIF_OFFLINE, 
        the CanIf shall report the runtime error code CANIF_E_STOPPED to the Det_ReportRuntimeError() 
        service of the DET and CanIf_Transmit() shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CANIF_E_STOPPED</srcid><srcstatus/><internalId>1086</internalId></linkedfrom><linkedfrom><srcid>dev.CanIf.PartiallyImplemented</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>538</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.CANIF382</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If an L-PDU is requested to be transmitted via a PDU channel mode (refer to
        chapter 7.19.2 PDU channel modes), which equals CANIF_OFFLINE,
        CanIf_Transmit() shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30296</srcid><srcstatus/><internalId>1496</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00317</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>539</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00383</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When callback notification CanIf_TxConfirmation() is called, CanIf shall identify the upper 
        layer communication layer , which is linked to the successfully transmitted L-PDU, and shall 
        notify it about the performed transmission by call of CanIf's transmit confirmation service &lt;
        User_TxConfirmation&gt;(E_OK)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31192</srcid><srcstatus/><internalId>1587</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30317</srcid><srcstatus/><internalId>1721</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30213</srcid><srcstatus/><internalId>1745</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30325</srcid><srcstatus/><internalId>1751</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>540</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00386</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall evaluate during transmit confirmation , whether pending CanIf Tx L-PDU or Transmit 
        Request are stored within the CanIfTxBuffers, which are assigned to the new free Hardware 
        Transmit Object 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxBufferCancel300Hths</srcid><srcstatus/><internalId>1545</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30318</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31235</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30332</srcid><srcstatus/><internalId>1746</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30343</srcid><srcstatus/><internalId>1747</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30325</srcid><srcstatus/><internalId>1751</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>541</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00387</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When function CanIf_Init() is called, CanIf shall initialize every Transmit L-PDU Buffer 
        assigned to CanIf.
      </description>
      <comment>
        This means that buffers are free again after re- and initial initializatuion.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_InitClearTxBuffers</srcid><srcstatus/><internalId>1684</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>542</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00389</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the function CanIf_RxIndication() is called, the CanIf shall process the Software Filtering 
        on the received L-PDU, if configured . If Software Filtering rejects the received L-PDU, the 
        CanIf shall end the receive indication for that call of CanIf_RxIndication(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31099</srcid><srcstatus/><internalId>1383</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31100</srcid><srcstatus/><internalId>1384</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_CANID</srcid><srcstatus/><internalId>1511</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_HRH_NOT_USED</srcid><srcstatus/><internalId>1515</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_SW_FILTERING_SUPPORTED_HRH_NOT_USED</srcid><srcstatus/><internalId>1563</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30333</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>543</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00390</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf accepts an L-PDU received via CanIf_RxIndication() during Software Filtering , CanIf 
        shall process the Data Length check afterwards, if configured (see CanIfPrivateDataLengthCheck and CanIfRxPduDataLengthCheck).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>544</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00392</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If configuration parameters CanIfPublicCfg.CanIfPublicReadRxPduNotifyStatusApi and 
        CanIfRxPduCfg.CanIfRxPduReadNotifyStatus for the Received L-PDU are set to TRUE, and if 
        CanIf_RxIndication() is called, the CanIf shall set the notification status for the Received L-
        PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30206</srcid><srcstatus/><internalId>1733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>545</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00393</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If configuration parameters CanIfPublicCfg.CanIfPublicReadTxPduNotifyStatusApi and 
        CanIfTxPduCfg.CanIfTxPduReadNotifyStatus for the transmitted L-SDU are set to TRUE, and if 
        CanIf_ReadTxNotifStatus() is called, the CanIf shall reset the notification status for the 
        transmitted L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30205</srcid><srcstatus/><internalId>1732</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>546</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00394</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If configuration parameters CanIfPublicCfg.CanIfPublicReadRxPduNotifyStatusApi and 
        CanIfRxPduCfg.CanIfRxPduReadNotifyStatus are set to TRUE, and if CanIf_ReadRxNotifStatus() is 
        called, then CanIf shall reset the notification status for the received L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30206</srcid><srcstatus/><internalId>1733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>547</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00395</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When CanIf_CheckWakeup(EcuM_WakeupSourceType WakeupSource) is invoked, CanIf shall query CanDrv 
        CanTrcv via CanTrcv_CheckWakeup() or Can_CheckWakeup(), which exact CAN hardware device caused 
        the bus wake-up.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanOnlyWakeup</srcid><srcstatus/><internalId>1336</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31201</srcid><srcstatus/><internalId>1590</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30339</srcid><srcstatus/><internalId>1604</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupEvent</srcid><srcstatus/><internalId>1620</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupValidation</srcid><srcstatus/><internalId>1624</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupValidation_DET</srcid><srcstatus/><internalId>1625</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_WakeupByCanOnly</srcid><srcstatus/><internalId>1705</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>548</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00395_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf_CheckWakeup(WakeupSource) checks by comparing WakeupSource to configured input
        reference to EcuMWakeupSource in the Driver modules (Can, CanTrcv),
        which controllers/transceivers have to be checked.
        The CanIf gets this information via reference CanIfCtrlCanCtrlRef and CanIfTrcvCanTrcvRef.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30339</srcid><srcstatus/><internalId>1604</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupEvent</srcid><srcstatus/><internalId>1620</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>549</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.CanIf_00395_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIf_CheckWakeup(WakeupSource) checks by comparing WakeupSource to configured input
        reference to EcuMWakeupSource using EB specific config parameters
        CanIfCtrlWakeupSourceInRef and CanIfTrcvWakeupSourceInRef.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30339</srcid><srcstatus/><internalId>1604</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupEvent</srcid><srcstatus/><internalId>1620</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>550</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00398</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter WakeupSource of CanIf_CheckWakeup() has an invalid value, CanIf shall report 
        development error code CANIF_E_PARAM_WAKEUPSOURCE to the Det_ReportError service of the DET, 
        when CanIf_CheckWakeup() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30853</srcid><srcstatus/><internalId>1484</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_WAKEUPSOURCE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>551</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00404</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter WakeupSource of CanIf_CheckValidation() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_WAKEUPSOURCE to the Det_ReportError service of the 
        DET module, when CanIf_CheckValidation() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30854</srcid><srcstatus/><internalId>1485</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_WAKEUPSOURCE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>47</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>552</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00408</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_CheckValidation(): If no validation is needed, this API can be omitted 
        by disabling of CanIfPublicCfg.CanIfPublicWakeupCheckValidSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00226</srcid><srcstatus/><internalId>481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>553</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00410</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanTxPduId of CanIf_TxConfirmation() has an invalid value, CanIf shall report 
        development error code CANIF_E_PARAM_LPDU to the Det_ReportError service of the DET module, 
        when CanIf_TxConfirmation() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30257</srcid><srcstatus/><internalId>1487</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_LPDU</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>44</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>554</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00412</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf was not initialized before calling CanIf_TxConfirmation(), CanIf shall not call the 
        service &lt;User_TxConfirmation&gt;() and shall not set the Tx confirmation status, when 
        CanIf_TxConfirmation() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxConfirmationBeforeInit</srcid><srcstatus/><internalId>1710</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>555</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00414</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_TxConfirmation(): Each Tx L-PDU  has to be configured with a 
        corresponding transmit confirmation service of an upper layer module  which is called in 
        CanIf_TxConfirmation(
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>556</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00415</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Within the service CanIf_RxIndication() the CanIf routes this indication to the configured 
        upper layer target service(s)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ReceiveDuplicateId</srcid><srcstatus/><internalId>1423</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Receive300Hrhs</srcid><srcstatus/><internalId>1543</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31186</srcid><srcstatus/><internalId>1585</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30214</srcid><srcstatus/><internalId>1754</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31226</srcid><srcstatus/><internalId>1769</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31227</srcid><srcstatus/><internalId>1770</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31231</srcid><srcstatus/><internalId>1771</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>557</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00416</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter Mailbox-&gt;Hoh of CanIf_RxIndication() has an invalid value,
        CanIf shall report development error code CANIF_E_PARAM_HOH to the
        Det_ReportError service of the DET module, when CanIf_RxIndication()is called (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00416_1</srcid><srcstatus/><internalId>559</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>558</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00416_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>2</version>
      <description>
        If CanIfCanDriverCompatibility is set to ASR422, ASR431, ASR440 or ASR21_11 and parameter Mailbox-&gt;Hoh of CanIf_RxIndication()
        has an invalid value, CanIf shall report development error code CANIF_E_PARAM_HRH to the Det_ReportError
        service of the DET module, when CanIf_RxIndication() is called. (SRS_BSW_00323)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30258</srcid><srcstatus/><internalId>1488</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Det_E_PARAM_HRH</srcid><srcstatus/><internalId>1753</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00416</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>558</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>559</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00417</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter Mailbox-&gt;CanId of CanIf_RxIndication() has an invalid value, CanIf shall report 
        development error code CANIF_E_PARAM_CANID to the Det_ReportError service of the DET module, 
        when CanIf_RxIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30259</srcid><srcstatus/><internalId>1489</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>560</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00419</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter PduInfoPtr or Mailbox of CanIf_RxIndication()
        has an invalid value, CanIf shall report development error code CANIF_E_PARAM_POINTER 
        to the Det_ReportError service of the DET module, when CanIf_RxIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00419_1</srcid><srcstatus/><internalId>562</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00419_2</srcid><srcstatus/><internalId>563</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>561</internalId></specobject>
  
    <specobject>
      <id>CanIf.SWS_CanIf_00419_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>2</version>
      <description>
        If CanIfCanDriverCompatibility is set to ASR422, ASR431, ASR440 or ASR21_11 and parameter PduInfoPtr of CanIf_RxIndication()
        has an invalid value, CanIf shall report development error code CANIF_E_PARAM_POINTER to the
        Det_ReportError service of the DET module, when CanIf_RxIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30261</srcid><srcstatus/><internalId>1491</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00419</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>561</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>562</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00419_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>2</version>
      <description>
        If CanIfCanDriverCompatibility is set to ASR422, ASR431, ASR440 or ASR21_11 and parameter Mailbox of CanIf_RxIndication()
        has an invalid value, CanIf shall report development error code CANIF_E_PARAM_POINTER to the
        Det_ReportError service of the DET module, when CanIf_RxIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30261</srcid><srcstatus/><internalId>1491</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00419</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>561</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>563</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00421</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf was not initialized before calling CanIf_RxIndication(), CanIf shall not execute Rx 
        indication handling, when CanIf_RxIndication(), is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RxIndicationBeforeInit</srcid><srcstatus/><internalId>1711</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>564</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00423</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_RxIndication(): Each Rx L-PDU  has to be configured with a corresponding 
        receive indication service of an upper layer module  which is called in CanIf_RxIndication(
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>565</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00429</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_ControllerBusOff() has an invalid value, CanIf shall report 
        development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the DET 
        module, when CanIf_ControllerBusOff() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_BusOff_InvalidCtrlId</srcid><srcstatus/><internalId>1433</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30263</srcid><srcstatus/><internalId>1493</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31177</srcid><srcstatus/><internalId>1580</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CONTROLLER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>566</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00431</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf was not initialized before calling CanIf_ControllerBusOff(), CanIf shall not execute 
        BusOff notification, when CanIf_ControllerBusOff(), is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_BusOffBeforeInit</srcid><srcstatus/><internalId>1707</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>567</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00433</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_ControllerBusOff(): ID of the CAN Controller is published inside the 
        configuration description of the CanIf 
      </description>
      <comment>
        According to the SWS chapter 7.5 (compare CANIF653 and the text after
      CANIF655), the value passed in parameter Controller to CanIf_ControllerBusOff() is
      the controller ID defined in the CAN driver.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SymbolicNameValues</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>568</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00438</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): The upper layer module, which provides this callback 
        service, has to be configured by CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL. If no upper 
        layer modules are configured for transmit confirmation using &lt;User_TxConfirmation&gt;(), no 
        transmit confirmation is executed.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NoTxConfirmation</srcid><srcstatus/><internalId>1342</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30885</srcid><srcstatus/><internalId>1343</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoUpperLayerCbks</srcid><srcstatus/><internalId>1344</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30871</srcid><srcstatus/><internalId>1424</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_40178</srcid><srcstatus/><internalId>1686</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>569</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00439</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to PDUR, CanIfTxPduCfg.CanIfTxPduUserTxConfirmationName must be PduR_CanIfTxConfirmation.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31228</srcid><srcstatus/><internalId>1773</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>570</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00441</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): The upper layer module, which provides this callback 
        service, has to be configured by CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31214_Dlc</srcid><srcstatus/><internalId>1392</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_40176</srcid><srcstatus/><internalId>1687</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>571</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00442</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): If CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL is set to 
        PDUR, CanIfRxPduCfg.CanIfRxPduUserRxIndicationName must be PduR_CanIfRxIndication.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>572</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00445</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): If CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL is set to 
        CAN_NM, CanIfRxPduCfg.CanIfRxPduUserRxIndicationName must be CanNm_RxIndication.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>573</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00448</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): If CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL is set to 
        CAN_TP, CanIfRxPduCfg.CanIfRxPduUserRxIndicationName must be CanTp_RxIndication.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>574</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00450</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerBusOff&gt;(): The upper layer module which provides this callback 
        service has to be configured by CanIfDispatchCfg.CanIfDispatchUserCtrlBusOffUL.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>575</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00456</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ValidateWakeupEvent&gt;(): The upper layer module which provides this 
        callback service has to be configured by CanIfDispatchCfg.
        CanIfDispatchUserValidateWakeupEventUL, but:
        If no upper layer modules are configured for wake up notification using &lt;
        User_ValidateWakeupEvent&gt;(), no wake up notification needs to be configured. CanIfDispatchCfg.
        CanIfDispatchUserValidateWakeupEventUL needs not to be configured.
        If wake up is not supported (CanIfCtrlCfg.CanIfCtrlWakeupSupport and CanIfTrcvCfg.
        CanIfTrcvWakeupSupport equal FALSE, CanIfDispatchCfg.CanIfDispatchUserValidateWakeupEventUL is 
        not configurable.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00456_1</srcid><srcstatus/><internalId>577</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00456_2</srcid><srcstatus/><internalId>578</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00456_3</srcid><srcstatus/><internalId>579</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>576</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00456_1</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ValidateWakeupEvent&gt;: The upper layer module which
      provides this callback service has to be configured by
      CANIF_DISPATCH_USERVALIDATEWAKEUPEVENT_UL (see CanIf.ECUC_CanIf_00549)
      </description>
         <comment>
        This requirement is informational only.
        For a more detailed config parameter specification
        see CanIf.ECUC_CanIf_00549.
      </comment>
         <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00456</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>576</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>577</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00456_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no upper layer modules are configured for wake up notification using
      &lt;User_ValidateWakeupEvent&gt;(), no wake up notification needs to be
      configured. CANIF_DISPATCH_USERVALIDATEWAKEUPEVENT_UL needs not to  be
      configured.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_657</srcid><srcstatus/><internalId>1256</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00456</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>576</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>578</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00456_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If wake up is not supported (CanIfCtrlWakeupSupport
      and  CanIfTrcvWakeupSupport equal FALSE, see CanIf.ECUC_CanIf_00637,
      CanIf.ECUC_CanIf_00606), CANIF_DISPATCH_USERVALIDATEWAKEUPEVENT_UL is not
      configurable.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3162</srcid><srcstatus/><internalId>1272</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00456</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>576</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>579</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00466</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Each CanIf Tx L-PDU shall statically be assigned to one CanIfBufferCfg configuration container 
        at configuration time 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ECUC_CanIf_00831</srcid><srcstatus/><internalId>405</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>580</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00467</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall configure and store an order on HTH and HRH for all HOH derived from the 
        configuration containers CanIfHthCfg and CanIfHrhCfg.
      </description>
      <comment>
        This requirement is informational only.
        This is just a rationale why config parameters CanIfHthCfg and CanIfHrhCfg exist.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>581</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00468</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall reference a hardware acceptance filter for each HOH derived from the configuration 
        parameters CanIfHthCfg.CanIfHthIdSymRef and CanIfHrhCfg.CanIfHrhIdSymRef.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>582</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00469</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall give the possibility to configure and store a software acceptance filter for each 
        HRH of type BasicCAN configured by parameter CanIfHrhCfg.CanIfHrhSoftwareFilter.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ECUC_CanIf_00632</srcid><srcstatus/><internalId>381</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>583</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00472</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If configuration parameter CanIfPublicCfg.CanIfPublicReadTxPduNotifyStatusApi is set to TRUE, 
        CanIf shall store the current notification status for each transmit L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30885</srcid><srcstatus/><internalId>1343</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30205</srcid><srcstatus/><internalId>1732</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30206</srcid><srcstatus/><internalId>1733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>584</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00473</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If configuration parameter CanIfPublicCfg.CanIfPublicReadRxPduNotifyStatusApi is set to TRUE, 
        CanIf shall store the current notification status for each receive L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30206</srcid><srcstatus/><internalId>1733</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>585</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00485</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If a controller mode referenced by ControllerId enters state CAN_CS_STOPPED, then CanIf shall 
        clear the CanIf transmit buffers assigned to the CAN Controller corresponding.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30366</srcid><srcstatus/><internalId>1720</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>586</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00489</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For Physical Channel switching to CANIF_TX_OFFLINE mode CanIf shall:
        prevent forwarding of transmit requests CanIf_Transmit() of associated L-PDU to CanDrv (return 
        E_NOT_OK to the calling upper layer modules)
        clear the corresponding CanIf transmit buffers,
        prevent invocation of transmit confirmation callback services of the upper layer modules.
        enable invocation of receive indication callback services of the upper layer modules.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00489_1</srcid><srcstatus/><internalId>588</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00489_2</srcid><srcstatus/><internalId>589</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00489_3</srcid><srcstatus/><internalId>590</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00489_4</srcid><srcstatus/><internalId>591</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00489.PendingConfirmations</srcid><srcstatus/><internalId>592</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
           <linksto>CanIf.SWS_CanIf_00317</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>587</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00489_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For Physical Channels switching to CANIF_TX_OFFLINE mode CanIf shall 
        prevent forwarding of transmit requests CanIf_Transmit() of associated LPDUs
        to CanDrv (return E_NOT_OK to the calling upper layer modules)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30306</srcid><srcstatus/><internalId>1741</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>587</internalId></provcov>
        <provcov>
           <linksto>CanIf.SWS_CanIf_00317</linksto>
           <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>588</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00489_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For Physical Channels switching to CANIF_TX_OFFLINE mode CanIf shall 
        clear the corresponding CanIf transmit buffers.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30308</srcid><srcstatus/><internalId>1735</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>587</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>589</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00489_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
         For Physical Channels switching to CANIF_TX_OFFLINE mode CanIf shall 
         prevent invocation of transmit confirmation callback services of the upper layer modules.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.BlockTxConfirmation</srcid><srcstatus/><internalId>1083</internalId></linkedfrom><linkedfrom><srcid>dev.UseCanIfPduModeTypeInsteadCanIf_PduSetModeTypeAndCanIf_PduGetModeType</srcid><srcstatus/><internalId>1089</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>587</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>590</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00489_4</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
         For Physical Channels switching to CANIF_TX_OFFLINE mode CanIf shall
         enable invocation of receive indication callback services of the upper layer modules.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30321</srcid><srcstatus/><internalId>1737</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>587</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>591</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00489.PendingConfirmations</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
         After function CanIf_SetPduMode(ControllerId, CANIF_TX_OFFLINE) has been
         called, the CanIf shall deal with the transmit LPDUSs, which are assigned
         to the physical channel (defined by ControllerId ,refer to CanIf.ASR40.CANIF382) as
         follows:
           - forward transmit confirmations to the upper layer module for all pending
             confirmations (LPDUs transmitted before Pdu mode set to CANIF_TX_OFFLINE).
           - prevent invocation of transmit confirmation callback services of the
           upper layer modules for all other LPDUs.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30808</srcid><srcstatus/><internalId>1748</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>587</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>592</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00523</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The initialization data structure for a specific CanIf_ConfigType shall include the definition 
        of CanIf public parameters and the definition for each L-PDU/L-SDU.
      </description>
      <comment>
        This requirement is informational only.
        We do not need to include all public parameters to the initialization data
        structure. E.g. the parameter for Development error detection is provided as #define
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>593</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00524</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerBusOff&gt;(): At least one upper layer module and hence an API of 
        User_ControllerBusOff&gt;() has mandatorily to be configured, which CanIf can call in case of an 
        occurred call of CanIf_ControllerBusOff(
      </description>
      <comment>
        Since CanIfDispatchUserCtrlBusOffUL is a mandatory config parameter this is implicitly enforced.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_344</srcid><srcstatus/><internalId>1253</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>594</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00532</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_ValidateWakeupEvent&gt;
        Syntax 
        void &lt;User_ValidateWakeupEvent&gt; (EcuM_WakeupSourceType sources)
        Sync/Async | (defined within providing upper layer module)
        Reentrancy | (defined within providing upper layer module)
        Parameters (in) | sources | Validated CAN wakeup events. Every CAN controller or CAN 
        transceiver can be a separate wakeup source.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates if a wake up event initiated from the wake up source (CAN 
        controller or transceiver) after a former request to the CAN Driver or CAN Transceiver Driver 
        module is valid.
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NmWuValidWithCanNmPdu</srcid><srcstatus/><internalId>1592</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30338</srcid><srcstatus/><internalId>1611</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30834</srcid><srcstatus/><internalId>1612</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>595</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00535</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_SetTrcvWakeupMode() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the DET 
        module, when CanIf_SetTrcvWakeupMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvApiInvalidTrcvId</srcid><srcstatus/><internalId>1358</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30849</srcid><srcstatus/><internalId>1483</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>596</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00536</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TrcvWakeupMode of CanIf_SetTrcvWakeupMode() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_TRCVWAKEUPMODE to the Det_ReportError service of 
        the DET module, when CanIf_SetTrcvWakeupMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvApiInvalidTrcvId</srcid><srcstatus/><internalId>1358</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCVWAKEUPMODE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>50</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>597</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00537</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_GetTrcvWakeupReason() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the DET 
        module, when CanIf_GetTrcvWakeupReason() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvApiInvalidTrcvId</srcid><srcstatus/><internalId>1358</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30850</srcid><srcstatus/><internalId>1481</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>598</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00538</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_SetTrcvMode() has an invalid value, the CanIf shall report 
        development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the DET, when 
        CanIf_SetTrcvMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvApiInvalidTrcvId</srcid><srcstatus/><internalId>1358</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30848</srcid><srcstatus/><internalId>1477</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>599</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00542</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): The name of the API &lt;User_TxConfirmation&gt;() which is 
        called by CanIf shall be configured for CanIf by parameter CanIfTxPduCfg.
        CanIfTxPduUserTxConfirmationName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfPublicSingleCtrlOpt_Enabled</srcid><srcstatus/><internalId>1348</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_40178</srcid><srcstatus/><internalId>1686</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>600</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00543</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to CAN_NM, CanIfTxPduCfg.CanIfTxPduUserTxConfirmationName must be CanNm_TxConfirmation.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>601</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00544</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to J1939TP, CanIfTxPduCfg.CanIfTxPduUserTxConfirmationName must be J1939Tp_TxConfirmation.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION</srcid><srcstatus/><internalId>1501</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>602</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00550</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to CAN_TP, CanIfTxPduCfg.CanIfTxPduUserTxConfirmationName must be CanTp_TxConfirmation.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>603</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00551</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to CDD, the name of the API &lt;User_TxConfirmation&gt;() has to be configured via parameter 
        CanIfTxPduCfg.CanIfTxPduUserTxConfirmationName.
      </description>
      <comment>
        Name of the API is configured in CanIfUpperLayerConfig container for all TxLPdus
        of the same upper layer.
        If parameter CanIfRxPduUserTxConfirmationUL is disabled, this specific TxLPdu does
        not indicate a TxConfirmation.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE</srcid><srcstatus/><internalId>1599</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE_ACTIVE</srcid><srcstatus/><internalId>1600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>604</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00552</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): The name of the API &lt;User_RxIndication&gt;() which will be 
        called by CanIf shall be configured for CanIf by parameter CanIfRxPduCfg.
        CanIfRxPduUserRxIndicationName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31214_Dlc</srcid><srcstatus/><internalId>1392</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_40176</srcid><srcstatus/><internalId>1687</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>605</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00554</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): If CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL is set to 
        J1939TP, CanIfRxPduCfg.CanIfRxPduUserRxIndicationName must be J1939Tp_RxIndication.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_CDD_RXINDICATION</srcid><srcstatus/><internalId>1500</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE</srcid><srcstatus/><internalId>1599</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE_ACTIVE</srcid><srcstatus/><internalId>1600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>606</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00555</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): If CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL is set to 
        XCP, CanIfRxPduCfg.CanIfRxPduUserRxIndicationName must be Xcp_CanIfRxIndication.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_CDD_RXINDICATION</srcid><srcstatus/><internalId>1500</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>607</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00556</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to XCP, CanIfTxPduCfg.CanIfTxPduUserTxConfirmationName must be Xcp_CanIfTxConfirmation.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION</srcid><srcstatus/><internalId>1501</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>608</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00557</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): If CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL is set to 
        CDD the name of the API has to be configured via parameter CanIfRxPduCfg.
        CanIfRxPduUserRxIndicationName.
      </description>
      <comment>
        Name of the API is configured in CanIfUpperLayerConfig container for all RxLPdus
        of the same upper layer.
        If parameter CanIfRxPduUserRxIndicationUL is disabled, this specific RxLPdu does
        not indicate a RxIndication.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_CDD_RXINDICATION</srcid><srcstatus/><internalId>1500</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>609</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00558</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerBusOff&gt;(): The name of the API &lt;User_ControllerBusOff&gt;() which 
        will be called by CanIf shall be configured for CanIf by parameter CanIfDispatchCfg.
        CanIfDispatchUserCtrlBusOffName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>610</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00559</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerBusOff&gt;(): If CanIfDispatchCfg.CanIfDispatchUserCtrlBusOffUL 
        is set to CAN_SM, CanIfDispatchCfg.CanIfDispatchUserCtrlBusOffName must be 
        CanSM_ControllerBusOff.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>611</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00560</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerBusOff&gt;(): If CanIfDispatchCfg.CanIfDispatchUserCtrlBusOffUL 
        is set to CDD the name of the API has to be configured via parameter CanIfDispatchCfg.
        CanIfDispatchUserCtrlBusOffName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30444</srcid><srcstatus/><internalId>1420</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>612</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00563</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ValidateWakeupEvent&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserValidateWakeupEventUL is set to ECUM, CanIfDispatchCfg.
        CanIfDispatchUserValidateWakeupEventName must be EcuM_ValidateWakeupEvent.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NmWuValidWithCanNmPdu</srcid><srcstatus/><internalId>1592</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>613</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00564</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ValidateWakeupEvent&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserValidateWakeupEventUL is set to CDD the name of the API has to be configured 
        via parameter CanIfDispatchCfg.CanIfDispatchUserValidateWakeupEventName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30442</srcid><srcstatus/><internalId>1419</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>614</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00645</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        A range of CanId which shall pass the software receive filter shall either be defined by its 
        upper limit  and lower limit  CanId, or by a base ID  and a mask that defines the relevant bits 
        of the base ID (see CanIfHrhRangeMask).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>615</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00646</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Each configurable range of CanId , which shall pass the software receive filter, shall be 
        configurable either for Standard CAN IDs or Extended CAN IDs via CanIfHrhRangeCfg.
        CanIfHrhRangeRxPduRangeCanIdType.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>616</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00648</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverMode of CanIf_SetTrcvMode() has an invalid value (not 
        CANTRCV_TRCVMODE_STANDBY, CANTRCV_TRCVMODE_SLEEP or CANTRCV_TRCVMODE_NORMAL), the CanIf shall 
        report development error code CANIF_E_PARAM_TRCVMODE to the Det_ReportError service of the DET 
        module, when CanIf_SetTrcvMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvApiInvalidTrcvId</srcid><srcstatus/><internalId>1358</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCVMODE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>49</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>617</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00649</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TrcvWuReasonPtr of CanIf_GetTrcvWakeupReason() has an invalid value, the CanIf 
        shall report development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the 
        DET module, when CanIf_GetTrcvWakeupReason() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetTrcvWuReasonNullPtr</srcid><srcstatus/><internalId>1482</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>618</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00650</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverModePtr of CanIf_GetTrcvMode() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the DET 
        module, when CanIf_GetTrcvMode() was called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetTrcvModeNullPtr</srcid><srcstatus/><internalId>1480</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>619</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00653</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanIf shall provide a ControllerId, which abstracts from the different Controllers of the 
        different CanDrv instances. The range of the ControllerIds within the CanIf shall start with '0'
        It shall be configurable via CanIfCtrlCfg.CanIfCtrlId.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30217</srcid><srcstatus/><internalId>1762</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>620</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00655</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanIf shall provide a TransceiverId, which abstracts from the different Transceivers of the 
        different CanTrcv instances. The range of the TransceiverIds within the CanIf shall start with 
        0'. It shall be configurable via CanIfTrcvCfg.CanIfTrcvId.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30420_MultiIds</srcid><srcstatus/><internalId>1354</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30428_MultiIds</srcid><srcstatus/><internalId>1355</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30430_MultiIds</srcid><srcstatus/><internalId>1356</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30432_MultiIds</srcid><srcstatus/><internalId>1357</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvApiInvalidTrcvId</srcid><srcstatus/><internalId>1358</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>621</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00656</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerModePtr of CanIf_GetControllerMode() has an invalid value, the CanIf 
        shall report development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the 
        DET, when CanIf_GetControllerMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30265</srcid><srcstatus/><internalId>1461</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>622</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00657</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_GetPduMode() is called with invalid PduModePtr, CanIf shall report development error 
        code CANIF_E_PARAM_POINTER to the Det_ReportError service of the DET module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30266</srcid><srcstatus/><internalId>1473</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_POINTER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>52</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>623</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00659</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ValidateWakeupEvent&gt;(): If no validation is needed, this API can be 
        omitted by disabling CanIfPublicCfg.CanIfPublicWakeupCheckValidSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ComTest_NoValidWu</srcid><srcstatus/><internalId>1333</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_NoWuValid</srcid><srcstatus/><internalId>1702</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>624</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00661</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        All CanIf API services other than CanIf_Init() and CanIf_GetVersionInfo() shall not execute 
        their normal operation and return E_NOT_OK unless the CanIf has been initialized with a 
        preceding call of CanIf_Init().
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIf_GetVersionInfo</srcid><srcstatus/><internalId>1106</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00661</srcid><srcstatus/><internalId>133</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>625</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00663</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the HRH references a reception unit configured for BasicCAN reception, software filtering 
        shall be enabled in CanIf.
      </description>
      <comment>
        Config consistency check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_33</srcid><srcstatus/><internalId>1282</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>626</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00664</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If multiple HRH are used, each HRH shall belong at least to a single or fixed group of Rx L-SDU 
        CanRxPduIds)
      </description>
      <comment>
        This requirement is informational only.
      Since there is no API to change the assignment at runtime, this requirement is
      fulfilled by the SWS itself.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>627</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00665</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The HRH shall enable CanIf to use BasicCAN or a FullCAN reception method of the referenced 
        reception unit and to indicate a Received L-SDU to a target upper layer module.
      </description>
      <comment>
        This requirement is informational only.
        Descriptive text, no requirement
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>628</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00666</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The HTH shall enable CanIf to use BasicCAN or FullCAN transmission method of the referenced 
        transmission unit and to confirm a transmitted L-SDU to a target upper layer module.
      </description>
      <comment>
        This requirement is informational only.
      Descriptive text, no requirement
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>629</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00667</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If multiple HTH are used, each HTH shall belong to a single or fixed group of Tx L-PDU (
        CanTxPduIds)
      </description>
      <comment>
        This requirement is informational only.
      Since there is no API to change the assignment at runtime, this requirement is
      fulfilled by the SWS itself.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>630</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00668</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If pending CanIf Tx L-PDU or Transmit Request are available in the CanIfTxBuffers as per 
        SWS_CANIF_00386, then CanIf shall call Can_Write() for that pending CanIf Tx L-PDU or Transmit 
        Request (of the one assigned to the new Hardware Transmit Object) with the highest priority 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxBufferCancel300Hths</srcid><srcstatus/><internalId>1545</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30318</srcid><srcstatus/><internalId>1722</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31235</srcid><srcstatus/><internalId>1723</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30332</srcid><srcstatus/><internalId>1746</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30343</srcid><srcstatus/><internalId>1747</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30325</srcid><srcstatus/><internalId>1751</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>631</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00672</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The header file CanIf.h only contains extern declarations of constants, global data and 
        services that are specified in CanIf.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
            <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.ExternalHeaderFile</srcid><srcstatus/><internalId>1049</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>632</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00673</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The CanIf shall guarantee data consistency of the CanId in case of running function 
        CanIf_SetDynamicTxId(). This service may be interrupted by a pre-emptive call of CanIf_Transmit(
        affecting the same L-PDU, seeSWS_CANIF_00064.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.CanIf.DataProtection</srcid><srcstatus/><internalId>1315</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>633</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00677</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If a controller mode referenced by ControllerId is in state CAN_CS_STOPPED and if the PduIdType 
        parameter in a call of CanIf_Transmit() is assigned to that CAN Controller, then the call of 
        CanIf_Transmit() does not result in a call of Can_Write()  and returns E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30320</srcid><srcstatus/><internalId>1728</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00317</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>634</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00678</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If all calls of Can_CheckWakeup() or CanTrcv_CheckWakeup() return E_NOT_OK to CanIf, then 
        CanIf_CheckWakeup() shall return E_NOT_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00678</srcid><srcstatus/><internalId>246</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CheckWakeupReturnValues</srcid><srcstatus/><internalId>1111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>635</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00687</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_ControllerModeIndication&gt;
        Syntax 
        void &lt;User_ControllerModeIndication&gt; (uint8 ControllerId, Can_ControllerStateType 
        ControllerMode)
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller, at which a controller state transition occurred.
        ControllerMode | Notified CAN controller mode 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates a CAN controller state transition to the corresponding 
        upper layer module (mainly the CAN State Manager module)
        Available via | configurable 
      </description>
      <comment>
         API signature configurable via CanIfCanDriverCompatibility configuration parameter.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_44_TX_RX</srcid><srcstatus/><internalId>1395</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>636</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00689</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerModeIndication&gt;(): The upper layer module which provides this 
        callback service has to be configured by CanIfDispatchCfg.CanIfDispatchUserCtrlModeIndicationUL.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserControllerModeIndication</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>637</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00690</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerModeIndication&gt;(): The name of &lt;User_ControllerModeIndication&gt;
        which is called by CanIf shall be configured for CanIf by parameter CanIfDispatchCfg.
        CanIfDispatchUserCtrlModeIndicationName. This is only necessary if state transition 
        notifications are configured via CanIfDispatchCfg.CanIfDispatchUserCtrlModeIndicationUL.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserControllerModeIndication</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>638</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00691</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerModeIndication&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserCtrlModeIndicationUL is set to CAN_SM, CanIfDispatchCfg.
        CanIfDispatchUserCtrlModeIndicationName must be CanSM_ControllerModeIndication.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserControllerModeIndication</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>639</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00692</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ControllerModeIndication&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserCtrlModeIndicationUL is set to CDD the name of the function has to be 
        configured via parameter CanIfDispatchCfg.CanIfDispatchUserCtrlModeIndicationName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserControllerModeIndication</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>640</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00693</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_TrcvModeIndication&gt;
        Syntax 
        void &lt;User_TrcvModeIndication&gt; (uint8 TransceiverId, CanTrcv_TrcvModeType TransceiverMode)
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TransceiverId | Abstracted CanIf TransceiverId which is assigned to a CAN 
        transceiver, at which a transceiver state transition occurred.
        TransceiverMode | Notified CAN transceiver mode 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates a CAN transceiver state transition to the corresponding 
        upper layer module (mainly the CAN State Manager module)
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValidTrcvId</srcid><srcstatus/><internalId>1352</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeInd_1Trcv</srcid><srcstatus/><internalId>1370</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeInd</srcid><srcstatus/><internalId>1378</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UserTrcvModeIndication</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>641</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00694</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Caveats of &lt;User_TrcvModeIndication&gt;
        The CanTrcv must be initialized after Power ON.
        The call context is either on task level (polling mode)
        This callback service is in general re-entrant for multiple CAN Transceiver usage, but not for 
        the same CAN Transceiver.
      </description>
      <comment>
        This requirement is informational only.
        This is no requirement for the CanIf
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>642</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00695</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TrcvModeIndication&gt;(): The upper layer module which provides this 
        callback service has to be configured by CanIfDispatchCfg.CanIfDispatchUserTrcvModeIndicationUL,
        but:
        If no upper layer modules are configured for transceiver mode indications using &lt;
        User_TrcvModeIndication&gt;(), no transceiver mode indication needs to be configured. 
        CanIfDispatchCfg.CanIfDispatchUserTrcvModeIndicationUL needs not to be configured.
        If transceivers are not supported (CanIfTrcvDrvCfg is not configured, CanIfDispatchCfg.
        CanIfDispatchUserTrcvModeIndicationUL is not configurable.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00695_1</srcid><srcstatus/><internalId>644</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00695_2</srcid><srcstatus/><internalId>645</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00695_3</srcid><srcstatus/><internalId>646</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>643</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00695_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TrcvModeIndication&gt;(): The upper layer module which
        provides this callback service has to be configured by
        CANIF_DISPATCH_USERTRCVMODEINDICATION_UL (see CanIf.ECUC_CanIf_00686)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeInd_1Trcv</srcid><srcstatus/><internalId>1370</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeInd</srcid><srcstatus/><internalId>1378</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UserTrcvModeIndication</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00695</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>643</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>644</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00695_2</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If no upper layer modules are configured for transceiver mode indications
        using &lt;User_TrcvModeIndication&gt;(), no transceiver mode indication needs
        to be configured. CANIF_DISPATCH_USERTRCVMODEINDICATION_UL needs not to
        be configured.
      </description>
         <comment>
        This requirement is informational only.
        This is a configuration hint in order to optimize resource consumption.
        This is no requirement for the implementation.
      </comment>
         <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00695</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>643</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>645</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00695_3</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If transceivers are not supported (
        CanInterfaceTransceiverDriverConfiguration is not configured, see
        CanIf.ECUC_CanIf_00273), CANIF_DISPATCH_USERTRCVMODEINDICATION_UL is not
        configurable.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_619</srcid><srcstatus/><internalId>1255</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00695</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>643</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>646</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00696</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TrcvModeIndication&gt;(): The name of &lt;User_TrcvModeIndication&gt;() which 
        will be called by CanIf shall be configured for CanIf by parameter CanIfDispatchCfg.
        CanIfDispatchUserTrcvModeIndicationName. This is only necessary if state transition 
        notifications are configured via CanIfDispatchCfg.CanIfDispatchUserTrcvModeIndicationUL.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserTrcvModeIndication</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>647</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00697</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TrcvModeIndication&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserTrcvModeIndicationUL is set to CAN_SM, CanIfDispatchCfg.
        CanIfDispatchUserTrcvModeIndicationName must be CanSM_TransceiverModeIndication.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValidTrcvId</srcid><srcstatus/><internalId>1352</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeInd_1Trcv</srcid><srcstatus/><internalId>1370</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeInd</srcid><srcstatus/><internalId>1378</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>648</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00698</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TrcvModeIndication&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserTrcvModeIndicationUL is set to CDD the name of the API has to be configured 
        via parameter CanIfDispatchCfg.CanIfDispatchUserTrcvModeIndicationName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserTrcvModeIndication</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>649</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00699</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ControllerModeIndication 
        Syntax 
        void CanIf_ControllerModeIndication (uint8 ControllerId, Can_ControllerStateType ControllerMode)
        Service ID [hex] | 0x17 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | ControllerId | Abstract CanIf ControllerId which is assigned to a CAN 
        controller, which state has been transitioned.
        ControllerMode | Mode to which the CAN controller transitioned 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates a controller state transition referring to the 
        corresponding CAN controller with the abstract CanIf ControllerId.
        Available via | CanIf_Can.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_44_TX_RX</srcid><srcstatus/><internalId>1395</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_TRANSMIT</srcid><srcstatus/><internalId>1547</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_RXINDICATION</srcid><srcstatus/><internalId>1548</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_SETBAUDRATE</srcid><srcstatus/><internalId>1549</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CHECKWAKEUP</srcid><srcstatus/><internalId>1550</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1551</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1552</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CANCELTXCONFIRMATION</srcid><srcstatus/><internalId>1553</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_CONTROLLERBUSOFF</srcid><srcstatus/><internalId>1554</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MULTIDRV_OFFSETTXBUFF</srcid><srcstatus/><internalId>1555</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>650</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00700</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_ControllerModeIndication() has an invalid value, CanIf shall 
        report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the 
        DET module, when CanIf_ControllerModeIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ControllerModeIndication_InvalidCtrl_1</srcid><srcstatus/><internalId>1434</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ControllerModeIndication_InvCtrl</srcid><srcstatus/><internalId>1458</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CONTROLLER</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>45</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>651</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00702</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf was not initialized before calling CanIf_ControllerModeIndication(), CanIf shall not 
        execute state transition notification, when CanIf_ControllerModeIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ControllerModeIndicationBeforeInit</srcid><srcstatus/><internalId>1708</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>652</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00706</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_TrcvModeIndication() has an invalid value, CanIf shall 
        report development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the DET 
        module, when CanIf_TrcvModeIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndInvalidTrcvId</srcid><srcstatus/><internalId>1353</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndication_InvTrcv</srcid><srcstatus/><internalId>1478</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>653</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00708</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf was not initialized before calling CanIf_TrcvModeIndication(), CanIf shall not execute 
        state transition notification, when CanIf_TrcvModeIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndicationBeforeInit</srcid><srcstatus/><internalId>1709</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>654</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00710</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_TrcvModeIndication(): ID of the CAN Transceiver is published inside the 
        configuration description of CanIf via parameter CanIfTrcvCfg.CanIfTrcvId.
      </description>
      <comment>
        According to the SWS chapter 7.5 (compare CANIF653 and the text after
      CANIF655), the value passed in parameter TransceiverId to CanIf_TrcvModeIndication() is
      the tracnsceiver ID defined in the CAN transceiver driver.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SymbolicNameValues</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>655</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00711</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When callback CanIf_ControllerModeIndication(ControllerId, ControllerMode) is called, CanIf 
        shall call CanSm_ControllerModeIndication(ControllerId, ControllerMode) of the CanSm or a CDD 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UserControllerModeIndication</srcid><srcstatus/><internalId>1421</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>656</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00712</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When callback CanIf_TrcvModeIndication(Transceiver, TransceiverMode) is called, CanIf shall 
        call CanSM_TransceiverModeIndication(TransceiverId, TransceiverMode) of the CanSm or a CDD 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeInd_1Trcv</srcid><srcstatus/><internalId>1370</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeInd</srcid><srcstatus/><internalId>1378</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UserTrcvModeIndication</srcid><srcstatus/><internalId>1422</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>657</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00720</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If at least one function call of Can_CheckWakeup() or CanTrcv_CheckWakeup() returns E_OK to 
        CanIf, then CanIf_CheckWakeup() shall return E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00720</srcid><srcstatus/><internalId>247</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CheckWakeupReturnValues</srcid><srcstatus/><internalId>1111</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>658</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00724</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When callback CanIf_ControllerBusOff(ControllerId) is called, the CanIf shall call 
        CanSM_ControllerBusOff(ControllerId) of the CanSm or a CDD 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30444</srcid><srcstatus/><internalId>1420</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30217</srcid><srcstatus/><internalId>1762</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31233</srcid><srcstatus/><internalId>1776</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>659</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00730</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_TrcvModeIndication(): If transceivers are not supported (CanIfTrcvDrvCfg 
        is not configured, seeCanIfTrcvDrvCfg), CanIf_TrcvModeIndication() shall not be provided by 
        CanIf.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31234</srcid><srcstatus/><internalId>1328</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_TrcvAvailability</srcid><srcstatus/><internalId>1351</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOf_403_and_422_Trcv_UsedTrcv</srcid><srcstatus/><internalId>1416</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_AccessToPnSupport_DependentOfUsedTrcv</srcid><srcstatus/><internalId>1417</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ConTest_ParametersRelatedTo_PnSupport_SetTo_FALSE</srcid><srcstatus/><internalId>1569</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>660</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00734</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetTxConfirmationState 
        Syntax 
        CanIf_NotifStatusType CanIf_GetTxConfirmationState (uint8 ControllerId)
        Service ID [hex] | 0x19 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant (Not for the same controller)
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | CanIf_NotifStatusType | Combined TX confirmation status for all TX PDUs of the 
        CAN controller 
        Description | This service reports, if any TX confirmation has been done for the whole CAN 
        controller since the last CAN controller start.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetTxConfStateDetUninit</srcid><srcstatus/><internalId>1452</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTxConfStateDetCtrlId</srcid><srcstatus/><internalId>1486</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTxConfStateGen</srcid><srcstatus/><internalId>1764</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTxConfStateClearStat</srcid><srcstatus/><internalId>1765</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTxConfStateBusOff</srcid><srcstatus/><internalId>1766</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTxConfStateOffAct</srcid><srcstatus/><internalId>1767</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>661</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00736</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_GetTxConfirmationState() has an invalid value, the CanIf 
        shall report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service 
        of the DET module, when CanIf_GetTxConfirmationState() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetTxConfStateDetCtrlId</srcid><srcstatus/><internalId>1486</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CONTROLLERID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>46</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>662</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00738</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_GetTxConfirmationState(): If BusOff Recovery of CanSm doesn't need the 
        status of the Tx confirmations , this API can be omitted by disabling of CanIfPublicCfg.
        CanIfPublicTxConfirmPollingSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31377</srcid><srcstatus/><internalId>1332</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30377</srcid><srcstatus/><internalId>1701</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>663</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00739</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If a controller mode referenced by ControllerId enters state CAN_CS_STOPPED, then CanIf shall 
        inform corresponding upper layer modules about failed transmission by calling &lt;
        User_TxConfirmation&gt;(id, E_NOT_OK) for every outstanding TxConfirmation assigned to that CAN 
        Controller. If CanIfPublicCfg.CanIfPublicTxConfirmPollingSupport is enabled, CanIf shall also 
        clear the information about a TxConfirmation 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk</srcid><srcstatus/><internalId>665</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag</srcid><srcstatus/><internalId>666</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>664</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If a controller mode referenced by ControllerId enters state CAN_CS_STOPPED,
        then CanIf shall inform corresponding upper layer modules about failed transmission
        by calling &lt;User_TxConfirmation&gt;(id, E_NOT_OK) for every outstanding TxConfirmation
        assigned to that CAN Controller.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_CTRL_MODE_STOPPED</srcid><srcstatus/><internalId>1598</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4417</srcid><srcstatus/><internalId>1163</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4624</srcid><srcstatus/><internalId>1167</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00739</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>664</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>665</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If a controller mode referenced by ControllerId enters state CAN_CS_STOPPED,
        If CanIfPublicTx-ConfirmPollingSupport is enabled, CanIf shall also clear
        the information about a TxConfirmation (see [SWS_CANIF_00740])
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_CTRL_MODE_STOPPED</srcid><srcstatus/><internalId>1598</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4428</srcid><srcstatus/><internalId>1164</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4635</srcid><srcstatus/><internalId>1168</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00739</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>664</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>666</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00740</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIfPublicCfg.CanIfPublicTxConfirmPollingSupport is enabled, CanIf shall buffer the 
        information about a received TxConfirmation per CAN Controller, if the controller mode of that 
        controller is in state CAN_CS_STARTED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_GetTxConfStateGen</srcid><srcstatus/><internalId>1764</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTxConfStateBusOff</srcid><srcstatus/><internalId>1766</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_GetTxConfStateOffAct</srcid><srcstatus/><internalId>1767</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>667</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00753</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_ConfirmPnAvailability() is called, CanIf calls &lt;User_ConfirmPnAvailability&gt;
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>668</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00754</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_ConfirmPnAvailability(): This function shall be pre compile time 
        configurable ON/OFF by the configuration parameter CanIfPublicCfg.CanIfPublicPnSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_POLLING_SUPPORT</srcid><srcstatus/><internalId>1341</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>669</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00757</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_ClearTrcvWufFlagIndication() is called, CanIf calls &lt;User_ClearTrcvWufFlagIndication&gt;
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>670</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00759</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_CheckTrcvWakeFlagIndication() is called, CanIf calls &lt;User_CheckTrcvWakeFlagIndication&gt;
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>671</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00760</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ClearTrcvWufFlag 
        Syntax 
        Std_ReturnType CanIf_ClearTrcvWufFlag (uint8 TransceiverId)
        Service ID [hex] | 0x1e 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant for different CAN transceivers 
        Parameters (in) | TransceiverId | Abstract CanIf TransceiverId, which is assigned to the 
        designated CAN transceiver.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request has been acceptedE_NOT_OK: Request has not been 
        accepted 
        Description | Requests the CanIf module to clear the WUF flag of the designated CAN transceiver.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ClearTrcvWufFlagInvalid</srcid><srcstatus/><internalId>1366</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>672</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00761</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_CheckTrcvWakeFlag 
        Syntax 
        Std_ReturnType CanIf_CheckTrcvWakeFlag (uint8 TransceiverId)
        Service ID [hex] | 0x1f 
        Sync/Async | Asynchronous 
        Reentrancy | Reentrant for different CAN transceivers 
        Parameters (in) | TransceiverId | Abstract CanIf TransceiverId, which is assigned to the 
        designated CAN transceiver.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Request has been acceptedE_NOT_OK: Request has not been 
        accepted 
        Description | Requests the CanIf module to check the Wake flag of the designated CAN 
        transceiver.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlagInvalid</srcid><srcstatus/><internalId>1365</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>673</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00762</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ClearTrcvWufFlagIndication 
        Syntax 
        void CanIf_ClearTrcvWufFlagIndication (uint8 TransceiverId)
        Service ID [hex] | 0x20 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | TransceiverId | Abstract CanIf TransceiverId, which is assigned to a CAN 
        transceiver, for which this function was called.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates that the transceiver has cleared the WufFlag referring to 
        the corresponding CAN transceiver with the abstract CanIf TransceiverId.
        Available via | CanIf_CanTrcv.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ClearTrcvIndInvalidTrcvId</srcid><srcstatus/><internalId>1362</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>674</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00763</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_CheckTrcvWakeFlagIndication 
        Syntax 
        void CanIf_CheckTrcvWakeFlagIndication (uint8 TransceiverId)
        Service ID [hex] | 0x21 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | TransceiverId | Abstract CanIf TransceiverId, which is assigned to a CAN 
        transceiver, for which this function was called.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates that the check of the transceiver's wake-up flag has been 
        finished by the corresponding CAN transceiver with the abstract CanIf TransceiverId. This 
        indication is used to cope with the asynchronous transceiver communication.
        Available via | CanIf_CanTrcv.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTrcvIndInvalidTrcvId</srcid><srcstatus/><internalId>1361</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>675</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00764</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_TrcvModeIndication 
        Syntax 
        void CanIf_TrcvModeIndication (uint8 TransceiverId, CanTrcv_TrcvModeType TransceiverMode)
        Service ID [hex] | 0x22 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | TransceiverId | Abstract CanIf TransceiverId, which is assigned to a CAN 
        transceiver, which state has been transitioned.
        TransceiverMode | Mode to which the CAN transceiver transitioned 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates a transceiver state transition referring to the 
        corresponding CAN transceiver with the abstract CanIf TransceiverId.
        Available via | CanIf_CanTrcv.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.SWS_CanIf_00764</srcid><srcstatus/><internalId>245</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.Changed_ServiceID</srcid><srcstatus/><internalId>1101</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>676</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00765</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Within CanIf_CheckTrcvWakeFlag() the function CanTrcv_CheckWakeFlag() shall be called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlagValid</srcid><srcstatus/><internalId>1363</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlagInvalid</srcid><srcstatus/><internalId>1365</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>677</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00766</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Within CanIf_ClearTrcvWufFlag() the function CanTrcv_ClearTrcvWufFlag() shall be called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ClearTrcvWufFlagValid</srcid><srcstatus/><internalId>1364</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>678</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00769</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_ClearTrcvWufFlag() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the DET 
        module, when CanIf_ClearTrcvWufFlag() is caled.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ClearTrcvWufFlagInvalid</srcid><srcstatus/><internalId>1366</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ClearTrcvWufFlag_NoPnTrcv</srcid><srcstatus/><internalId>1494</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>679</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00770</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_CheckTrcvWakeFlag() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the DET 
        module, when CanIf_CheckTrcvWakeFlag() is caled.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlagInvalid</srcid><srcstatus/><internalId>1365</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlag_NoPnTrcv</srcid><srcstatus/><internalId>1495</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>680</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00771</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_ClearTrcvWufFlag(): Whether the CanIf supports this function shall be 
        pre compile time configurable On/Off by the configuration parameter CanIfPublicCfg.
        CanIfPublicPnSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_POLLING_SUPPORT</srcid><srcstatus/><internalId>1341</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>681</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00774</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerMode of CanIf_SetControllerMode() has an invalid value (not 
        CAN_CS_STARTED, CAN_CS_SLEEP or CAN_CS_STOPPED), the CanIfshall report development error code 
        CANIF_E_PARAM_CTRLMODE to the Det_ReportError service of the DET module, when 
        CanIf_SetControllerMode() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30241</srcid><srcstatus/><internalId>1457</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_CTRLMODE</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>51</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>682</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00788</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_ClearTrcvWufFlagIndication&gt;
        Syntax 
        void &lt;User_ClearTrcvWufFlagIndication&gt; (uint8 TransceiverId)
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TransceiverId | Abstracted CanIf TransceiverId, for which this function was 
        called.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates that the CAN transceiver has cleared the WufFlag. This 
        function is called in CanIf_ClearTrcvWufFlagIndication.
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>683</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00794</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ClearTrcvWufFlagIndication&gt;(): The upper layer module, which is called 
        has to be configurable by CanIfDispatchCfg.CanIfDispatchUserClearTrcvWufFlagIndicationUL if 
        CanIfPublicCfg.CanIfPublicPnSupport equals True.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00796</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>686</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>684</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00795</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ClearTrcvWufFlagIndication&gt;(): The name of &lt;
        User_ClearTrcvWufFlagIndication&gt;() shall be configurable by CanIfDispatchCfg.
        CanIfDispatchUserClearTrcvWufFlagIndicationName if CanIfPublicCfg.CanIfPublicPnSupport equals 
        True.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00796</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>686</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>685</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00796</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ClearTrcvWufFlagIndication&gt;(): It shall be configurable by 
        CanIfPublicCfg.CanIfPublicPnSupport, if CanIf supports this service (False: not supported, True:
        supported)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00794</srcid><srcstatus/><internalId>684</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00795</srcid><srcstatus/><internalId>685</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>686</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00797</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ClearTrcvWufFlagIndication&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserClearTrcvWufFlagIndicationUL is set to CAN_SM, CanIfDispatchCfg.
        CanIfDispatchUserClearTrcvWufFlagIndicationName must be CanSM_ClearTrcvWufFlagIndication.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>687</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00798</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ClearTrcvWufFlagIndication&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserClearTrcvWufFlagIndicationUL is set to CDD, the name of the service has to be 
        configurable via parameter CanIfDispatchCfg.CanIfDispatchUserClearTrcvWufFlagIndicationName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>688</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00800</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_CheckTrcvWakeFlagIndication&gt;(): The upper layer module, which is called 
        has to be configurable by CanIfDispatchCfg.CanIfDispatchUserCheckTrcvWakeFlagIndicationUL if 
        CanIfPublicCfg.CanIfPublicPnSupport equals True.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00802</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>691</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>689</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00801</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_CheckTrcvWakeFlagIndication&gt;(): The name of &lt;
        User_CheckTrcvWakeFlagIndication&gt;() shall be configurable by CanIfDispatchCfg.
        CanIfDispatchUserCheckTrcvWakeFlagIndicationName if CanIfPublicCfg.CanIfPublicPnSupport equals 
        True.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00802</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>691</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>690</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00802</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_CheckTrcvWakeFlagIndication&gt;(): It shall be configurable by 
        CanIfPublicCfg.CanIfPublicPnSupport, if CanIf supports this service (False: not supported, True:
        supported)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00800</srcid><srcstatus/><internalId>689</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00801</srcid><srcstatus/><internalId>690</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>691</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00803</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_CheckTrcvWakeFlagIndication&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserCheckTrcvWakeFlagIndicationUL is set to CAN_SM, CanIfDispatchCfg.
        CanIfDispatchUserCheckTrcvWakeFlagIndicationName must be 
        CanSM_CheckTransceiverWakeFlagIndication.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>692</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00804</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_CheckTrcvWakeFlagIndication&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserCheckTrcvWakeFlagIndicationUL is set to CDD, the name of the service has to be 
        configurable via parameter CanIfDispatchCfg.CanIfDispatchUserCheckTrcvWakeFlagIndicationName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>693</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00805</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_ClearTrcvWufFlagIndication() has an invalid value, CanIf 
        shall report development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the 
        DET module, when CanIf_ClearTrcvWufFlagIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ClearTrcvIndInvalidTrcvId</srcid><srcstatus/><internalId>1362</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>694</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00806</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf was not initialized before calling CanIf_ClearTrcvWufFlagIndication(), CanIf shall not 
        execute notification, when CanIf_ClearTrcvWufFlagIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ClearTrcvWufFlagIndication_NOINIT</srcid><srcstatus/><internalId>1441</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>695</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00808</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_ClearTrcvWufFlagIndication(): This function shall be pre compile time 
        configurable ON/OFF by the configuration parameter CanIfPublicCfg.CanIfPublicPnSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_POLLING_SUPPORT</srcid><srcstatus/><internalId>1341</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>696</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00809</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_CheckTrcvWakeFlagIndication() has an invalid value, CanIf 
        shall report development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the 
        DET module, when CanIf_CheckTrcvWakeFlagIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTrcvIndInvalidTrcvId</srcid><srcstatus/><internalId>1361</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>697</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00810</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the CanIf was not initialized before calling CanIf_CheckTrcvWakeFlagIndication(), CanIf 
        shall not execute notification, when CanIf_CheckTrcvWakeFlagIndication() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlagIndication_NOINIT</srcid><srcstatus/><internalId>1442</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>698</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00812</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_CheckTrcvWakeFlagIndication(): This function shall be pre compile time 
        configurable ON/OFF by the configuration parameter CanIfPublicCfg.CanIfPublicPnSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_POLLING_SUPPORT</srcid><srcstatus/><internalId>1341</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>699</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00813</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_CheckTrcvWakeFlag(): Whether the CanIf supports this function shall be 
        pre compile time configurable On/Off by the configuration parameter CanIfPublicCfg.
        CanIfPublicPnSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_POLLING_SUPPORT</srcid><srcstatus/><internalId>1341</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>700</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00814</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_CheckTrcvWakeFlagIndication&gt;
        Syntax 
        void &lt;User_CheckTrcvWakeFlagIndication&gt; (uint8 TransceiverId)
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | TransceiverId | Abstracted CanIf TransceiverId, for which this function was 
        called.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates that the wake up flag in the CAN transceiver is set. This 
        function is called in CanIf_CheckTrcvWakeFlagIndication.
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>701</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00815</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ConfirmPnAvailability 
        Syntax 
        void CanIf_ConfirmPnAvailability (uint8 TransceiverId)
        Service ID [hex] | 0x1a 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | TransceiverId | Abstract CanIf TransceiverId, which is assigned to a CAN 
        transceiver, which was checked for PN availability.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates that the transceiver is running in PN communication mode 
        referring to the corresponding CAN transceiver with the abstract CanIf TransceiverId.
        Available via | CanIf_CanTrcv.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ConfirmPnIndInvalidTrcvId</srcid><srcstatus/><internalId>1360</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>702</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00816</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TransceiverId of CanIf_ConfirmPnAvailability() has an invalid value, CanIf shall 
        report development error code CANIF_E_PARAM_TRCV to the Det_ReportError service of the DET 
        module, when CanIf_ConfirmPnAvailability() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ConfirmPnIndInvalidTrcvId</srcid><srcstatus/><internalId>1360</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_PARAM_TRCV</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>48</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00156</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>59</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>703</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00817</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf was not initialized before calling CanIf_ConfirmPnAvailability(), CanIf shall not 
        execute notification, when CanIf_ConfirmPnAvailability() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIf_ConfirmPnAvailability_NOINIT</srcid><srcstatus/><internalId>1443</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>704</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00821</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_ConfirmPnAvailability&gt;
        Syntax 
        void &lt;User_ConfirmPnAvailability&gt; (uint8 TransceiverId)
        Sync/Async | (defined within providing upper layer module)
        Reentrancy | (defined within providing upper layer module)
        Parameters (in) | TransceiverId | Abstract CanIf TransceiverId, which is assigned to a CAN 
        transceiver, which was checked for PN availability.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | This service indicates that the CAN transceiver is running in PN communication 
        mode.
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>705</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00823</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ConfirmPnAvailability&gt;(): The upper layer module, which is called , has 
        to be configurable by CanIfDispatchCfg.CanIfDispatchUserConfirmPnAvailabilityUL if 
        CanIfPublicCfg.CanIfPublicPnSupport equals True.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00825</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>708</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>706</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00824</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ConfirmPnAvailability&gt;(): The name of &lt;User_ConfirmPnAvailability&gt;() 
        shall be configurable by CanIfDispatchCfg.CanIfDispatchUserConfirmPnAvailabilityName if 
        CanIfPublicCfg.CanIfPublicPnSupport equals True.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00825</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>708</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>707</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00825</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ConfirmPnAvailability&gt;(): It shall be configurable by CanIfPublicCfg.
        CanIfPublicPnSupport, if CanIf supports this service (False: not supported, True: supported)
      </description>
      <comment>
        Duplicated by CanIf.SWS_CanIf_00823 and CanIf.SWS_CanIf_00824
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00823</srcid><srcstatus/><internalId>706</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00824</srcid><srcstatus/><internalId>707</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>708</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00826</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ConfirmPnAvailability&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserConfirmPnAvailabilityUL is set to CAN_SM, CanIfDispatchCfg.
        CanIfDispatchUserConfirmPnAvailabilityName must be CanSM_ConfirmPnAvailability.
      </description>
      <comment>
        The restriction for the name of the function parameter has been removed from this
        requirement. The name of a function parameter has no relevance for the
        specifcation of a C interface.
        This part is non-functional and of no relevance.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>709</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00827</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_ConfirmPnAvailability&gt;(): If CanIfDispatchCfg.
        CanIfDispatchUserConfirmPnAvailabilityUL is set to CDD, the name of the service has to be 
        configurable via parameter CanIfDispatchCfg.CanIfDispatchUserConfirmPnAvailabilityName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>710</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00829</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall pass the received  length value to the target upper layer module , if the Data 
        Length Check is passed.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_FdDlcCheckPass</srcid><srcstatus/><internalId>1405</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31144</srcid><srcstatus/><internalId>1556</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxRange_1</srcid><srcstatus/><internalId>1557</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>711</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00830</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall pass the received  length value to the target upper layer module , if the Data 
        Length Check is not configured(see CanIfPrivateDataLengthCheck and CanIfRxPduDataLengthCheck).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30363</srcid><srcstatus/><internalId>1558</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30416</srcid><srcstatus/><internalId>1559</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30335</srcid><srcstatus/><internalId>1760</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30876</srcid><srcstatus/><internalId>1761</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>712</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00835</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When CanIf checks whether it is possible to buffer a CanIf Tx L-PDU or a Transmit Request , 
        this shall only be possible, if the CanIf Tx L-PDU is assigned  to a CanIfBufferCfg , which is 
        configured with a buffer size  bigger than zero.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_FdBuffering</srcid><srcstatus/><internalId>1409</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_2</srcid><srcstatus/><internalId>1571</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30318</srcid><srcstatus/><internalId>1722</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>713</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00835.CanIf_TxBufferSize_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
        <description>
      The buffer size of any CanIfTxBuffer is only configurable bigger than zero,
      if transmit buffering is enabled.
      </description>
         <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TxBuffer</srcid><srcstatus/><internalId>1081</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>714</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00835.CanIf_TxBufferSize_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
      Additionally the buffer size of a single CanIfTxBuffer is only configurable bigger than
      zero if the CanIfTxBuffer is not assigned to a FullCAN HTH (see CanIf.ECUC_CanIf_00834).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.CanIf.PBconfig.bufferindex</srcid><srcstatus/><internalId>1314</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>715</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00836</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If it is possible to buffer a CanIf Tx L-PDU or a Transmit Request, because the buffer size of 
        the assigned CanIfTxBuffer is bigger than zero , CanIf shall buffer a CanIf Tx L-PDU or the 
        Transmit Request in a free buffer element of the assigned CanIfTxBuffer, if the CanIf Tx L-PDU 
        or the Transmit Request is not already buffered in the CanIfTxBuffer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_FdBuffering</srcid><srcstatus/><internalId>1409</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30318</srcid><srcstatus/><internalId>1722</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>716</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00837</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the buffer size is greater zero, all buffer elements are busy and CanIf_Transmit() is called 
        with a new L-PDU (no other instance of the same L-PDU is already stored in the buffer), then 
        the new L-PDU or its Transmit Request shall not be stored and CanIf_Transmit() shall return 
        E_NOT_OK.
      </description>
      <comment>
        Curent Tx-Buffering implementation provides a single Buffer per LPdu.
        Thus this scenario described here cannot happen.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TxBuffer</srcid><srcstatus/><internalId>1081</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>717</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00999</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        These requirements are not applicable to this specification.
      </description>
      <comment>
        This requirement is informational only.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>718</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00822</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduCanIdMask 
        Parent Container | CanIfRxPduCfg 
        Description | Identifier mask which denotes relevant bits in the CAN Identifier. This parameter 
        defines a CAN Identifier range in an alternative way to CanIfRxPduCanIdRange. It identifies the 
        bits of the configured CAN Identifier that must match the received CAN Identifier. Range: 11 
        bits for Standard CAN Identifier, 29 bits for Extended CAN Identifier.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value | 536870911 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PBMultiplicity</srcid><srcstatus/><internalId>1109</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ECUC_CanIf_00822_1</srcid><srcstatus/><internalId>720</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>719</internalId></specobject>
    
    <specobject>
      <id>CanIf.ECUC_CanIf_00822_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduCanIdMask 
        Parent Container | CanIfRxPduCfg 
        Description | Identifier mask which denotes relevant bits in the CAN Identifier. This parameter 
        defines a CAN Identifier range in an alternative way to CanIfRxPduCanIdRange. It identifies the 
        bits of the configured CAN Identifier that must match the received CAN Identifier. Range: 11 
        bits for Standard CAN Identifier, 29 bits for Extended CAN Identifier.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value | 536870911 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <verifycrit>
        EC valid: EcuC_SetMetaDataCanId() is called with correct parameters if the CanId of the
                  received PDU is correct.
        EC invalid: EcuC_SetMetaDataCanId() is not called if the CanId of the received PDU is incorrect.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_1255</srcid><srcstatus/><internalId>1258</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_RX</srcid><srcstatus/><internalId>1508</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_CANID_MASKED</srcid><srcstatus/><internalId>1509</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_MIXED</srcid><srcstatus/><internalId>1512</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00822</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>719</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>720</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00823</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduCanIdMask 
        Parent Container | CanIfTxPduCfg 
        Description | Identifier mask which denotes relevant bits in the CAN Identifier. This parameter 
        may be used to keep parts of the CAN Identifier of dynamic transmit L-PDUs static. Range: 11 
        bits for Standard CAN Identifier, 29 bits for Extended CAN Identifier.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 3758096383 
        Default value | 3758096383 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <verifycrit>
          EC valid: 1. If CanIfTxPduCanIdMask is not configured: After CanIf_Transmit() is called for a
          PDU which contains metadata and doesn't have a CANID configured, CanIf calls Can_Write()
          with the CANID provided in the metadata.
          2. If CanIfTxPduCanIdMask is configured: After CanIf_Transmit() is called for a
          PDU which contains metadata, Can_Write() is called with a CanId combined from
          CanIfTxPduCanId and Metadata based on CanIfTxPduCanIdMask.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PBMultiplicity</srcid><srcstatus/><internalId>1109</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ECUC_CanIf_00823_1</srcid><srcstatus/><internalId>722</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>721</internalId></specobject>
    
    <specobject>
      <id>CanIf.ECUC_CanIf_00823_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduCanIdMask 
        Parent Container | CanIfTxPduCfg 
        Description | Identifier mask which denotes relevant bits in the CAN Identifier. This parameter 
        may be used to keep parts of the CAN Identifier of dynamic transmit L-PDUs static. Range: 11 
        bits for Standard CAN Identifier, 29 bits for Extended CAN Identifier.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 3758096383 
        Default value | 3758096383 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <verifycrit>
        EC valid: 1. If CanIfTxPduCanIdMask is not configured: After CanIf_Transmit() is called for a
        PDU which contains metadata and doesn't have a CANID configured, CanIf calls Can_Write()
        with the CANID provided in the metadata.
        2. If CanIfTxPduCanIdMask is configured: After CanIf_Transmit() is called for a
        PDU which contains metadata, Can_Write() is called with a CanId combined from
        CanIfTxPduCanId and Metadata based on CanIfTxPduCanIdMask.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_1997</srcid><srcstatus/><internalId>1263</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00823</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>721</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>722</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00824</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfMetaDataSupport 
        Parent Container | CanIfPublicCfg 
        Description | Enable support for dynamic ID handling using L-SDU MetaData.
        Multiplicity | 0..1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.OptionalConfigParameters</srcid><srcstatus/><internalId>1110</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ECUC_CanIf_00824_1</srcid><srcstatus/><internalId>724</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>723</internalId></specobject>
    
    <specobject>
      <id>CanIf.ECUC_CanIf_00824_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfMetaDataSupport 
        Parent Container | CanIfPublicCfg 
        Description | Enable support for dynamic ID handling using L-SDU MetaData.
        Multiplicity | 1
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3050</srcid><srcstatus/><internalId>1270</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX</srcid><srcstatus/><internalId>1508</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_CANID_MASKED</srcid><srcstatus/><internalId>1509</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_MIXED</srcid><srcstatus/><internalId>1512</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00824</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>723</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>724</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00825</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHrhRangeBaseId 
        Parent Container | CanIfHrhRangeCfg 
        Description | CAN Identifier used as base value in combination with CanIfHrhRangeMask for a 
        masked ID range in which all CAN Ids shall pass the software filtering. The size of this 
        parameter is limited by CanIfHrhRangeRxPduRangeCanIdType.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>725</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00826</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfHrhRangeMask 
        Parent Container | CanIfHrhRangeCfg 
        Description | Used as mask value in combination with CanIfHrhRangeBaseId for a masked ID range 
        in which all CAN Ids shall pass the software filtering. The size of this parameter is limited 
        by CanIfHrhRangeRxPduRangeCanIdType.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 536870911 
        Default value 
        Post-Build Variant Multiplicity | true 
        Post-Build Variant Value | true 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>726</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00827</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfFixedBuffer 
        Parent Container | CanIfPrivateCfg 
        Description | This parameter defines if the buffer element length shall be fixed to 8 Bytes for 
        buffers to which only PDUs &lt; 8 Bytes are assigned. TRUE: Minimum buffer element length is fixed 
        to 8 Bytes. FALSE: Buffer element length depends on the configured length of the referenced 
        global PDUs 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_2463</srcid><srcstatus/><internalId>1268</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>727</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00828</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfMaxBufferSize 
        Parent Container | CanIfInitCfg 
        Description | Maximum total size of all Tx buffers. This parameter is needed only in case of 
        post-build loadable implementation using static memoryallocation.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 18446744073709551615 
        Default value 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIfMaxBufferSize</srcid><srcstatus/><internalId>1107</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.CanIfPublicMaxTxBuffers</srcid><srcstatus/><internalId>922</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>728</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00829</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfMaxTxPduCfg 
        Parent Container | CanIfInitCfg 
        Description | Maximum number of Pdus. This parameter is needed only in case of post-build 
        loadable implementation using static memory allocation.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 18446744073709551615 
        Default value 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.MaxPdu</srcid><srcstatus/><internalId>1093</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>729</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00830</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfMaxRxPduCfg 
        Parent Container | CanIfInitCfg 
        Description | Maximum number of Pdus. This parameter is needed only in case of post-build 
        loadable implementation using static memory allocation.
        Multiplicity | 0..1 
        Type | EcucIntegerParamDef 
        Range | 0.. 18446744073709551615 
        Default value 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_749</srcid><srcstatus/><internalId>1257</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>730</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00837</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxOfflineActiveSupport 
        Parent Container | CanIfPublicCfg 
        Description | Determines wether TxOffLineActive feature  is supported by CanIf. True: 
        EnabledFalse: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>731</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00838</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfSetBaudrateApi 
        Parent Container | CanIfPublicCfg 
        Description | Configuration parameter to enable/disable the CanIf_SetBaudrate API to change the 
        baud rate of a CAN Controller. If this parameter is set to true the CanIf_SetBaudrate API shall 
        be supported. Otherwise the API is not supported.
        Multiplicity | 0..1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ECUC_CanIf_00838_1</srcid><srcstatus/><internalId>733</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.OptionalConfigParameters</srcid><srcstatus/><internalId>1110</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>732</internalId></specobject>
    
    <specobject>
      <id>CanIf.ECUC_CanIf_00838_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfSetBaudrateApi 
        Parent Container | CanIfPublicCfg 
        Description | Configuration parameter to enable/disable the CanIf_SetBaudrate API to change the 
        baud rate of a CAN Controller. If this parameter is set to true the CanIf_SetBaudrate API shall 
        be supported. Otherwise the API is not supported.
        Multiplicity | 1
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_SetBaudrate</srcid><srcstatus/><internalId>1337</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SetBaudrate_API</srcid><srcstatus/><internalId>1706</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00838</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>732</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>733</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00137</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIf_PduModeType 
        Kind | Enumeration 
        Range | CANIF_OFFLINE | 0x00 | = 0 Transmit and receive path of the corresponding channel are 
        disabled =&gt; no communication mode 
        CANIF_TX_OFFLINE | 0x01 | Transmit path of the corresponding channel is disabled. The receive 
        path is enabled.
        CANIF_TX_OFFLINE_ACTIVE | 0x02 | Transmit path of the corresponding channel is in offline 
        active mode . The receive path is disabled. This mode requires CanIfTxOfflineActiveSupport = 
        TRUE.
        CANIF_ONLINE | 0x03 | Transmit and receive path of the corresponding channel are enabled =&gt; 
        full operation mode 
        Description | The PduMode of a channel defines its transmit or receive activity. Communication 
        direction (transmission and/or reception) of the channel can be controlled separately or 
        together by upper layers.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PDUMODETYPE</srcid><srcstatus/><internalId>1426</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30309</srcid><srcstatus/><internalId>1736</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>734</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00144</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIf_ConfigType 
        Kind | Structure 
        Elements | implementation specific 
        Type 
        Comment | The contents of the initialization data structure are CAN interface specific 
        Description | This type defines a data structure for the post build parameters of the CAN 
        interface for all underlying CAN drivers. At initialization the CanIf gets a pointer to a 
        structure of this type to get access to its configuration data, which is necessary for 
        initialization.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swdd</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dsn.CanIf.PostBuildConfigurationData</srcid><srcstatus/><internalId>1313</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>735</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00162</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the call of Can_Write() returns E_OK the transmit request service CanIf_Transmit() shall 
        return E_OK.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_Transmit300Hths</srcid><srcstatus/><internalId>1544</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30317</srcid><srcstatus/><internalId>1721</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>736</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00201</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIf_NotifStatusType 
        Kind | Enumeration 
        Range | CANIF_TX_RX_NOTIFICATION | -- | The requested Rx/Tx CAN L-PDU was successfully 
        transmitted or received.
        CANIF_NO_NOTIFICATION | 0x00 | No transmit or receive event occurred for the requested L-PDU.
        Description | Return value of CAN L-PDU notification status.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NOTIFSTATUSTYPE</srcid><srcstatus/><internalId>1427</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_SW_FILTERING_SUPPORTED_READRXNOTIFYSTATUS</srcid><srcstatus/><internalId>1561</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>737</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00286</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIfPublicCfg.CanIfPublicWakeupCheckValidSupport equals TRUE, CanIf enables the detection 
        for CAN wake-up validation. Therefore, CanIf stores the event of the first valid call of 
        CanIf_RxIndication() of a CAN Controller which has been set to CAN_CS_STARTED. The first call 
        of CanIf_RxIndication() is valid:
        only for received NM messages if CanIfPublicCfg.CanIfPublicWakeupCheckValidByNM is TRUE
        for all received messages corresponding to a configured Rx PDU if CanIfPublicCfg.
        CanIfPublicWakeupCheckValidByNM is FALSE.
      </description>
      <comment>
        CanIf behaves here as specified in Rev 2.
        See requirements CanIf.EB.CANIF403 and CanIf.EB.CANIF680 for details.
      AUTOSAR R20-11 comment: Covered by CanIf.EB.SWS_CANIF_00286_1 &amp; CanIf.EB.SWS_CANIF_00286_2;
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.WakeupValidation</srcid><srcstatus/><internalId>1082</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.CANIF680</srcid><srcstatus/><internalId>233</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.SWS_CANIF_00286_1</srcid><srcstatus/><internalId>1002</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.SWS_CANIF_00286_2</srcid><srcstatus/><internalId>1003</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.CANIF403</srcid><srcstatus/><internalId>1043</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>738</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00391</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If configuration parameters CanIfPublicCfg.CanIfPublicReadTxPduNotifyStatusApi and 
        CanIfTxPduCfg.CanIfTxPduReadNotifyStatus for the Transmitted L-PDU are set to TRUE, and if 
        CanIf_TxConfirmation() is called, CanIf shall set the notification status for the Transmitted L-
        PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30205</srcid><srcstatus/><internalId>1732</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>739</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00662</id>
      <status>rejected</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall use two types of HOH to enable access to CanDrv:
        Hardware Transmit Handle (HTH) and
        Hardware Receive Handle (HRH)
      </description>
      <comment>
        This requirement is informational only.
        Descriptive text, no requirement.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>740</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00747</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If Partial Networking (PN) is enabled , CanIf shall support a PnTxFilter per CAN Controller 
        which overlays the PDU channel modes.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PnFilterBlocksTxPdu</srcid><srcstatus/><internalId>1564</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_PnFilterAllowsTxPdu</srcid><srcstatus/><internalId>1565</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterAfterTxConf</srcid><srcstatus/><internalId>1566</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterWithoutTxPdu</srcid><srcstatus/><internalId>1567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>741</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00748</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The PnTxFilter of SWS_CANIF_00747 shall only have an effect and transition its modes (enabled/
        disabled) if more than zero Tx L-PDU per CAN Controller are configured as CanIfTxPduPnFilterPdu 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PnFilterBlocksTxPdu</srcid><srcstatus/><internalId>1564</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_PnFilterAllowsTxPdu</srcid><srcstatus/><internalId>1565</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterAfterTxConf</srcid><srcstatus/><internalId>1566</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterWithoutTxPdu</srcid><srcstatus/><internalId>1567</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>742</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00749</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_SetControllerMode(ControllerId, CAN_CS_SLEEP) is called the PnTxFilter of the 
        corresponding CAN Controller shall be enabled (ref. to CanIf.SWS_CanIf_00748 and CanIf.SWS_CanIf_00747)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PnFilterBlocksTxPdu</srcid><srcstatus/><internalId>1564</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_PnFilterAllowsTxPdu</srcid><srcstatus/><internalId>1565</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterAfterTxConf</srcid><srcstatus/><internalId>1566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>743</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00750</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the PnTxFilter of a CAN Controller is enabled, CanIf shall block all Tx requests to that CAN 
        Controller (return E_NOT_OK when CanIf_Transmit() is called), except if the requested Tx L-PDU 
        is one of the configured CanIfTxPduPnFilterPdus of that CAN Controller. These 
        CanIfTxPduPnFilterPdus shall always be passed to the corresponding CAN Driver.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00750_1</srcid><srcstatus/><internalId>745</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00750_2</srcid><srcstatus/><internalId>746</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>744</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00750_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the PnTxFilter (ref. to CANIF749) of a CAN controller is enabled, the
        CanIf shall block all Tx requests (return E_NOT_OK when CanIf_Transmit()
        is called) to that CAN controller, except if the requested TxPdu is one
        of the configured PnFilterPdus of that CAN controller.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PnFilterBlocksTxPdu</srcid><srcstatus/><internalId>1564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00750</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>745</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00750_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        These PnFilterPdus shall always be passed to the corresponding CAN driver
        module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PnFilterAllowsTxPdu</srcid><srcstatus/><internalId>1565</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterAfterTxConf</srcid><srcstatus/><internalId>1566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00750</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>744</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>746</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00751</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_TxConfirmation() is called, the corresponding PnTxFilter shall be disabled (ref. to 
        CanIf.SWS_CanIf_00747 and CanIf.SWS_CanIf_00748)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NoPnFilterAfterTxConf</srcid><srcstatus/><internalId>1566</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>747</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00752</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the PnTxFilter of a CAN Controller is disabled, CanIf shall behave as requested via 
        CanIf_SetPduMode(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NoPnFilterAfterTxConf</srcid><srcstatus/><internalId>1566</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NoPnFilterWithoutTxPdu</srcid><srcstatus/><internalId>1567</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30317</srcid><srcstatus/><internalId>1721</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>748</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00756</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When controller mode is set to CAN_CS_SLEEP the stored event from previous wake-up (first call 
        of CanIf_RxIndication) shall be cleared 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupEventClear_OnTransitionToSleep</srcid><srcstatus/><internalId>1623</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>749</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00844</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall support dynamic L-PDU, where the CanId or relevant parts of the CanId are placed in 
        the MetaData of a L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1778</srcid><srcstatus/><internalId>1128</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>750</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00847</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration shall ensure that dynamic Receive L-PDU use an ID range or a mask and that the 
        MetaDataItem CAN_ID_32 is configured for the L-SDU. Besides, the software filtering must be 
        enabled for these L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.Metadata.Config.4</srcid><srcstatus/><internalId>963</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>751</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00848</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Upon reception of a dynamic L-SDU, CanIf shall place the CanId in the MetaDataItem of type 
        CAN_ID_32.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.Metadata.Functional.3</srcid><srcstatus/><internalId>967</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>752</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00849</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        For dynamic Transmit L-PDU, also the CanId has to be stored in the CanIfTxBuffer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_2628</srcid><srcstatus/><internalId>1135</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31232</srcid><srcstatus/><internalId>1596</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>753</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00851</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If MetaData is configured for a received L-SDU, CanIf shall copy the PDU payload to the static 
        receive buffer and the CAN ID to the MetaDataItem of type CAN_ID_32.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.MetadataRxBuffer</srcid><srcstatus/><internalId>1108</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>754</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00852</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If a range is (partly) contained in another range, or a single CanId is contained in a range, 
        the software filter shall select the L-PDU based on the following assumptions:
        A single CanId is always more relevant than a range.
        A smaller range is more relevant than a larger range.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.software</srcid><srcstatus/><internalId>1074</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>755</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00854</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the MetaDataItem CAN_ID_32, CanIfTxPduCanIdMask and CanIfTxPduCanId are available, 
        CanIfTxPduCanIdMask defines the bits in CanIfTxPduCanId and the bits of the Can_IdType derived 
        from CanIfTxPduCanIdType that shall appear in the actual CanId, the other bits are taken from 
        the MetaData.
      </description>
      <comment>
        The resulting ID could be calculated in the following way:
        (CanIfTxPduCanId &amp; CanIfTxPduCanIdMask) | (Metadata &amp; ~CanIfTxPduCanIdMask).
      </comment>
      <verifycrit>
        EC valid: Can_Write() is called with a CanId combined from CanIfTxPduCanId and Metadata
        based on CanIfTxPduCanIdMask.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1777</srcid><srcstatus/><internalId>1127</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>756</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00855</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIfTxPduCanIdMask and CanIfTxPduCanId are omitted, the CanId is directly taken from the 
        MetaData.
      </description>
      <comment>
        The whole CanId is provided via metadata.
      </comment>
      <verifycrit>
        EC valid: After CanIf_Transmit() is called for a PDU which contains metadata and doesn't have a CANID configured,
        CanIf calls Can_Write() with the CANID provided in the metadata.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1784</srcid><srcstatus/><internalId>1129</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>757</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00856</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIfTxPduCanIdMask shall be ignored when meta data configuration does not contain CAN_ID_32 
        for this L-SDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.Metadata.Config.3</srcid><srcstatus/><internalId>962</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>758</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00857</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf_Init()  initializes the CanId of the dynamic Transmit L-PDU with CanIfTxPduCfg.
        CanIfTxPduType to the value configured via CanIfTxPduCanId.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1338</srcid><srcstatus/><internalId>1123</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>759</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00858</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to J1939NM, CanIfTxPduCfg.CanIfTxPduUserTxConfirmationName must be J1939Nm_TxConfirmation.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE</srcid><srcstatus/><internalId>1599</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE_ACTIVE</srcid><srcstatus/><internalId>1600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>760</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00859</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): If CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL is set to 
        J1939NM, CanIfRxPduCfg.CanIfRxPduUserRxIndicationName must be J1939Nm_RxIndication.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_CDD_RXINDICATION</srcid><srcstatus/><internalId>1500</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>761</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00860</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_SetPduMode() is called with invalid PduModeRequest, CanIf shall report development 
        error code CANIF_E_PARAM_PDU_MODE to the Det_ReportError service of the DET module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PduModeRequest_InvPduMode</srcid><srcstatus/><internalId>1471</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>762</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00863</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        PnTxFilter shall be enabled during initialization (ref. to CanIf.SWS_CanIf_00747 and CanIf.SWS_CanIf_00748)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PnFilterBlocksTxPdu</srcid><srcstatus/><internalId>1564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>763</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00864</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        During initialization CanIf shall switch every channel to CANIF_OFFLINE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30293</srcid><srcstatus/><internalId>1713</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>764</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00865</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_SetControllerMode(ControllerId, CAN_CS_SLEEP) is called, CanIf shall set the PDU 
        channel mode of the corresponding channel to CANIF_OFFLINE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30339</srcid><srcstatus/><internalId>1604</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>765</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00866</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_SetControllerMode(ControllerId, CAN_CS_STOPPED) or CanIf_ControllerBusOff(ControllerId)
        is called, CanIf shall set the PDU channel mode of the corresponding channel to 
        CANIF_TX_OFFLINE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00866_1</srcid><srcstatus/><internalId>767</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00866_2</srcid><srcstatus/><internalId>768</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>766</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00866_1</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_SetControllerMode(ControllerId, CANIF_CS_STOPPED)
        is called, CanIf shall set the PDU channel mode of the corresponding channel
        to CANIF_TX_OFFLINE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PnFilterBlocksTxPdu</srcid><srcstatus/><internalId>1564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00866</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>766</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>767</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00866_2</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_ControllerBusOff(ControllerId) is called, CanIf shall set the PDU
        channel mode of the corresponding channel to CANIF_TX_OFFLINE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31197</srcid><srcstatus/><internalId>1589</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30805</srcid><srcstatus/><internalId>1763</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00866</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>766</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>768</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00867</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_SetBaudrate 
        Syntax 
        Std_ReturnType CanIf_SetBaudrate (uint8 ControllerId, uint16 BaudRateConfigID)
        Service ID [hex] | 0x27 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different ControllerIds. Non reentrant for the same ControllerId.
        Parameters (in) | ControllerId | Abstract CanIf ControllerId which is assigned to a CAN 
        controller, whose baud rate shall be set.
        BaudRateConfigID | references a baud rate configuration by ID 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Service request accepted, setting of (new) baud rate 
        startedE_NOT_OK: Service request not accepted 
        Description | This service shall set the baud rate configuration of the CAN controller. 
        Depending on necessary baud rate modifications the controller might have to reset.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_SetBaudrate</srcid><srcstatus/><internalId>1337</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SETBAUDRATE_NOK</srcid><srcstatus/><internalId>1430</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanIf_SetBaudrate_NOINIT</srcid><srcstatus/><internalId>1444</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SetBaudrate_API</srcid><srcstatus/><internalId>1706</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>769</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00868</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The service CanIf_SetBaudrate() shall call Can_SetBaudrate(Controller, BaudRateConfigID) for 
        the requested CAN Controller.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_SETBAUDRATE</srcid><srcstatus/><internalId>1429</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>770</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00869</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_SetBaudrate() is called with invalid ControllerId, CanIf shall report development 
        error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the DET module.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_SETBAUDRATE_INVALID</srcid><srcstatus/><internalId>1431</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>771</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00871</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf supports changing baud rate and thus CanIf_SetBaudrate(), shall be configurable via 
        CanIfPublicCfg.CanIfSetBaudrateApi.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_SetBaudrate</srcid><srcstatus/><internalId>1337</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SetBaudrate_API</srcid><srcstatus/><internalId>1706</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>772</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00874</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The service CanIf_SetPduMode() shall not accept any request and shall return E_NOT_OK, if the 
        controller mode referenced by ControllerId is not in state CAN_CS_STARTED.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30806</srcid><srcstatus/><internalId>1609</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>773</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00877</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf receives a L-PDU , it shall perform the following comparisons to select the correct 
        reception L-SDU configured in CanIfInitCfg.CanIfRxPduCfg:
        compare CanIfRxPduCfg.CanIfRxPduCanId with the passed Mailbox-&gt;CanId (Can_IdType) excluding the 
        two most significant bits
        compare CanIfRxPduCf.CanIfRxPduCanIdType with the two most significant bits of the passed 
        Mailbox-&gt;CanId (Can_IdType)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00877_CanId</srcid><srcstatus/><internalId>775</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00877_CanIdType</srcid><srcstatus/><internalId>776</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>774</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00877_CanId</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>2</version>
      <description>
        If CanIfCanDriverCompatibility is set to ASR422, ASR431, ASR440 or ASR21_11 and CanIf receives a L-PDU (see CanIf_RxIndication),
        it shall compare the CanIfRxPduCanId with the passed Mailbox-&gt;CanId (Can_IdType) excluding the two most
        significant bits to select the correct reception L-SDU configured in CanIfRxPduCfg.
        Basically, CanIf supports reception either of Standard CAN IDs or Extended CAN IDs on one
        Physical CAN Channel by the parameter CANIF_RXPDU_CANIDTYPE (see ECUC_CanIf_00596).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30259</srcid><srcstatus/><internalId>1489</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30333</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00877</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>775</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00877_CanIdType</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>2</version>
      <description>
        If CanIfCanDriverCompatibility is set to ASR422, ASR431, ASR440 or ASR21_11 and CanIf receives a L-PDU (see CanIf_RxIndication),
        it shall compare the CanIfRxPduCanIdType with the two most significant bits of the passed Mailbox-&gt;CanId
        (Can_IdType) to select the correct reception L-SDU configured in CanIfRxPduCfg. (SRS_Can_01140, SRS_Can_01141,
        SRS_Can_01162)
        Basically, CanIf supports reception either of Standard CAN IDs or Extended CAN IDs on one
        Physical CAN Channel by the parameter CANIF_RXPDU_CANIDTYPE (see ECUC_CanIf_00596).
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30259</srcid><srcstatus/><internalId>1489</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30333</srcid><srcstatus/><internalId>1758</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00877</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>774</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>776</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00840</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduTriggerTransmit 
        Parent Container | CanIfTxPduCfg 
        Description | Determines if or if not CanIf shall use the trigger transmit API for this PDU.
        Multiplicity | 0..1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU dependency: If CanIfTxPduTriggerTransmit is TRUE then 
        CanIfTxPduUserTxConfirmationUL has to be either PDUR or CDD and 
        CanIfTxPduUserTriggerTransmitName has to be specified accordingly.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_2131</srcid><srcstatus/><internalId>1265</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>777</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00842</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduUserTriggerTransmitName 
        Parent Container | CanIfTxPduCfg 
        Description | This parameter defines the name of the &lt;User_TriggerTransmit&gt;. This parameter 
        depends on the parameter CanIfTxPduUserTxConfirmationUL. If CanIfTxPduUserTxConfirmationUL 
        equals CAN_TP, CAN_NM, PDUR, XCP, CAN_TSYN, J1939NM or J1939TP, the name of the &lt;
        User_TriggerTransmit&gt; is fixed. If CanIfTxPduUserTxConfirmationUL equals CDD, the name of the &lt;
        User_TxConfirmation&gt; is selectable. Please be aware that this parameter depends on the same 
        parameter as CanIfTxPduUserTxConfirmationName. It shall be clear which upper layer is 
        responsible for that PDU.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength | 32 
        minLength | 1 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfTxPduUserTriggerTransmitName requires 
        CanIfTxPduUserTxConfirmationUL to be either PDUR or CDD.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_2213</srcid><srcstatus/><internalId>1267</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>778</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00878</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_SetPduMode(ControllerId, CANIF_TX_OFFLINE) is called and Partial Networking is enabled 
        ref. to CanIfPublicCfg.CanIfPublicPnSupport) the PnTxFilter of the corresponding CAN Controller 
        shall be enabled (ref. to CanIf.SWS_CanIf_00748 and CanIf.SWS_CanIf_00747)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.2.2</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PnFilterBlocksTxPdu</srcid><srcstatus/><internalId>1564</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>779</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00879</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TxConfirmation&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to CAN_TSYN, CanIfTxPduCfg.CanIfTxPduUserTxConfirmationName must be CanTSyn_TxConfirmation.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2260</srcid><srcstatus/><internalId>1246</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION</srcid><srcstatus/><internalId>1501</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE</srcid><srcstatus/><internalId>1599</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE_ACTIVE</srcid><srcstatus/><internalId>1600</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>780</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00880</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_RxIndication&gt;(): If CanIfRxPduCfg.CanIfRxPduUserRxIndicationUL is set to 
        CAN_TSYN, CanIfRxPduCfg.CanIfRxPduUserRxIndicationName must be CanTSyn_RxIndication.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_CDD_RXINDICATION</srcid><srcstatus/><internalId>1500</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>781</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00881</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If transmit buffering is enabled  and if the call of Can_Write() for a PDU configured for 
        triggered transmission returns with CAN_BUSY, CanIf shall check if it is possible to buffer the 
        Transmit Request, which was requested to be transmitted via Can_Write() in a CanIfTxBuffer.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>782</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00882</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf_Transmit() shall accept a NULL pointer as PduInfoPtr-&gt;SduDataPtr, if the PDU is 
        configured for triggered transmission: CanIfPublicCfg.CanIfTxPduTriggerTransmit = TRUE.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>783</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00883</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_TriggerTransmit 
        Syntax 
        Std_ReturnType CanIf_TriggerTransmit (PduIdType TxPduId, PduInfoType* PduInfoPtr)
        Service ID [hex] | 0x41 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | TxPduId | ID of the SDU that is requested to be transmitted.
        Parameters (inout) | PduInfoPtr | Contains a pointer to a buffer (SduDataPtr) to where the SDU 
        data shall be copied, and the available buffer size in SduLengh. On return, the service will 
        indicate the length of the copied SDU data in SduLength.
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: SDU has been copied and SduLength indicates the number of 
        copied bytes.E_NOT_OK: No SDU data has been copied. PduInfoPtr must not be used since it may 
        contain a NULL pointer or point to invalid data.
        Description | Within this API, the upper layer module (called module) shall check whether the 
        available data fits into the buffer size reported by PduInfoPtr-&gt;SduLength. If it fits, it 
        shall copy its data into the buffer provided by PduInfoPtr-&gt;SduDataPtr and update the length of 
        the actual copied data in PduInfoPtr-&gt;SduLength. If not, it returns E_NOT_OK without changing 
        PduInfoPtr.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>784</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00884</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall only provide the API function CanIf_TriggerTransmit() if TriggerTransmit support is 
        enabled (CanIfPublicCfg.CanIfTriggerTransmitSupport = TRUE)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>785</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00885</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The function CanIf_TriggerTransmit() shall call the corresponding &lt;User_TriggerTransmit&gt;() 
        function, passing the translated TxPduId and the pointer to the PduInfo structure (PduInfoPtr)
        Upon return, CanIf_TriggerTransmit() shall return the return value of its &lt;User_TriggerTransmit&gt;
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>786</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00886</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | &lt;User_TriggerTransmit&gt;
        Syntax 
        Std_ReturnType &lt;User_TriggerTransmit&gt; (PduIdType TxPduId, PduInfoType* PduInfoPtr)
        Sync/Async | Synchronous 
        Reentrancy | Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in) | TxPduId | ID of the SDU that is requested to be transmitted.
        Parameters (inout) | PduInfoPtr | Contains a pointer to a buffer (SduDataPtr) to where the SDU 
        data shall be copied, and the available buffer size in SduLengh. On return, the service will 
        indicate the length of the copied SDU data in SduLength.
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: SDU has been copied and SduLength indicates the number of 
        copied bytes.E_NOT_OK: No SDU data has been copied. PduInfoPtr must not be used since it may 
        contain a NULL pointer or point to invalid data.
        Description | Within this API, the upper layer module (called module) shall check whether the 
        available data fits into the buffer size reported by PduInfoPtr-&gt;SduLength. If it fits, it 
        shall copy its data into the buffer provided by PduInfoPtr-&gt;SduDataPtr and update the length of 
        the actual copied data in PduInfoPtr-&gt;SduLength. If not, it returns E_NOT_OK without changing 
        PduInfoPtr.
        Available via | configurable 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>787</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00888</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TriggerTransmit&gt;(): The upper layer module, which provides the 
        TriggerTransmit callback service, has to be configured by CanIfTxPduCfg.
        CanIfTxPduUserTxConfirmationUL . If no upper layer modules are configured, no TriggerTransmit 
        callback service is executed and therefore Trigger Transmit functionality is not supported for 
        that PDU.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>788</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00889</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TriggerTransmit&gt;(): The name of the API &lt;User_TriggerTransmit&gt;() which 
        is called by CanIf shall be configured for CanIf by parameter CanIfTxPduCfg.
        CanIfTxPduUserTriggerTransmitName 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>789</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00890</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TriggerTransmit&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to PDUR, CanIfTxPduCfg.CanIfTxPduUserTriggerTransmitName must be PduR_CanIfTriggerTransmit.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>790</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00891</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of &lt;User_TriggerTransmit&gt;(): If CanIfTxPduCfg.CanIfTxPduUserTxConfirmationUL is 
        set to CDD, the name of the API &lt;User_TriggerTransmit&gt;() has to be configured via parameter 
        CanIfTxPduCfg.CanIfTxPduUserTriggerTransmitName.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>791</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00789</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserClearTrcvWufFlagIndicationName 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the name of &lt;User_ClearTrcvWufFlagIndication&gt;.If 
        CanIfDispatchUserClearTrcvWufFlagIndicationUL equals CAN_SM the name of &lt;
        User_ClearTrcvWufFlagIndication&gt; is fixed. If it equals CDD, the name is selectable. If 
        CanIfPublicPnSupport equals False, this parameter shall not be configurable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength 
        minLength 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfDispatchUserClearTrcvWufFlagIndicationUL, 
        CanIfPublicPnSupport 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>792</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00790</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserClearTrcvWufFlagIndicationUL 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the upper layer module to which the 
        ClearTrcvWufFlagIndication from the Driver modules have to be routed.If CanIfPublicPnSupport 
        equals False, this parameter shall not be configurable.
        Multiplicity | 0..1 
        Type | EcucEnumerationParamDef 
        Range | CAN_SMCanIfDispatchCfg.CanIfDispatchUserClearTrcvWufFlagIndicationUL.CAN_SM | CAN State 
        Manager 
        CDDCanIfDispatchCfg.CanIfDispatchUserClearTrcvWufFlagIndicationUL.CDD | Complex Driver 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfPublicPnSupport 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_498</srcid><srcstatus/><internalId>1254</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>793</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00791</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserCheckTrcvWakeFlagIndicationName 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the name of &lt;User_CheckTrcvWakeFlagIndication&gt;. If 
        CanIfDispatchUserCheckTrcvWakeFlagIndicationUL equals CAN_SM the name of &lt;
        User_CheckTrcvWakeFlagIndication&gt; is fixed. If it equals CDD, the name is selectable. 
        IfCanIfPublicPnSupport equals False, this parameter shall not be configurable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength 
        minLength 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfDispatchUserCheckTrcvWakeFlagIndicationUL, 
        CanIfPublicPnSupport 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>794</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00792</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserCheckTrcvWakeFlagIndicationUL 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the upper layer module to which the 
        CheckTrcvWakeFlagIndication from the Driver modules have to be routed.If CanIfPublicPnSupport 
        equals False, this parameter shall not be configurable.
        Multiplicity | 0..1 
        Type | EcucEnumerationParamDef 
        Range | CAN_SMCanIfDispatchCfg.CanIfDispatchUserCheckTrcvWakeFlagIndicationUL.CAN_SM | CAN 
        State Manager 
        CDDCanIfDispatchCfg.CanIfDispatchUserCheckTrcvWakeFlagIndicationUL.CDD | Complex Driver 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfPublicPnSupport 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>795</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00819</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfDispatchUserConfirmPnAvailabilityName 
        Parent Container | CanIfDispatchCfg 
        Description | This parameter defines the name of &lt;User_ConfirmPnAvailability&gt;. If 
        CanIfDispatchUserConfirmPnAvailabilityUL equals CAN_SM the name of &lt;User_ConfirmPnAvailability&gt;
        is fixed. If it equals CDD, the name is selectable. If CanIfPublicPnSupport equals False, this 
        parameter shall not be configurable.
        Multiplicity | 0..1 
        Type | EcucFunctionNameDef 
        Default value 
        maxLength 
        minLength 
        regularExpression 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME, VARIANT-POST-BUILD 
        Post-build time 
        Scope / Dependency | scope: ECU dependency: CanIfDispatchUserConfirmPnAvailabilityUL, 
        CanIfPublicPnSupport 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.ASR40.ECUC_CanIf_00819</srcid><srcstatus/><internalId>218</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ParameterMultiplicity</srcid><srcstatus/><internalId>1099</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>796</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00843</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfWakeupSupport 
        Parent Container | CanIfPublicCfg 
        Description | Enables the CanIf_CheckWakeup API at Pre-Compile-Time. Therefore, this parameter 
        defines if there shall be support for wake-up.TRUE: Enabled FALSE: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | true 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIfWakeupSupport</srcid><srcstatus/><internalId>1096</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>797</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00844</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTriggerTransmitSupport 
        Parent Container | CanIfPublicCfg 
        Description | Enables the CanIf_TriggerTransmit API at Pre-Compile-Time. Therefore, this 
        parameter defines if there shall be support for trigger transmit transmissions.TRUE: Enabled 
        FALSE: Disabled 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | true 
        Post-Build Variant Multiplicity | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.TriggerTransmit</srcid><srcstatus/><internalId>1088</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>798</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00892</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Configuration of CanIf_CheckWakeup(): If no wake-up shall be used, this API can be omitted by 
        disabling of CanIfPublicCfg.CanIfWakeupSupport.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIfWakeupSupport</srcid><srcstatus/><internalId>1096</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>799</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00893</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When CanIf_Transmit() is called with PduInfoPtr-&gt;SduLength exceeding the maximum length of the 
        PDU referenced by TxPduId:
        SduLength &gt; 8 if the Can_IdType indicates a classic CAN frame
        SduLength &gt; 64 if the Can_IdType indicates a CAN FD frame
        CanIf shall report runtime error code CANIF_E_DATA_LENGTH_MISMATCH to the 
        Det_ReportRuntimeError() service of the DET.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PartiallyImplemented</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>800</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00894</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When CanIf_Transmit() is called with PduInfoPtr-&gt;SduLength exceeding the length of the global 
        PDU  referenced by TxPduId and CanIfTxPduTruncation is enabled, CanIf shall transmit data up to 
        the length of the global PDU  and discard the rest.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.SWS_CANIF_00894.TruncateToFrame</srcid><srcstatus/><internalId>802</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.SWS_CANIF_00894.TruncateToPduLength</srcid><srcstatus/><internalId>803</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>801</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.SWS_CANIF_00894.TruncateToFrame</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When CanIf_Transmit() is called with PduInfoPtr-&gt;SduLength
        exceeding the CAN frame length (8B for CAN 2.0, 64B for CAN FD)
        and CanIfTxPduTruncateToFrame is True, CanIf shall transmit
        data up the CAN frame length and discard the rest.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Transmit_UINT32_PduLengthType</srcid><srcstatus/><internalId>1601</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6726</srcid><srcstatus/><internalId>1191</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00894</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>801</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>802</internalId></specobject>
    
    <specobject>
      <id>CanIf.EB.SWS_CANIF_00894.TruncateToPduLength</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When CanIf_Transmit() is called with PduInfoPtr-&gt;SduLength
        exceeding the length of the global PDU referenced
        by TxPduId and CanIfTxPduTruncateToFrame is False, CanIf shall transmit
        data up to the length of the global PDU and discard the rest.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6748</srcid><srcstatus/><internalId>1192</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00894</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>801</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>803</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00895</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If the rejected data length exceeds the configured size, CanIf shall:
        buffer the configured amount of data and discard the rest
        and report runtime error code CANIF_E_DATA_LENGTH_MISMATCH to the Det_ReportRuntimeError() 
        service of the DET.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PartiallyImplemented</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>804</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00896</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_RxIndication() is called and PnTxFilter is enabled, the corresponding PnTxFilter shall 
        be disabled (ref. to CanIf.SWS_CanIf_00747 and CanIf.SWS_CanIf_00748)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.3.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6296</srcid><srcstatus/><internalId>1174</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NoPnFilterAfterFirstRxIndication</srcid><srcstatus/><internalId>1568</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>805</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00898</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_GetControllerErrorState() has an invalid value, the CanIf 
        shall report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service 
        of the DET, when CanIf_GetControllerErrorState() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6428</srcid><srcstatus/><internalId>1180</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1517</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>806</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00899</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ErrorStatePtr of CanIf_GetControllerErrorState() is a null pointer, the CanIf 
        shall report development error code CANIF_E_PARAM_POINTER to the Det_ReportError service of the 
        DET, when CanIf_GetControllerErrorState() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6438</srcid><srcstatus/><internalId>1181</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1517</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>807</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91001</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetControllerErrorState 
        Syntax 
        Std_ReturnType CanIf_GetControllerErrorState (uint8 ControllerId, Can_ErrorStateType* 
        ErrorStatePtr)
        Service ID [hex] | 0x4b 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant for the same ControllerId 
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller, which is requested for ErrorState.
        Parameters (inout) | None 
        Parameters (out) | ErrorStatePtr | Pointer to a memory location, where the error state of the 
        CAN controller will be stored.
        Return value | Std_ReturnType | E_OK: Error state request has been accepted.E_NOT_OK: Error 
        state request has not been accepted.
        Description | This service calls the corresponding CAN Driver service for obtaining the error 
        state of the CAN controller.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanControllerErrorStateSupported</srcid><srcstatus/><internalId>949</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>808</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_91001.ReturnValue.NotSupportedByDriver</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service name: CanIf_GetControllerErrorState
        Syntax: Std_ReturnType CanIf_GetControllerErrorState(
                                uint8 ControllerId,
                                Can_ErrorStateType * ErrorStatePtr
                              )
        Service ID[hex]: 0x4b
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant for the same ControllerId
        Parameters (in): ControllerId Abstracted CanIf ControllerId which is assigned to a
                         CAN controller, which is requested for ErrorState.
        Parameters (inout): None
        Parameters (out): ErrorStatePtr Pointer to a memory location, where the error state
                          of the CAN controller will be stored.
                          The value is that of CanIfErrorStateValue.
        Return value: Std_ReturnType E_OK: Error state request has been accepted.
        Description: This service returns the value as configured by CanIfErrorStateValue.
                     As the Can Driver lacks support, the call is not forwarded.
        Available via: CanIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.ECUC_CanIf_Mirroring.CanIfErrorStateValue</srcid><srcstatus/><internalId>950</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6459</srcid><srcstatus/><internalId>1183</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>809</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_91001.ReturnValue.ProperlySupported</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service name: CanIf_GetControllerErrorState
        Syntax: Std_ReturnType CanIf_GetControllerErrorState(
                                uint8 ControllerId,
                                Can_ErrorStateType * ErrorStatePtr
                              )
        Service ID[hex]: 0x4b
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant for the same ControllerId
        Parameters (in): ControllerId Abstracted CanIf ControllerId which is assigned to a
                         CAN controller, which is requested for ErrorState.
        Parameters (inout): None
        Parameters (out): ErrorStatePtr Pointer to a memory location, where the error state
                          of the CAN controller will be stored.
        Return value: Std_ReturnType E_OK: Error state request has been accepted.
                                     E_NOT_OK: Error state request has not been accepted.
        Description: This service calls the corresponding CAN Driver service for obtaining the
                     error state of the CAN controller.
        Available via: CanIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6452</srcid><srcstatus/><internalId>1182</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1517</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>810</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00845</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfTxPduTruncation 
        Parent Container | CanIfTxPduCfg 
        Description | Enables/disables truncation of PDUs that exceed the configured size.
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | true 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_2146</srcid><srcstatus/><internalId>1266</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>811</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00900</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        When CanIf_Transmit() is called with PduInfoPtr-&gt;SduLength exceeding the length of the global 
        PDU  referenced by TxPduId and CanIfTxPduTruncation is disabled, CanIf shall report the runtime 
        error CANIF_E_TXPDU_LENGTH_EXCEEDED and return E_NOT_OK without further actions.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6757</srcid><srcstatus/><internalId>1194</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>812</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91002</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_DeInit 
        Syntax 
        void CanIf_DeInit (void)
        Service ID [hex] | 0x02 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant 
        Parameters (in) | None 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | None 
        Description | De-initializes the CanIf module.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIf_DeInit</srcid><srcstatus/><internalId>1095</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>813</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00846</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfRxPduDataLengthCheck 
        Parent Container | CanIfRxPduCfg 
        Description | This parameter switches the message specific data length check.True: Data length 
        check will be executed during the reception of this PDU.False: No data length check will be 
        executed during the reception of this PDU.
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | true 
        Post-Build Variant Value | true 
        Value Configuration Class | Pre-compile time | X | VARIANT-PRE-COMPILE 
        Link time | X | VARIANT-LINK-TIME 
        Post-build time | X | VARIANT-POST-BUILD 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_1359</srcid><srcstatus/><internalId>1260</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>814</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00847</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfBusMirroringSupport 
        Parent Container | CanIfPublicCfg 
        Description | Enable support for Bus Mirroring.
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1516</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1517</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_ENABLEMIRROR</srcid><srcstatus/><internalId>1532</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1533</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>815</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00902</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        The Data Length Check shall be processed if it is enabled globally  and not disabled 
        individually per PDU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.ConfigParametersChanged</srcid><srcstatus/><internalId>1100</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>816</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00903</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        CanIf shall include the header file Mirror.h if Bus Mirroring is enabled 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_93</srcid><srcstatus/><internalId>1122</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_RX</srcid><srcstatus/><internalId>1537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>817</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00904</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If Bus Mirroring is enabled globally  and has been activated with a call to 
        CanIf_EnableBusMirroring() for a CAN Controller, the CanIf shall store the content of each 
        frame before it is transmitted on that controller with Can_Write(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00905</srcid><srcstatus/><internalId>819</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>818</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00905</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If Bus Mirroring is enabled globally  and has been activated with a call to 
        CanIf_EnableBusMirroring() for a CAN Controller, the CanIf shall call Mirror_ReportCanFrame() 
        for each frame transmission on that controller that is confirmed with CanIf_TxConfirmation(), 
        providing the stored content and the actual CAN ID.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00905.Provision.CANID</srcid><srcstatus/><internalId>820</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00905.Provision.Payload</srcid><srcstatus/><internalId>821</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00904</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>818</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>819</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00905.Provision.CANID</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        With bus mirroring activated by a call to CanIf_EnableBusMirroring()
        for a CAN Controller, the CanIf shall call Mirror_ReportCanFrame()
        for each frame transmission on that controller that is confirmed
        with CanIf_TxConfirmation(), providing the stored CAN ID. (SRS_Can_01172)
      </description>
      <verifycrit>
        EC valid:   1.  After mirroring being activated with a call to CanIf_EnableBusMirroring(),
                        with the MirroringActive parameter as TRUE,
                        during transmission, after CanIf_TxConfirmation
                        Mirror_ReportCanFrame() is called.
                        The reported CANID is an expected one and associated to the controller
                        with the ID activated by CanIf_EnableBusMirroring().
        EC invalid: 1.  Call to CanIf_EnableBusMirroring() with an invalid
                        controller ID (CANIF_E_PARAM_CONTROLLERID reported to DET)
                        During transmission calls to Mirror_ReportCanFrame().
                        Note: Mirroring shall not be activated for any other controller.
                    2.  Call to CanIf_EnableBusMirroring() with a valid controller ID
                        (no CANIF_E_PARAM_CONTROLLERID reported to DET) and with the
                        MirroringActive parameter as TRUE,
                        during transmission calls to Mirror_ReportCanFrame() can be observed
                        when the frame isn't confirmed (any other time except immediately after
                        CanIf_TxConfirmation())
                    3.  Call to CanIf_EnableBusMirroring() with a valid controller ID
                        (no CANIF_E_PARAM_CONTROLLERID reported to DET), and with the
                        MirroringActive parameter as TRUE,
                        Mirror_ReportCanFrame() is called after a  CanIf_TxConfirmation()
                        with an unexpected ID.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_FdBuffering</srcid><srcstatus/><internalId>1409</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_1</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_2</srcid><srcstatus/><internalId>1520</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_3</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_1</srcid><srcstatus/><internalId>1525</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_2</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2_1</srcid><srcstatus/><internalId>1540</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_3</srcid><srcstatus/><internalId>1541</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_4</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3613</srcid><srcstatus/><internalId>1141</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>820</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00905.Provision.Payload</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        With bus mirroring activated by a call to CanIf_EnableBusMirroring()
        for a CAN Controller, the CanIf shall call Mirror_ReportCanFrame()
        for each frame transmission on that controller that is confirmed
        with CanIf_TxConfirmation(), providing the stored content. (SRS_Can_01172)
      </description>
      <verifycrit>
        EC valid:   1.  After mirroring being activated with a call to CanIf_EnableBusMirroring()
                        with the MirroringActive parameter as TRUE,
                        during transmission, after CanIf_TxConfirmation
                        Mirror_ReportCanFrame() is called.
                        The reported payload is the one that's confirmed.
        EC invalid: 1.  Call to CanIf_EnableBusMirroring() with a valid controller ID
                        (no CANIF_E_PARAM_CONTROLLERID reported to DET), with the
                        MirroringActive parameter as TRUE,
                        during transmission calls to Mirror_ReportCanFrame() can be observed
                        when the frame isn't confirmed (any other time except immediately after
                        CanIf_TxConfirmation())
                    2.  Call to CanIf_EnableBusMirroring() with a valid controller ID
                        (no CANIF_E_PARAM_CONTROLLERID reported to DET),
                        with the MirroringActive parameter as TRUE,
                        Mirror_ReportCanFrame() is called after a  CanIf_TxConfirmation()
                        with a payload mismatch (not the one supplied to Can_Write())
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_1</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_2</srcid><srcstatus/><internalId>1520</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_3</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_1</srcid><srcstatus/><internalId>1525</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_2</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2_1</srcid><srcstatus/><internalId>1540</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_3</srcid><srcstatus/><internalId>1541</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_4</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3614</srcid><srcstatus/><internalId>1142</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>819</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>821</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00906</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If Bus Mirroring is enabled globally  and has been activated with a call to 
        CanIf_EnableBusMirroring() for a CAN Controller, the CanIf shall call Mirror_ReportCanFrame() 
        for each frame reception on that controller that is indicated with CanIf_RxIndication(
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00906.Provision.CANID</srcid><srcstatus/><internalId>823</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_00906.Provision.Payload</srcid><srcstatus/><internalId>824</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>822</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00906.Provision.CANID</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        With bus mirroring activated by a call to CanIf_EnableBusMirroring()
        for a CAN Controller, the CanIf shall call Mirror_ReportCanFrame()
        for each frame reception on that controller that is indicated with
        CanIf_RxIndication(), providing the CAN ID. (SRS_Can_01172)
      </description>
      <verifycrit>
        EC valid:   1. Mirroring activated with valid controller ID.
                       CanIf_RxIndication() called with valid ID.
                       Mirror_ReportCanFrame() called with a valid ID.
        EC invalid: 1. Mirroring not activated for the controller.
                       CanIf_RxIndication() callied with an invalid ID.
                       Mirror_ReportCanFrame() called.
                    2. Mirroring activated for the controller.
                       CanIf_RxIndciation() called with a valid ID.
                       Mirror_ReportCanFrame() called with an ID differing
                       from the one obtained during CanIf_RxIndication(), when
                       CanIfTranslateRxCanIdFunc is deactivated
                    3. Mirroring activated for the controller.
                       CanIf_RxIndciation() called with a valid ID.
                       Mirror_ReportCanFrame() called with an ID matching
                       the one obtained during CanIf_RxIndication(), when
                       CanIfTranslateRxCanIdFunc is activated.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3854</srcid><srcstatus/><internalId>1148</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_RX</srcid><srcstatus/><internalId>1537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00906</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>822</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>823</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00906.Provision.Payload</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        With bus mirroring activated by a call to CanIf_EnableBusMirroring()
        for a CAN Controller, the CanIf shall call Mirror_ReportCanFrame()
        for each frame reception on that controller that is indicated with
        CanIf_RxIndication(), providing the payload. (SRS_Can_01172)
      </description>
      <verifycrit>
        EC valid:    CanIf_EnableBusMirroring() is called with a valid controller
                     ID and the MirroringActive parameter as TRUE.
                     Mirror_ReportCanFrame() called with a payload
                     matching the one obtained during CanIf_RxIndication().
        EC invalid:  CanIf_EnableBusMirroring() is called with a valid controller
                     ID and the MirroringActive parameter as TRUE.
                     Mirror_ReportCanFrame() called with a payload differing
                     from the one obtained during CanIf_RxIndication().
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3855</srcid><srcstatus/><internalId>1149</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_RX</srcid><srcstatus/><internalId>1537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00906</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>822</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>824</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00907</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_GetControllerRxErrorCounter() has an invalid value, the 
        CanIf shall report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError 
        service of the DET, when CanIf_GetControllerRxErrorCounter() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIf_GetControllerRxErrorCounter</srcid><srcstatus/><internalId>1094</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>825</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00908</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter RxErrorCounterPtr of CanIf_GetControllerRxErrorCounter() is a null pointer, the 
        CanIf shall report development error code CANIF_E_PARAM_POINTER to the Det_ReportError service 
        of the DET, when CanIf_GetControllerRxErrorCounter() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIf_GetControllerRxErrorCounter</srcid><srcstatus/><internalId>1094</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>826</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00909</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_GetControllerTxErrorCounter() has an invalid value, the 
        CanIf shall report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError 
        service of the DET, when CanIf_GetControllerTxErrorCounter() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6490</srcid><srcstatus/><internalId>1184</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1516</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>827</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00910</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter TxErrorCounterPtr of CanIf_GetControllerTxErrorCounter() is a null pointer, the 
        CanIf shall report development error code CANIF_E_PARAM_POINTER to the Det_ReportError service 
        of the DET, when CanIf_GetControllerTxErrorCounter() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6500</srcid><srcstatus/><internalId>1185</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1516</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>828</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00911</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If Bus Mirroring is not enabled , the API CanIf_EnableBusMirroring() can be omitted.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00911.Availability</srcid><srcstatus/><internalId>830</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>836</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>829</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00911.Availability</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If Bus Mirroring is not enabled (see CanIfBusMirroringSupport),
        the API CanIf_EnableBusMirroring() is omitted. (SRS_Can_01172)
      </description>
      <verifycrit>
        EC valid:   1. CanIfBusMirroringSupport is set to TRUE.
                       The API is available.
                    2. CanIfBusMirroringSupport is set to FALSE.
                       The API is unavailable.
                       When defined locally the are no issues during linking.
        EC invalid: 1. CanIfBusMirroringSupport is set to TRUE.
                       The API is unavailable.
                    2. CanIfBusMirroringSupport is set to FALSE.
                       The API is exported.
                       When defined locally, linking fails.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6343</srcid><srcstatus/><internalId>1177</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00911</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>829</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>830</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00912</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_EnableBusMirroring() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the 
        DET, when CanIf_EnableBusMirroring() is called.
      </description>
      <verifycrit>
        EC valid: 1. CANIF_E_PARAM_CONTROLLERID is reported to DET when
        CanIf_EnableBusMirroring() is called with incorrect controller ID
        2. CANIF_E_PARAM_CONTROLLERID is not reported when
        CanIf_EnableBusMirroring() is called with a correct controller ID
        EC invalid: 1. CANIF_E_PARAM_CONTROLLERID is reported to DET when
        CanIf_EnableBusMirroring() is called with a correct controller ID
        2. CANIF_E_PARAM_CONTROLLERID is not reported when
        CanIf_EnableBusMirroring() is called with an incorrect controller ID
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6365</srcid><srcstatus/><internalId>1178</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_ENABLEMIRROR</srcid><srcstatus/><internalId>1532</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>831</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91003</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetControllerRxErrorCounter 
        Syntax 
        Std_ReturnType CanIf_GetControllerRxErrorCounter (uint8 ControllerId, uint8* RxErrorCounterPtr)
        Service ID [hex] | 0x4d 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant for the same ControllerId 
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller.
        Parameters (inout) | None 
        Parameters (out) | RxErrorCounterPtr | Pointer to a memory location, where the current Rx error 
        counter of the CAN controller will be stored.
        Return value | Std_ReturnType | E_OK: Rx error counter available.E_NOT_OK: Wrong ControllerId, 
        or Rx error counter not available.
        Description | This service calls the corresponding CAN Driver service for obtaining the Rx 
        error counter of the CAN controller.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.CanIf_GetControllerRxErrorCounter</srcid><srcstatus/><internalId>1094</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>832</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91004</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetControllerTxErrorCounter 
        Syntax 
        Std_ReturnType CanIf_GetControllerTxErrorCounter (uint8 ControllerId, uint8* TxErrorCounterPtr)
        Service ID [hex] | 0x4e 
        Sync/Async | Synchronous 
        Reentrancy | Non Reentrant for the same ControllerId 
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller.
        Parameters (inout) | None 
        Parameters (out) | TxErrorCounterPtr | Pointer to a memory location, where the current Tx error 
        counter of the CAN controller will be stored.
        Return value | Std_ReturnType | E_OK: Tx error counter available.E_NOT_OK: Wrong ControllerId, 
        or Tx error counter not available.
        Description | This service calls the corresponding CAN Driver service for obtaining the Tx 
        error counter of the CAN controller.
        Available via | CanIf.h 
      </description>
      <comment>
        This requirement is identical with CanIf.SWS_CanIf_91004.
        It is the behavior when the feature is properly supported.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanTxErrorCounterSupported</srcid><srcstatus/><internalId>947</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>833</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_91004.ReturnValue.NotSupportedByDriver</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service name: CanIf_GetControllerTxErrorCounter
        Syntax: Std_ReturnType CanIf_GetControllerTxErrorCounter(
                                uint8 ControllerId,
                                uint8 * TxErrorCounterPtr
                              )
        Service ID[hex]: 0x4e
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant for the same ControllerId
        Parameters (in): ControllerId Abstracted CanIf ControllerId which is assigned to a
                         CAN controller.
        Parameters (inout): None
        Parameters (out): TxErrorCounterPtr Pointer to a memory location, where the current Tx
                          error counter of the CAN controller will be stored.
                          The value is that of CanIfTxErrorCounterValue.
        Return value: Std_ReturnType E_OK: Tx error counter available.
        Description: This service returns the value as configured by CanIfTxErrorCounterValue.
                     As the Can Driver lacks support, the call is not forwarded.
        Available via: CanIf.h
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxErrorCounterValue</srcid><srcstatus/><internalId>948</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6520</srcid><srcstatus/><internalId>1187</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>834</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_91004.ReturnValue.ProperlySupported</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service name: CanIf_GetControllerTxErrorCounter
        Syntax: Std_ReturnType CanIf_GetControllerTxErrorCounter(
                                uint8 ControllerId,
                                uint8 * TxErrorCounterPtr
                              )
        Service ID[hex]: 0x4e
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant for the same ControllerId
        Parameters (in): ControllerId Abstracted CanIf ControllerId which is assigned to a
                         CAN controller.
        Parameters (inout): None
        Parameters (out): TxErrorCounterPtr Pointer to a memory location, where the current Tx
                          error counter of the CAN controller will be stored.
        Return value: Std_ReturnType E_OK: Tx error counter available.
                                     E_NOT_OK: Wrong ControllerId, or Tx error counter not available.
        Description: This service calls the corresponding CAN Driver service for obtaining the
                     Tx error counter of the CAN controller.
        Available via: CanIf.h
      </description>
      <comment>
        This requirement is identical with CanIf.SWS_CanIf_91004.
        It is the behavior when the feature is properly supported.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6514</srcid><srcstatus/><internalId>1186</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1516</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>835</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91005</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_EnableBusMirroring 
        Syntax 
        Std_ReturnType CanIf_EnableBusMirroring (uint8 ControllerId, boolean MirroringActive)
        Service ID [hex] | 0x4c 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller.
        MirroringActive | TRUE: Mirror_ReportCanFrame will be called for each frame received or 
        transmitted on the given controller. FALSE: Mirror_ReportCanFrame will not be called for the 
        given controller.
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | Std_ReturnType | E_OK: Mirroring mode was changed.E_NOT_OK: Wrong ControllerId, 
        or mirroring globally disabled 
        Description | Enables or disables mirroring for a CAN controller.
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00911</srcid><srcstatus/><internalId>829</internalId></linkedfrom><linkedfrom><srcid>CanIf.SWS_CanIf_91005.ReturnValue</srcid><srcstatus/><internalId>837</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>836</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_91005.ReturnValue</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service name: CanIf_EnableBusMirroring
        Syntax: Std_ReturnType CanIf_EnableBusMirroring(
                                uint8 ControllerId,
                                boolean MirroringActive
                              )
        Service ID[hex]: 0x4c
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): ControllerId Abstracted CanIf ControllerId which is assigned to a
        CAN controller.
        MirroringActive TRUE: Mirror_ReportCanFrame will be called for
        each frame received or transmitted on the given controller.
        FALSE: Mirror_ReportCanFrame will not be called for the given controller.
        Parameters (inout): None
        Parameters (out): None
        Return value: Std_ReturnType E_OK: Mirroring mode was changed.
                                     E_NOT_OK: Wrong ControllerId
        Description: Enables or disables mirroring for a CAN controller.
        Available via: CanIf.h
      </description>
      <verifycrit>
        EC valid:   1. CanIf_EnableBusMirroring() called with valid ID
                       (no CANIF_E_PARAM_CONTROLLERID reported) and the
                       MirroringActive parameter as TRUE.
                       Return value is E_OK.
                       Mirror_ReportCanFrame() called during reception after
                       CanIf_RxIndication().
                    2. CanIf_EnableBusMirroring() called with a valid ID
                       (no CANIF_E_PARAM_CONTROLLERID) and the parameter
                       MirroringActive as FALSE.
                       Return value is E_OK.
                       Mirror_ReportCanFrame() is not called during reception.
                    3. CanIf_EnableBusMirroring() called with valid ID
                       (no CANIF_E_PARAM_CONTROLLERID reported) and the parameter
                       MirroringActive as TRUE.
                       Return value is E_OK.
                       Mirror_ReportCanFrame() called during transmission after
                       CanIf_TxConfirmation().
                    4. CanIf_EnableBusMirroring() called with a valid ID
                       (no CANIF_E_PARAM_CONTROLLERID reported) and the parameter
                       Return value is E_OK.
                       MirroringActive as FALSE.
                       Mirror_ReportCanFrame() is not called during transmission.
                    5. CanIf_EnableBusMirroring() called with an invalid ID
                       (CANIF_E_PARAM_CONTROLLERID reported).
                       Return value is E_NOT_OK.
        EC invalid: 1. CanIf_EnableBusMirroring() called with an invalid ID
                       (CANIF_E_PARAM_CONTROLLERID reported).
                       Return value is E_OK.
                    2. CanIf_EnableBusMirroring() called with a valid ID
                       (no CANIF_E_PARAM_CONTROLLERID reported).
                       Return value is E_NOT_OK.
                    3. CanIf_EnableBusMirroring() called with a valid ID
                       (no CANIF_E_PARAM_CONTROLLERID reported) with the
                       MirroringActive parameter as TRUE.
                       Return value is E_OK.
                       Mirror_ReportCanFrame() is not called during reception
                       after CanIf_RxIndication().
                    4. CanIf_EnableBusMirroring() called with a valid ID
                       (no CANIF_E_PARAM_CONTROLLERID reported) with the
                       MirroringActive parameter as FALSE.
                       Return value is E_OK.
                       Mirror_ReportCanFrame() is called during reception after
                       CanIf_RxIndication().
                    5. CanIf_EnableBusMirroring() called with a valid ID
                       (no CANIF_E_PARAM_CONTROLLERID reported) with the
                       MirroringActive parameter as TRUE.
                       Return value is E_OK.
                       Mirror_ReportCanFrame() is not called during transmission
                       after CanIf_TxConfirmation().
                    6. CanIf_EnableBusMirroring() called with a valid ID
                       (no CANIF_E_PARAM_CONTROLLERID reported) with the
                       MirroringActive parameter as FALSE.
                       Return value is E_OK.
                       Mirror_ReportCanFrame() is called during transmission.
      </verifycrit>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.4.0</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6398</srcid><srcstatus/><internalId>1179</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_EnableBusMirroringDetUninit</srcid><srcstatus/><internalId>1453</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_ENABLEMIRROR</srcid><srcstatus/><internalId>1532</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>836</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>837</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00244</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Module Name | CanIf 
        Module Description | This container includes all necessary configuration sub-containers 
        according the CAN Interface configuration structure.
        Post-Build Variant Support | true 
        Supported Config Variants | VARIANT-LINK-TIME, VARIANT-POST-BUILD, VARIANT-PRE-COMPILE 
        Included containers: "CanIf_x_Included_Containers"
        Included Containers 
        Container Name | Multiplicity | Scope / Dependency 
        CanIfCtrlDrvCfg | 1..* | Configuration parameters for all the underlying CAN Driver modules are 
        aggregated under this container. For each CAN Driver module a seperate instance of this 
        container has to be provided.
        CanIfDispatchCfg | 1 | Callback functions provided by upper layer modules of the CanIf. The 
        callback functions defined in this container are common to all configured CAN Driver / CAN 
        Transceiver Driver modules.
        CanIfInitCfg | 1 | This container contains the init parameters of the CAN Interface.
        CanIfPrivateCfg | 1 | This container contains the private configuration (parameters) of the CAN 
        Interface.
        CanIfPublicCfg | 1 | This container contains the public configuration (parameters) of the CAN 
        Interface.
        CanIfTrcvDrvCfg | 0..* | This container contains the configuration (parameters) of all 
        addressed CAN transceivers by each underlying CAN Transceiver Driver module. For each CAN 
        transceiver Driver a seperate instance of this container shall be provided.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
        Covered by development toolchain: VSMD check.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
        <release>AUTOSAR 4.0.3</release>
      </releases>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>838</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00848</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CanIfEnableSecurityEventReporting 
        Parent Container | CanIfPublicCfg 
        Description | Switches the reporting of security events to the IdsM:- true: reporting is 
        enabled.- false: reporting is disabled. Tags: atp.Status=draft 
        Multiplicity | 1 
        Type | EcucBooleanParamDef 
        Default value | false 
        Post-Build Variant Value | false 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: ECU 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERROR_NO_INIT</srcid><srcstatus/><internalId>1502</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3212</srcid><srcstatus/><internalId>1273</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>839</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00849</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Container Name | CanIfSecurityEventRefs
        Parent Container | CanIfPublicCfg 
        Description | Container for the references to IdsMEvent elements representing the security 
        events that the CanIf module shall report to the IdsM in case the coresponding security related 
        event occurs (and if CanIfEnableSecurityEventReporting is set to "true"). The standardized 
        security events in this container can be extended by vendor-specific security events. Tags: atp.
        Status=draft 
        Post-Build Variant Multiplicity | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERRORSTATE_BUSOFF</srcid><srcstatus/><internalId>1503</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ERRORSTATE_PASSIVE</srcid><srcstatus/><internalId>1504</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RX_ERROR_DETECTED</srcid><srcstatus/><internalId>1505</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TX_ERROR_DETECTED</srcid><srcstatus/><internalId>1506</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3222</srcid><srcstatus/><internalId>1274</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>840</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00850</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CANIF_SEV_TX_ERROR_DETECTED 
        Parent Container | CanIfSecurityEventRefs 
        Description | A transmission related error was detected. Depending on the context data this 
        could indicate suspicious CAN activity. Tags: atp.Status=draft 
        Multiplicity | 0..1 
        Type | Symbolic name reference to [ IdsMEvent 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TX_ERROR_DETECTED</srcid><srcstatus/><internalId>1506</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3328</srcid><srcstatus/><internalId>1279</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>841</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00851</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CANIF_SEV_RX_ERROR_DETECTED 
        Parent Container | CanIfSecurityEventRefs 
        Description | A reception related error was detected. Depending on the context data this could 
        indicate suspicious CAN activity. Tags: atp.Status=draft 
        Multiplicity | 0..1 
        Type | Symbolic name reference to [ IdsMEvent 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RX_ERROR_DETECTED</srcid><srcstatus/><internalId>1505</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3303</srcid><srcstatus/><internalId>1278</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>842</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00852</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CANIF_SEV_ERRORSTATE_PASSIVE 
        Parent Container | CanIfSecurityEventRefs 
        Description | A reception related error was detected. Depending on the context data this could 
        indicate suspicious CAN activity. Tags: atp.Status=draft 
        Multiplicity | 0..1 
        Type | Symbolic name reference to [ IdsMEvent 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERRORSTATE_PASSIVE</srcid><srcstatus/><internalId>1504</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3279</srcid><srcstatus/><internalId>1277</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>843</internalId></specobject>

    <specobject>
      <id>CanIf.ECUC_CanIf_00853</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | CANIF_SEV_ERRORSTATE_BUSOFF 
        Parent Container | CanIfSecurityEventRefs 
        Description | The CAN controller transitioned to state busoff. Tags: atp.Status=draft 
        Multiplicity | 0..1 
        Type | Symbolic name reference to [ IdsMEvent 
        Post-Build Variant Multiplicity | false 
        Post-Build Variant Value | false 
        Multiplicity Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Value Configuration Class | Pre-compile time | X | All Variants 
        Link time 
        Post-build time 
        Scope / Dependency | scope: local 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERRORSTATE_BUSOFF</srcid><srcstatus/><internalId>1503</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3255</srcid><srcstatus/><internalId>1276</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>844</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00913</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If security event reporting has been enabled for the CanIf module (CanIfPublicCfg.
        CanIfEnableSecurityEventReporting = true) the respective security events shall bereported to 
        the IdsM via the interfaces defined in AUTOSAR_SWS_BSWGeneral.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERRORSTATE_BUSOFF</srcid><srcstatus/><internalId>1503</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>845</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00915</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_ErrorNotification() is called by CanDrv, the function shall evaluate whether a Tx 
        related error was detected. If this is the case the CanIfshall report the security event 
        CANIF_SEV_TX_ERROR_DETECTED. The context data is structured as follows: Context Data (2 Byte)
        ControllerID (1 Byte)
        CanError (1 Byte)
        CAN_ERROR_BIT_MONITORING1 (0x1)
        CAN_ERROR_BIT_MONITORING0 (0x2)
        CAN_ERROR_BIT (0x3)
        CAN_ERROR_CHECK_ACK_FAILED (0x4)
        CAN_ERROR_ACK_DELIMITER (0x5)
        CAN_ERROR_ARBITRATION_LOST (0x6)
        CAN_ERROR_OVERLOAD (0x7)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TX_ERROR_DETECTED</srcid><srcstatus/><internalId>1506</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6603</srcid><srcstatus/><internalId>1188</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>846</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00916</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_ErrorNotification() is called by CanDrv, the function shall evaluate whether a Rx 
        related error was detected. If this is the case the CanIf shall report the security event 
        CANIF_SEV_RX_ERROR_DETECTED. The context data is structured as follows: Context Data (2 Byte)
        ControllerID (1 Byte)
        CanError (1 Byte)
        CAN_ERROR_CHECK_FORM_FAILED (0x8)
        CAN_ERROR_CHECK_STUFFING_FAILED (0x9)
        CAN_ERROR_CHECK_CRC_FAILED (0xA)
        CAN_ERROR_BUS_LOCK (0xB)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RX_ERROR_DETECTED</srcid><srcstatus/><internalId>1505</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6611</srcid><srcstatus/><internalId>1189</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>847</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00917</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_ControllerErrorStatePassive() is called by CanDrv, the CanIf shall report the security 
        event CANIF_SEV_ERRORSTATE_PASSIVE in following cases:
        TxErrorCounter &gt; 127 and TxErrorCounter &lt;= 255
        RxErrorCounter &gt; 127 and TxErrorCounter &lt;= 255
        The context data is structured as follows: Context Data (2 Byte)
        ControllerID (1 Byte)
        ErrorCounterThreshold (1 Byte)
        TxErrorCounter &gt; 127 AND RxErrorCounter &gt; 127(0x0)
        TxErrorCounter &gt; 127 AND RxErrorCounter &lt; 127 (0x1)
        RxErrorCounter &gt; 127 AND TxErrorCounter &lt; 127 (0x2)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.SWS_CanIf_00917.ErrorCounter_BoundaryValue</srcid><srcstatus/><internalId>849</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.SEV_ErrorCounter</srcid><srcstatus/><internalId>1092</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>848</internalId></specobject>
    
    <specobject>
      <id>CanIf.SWS_CanIf_00917.ErrorCounter_BoundaryValue</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_ControllerErrorStatePassive() is called by CanDrv, the CanIf shall report the security 
        event CANIF_SEV_ERRORSTATE_PASSIVE in following cases:
        TxErrorCounter &gt; 127 and TxErrorCounter &lt;= 255
        RxErrorCounter &gt; 127 and TxErrorCounter &lt;= 255
        The context data is structured as follows: Context Data (2 Byte)
        ControllerID (1 Byte)
        ErrorCounterThreshold (1 Byte)
        TxErrorCounter &gt; 127 AND RxErrorCounter &gt; 127(0x0)
        TxErrorCounter &gt; 127 AND RxErrorCounter &lt; 127 (0x1)
        RxErrorCounter &gt; 127 AND TxErrorCounter &lt; 127 (0x2)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERRORSTATE_PASSIVE</srcid><srcstatus/><internalId>1504</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6671</srcid><srcstatus/><internalId>1190</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00917</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
       </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>849</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00918</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If CanIf_ControllerBusOff is called by CanDrv, the CanIf shall report the security event 
        CANIF_SEV_ERRORSTATE_BUSOFF. The context data is structured as follows: Context Data (1 Byte)
        Controller ID (1 Byte)
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERRORSTATE_BUSOFF</srcid><srcstatus/><internalId>1503</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4443</srcid><srcstatus/><internalId>1165</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>850</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00919</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_ControllerErrorStatePassive() has an invalid value, the 
        CanIf shall report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError 
        service of the DET module when CanIf_ControllerErrorStatePassive() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERRORSTATE_PASSIVE</srcid><srcstatus/><internalId>1504</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>851</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00920</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter ControllerId of CanIf_ErrorNotification() has an invalid value, the CanIf shall 
        report development error code CANIF_E_PARAM_CONTROLLERID to the Det_ReportError service of the 
        DET module, when CanIf_ErrorNotification() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TX_ERROR_DETECTED</srcid><srcstatus/><internalId>1506</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>852</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00921</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        If parameter CanError of CanIf_ErrorNotification() has an invalid value, the CanIf shall report 
        development error code CANIF_E_PARAM_CAN_ERROR to the Det_ReportError service of the DET module,
        when CanIf_ErrorNotification() is called.
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RX_ERROR_DETECTED</srcid><srcstatus/><internalId>1505</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>853</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91006</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        API service called with invalid CAN ID | CANIF_E_PARAM_CANID | 10 
        API service called with invalid hardware object | CANIF_E_PARAM_HOH | 12 
        API service called with invalid PDU ID | CANIF_E_PARAM_LPDU | 13 
        API service called with invalid controller ID | CANIF_E_PARAM_CONTROLLERID | 15 
        API service called with invalid wakeup source | CANIF_E_PARAM_WAKEUPSOURCE | 16 
        API service called with invalid transceiver ID | CANIF_E_PARAM_TRCV | 17 
        API service called with invalid transceiver mode | CANIF_E_PARAM_TRCVMODE | 18 
        API service called with invalid transceiver wakeup mode | CANIF_E_PARAM_TRCVWAKEUPMODE | 19 
        API service called with invalid pointer | CANIF_E_PARAM_POINTER | 20 
        API service called with invalid controller mode | CANIF_E_PARAM_CTRLMODE | 21 
        API service called with invalid PDU mode | CANIF_E_PARAM_PDU_MODE 22 
        API services called with invalid parameter | CANIF_E_PARAM_CAN_ERROR | 23 
        API service used without module initialization | CANIF_E_UNINIT | 30 
        Transmit PDU ID invalid | CANIF_E_INVALID_TXPDUID | 50 
        Receive PDU ID invalid | CANIF_E_INVALID_RXPDUID | 60 
        CAN Interface initialisation failed | CANIF_E_INIT_FAILED | 80 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PartiallyImplemented</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>854</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91007</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Type of error | Related error code | Error value 
        Failed Data Length Check | CANIF_E_INVALID_DATA_LENGTHCanIf.CANIF_E_INVALID_DATA_LENGTH | 61 
        Data Length | CANIF_E_DATA_LENGTH_MISMATCHCanIf.CANIF_E_DATA_LENGTH_MISMATCH | 62 
        Transmit requested on offline PDU channel | CANIF_E_STOPPEDCanIf.CANIF_E_STOPPED | 70 
        Message length was exceeding the maximum length | CANIF_E_TXPDU_LENGTH_EXCEEDEDCanIf.
        CANIF_E_TXPDU_LENGTH_EXCEEDED | 90 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>dev</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>dev.CanIf.PartiallyImplemented</srcid><srcstatus/><internalId>1097</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>855</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91008</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ControllerErrorStatePassive 
        Syntax 
        void CanIf_ControllerErrorStatePassive (uint8 ControllerId, uint16 RxErrorCounter, uint16 
        TxErrorCounter)
        Service ID [hex] | 0x4f 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller.
        RxErrorCounter | Value of the Rx error counter 
        TxErrorCounter | Value of the Tx error counter 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | void 
        Description | The function derives the ErrorCounterTreshold from RxErrorCounter/ TxErrorCounter 
        values and reports it to the IdsM as security event CANIF_SEV_ERRORSTATE_PASSIVE to the IdsM. 
        It also prepares the context data for the respective security event.
        Available via | CanIf_Can.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERROR_NO_INIT</srcid><srcstatus/><internalId>1502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>856</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91009</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_ErrorNotification 
        Syntax 
        void CanIf_ErrorNotification (uint8 ControllerId, Can_ErrorType Can_ErrorType)
        Service ID [hex] | 0x50 
        Sync/Async | Synchronous 
        Reentrancy | Reentrant 
        Parameters (in) | ControllerId | Abstracted CanIf ControllerId which is assigned to a CAN 
        controller.
        Can_ErrorType | Reported CAN error 
        Parameters (inout) | None 
        Parameters (out) | None 
        Return value | void 
        Description | The function shall derive the bus error source rx or tx from the parameter 
        CanError and report the bus error as security event CANIF_SEV_TX_ERROR_DETECTED or 
        CANIF_SEV_RX_ERROR_DETECTED. It also prepares the context data for the respective security 
        event.
        Available via | CanIf_Can.h 
      </description>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERROR_NO_INIT</srcid><srcstatus/><internalId>1502</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>857</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91010</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R20-11</source>
      <version>1</version>
      <description>
        Name | Description | ID 
        CANIF_SEV_TX_ERROR_DETECTED | A transmission related error was detected. Depending on the 
        context data this could indicate suspicious CAN activity. | 19 
        CANIF_SEV_RX_ERROR_DETECTED | A reception related error was detected. Depending on the context 
        data this could indicate suspicious CAN activity. | 20 
        CANIF_SEV_ERRORSTATE_PASSIVE | The CAN controller transitioned to state passive. | 21 
        CANIF_SEV_ERRORSTATE_BUSOFF | The CAN controller transitioned to state busoff. | 22 
      </description>
      <comment>
        This requirement is informational only.
         SEV values are of type uint8.
      </comment>
      <releases>
        <release>AUTOSAR R20-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERRORSTATE_BUSOFF</srcid><srcstatus/><internalId>1503</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ERRORSTATE_PASSIVE</srcid><srcstatus/><internalId>1504</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RX_ERROR_DETECTED</srcid><srcstatus/><internalId>1505</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TX_ERROR_DETECTED</srcid><srcstatus/><internalId>1506</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>858</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanIf.ECUC_CanIf_00854</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Name | CanIfGlobalTimeSupport
        Parent Container | CanIfPublicCfg
        Description | Enables/Disables the Global Time APIs used when hardware
        timestamping is supported.
        Tags:
        atp.Status=draft
        Multiplicity | 1
        Type | EcucBooleanParamDef
        Post-Build Variant Value | false
        Value Configuration Class | Pre-compile time | x | All Variants
                                  | Link time | _ |
                                  | Post-build time | _ |
        Scope / Dependency | scope: local
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1723</srcid><srcstatus/><internalId>1236</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>859</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91014</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetCurrentTime
        Syntax |
        Std_ReturnType CanIf_GetCurrentTime (uint8 ControllerId, Can_TimeStampType* timeStampPtr)
        Service ID [hex] | 0x51
        Sync/Async | Synchronous
        Reentrancy | Non Reentrant
        Parameters (in) | ControllerId | Index of the addresses CAN controller.
        Parameters (inout) | None 
        Parameters (out) | timeStampPtr | current time stamp
        Return value | Std_ReturnType | E_OK: successful E_NOT_OK: failed
        Description | This service calls the corresponding CAN Driver service to retrieve the current time value out of
                      the HW registers.
                      Tags: atp.Status=draft
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>860</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00922</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check that the service CanIf_Init() was previously called. If the check
        fails, the function shall raise the development error CANIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7068</srcid><srcstatus/><internalId>1196</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>861</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00923</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check the parameter Controller for being valid. If the check fails, the
        function shall raise the development error CANIF_E_PARAM_CONTROLLERID.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7078</srcid><srcstatus/><internalId>1197</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>862</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00924</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check the parameter timeStampPtr for being valid. If the check fails, the
        function shall raise the development error CANIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7088</srcid><srcstatus/><internalId>1198</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>863</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00925</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable
        On/Off by the configuration parameter: CanIfGlobalTimeSupport.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>864</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91011</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_EnableEgressTimeStamp
        Syntax |
        void CanIf_EnableEgressTimeStamp (PduIdType TxPduId)
        Service ID [hex] | 0x52
        Sync/Async | Synchronous
        Reentrancy | Non Reentrant
        Parameters (in) | TxPduId | L-PDU handle of CAN L-PDU for which the time stamping shall be enabled.
        Parameters (inout) | None 
        Parameters (out) | None
        Return value | None
        Description | This service calls the corresponding CAN Driver service to activate egress time stamping on a
                      dedicated message object.
                      Tags: atp.Status=draft
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>865</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00926</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check that the service CanIf_Init() was previously called. If the check
        fails, the function shall raise the development error CANIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7118</srcid><srcstatus/><internalId>1199</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>866</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00927</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check the parameter TxPduId for being valid. If the check fails, the function
        shall raise the development error CANIF_E_PARAM_LPDU.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7128</srcid><srcstatus/><internalId>1200</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>867</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00928</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable
        On/Off by the configuration parameter: CanIfGlobalTimeSupport
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>868</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91012</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetEgressTimeStamp
        Syntax |
        Std_ReturnType CanIf_GetEgressTimeStamp ( PduIdType TxPduId, Can_TimeStampType* timeStampPtr)
        Service ID [hex] | 0x53
        Sync/Async | Synchronous
        Reentrancy | Non Reentrant for the same TxPduId, Reentrant for different TxPduId
        Parameters (in) | TxPduId | L-PDU handle of CAN L-PDU for which the time stamp shall be returned.
        Parameters (inout) | None 
        Parameters (out) | timeStampPtr | current time stamp
        Return value | Std_ReturnType | E_OK: successful E_NOT_OK: failed
        Description | This service calls the corresponding CAN Driver service to read back the egress time stamp on
                      a dedicated message object. It needs to be called within the TxConfirmation() function.
                      Tags: atp.Status=draft
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>869</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00929</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check that the service CanIf_Init() was previously called. If the check
        fails, the function shall raise the development error CANIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7167</srcid><srcstatus/><internalId>1201</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>870</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00930</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check the parameter TxPduId for being valid. If the check fails, the function
        shall raise the development error CANIF_E_PARAM_LPDU.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7177</srcid><srcstatus/><internalId>1202</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>871</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00931</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check the parameter timeStampPtr for being valid. If the check fails, the
        function shall raise the development error CANIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7187</srcid><srcstatus/><internalId>1203</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>872</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00932</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable
        On/Off by the configuration parameter: CanIfGlobalTimeSupport
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>873</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_91013</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        Service Name | CanIf_GetIngressTimeStamp
        Syntax |
        Std_ReturnType CanIf_GetIngressTimeStamp ( PduIdType RxPduId, Can_TimeStampType* timeStampPtr)
        Service ID [hex] | 0x54
        Sync/Async | Synchronous
        Reentrancy | Non Reentrant for the same RxPduId, Reentrant for different RxPduIds.
        Parameters (in) | RxPduId | ID of the received I-PDU for which the time stamp shall be returned.
        Parameters (inout) | None 
        Parameters (out) | timeStampPtr | current time stamp
        Return value | Std_ReturnType | E_OK: successful E_NOT_OK: failed
        Description | This service calls the corresponding CAN Driver service to reads back the ingress time stamp
                      on a dedicated message object. It needs to be called within the RxIndication() function.
                      Tags: atp.Status=draft
        Available via | CanIf.h 
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>874</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00933</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check that the service CanIf_Init() was previously called. If the check
        fails, the function shall raise the development error CANIF_E_UNINIT.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7228</srcid><srcstatus/><internalId>1204</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>875</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00934</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check the parameter RxPduId for being valid. If the check fails, the function
        shall raise the development error CANIF_E_PARAM_LPDU.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7238</srcid><srcstatus/><internalId>1205</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>876</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00935</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        If development error detection is enabled: the function
        shall check the parameter timeStampPtr for being valid. If the check fails, the
        function shall raise the development error CANIF_E_PARAM_POINTER.
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_7248</srcid><srcstatus/><internalId>1206</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CAN_47_TIMESTAMP</srcid><srcstatus/><internalId>1594</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>877</internalId></specobject>

    <specobject>
      <id>CanIf.SWS_CanIf_00936</id>
      <status>approved</status>
      <source>AUTOSAR_SWS_CANInterface.pdf, R21-11</source>
      <version>1</version>
      <description>
        The function shall be pre compile time configurable
        On/Off by the configuration parameter: CanIfGlobalTimeSupport
      </description>
      <releases>
        <release>AUTOSAR R21-11</release>
      </releases>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_47_TIMESTAMP</srcid><srcstatus/><internalId>1350</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>878</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

      <specobject>
         <id>CanIf.EB.CanIfTranslateTxCanIdFunc</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        There shall be an optional configuration parameter CanIfDispatchCfg/CanIfTranslateTxCanIdFunc,
        which enables to configure a user specific callout function.

        This function called, translates the CAN ID of the current Tx PDU into
        the CAN ID that shall be used on the CAN bus for transmission.
        The translated CAN ID is then used by CanIf_Transmit() as parameter to Can_Write() in order to
        send the Tx PDU with the translated CAN ID.

        Syntax:
        Can_IdType &lt;User_TranslateTxCanId&gt;
        (
          Can_IdType CanId
        );
        Sync/Async:	Synchronous
        Reentrancy:	Re-entrant
        Parameters (in):
          CanId		CAN ID that was configured for the current Tx PDU.
        Parameters (out): -
        Return value:	CAN ID that will be actually used for transmission.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31232</srcid><srcstatus/><internalId>1596</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31225</srcid><srcstatus/><internalId>1772</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31228</srcid><srcstatus/><internalId>1773</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>879</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfTranslateTxCanIdFuncDetCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      If the Tx translation callout function (configured by CanIfTranslateTxCanIdFunc) returns an invalid
      Can ID and CanIfDevErrorDetect is enabled, then function CanIf_Transmit() shall
      call Det_ReportError() passing the error code CANIF_E_PARAM_CANID and return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_Transmit_InvalidCanId</srcid><srcstatus/><internalId>1499</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31225</srcid><srcstatus/><internalId>1772</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>880</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfTranslateRxCanIdFunc</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        There shall be an optional configuration parameter CanIfDispatchConfig/CanIfTranslateRxCanIdFunc,
        which enables to configure a user specific callout function.

        This function called, translates the CAN ID of the currently received Rx PDU into
        the CAN ID that shall be used within the CanIf for further processing.
        The translated CAN ID is CanIf as input into software filtering for evaluating the associated
        Rx PDU.

        Syntax:
        Can_IdType &lt;User_TranslateRxCanId&gt;
        (
          Can_IdType CanId
        );
        Sync/Async:	Synchronous
        Reentrancy:	Re-entrant
        Parameters (in):
          CanId		CAN ID of the frame that was received on the network.
        Parameters (out): -
        Return value:	CAN ID that will be actually used for software filtering and Rx PDU mapping.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31224</srcid><srcstatus/><internalId>1768</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>881</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfTranslateRxCanIdFuncDetCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      If the Rx translation callout function (configured by CanIfTranslateRxCanIdFunc) returns an invalid
      Can ID and CanIfDevErrorDetect is enabled, then function CanIf_RxIndication() shall
      call Det_ReportError() passing the error code CANIF_E_PARAM_CANID and abort reception processing.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31224</srcid><srcstatus/><internalId>1768</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>882</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfPublicCanIdTypeEnum</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      Name: CanIfPublicCanIdTypeEnum
      Location: CanIf/CanIfPublicCfg
      Description:
        This parameter is used to configure the width of data type Can_IdType
        provided by asc_Base.
      Multiplicity: 1
      Type: EcucEnumerationParamDef
      Range:
        - UINT16: Can_IdType will be defined as type uint16
        - UINT32: Can_IdType will be defined as type uint32 (default)
      Configuration Class:
        Pre-compile   x   all Variants
        Link time     --  --
        Post Build    --  --
      Scope: ECU
      Dependency:
        If extended CAN IDs are used by the ECU, this parameter must be set to
        the value UINT32.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIdTypeEnum_32</srcid><srcstatus/><internalId>1390</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanIdTypeEnum_16</srcid><srcstatus/><internalId>1394</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>883</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CtrlIdSymbolicNameValue</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      The configuration parameter CanIfCtrlId shall be treated by the generator as a symbolic
      name value configuration parameter. Thus a macro shall be generated with the name of the
      parent container and the value of the actual configuration parameter.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_NonLegacySymbolicNameValues</srcid><srcstatus/><internalId>1345</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SymbolicNameValues</srcid><srcstatus/><internalId>1349</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>884</internalId></specobject>

      <specobject>
         <id>CanIf.EB.SetWakeupEvent</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      Service name: &amp;lt;User_SetWakeupEvent&amp;gt;
      Syntax: void &amp;lt;User_SetWakeupEvent&amp;gt;(EcuM_WakeupSourceType sources)
      Sync/Async: (defined within providing upper layer module)
      Reentrancy: (defined within providing upper layer module)
      Parameters (in):
        sources Events to be validated. Every CAN controller or CAN
                transceiver can be a separate wakeup source.
      Parameters (inout): None
      Parameters (out): None
      Return value: None
      Description: This service indicates a wake up event initiated from the
          wake up source (CAN controller or transceiver) after a former request to
          the CAN Driver or CAN Transceiver Driver module.
      </description>
         <comment>
        This API is currently called for ASr 4.0 Rev2 copmpatibility.
        In ASR 4.0 Rev3 caling this function has been moved to Can/CanTrcv.
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30441</srcid><srcstatus/><internalId>1418</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>885</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfDispatchUserSetWakeupEventName</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      Name CanIfDispatchUserSetWakeupEventName {CANIF_DISPATCH_USERSETWAKEUPEVENT_NAME}
      Description This parameter
        defines the name of &amp;lt;User_SetWakeupEvent&amp;gt;. This  parameter depends on the
        parameter  CANIF_USERSETWAKEUPEVENT_UL.  CANIF_USERSETWAKEUPEVENT_UL
        equals ECUM the name of  &amp;lt;User_SetWakeupEvent&amp;gt; is fixed.
        CANIF_USERSETWAKEUPEVENT_UL equals CDD, the name of
        &amp;lt;User_SetWakeupEvent&amp;gt; is selectable.
      Multiplicity 0..1
      Type EcucFunctionNameDef
      Default value -
      maxLength 32
      minLength 1
      regularExpression -
      ConfigurationClass
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time X VARIANT-LINK-TIME, VARIANT-POST BUILD
        Post-build time -
        Scope / Dependency scope: ECU  dependency: CANIF_DISPATCH_USERSETWAKEUPEVENT_UL
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30441</srcid><srcstatus/><internalId>1418</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_E_NOT_SLEEP_DET</srcid><srcstatus/><internalId>1432</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>886</internalId></specobject>

      <specobject>
         <id>CanIf.EB.ModeIndHandling</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      The CanIf shall handle the function CanIf_ControllerModeIndication() also
      correct in that cases, if function CanIf_ControllerModeIndication() is called
      during CanIf_SetControllerMode().
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>887</internalId></specobject>

      <specobject>
         <id>CanIf.EB.BSWMDGeneration_1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      The CanIf module's generator shall generate a basic software
      module description (BSWMD) based on the CanIf module's
      configuration containing information on the exclusive areas
      required by the CanIf module's implementation.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_SCHM</srcid><srcstatus/><internalId>1347</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>888</internalId></specobject>

      <specobject>
         <id>CanIf.EB.BSWMDGeneration_3</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      The CanIf module's BSWMD shall be generated using a generator
      mode named "generate_swcd".
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MULTICORE_PARTITIONING</srcid><srcstatus/><internalId>1324</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SCHM</srcid><srcstatus/><internalId>1347</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>889</internalId></specobject>

      <specobject>
         <id>CanIf.EB.BSWMDGeneration_4</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      The CanIf module's generator shall generate a basic software
      module description (BSWMD) based on the CanIf module's
      configuration containing information on the partition distribution
      required by the Rte module.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MULTICORE_PARTITIONING</srcid><srcstatus/><internalId>1324</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>890</internalId></specobject>

      <specobject>
         <id>CanIf.EB.User_TxConfirmation</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      When calling a User_CanIfTxConfirmation() for a CDD, the TxPduId passed shall be read from the corresponding
      configuration parameter CanIfTxPduSourcePduID.
      </description>
         <comment>
      Handle Id policy ASR 4.0 R3. See CanIf.ASR40.SWS_CanIf_00011_x
      </comment>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>891</internalId></specobject>

      <specobject>
         <id>CanIf.EB.RelocatablePBCfg</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      In order to support post-build-time configuration data handled by relative offsets to the configuration start address,
      the container CanIfPublicCfg must be extended by the configuration parameter CanIfRelocatablePbcfgEnable.
    </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1319</internalId></linkedfrom><linkedfrom><srcid>CanIf_Test_PBcfgM_On</srcid><srcstatus/><internalId>1320</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31391</srcid><srcstatus/><internalId>1330</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31866</srcid><srcstatus/><internalId>1331</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30391</srcid><srcstatus/><internalId>1699</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30866</srcid><srcstatus/><internalId>1700</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>892</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfUpperLayerUseCanId</id>
         <status>approved</status>
         <source>VAG_Ergaenzungsspezifikation_CAN_Interface, V2.0.5</source>
         <version>1</version>
         <description>
       If CanIfUserUpperLayerConfig/CanIfUpperLayerUseCanId is true, then the signature of function
      &lt;User_RxIndication&gt; is extended by argument Can_IdType CanID at the end of the parameter
      list.
      The argument CanId holds the actually CAN id received on the network.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02002_Err_Invalid_UpperLayerCanIdUsage</srcid><srcstatus/><internalId>1656</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>893</internalId></specobject>

      <specobject>
         <id>CanIf.EB.DlcErrorNotification</id>
         <status>approved</status>
         <source>VAG_Ergaenzungsspezifikation_CAN_Interface, V2.0.5</source>
         <version>1</version>
         <description>
        If the config parameter CanIfRxPduConfig/CanIfUserDlcErrorNotification is not empty, the
        configured function name shall be called if a DlcError happens for the particular RX Pdu.
        Signature of the callout function: void &lt;User_DlcErrorNotification&gt;(PduIdType PduId);
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31218</srcid><srcstatus/><internalId>1389</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31218_Dlc</srcid><srcstatus/><internalId>1393</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>894</internalId></specobject>

      <specobject>
         <id>CanIf.EB.DlcPassedNotification</id>
         <status>approved</status>
         <source>VAG_Ergaenzungsspezifikation_CAN_Interface, V2.0.5</source>
         <version>1</version>
         <description>
      If the config parameter CanIfRxPduConfig/CanIfUserDlcPassedNotification is not empty, the
      configured function name shall be called if no DlcError happens for the particular RX Pdu.
        Signature of the callout function: void &lt;User_DlcPassedNotification&gt;(PduIdType PduId);
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31218</srcid><srcstatus/><internalId>1389</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31218_Dlc</srcid><srcstatus/><internalId>1393</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>895</internalId></specobject>

      <specobject>
         <id>CanIf.EB.HandleIdGenerator</id>
         <status>approved</status>
         <source>EB</source>
         <version>2</version>
         <description>
      The module shall support the correct automatic calculation of
      the handle IDs for the following parameters:
      - CanIfRxPduId
      - CanIfTxPduId
      - CanIfCtrlId
      - CanIfRxPduTargetPduID
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_HandleIdGenerator</srcid><srcstatus/><internalId>1326</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>896</internalId></specobject>

      <specobject>
         <id>CanIf.EB.Rev2.Wakeup</id>
         <status>approved</status>
         <source>EB</source>
         <version>2</version>
         <description>
        If CanIfCanDriverCompatibility is set to ASR402, CanIf shall call EcuM_SetWakeupEvent().
        If either Can_CheckWakeup() or CanTrcv_CheckWakeup() return E_OK the respective bit will be set
        in the WakeupSourceMask passed to EcuM_SetWakeupEvent.
        Configuration of wakeup sources are read from EB specific config parameters
        CanIfCtrlWakeupSourceInRef and CanIfCtrlWakeupSourceOutRef.
      </description>
         <needscoverage>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3237</srcid><srcstatus/><internalId>1140</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31201</srcid><srcstatus/><internalId>1590</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30339</srcid><srcstatus/><internalId>1604</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30831</srcid><srcstatus/><internalId>1605</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30832</srcid><srcstatus/><internalId>1607</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30847</srcid><srcstatus/><internalId>1608</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30806</srcid><srcstatus/><internalId>1609</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30338</srcid><srcstatus/><internalId>1611</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30834</srcid><srcstatus/><internalId>1612</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanTrcvWakeupEvent</srcid><srcstatus/><internalId>1620</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MulticoreTrcvWakeup</srcid><srcstatus/><internalId>1697</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>897</internalId></specobject>

      <specobject>
         <id>CanIf.EB.Rev2.CancelTxConfirmation</id>
         <status>approved</status>
         <source>EB</source>
         <version>2</version>
         <description>
        If CanIfCanDriverCompatibility is set to ASR402, then the signature of CanIf_CancelTxConfirmation shall be compliant to:
        Syntax: void CanIf_CancelTxConfirmation(const Can_PduType* PduInfoPtr)
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30837</srcid><srcstatus/><internalId>1451</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxBufferCancel300Hths</srcid><srcstatus/><internalId>1545</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31195</srcid><srcstatus/><internalId>1588</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30319</srcid><srcstatus/><internalId>1749</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>898</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CancelTxConfirmationDLC</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        With the call of CanIf_CancelTxConfirmation, the module shall check if the DLC is valid, and
        in case of an invalid DLC, the module shall raise a Det error CANIF_E_PARAM_DLC if
        CanIfDevErrorDetect is enabled.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_InvalidDLC</srcid><srcstatus/><internalId>1436</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>899</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CancelTxConfirmation.SduDataPtr.DetCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>2</version>
         <description>
      If the member sdu (in case of parameter CanIfCanDriverCompatibility is set to ASR402) or the
      member SduDataPtr (in case of parameter CanIfCanDriverCompatibility is not set to ASR402) of parameter
      PduInfoPtr of function CanIf_CancelTxConfirmation() is a NULL pointer and CanIfDevErrorDetect
      is enabled, then function CanIf_CancelTxConfirmation() shall call Det_ReportError()
      passing the error code CANIF_E_PARAM_POINTER and return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_InvalidSduDataPtr</srcid><srcstatus/><internalId>1435</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>900</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIf_ControllerModeIndicationDetCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      If the API callback service CanIf_ControllerModeIndication() is invoked with an
      invalid ControllerMode (not equal to CANIF_CS_SLEEP, CANIF_CS_STARTED or
      CANIF_CS_STOPPED) and CanIfDevErrorDetect is enabled, then function
      CanIf_ControllerModeIndication() shall:
      - call Det_ReportError() passing the error code CANIF_E_PARAM_CTRLMODE
      - let the CanIf controller mode unchanged
      - not call a configured upper layer controller mode indication function
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ControllerModeIndication_InvMode</srcid><srcstatus/><internalId>1459</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>901</internalId></specobject>

      <specobject>
         <id>CanIf.EB.RxIndicationCtrlMode</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If the controller mode is not CANIF_CS_STARTED, the module shall ignore the call of
        CanIf_RxIndication and the received LPDU is not processed.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30327</srcid><srcstatus/><internalId>1756</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30365</srcid><srcstatus/><internalId>1757</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>902</internalId></specobject>

      <specobject>
         <id>CanIf.EB.MMapIsValidFunctionToMemSection</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If PbcfgM is used and if config parameter PbcfgMMapIsValidFunctionToMemSection
        exists and it is set on true then generate a new memory section and place the
        CanIf_IsValidConfig function in the new memory section.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_30883</srcid><srcstatus/><internalId>1340</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>903</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfTransmitNonFdDetCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>3</version>
         <description>
        If parameters CanIfDevErrorDetect, CanIfTxPduTruncation and CanIfTxPduTruncateToFrame are true and CanIf_Transmit gets invoked with a Pdu length greater than 8 bytes and the configured
        Can Id of the Pdu is of type STANDARD_CAN or EXTENDED_CAN, then CanIf_Transmit shall call
        Det_ReportError() passing the error code CANIF_E_PARAM_DLC.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>904</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfTransmitFdDetCheck</id>
         <status>approved</status>
         <source>EB</source>
         <version>3</version>
         <description>
        If parameters CanIfDevErrorDetect, CanIfTxPduTruncation and CanIfTxPduTruncateToFrame are true and CanIf_Transmit gets invoked with a Pdu length greater than 64 bytes and the configured
        Can Id of the Pdu is of type STANDARD_FD_CAN or EXTENDED_FD_CAN, then CanIf_Transmit shall
        call Det_ReportError() passing the error code CANIF_E_PARAM_DLC.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>905</internalId></specobject>

      <specobject>
        <id>CanIf.EB.CanIfDetReportRuntimeErrorParam</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          Name CanIfDetReportRuntimeError
          Description Switches the Runtime Error Reporting to Det ON or OFF.
          If true, runtime error is reported to Det, if false, runtime error is not reported to Det.
          Multiplicity 1
          Type EcucBooleanParamDef
          Default value true
          ConfigurationClass
            Pre-compile time X All Variants
            Link time -
            Post-build time -
          Scope / Dependency scope: local
        </description>
        <needscoverage>
          <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_622</srcid><srcstatus/><internalId>1212</internalId></linkedfrom></coveredby></needscov>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>906</internalId></specobject>

      <specobject>
        <id>CanIf.EB.CanIfDetReportRuntimeError</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          If the CanIfDetReportRuntimeError parameter is set to true the runtime error
          CANIF_E_TXPDU_LENGTH_EXCEEDED will be reported to DET, otherwise the
          runtime error CANIF_E_TXPDU_LENGTH_EXCEEDED is not reported to DET.
        </description>
        <needscoverage>
          <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6755</srcid><srcstatus/><internalId>1193</internalId></linkedfrom></coveredby></needscov>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
        <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>907</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfSetDynamicTxIdFdDetCheck.1</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If CanIf_SetDynamicTxId gets invoked with a Can Id representing a Can message
        with flexible data rate (STANDARD_FD_CAN or EXTENDED_FD_CAN) and the previously
        configured Can Id for the given Pdu Id is of Can 2.0 message format (STANDARD_CAN
        or EXTENDED_CAN), then CanIf_SetDynamicTxId shall call Det_ReportError() passing
        the error code CANIF_E_PARAM_CANID.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkSetDynamicTx1</srcid><srcstatus/><internalId>1407</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>908</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfSetDynamicTxIdFdDetCheck.2</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If CanIf_SetDynamicTxId gets invoked with a Can Id representing a Can 2.0 message
        (STANDARD_CAN or EXTENDED_CAN and the previously configured Can Id for the given
        Pdu Id is of flexible data rate (STANDARD_FD_CAN or EXTENDED_FD_CAN),
        then CanIf_SetDynamicTxId shall call Det_ReportError() passing
        the error code CANIF_E_PARAM_CANID.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkSetDynamicTx2</srcid><srcstatus/><internalId>1408</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>909</internalId></specobject>


      <specobject>
         <id>CanIf.EB.CanIfRxIndicationPduLength</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If a received Can message passes the DLC check and the received DLC value is
        larger than the configured Pdu length of the corresponding Pdu,
        then CanIf shall crop the message to the Pdu length before passing the message
        to the upper layer module.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_FdDlcTrimmed</srcid><srcstatus/><internalId>1406</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>910</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfDuplicateCanIfRxPduCanId</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Two RxPdus can share the same CanIfRxPduCanId if one is of
        CAN 2.0 type and the other one of CAN FD type.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ReceiveDuplicateId</srcid><srcstatus/><internalId>1423</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01001_Err_RxId_NotUnique_Standard</srcid><srcstatus/><internalId>1629</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01002_Err_RxId_NotUnique_Standard</srcid><srcstatus/><internalId>1630</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>911</internalId></specobject>

      <specobject>
         <id>CanIf.EB.PBSelectable.FileName</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If postBuildVariant returns a non-empty string, the module's post-build-time
        configuration file names shall be changed in the following way:
        &lt;Mod&gt;[_*]_PBcfg.* to &lt;Mod&gt;_&lt;postBuildVariant&gt;[_*]_PBcfg.*
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_PN_Trcv_Infix</srcid><srcstatus/><internalId>1346</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_ExtCanId</srcid><srcstatus/><internalId>1398</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>912</internalId></specobject>

      <specobject>
         <id>CanIf.EB.PBSelectable.TypeName</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If postBuildVariant returns a non-empty string, the module's post-build-time
        configuration type/variable names shall be changed in the following way:
        - CanIf_[Const]ConfigLayoutType to CanIf_&lt;postBuildVariant&gt;_[Const]ConfigLayoutType
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_ExtCanId</srcid><srcstatus/><internalId>1398</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>913</internalId></specobject>

      <specobject>
         <id>CanIf.EB.PBSelectable.Master</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        If postBuildVariant returns a non-empty string, the module shall generate a post-build-time
        configuration file CanIf_PBcfg.h/c which includes all the variants specific post-build-time
        configurations (CanIf_&lt;postBuildVariant&gt;[_*]_PBcfg.h/c).
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_RxTests_ExtCanId</srcid><srcstatus/><internalId>1398</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>914</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CANIF233</id>
         <status>approved</status>
         <source>EB</source>
         <version>3</version>
         <description>
      The CanIf shall include the following header files &lt;Module&gt;_Cbk.h, in which
      the callback functions called by the CanIf at the upper layers are declared:
      CanSM_Cbk.h - for callback declarations of the CanSm
      CanNm_Cbk.h - for callback declarations of the CanNm
      CanTp_Cbk.h - for callback declarations of the CanTp
      EcuM_Cbk.h - for callback declarations of the EcuM
      Xcp_Cbk.h - for callback declarations of the Xcp
      &lt;CDD&gt;_Cbk.h - for callback declarations of CDD; &lt;CDD&gt; is configurable
      via parameter CANIF_CDD_HEADERFILE (see CanIf.ECUC_CanIf_00671)
      CanTSyn.h - for callback declarations of CanTSyn
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanSM_Cbk</srcid><srcstatus/><internalId>1322</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00233</linksto>
               <dstversion>2</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>64</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>915</internalId></specobject>

      <specobject>
        <id>CanIf.EB.ECUC_CanIf_00528</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          Name CanIfTxPduUserTxConfirmationName  {CANIF_TXPDU_USERTXCONFIRMATION_NAME}
          Parent Container CanIfUpperLayerConfig
          Description This parameter defines the name of the &lt;User_TxConfirmation&gt;.
            This parameter depends on the CanIfUpperLayerConfig's name.
            If CanIfUpperLayerConfig's name equals CAN_TP, CAN_NM, PDUR, CAN_TSYN,
            J1939NM, J1939TP or Xcp the name of the &lt;User_TxConfirmation&gt; is fixed.
            Otherwise  the name of the &lt;User_TxConfirmation&gt; is selectable.
          Multiplicity 0..1
          Type EcucFunctionNameDef
          Default Value
          Length 132
          Regular Expression
          Post-Build Variant Multiplicity false
          Post-Build Variant Value false
          Multiplicity Configuration Class
            Pre-compile time X VARIANT-PRE-COMPILE
            Link time        X VARIANT-LINK-TIME, VARIANT-POST-BUILD
            Post-build time  
          Value Configuration Class
            Pre-compile time X VARIANT-PRE-COMPILE
            Link time        X VARIANT-LINK-TIME, VARIANT-POST-BUILD
            Post-build time  
          Scope / Dependency scope: ECU
        </description>
        <comment>
          This is a configuration parameter requirement without functional specification.
          Functional specification in requirement CanIf.SWS_CanIf_00542.
        </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>916</internalId></specobject>

      <specobject>
        <id>CanIf.EB.ECUC_CanIf_00530</id>
        <status>approved</status>
        <source>EB</source>
        <version>1</version>
        <description>
          Name CanIfRxPduUserRxIndicationName  {CANIF_RXPDU_USERRXINDICATION_NAME}
          Parent Container CanIfUpperLayerConfig
          Description This parameter defines the name of the &lt;User_RxIndication&gt;.
            This parameter depends on the CanIfUpperLayerConfig's name..
            If the CanIfUpperLayerConfig's name. equals CAN_TP, CAN_NM, PDUR, CAN_TSYN,
            J1939NM, J1939TP or Xcp the name of the &lt;User_RxIndication&gt; is fixed.
            Otherwise the name of the &lt;User_RxIndication&gt; is selectable.
          Multiplicity 0..1
          Type EcucFunctionNameDef
          Default value
          Length 1-32
          Regular Expression
          Post-Build Variant Multiplicity false
          Post-Build Variant Value false
          Multiplicity Configuration Class
            Pre-compile time X VARIANT-PRE-COMPILE
            Link time        X VARIANT-LINK-TIME, VARIANT-POST-BUILD
            Post-build time  
          Value Configuration Class
            Pre-compile time X VARIANT-PRE-COMPILE
            Link time        X VARIANT-LINK-TIME, VARIANT-POST-BUILD
            Post-build time  
          Scope / Dependency scope: ECU
        </description>
        <comment>
          This is a configuration parameter requirement without functional specification.
          Functional specification in requirement CanIf.SWS_CanIf_00552.
        </comment>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>917</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanTSynUpperLayerPdu</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        To configure a Rx/Tx Pdu with the CanTSyn as upper layer,
        the container CAN_TSYN must exist in CanIfUpperLayerConfig.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01003_Err_Invalid_MissingUpperLayerConfig</srcid><srcstatus/><internalId>1631</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>918</internalId></specobject>

      <specobject>
         <id>CanIf.EB.XcpLayerPdu</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        To configure a Rx/Tx Pdu with the Xcp as upper layer,
        the container XCP must exist in CanIfUpperLayerConfig.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01003_Err_Invalid_MissingUpperLayerConfig</srcid><srcstatus/><internalId>1631</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>919</internalId></specobject>

      <specobject>
         <id>CanIf.EB.UpperLayerAPINaming</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        CanIfTxPduUserTxConfirmationName/CanIfRxPduUserRxIndicationName shall
        consider the API naming convention defined by SWS.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02001_Err_Invalid_UserName</srcid><srcstatus/><internalId>1655</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>920</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfRxPduUpperLayerRef</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        CanIfRxPduUpperLayerRef shall refer the CDD when configured.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02003_Err_Invalid_CDD_Ref</srcid><srcstatus/><internalId>1657</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>921</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfPublicMaxTxBuffers</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The CanIfPublicMaxTxBuffers configuration parameter shall always
        be greater or equal than the number of CanIfTxPduCfgs with BASIC
        CanHandleType.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01004_Err_Invalid_BufferSize</srcid><srcstatus/><internalId>1632</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00828</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>728</internalId></provcov>
      </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>922</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfDecoupledProcessingSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfDecoupledProcessingSupport
        Parent Container CanIfPublicCfg
        Description Enables/disables the assignment of PDUs to selected
                    MainFunctions for processing.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value FALSE
        Post-Build Variant Value FALSE
        Value Configuration Class:
          Pre-compile   X   All Variants
          Link time     --  --
          Post Build    --  --
        Scope/Dependency: local
      </description>
      <comment>
        The MainFunctions are configured via the CanIfRxProcessing/CanIfTxProcessing
        containers.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_664</srcid><srcstatus/><internalId>1213</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>923</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfRxProcessing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfRxProcessing
        Description Container used for the definition/configuration of
                    a Rx MainFunction.
        Multiplicity [0 .. INF[
        Type EcucParamConfContainerDef
        Post-Build Variant Multiplicity FALSE
        Multiplicity Configuration Class
          Pre-compile time   X    All Variants
          Link time          --   --
          Post-build time    --   --
        Scope/Dependency: scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_747</srcid><srcstatus/><internalId>1216</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>924</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfTxProcessing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfTxProcessing
        Description Container used for the definition/configuration of
                    a Tx MainFunction.
        Multiplicity [0 .. INF[
        Type EcucParamConfContainerDef
        Post-Build Variant Multiplicity FALSE
        Multiplicity Configuration Class
          Pre-compile time   X   All Variants
          Link time          --  --
          Post-build time    --  --
        Scope/Dependency: scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_872</srcid><srcstatus/><internalId>1221</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterruptedByTxConfirmation</srcid><srcstatus/><internalId>1690</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>925</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfRxProcessing.CanIfRxPduProcessingRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfRxPduProcessingRef
        Parent container CanIfRxProcessing
        Description Reference to a CanIfRxPduCfg.
        Multiplicity 1
        Type Reference to Pdu
        Post-Build Variant Value TRUE
        Multiplicity Configuration Class
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time        X VARIANT-LINK-TIME
          Post-build time  X VARIANT-POST-BUILD
        Scope/Dependency: scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_787</srcid><srcstatus/><internalId>1218</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>926</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfTxProcessing.CanIfTxPduProcessingRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfTxPduProcessingRef
        Parent container CanIfTxProcessing
        Description Reference to a CanIfTxPduCfg.
        Multiplicity 1
        Type Reference to Pdu
        Post-Build Variant Value TRUE
        Multiplicity Configuration Class
          Pre-compile time X VARIANT-PRE-COMPILE
          Link time        X VARIANT-LINK-TIME
          Post-build time  X VARIANT-POST-BUILD
        Scope/Dependency: scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_912</srcid><srcstatus/><internalId>1223</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterruptedByTxConfirmation</srcid><srcstatus/><internalId>1690</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>927</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfTxPduQueueSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Name CanIfTxPduQueueSize
        Parent container CanIfTxProcessing
        Description Defines a local queue for handling of each TxPdu
                    when CanIfTxProcessing is enabled.
        Multiplicity 0..1
        Type EcuCIntegerParamDef
        Range 1..65535
        Post-Build Variant Multiplicity FALSE
        Post-Build Variant Value FALSE
        Multiplicity Configuration Class
          Pre-compile time   X   All Variants
          Link time          --  --
          Post-build time    --  --
        Scope/Dependency: scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_935</srcid><srcstatus/><internalId>1224</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>928</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfRxPduQueueSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        Name CanIfRxPduQueueSize
        Parent container CanIfRxProcessing
        Description Defines a local queue for handling of each RxPdu
                    when CanIfRxProcessing is enabled.
        Multiplicity 0..1
        Type EcuCIntegerParamDef
        Range 1..65535
        Post-Build Variant Multiplicity FALSE
        Post-Build Variant Value FALSE
        Multiplicity Configuration Class
          Pre-compile time   X   All Variants
          Link time          --  --
          Post-build time    --  --
        Scope/Dependency: scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_809</srcid><srcstatus/><internalId>1219</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_DecoupledBufferLimit</srcid><srcstatus/><internalId>1693</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>929</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfPublicMaxPayloadQueueSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfPublicMaxPayloadQueueSize
        Description The maximum total size (in bytes) of the
                    Rx data queue.
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 1..65535
        Default value 512
        Post-Build Variant Value FALSE
        Multiplicity Configuration Class
          Pre-compile time   X   All Variants
          Link time          --  --
          Post-build time    --  --
        Scope/Dependency: scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_837</srcid><srcstatus/><internalId>1220</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01005_Err_Invalid_BufferNonAddressable</srcid><srcstatus/><internalId>1633</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_DecoupledBufferLimit</srcid><srcstatus/><internalId>1693</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>930</internalId></specobject>

    <specobject>
      <id>CanIf.EB.RxDecoupledProcessing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIf shall handle the Rx L-PDUs received at CanIf_RxIndication()
        associated to a CanIfRxProcessing in the MainFunction context.
        The CanIfRxPduQueueSize represents the number of PDUs associated
        to a specific CanIf_MainFunctionRx().
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4002</srcid><srcstatus/><internalId>1158</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>931</internalId></specobject>

    <specobject>
      <id>CanIf.EB.TxDecoupledProcessing</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIf shall handle the Tx L-PDUs received at CanIf_TxConfirmation()
        associated to a CanIfTxProcessing in the MainFunction context.
        The CanIfTxPduQueueSize represents the number of PDUs associated
        to a specific CanIf_MainFunctionTx().
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4069</srcid><srcstatus/><internalId>1161</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxDecoupledProcessingQueueLimit</srcid><srcstatus/><internalId>1694</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>932</internalId></specobject>

    <specobject>
      <id>CanIf.EB.RxDecoupledProcessing.FullQueue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the queue is full (CanIfRxPduQueueSize was exceeded), CanIf shall
        ignore the incoming messages and report the development error code
        CANIF_E_FULL_QUEUE to the Det_ReportError service of the DET module
        when CanIf_RxIndication() is called.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3944</srcid><srcstatus/><internalId>1155</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>933</internalId></specobject>

    <specobject>
      <id>CanIf.EB.TxDecoupledProcessing.FullQueue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the queue is full (CanIfTxPduQueueSize was exceeded), CanIf shall
        ignore the incoming transmit confirmations and report the development
        error code CANIF_E_FULL_QUEUE to the Det_ReportError service of the
        DET module when CanIf_TxConfirmation() is called.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3730</srcid><srcstatus/><internalId>1147</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxDecoupledProcessingQueueLimit</srcid><srcstatus/><internalId>1694</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>934</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DecoupledProcessing.TriggerMainFunc</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIf shall notify a queued L-PDU by calling
        SchM_ActMainFunction_&lt;bsnp&gt;[_&lt;vi&gt;_&lt;ai&gt;]_&lt;name&gt;()
        (see SWS_Rte_07266).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3714</srcid><srcstatus/><internalId>1145</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3928</srcid><srcstatus/><internalId>1153</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterruptedByTxConfirmation</srcid><srcstatus/><internalId>1690</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>935</internalId></specobject>

    <specobject>
      <id>CanIf.EB.RxDecoupledProcessing.MainFunc</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIf shall process a queued Rx L-PDU when the associated
        CanIf_MainFunctionRx_&lt;CanIfRxProcessingShortName&gt;()
        API is called.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3977</srcid><srcstatus/><internalId>1156</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessingInterrupted</srcid><srcstatus/><internalId>1692</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>936</internalId></specobject>

    <specobject>
      <id>CanIf.EB.TxDecoupledProcessing.MainFunc</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIf shall process a queued Tx L-PDU when the associated
        CanIf_MainFunctionTx_&lt;CanIfTxProcessingShortName&gt;()
        API is called.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4047</srcid><srcstatus/><internalId>1159</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxDecoupledProcessingQueueLimit</srcid><srcstatus/><internalId>1694</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>937</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_10001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name CanIfMirroringSupport
        Description Contains Bus Mirroring related configuration parameters.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>938</internalId></specobject>

    <specobject>
      <id>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If Bus Mirroring is enabled globally (see CanIfBusMirroringSupport)
        and has been activated with a call to CanIf_EnableBusMirroring()
        for a CAN Controller and the CanIfMirrorToCDDReportingEnable parameter
        is enabled, the CanIf shall call Cdd_ReportCanFrame() for each frame
        transmission on that controller that is confirmed with CanIf_TxConfirmation(),
        providing the stored content and the actual CAN ID.
      </description>
      <verifycrit>
        EC valid:   1.  After mirroring being activated with a call to CanIf_EnableBusMirroring(),
                        with the MirroringActive parameter as TRUE and the CanIfMirrorToCDDReportingEnable
                        parameter is enabled, during transmission, after CanIf_TxConfirmation
                        Cdd_ReportCanFrame() is called.
                        The reported CANID is an expected one and associated to the controller
                        with the ID activated by CanIf_EnableBusMirroring().
        EC invalid: 1.  Call to CanIf_EnableBusMirroring() with an invalid
                        controller ID (CANIF_E_PARAM_CONTROLLERID reported to DET)
                        During transmission calls to Cdd_ReportCanFrame().
                        Note: Mirroring shall not be activated for any other controller.
                    2.  Call to CanIf_EnableBusMirroring() with a valid controller ID
                        (no CANIF_E_PARAM_CONTROLLERID reported to DET) and with the
                        MirroringActive parameter as TRUE and the CanIfMirrorToCDDReportingEnable
                        parameter is enabled, during transmission calls to Cdd_ReportCanFrame() can
                        be observed when the frame isn't confirmed (any other time except immediately after
                        CanIf_TxConfirmation())
                    3.  Call to CanIf_EnableBusMirroring() with a valid controller ID
                        (no CANIF_E_PARAM_CONTROLLERID reported to DET), and with the
                        MirroringActive parameter as TRUE, and the CanIfMirrorToCDDReportingEnable
                        parameter is enabled, Cdd_ReportCanFrame() is called after a  CanIf_TxConfirmation()
                        with an unexpected ID.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3615</srcid><srcstatus/><internalId>1143</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_1</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_2</srcid><srcstatus/><internalId>1520</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_3</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_1</srcid><srcstatus/><internalId>1525</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_2</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2_1</srcid><srcstatus/><internalId>1540</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_3</srcid><srcstatus/><internalId>1541</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_4</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>939</internalId></specobject>

    <specobject>
      <id>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If Bus Mirroring is enabled globally (see CanIfBusMirroringSupport)
        and has been activated with a call to CanIf_EnableBusMirroring()
        for a CAN Controller and the CanIfMirrorToCDDReportingEnable parameter
        is enabled, the CanIf shall call Cdd_ReportCanFrame() for each frame
        transmission on that controller that is confirmed with CanIf_TxConfirmation(),
        providing the stored content and the actual CAN ID.
      </description>
      <verifycrit>
        EC valid:   1.  After mirroring being activated with a call to CanIf_EnableBusMirroring()
                        with the MirroringActive parameter as TRUE and the CanIfMirrorToCDDReportingEnable
                        parameter is enabled, during transmission, after CanIf_TxConfirmation
                        Cdd_ReportCanFrame() is called.
                        The reported payload is the one that's confirmed.
        EC invalid: 1.  Call to CanIf_EnableBusMirroring() with a valid controller ID
                        (no CANIF_E_PARAM_CONTROLLERID reported to DET), with the
                        MirroringActive parameter as TRUE and the CanIfMirrorToCDDReportingEnable
                        parameter is enabled, during transmission calls to Cdd_ReportCanFrame() can be
                        observed when the frame isn't confirmed (any other time except immediately after
                        CanIf_TxConfirmation())
                    2.  Call to CanIf_EnableBusMirroring() with a valid controller ID
                        (no CANIF_E_PARAM_CONTROLLERID reported to DET),
                        with the MirroringActive parameter as TRUE and the CanIfMirrorToCDDReportingEnable
                        parameter is enabled, Cdd_ReportCanFrame() is called after a  CanIf_TxConfirmation()
                        with a payload mismatch (not the one supplied to Can_Write())
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3616</srcid><srcstatus/><internalId>1144</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_1</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_2</srcid><srcstatus/><internalId>1520</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_3</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_1</srcid><srcstatus/><internalId>1525</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_2</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2_1</srcid><srcstatus/><internalId>1540</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_3</srcid><srcstatus/><internalId>1541</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_4</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>940</internalId></specobject>

    <specobject>
      <id>CanIf.EB.SWS_CANIF_00905.Cdd</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CAN Interface shall include the header file CddName.h if Bus Mirroring is enabled
        (configuration parameter CanIfBusMirroringSupport) and CanIfMirrorToCDDReportingEnable is enabled.
      </description>
      <comment/>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanIf_Cfg.h.m4_32</srcid><srcstatus/><internalId>1113</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_1</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_2</srcid><srcstatus/><internalId>1520</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_3</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_1</srcid><srcstatus/><internalId>1525</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_2</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_RX</srcid><srcstatus/><internalId>1537</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2_1</srcid><srcstatus/><internalId>1540</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_3</srcid><srcstatus/><internalId>1541</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_4</srcid><srcstatus/><internalId>1542</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>941</internalId></specobject>

    <specobject>
      <id>CanIf.EB.SWS_CANIF_00906.Provision.CANID.Cdd</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If Bus Mirroring is enabled globally (see CanIfBusMirroringSupport)
        and has been activated with a call to CanIf_EnableBusMirroring()
        for a CAN Controller and the CanIfMirrorToCDDReportingEnable parameter
        is enabled, the CanIf shall call Cdd_ReportCanFrame() for each frame
        reception on that controller that is indicated with CanIf_RxIndication(),
        providing the CAN ID.
      </description>
      <verifycrit>
        EC valid:   1. Mirroring activated with valid controller ID.
                       CanIf_RxIndication() called with valid ID.
                       Cdd_ReportCanFrame() called with a valid ID.
        EC invalid: 1. Mirroring not activated for the controller.
                       CanIf_RxIndication() callied with an invalid ID.
                       Cdd_ReportCanFrame() called.
                    2. Mirroring activated for the controller.
                       CanIf_RxIndciation() called with a valid ID.
                       Cdd_ReportCanFrame() called with an ID differing
                       from the one obtained during CanIf_RxIndication(), when
                       CanIfTranslateRxCanIdFunc is deactivated
                    3. Mirroring activated for the controller.
                       CanIf_RxIndciation() called with a valid ID.
                       Cdd_ReportCanFrame() called with an ID matching
                       the one obtained during CanIf_RxIndication(), when
                       CanIfTranslateRxCanIdFunc is activated.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3856</srcid><srcstatus/><internalId>1150</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_RX</srcid><srcstatus/><internalId>1537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>942</internalId></specobject>

    <specobject>
      <id>CanIf.EB.SWS_CANIF_00906.Provision.Payload.Cdd</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If Bus Mirroring is enabled globally (see CanIfBusMirroringSupport)
        and has been activated with a call to CanIf_EnableBusMirroring()
        for a CAN Controller and the CanIfMirrorToCDDReportingEnable parameter
        is enabled, the CanIf shall call Cdd_ReportCanFrame() for each frame
        reception on that controller that is indicated with CanIf_RxIndication(),
        providing the payload.
      </description>
      <verifycrit>
        EC valid:    CanIf_EnableBusMirroring() is called with a valid controller
                     ID and the MirroringActive parameter as TRUE and the
                     CanIfMirrorToCDDReportingEnable parameter is enabled.
                     Cdd_ReportCanFrame() called with a payload
                     matching the one obtained during CanIf_RxIndication().
        EC invalid:  CanIf_EnableBusMirroring() is called with a valid controller
                     ID and the MirroringActive parameter as TRUE and the
                     CanIfMirrorToCDDReportingEnable parameter is enabled.
                     Cdd_ReportCanFrame() called with a payload differing
                     from the one obtained during CanIf_RxIndication().
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3857</srcid><srcstatus/><internalId>1151</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_RX</srcid><srcstatus/><internalId>1537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>943</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfMirrorToCDDReportingEnable
        Description States if reporting is done to Mirror or to a specific CDD.
        If true, reporting is done to Cdd, if false, reporting is done to Mirror.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value false
        ConfigurationClass Pre-compile time X All Variants  Link time - Post-build time -
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2511</srcid><srcstatus/><internalId>1248</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_1</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_2</srcid><srcstatus/><internalId>1520</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_3</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_1</srcid><srcstatus/><internalId>1525</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_2</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2_1</srcid><srcstatus/><internalId>1540</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_3</srcid><srcstatus/><internalId>1541</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_4</srcid><srcstatus/><internalId>1542</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01018_Err_Invalid_CDDReportingFunctionName</srcid><srcstatus/><internalId>1646</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01019_Err_Invalid_CDDReportingHeader</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>944</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfMirrorToCDDReportingFunctionName
        Description Function name for CDD reporting
        Multiplicity 1
        Type EcucFunctionNameDef
        Default value false
        ConfigurationClass Pre-compile time X All Variants  Link time - Post-build time -
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2534</srcid><srcstatus/><internalId>1249</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_1</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_2</srcid><srcstatus/><internalId>1520</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_3</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_1</srcid><srcstatus/><internalId>1525</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_2</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2_1</srcid><srcstatus/><internalId>1540</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_3</srcid><srcstatus/><internalId>1541</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_4</srcid><srcstatus/><internalId>1542</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01018_Err_Invalid_CDDReportingFunctionName</srcid><srcstatus/><internalId>1646</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>945</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfMirrorToCDDReportingHeader
        Description Header containing the Cdd function for reporting
        Multiplicity 1
        Type EcucFunctionNameDef
        Default value false
        ConfigurationClass Pre-compile time X All Variants  Link time - Post-build time -
        Scope / Dependency scope: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2558</srcid><srcstatus/><internalId>1250</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_1</srcid><srcstatus/><internalId>1519</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_2</srcid><srcstatus/><internalId>1520</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1_3</srcid><srcstatus/><internalId>1521</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_1</srcid><srcstatus/><internalId>1525</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3_2</srcid><srcstatus/><internalId>1526</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX</srcid><srcstatus/><internalId>1538</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2</srcid><srcstatus/><internalId>1539</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_2_1</srcid><srcstatus/><internalId>1540</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_3</srcid><srcstatus/><internalId>1541</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_TX_4</srcid><srcstatus/><internalId>1542</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01019_Err_Invalid_CDDReportingHeader</srcid><srcstatus/><internalId>1647</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>946</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanTxErrorCounterSupported</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfCanTxErrorCounterSupported
        Parent Container CanIfMirroringSupport
        Description Enable support for call dispatch to the Can Driver.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value  false
        Value Configuration Class
          Pre-compile time X All Variants
          Link time        --
          Post-build time  --
        Scope / Dependency scope: ECU
      </description>
      <comment>
        The parameter specifies whether the Can Driver exposes the
        API Can_GetControllerTxErrorCounter().
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1516</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>833</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>947</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxErrorCounterValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfTxErrorCounterValue
        Parent Container CanIfMirroringSupport
        Description Specifies the value to which TxErrorCounterPtr is set when
                    the API CanIf_GetControllerTxErrorCounter is called.
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0..255
        Default Value 0
        Post-Build Variant Value  false
        Value Configuration Class
          Pre-compile time X All Variants
          Link time        --
          Post-build time  --
        Scope / Dependency scope: ECU
                                  CanIfCanTxErrorCounterSupported
      </description>
      <comment>
        Specifies the value reported to the Mirror module when calls to the
        Driver are not dispatched from CanIf_GetControllerTxErrorCounter().
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1516</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERTXERRORCOUNTER</srcid><srcstatus/><internalId>1533</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91004.ReturnValue.NotSupportedByDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>834</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>948</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanControllerErrorStateSupported</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfCanControllerErrorStateSupported
        Parent Container CanIfMirroringSupport
        Description Enable support for call dispatch to the Can Driver.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value  false
        Value Configuration Class
          Pre-compile time X All Variants
          Link time        --
          Post-build time  --
        Scope / Dependency scope: ECU
      </description>
      <comment>
        The parameter specifies whether the Can Driver exposes the
        API CanIf_GetControllerErrorState().
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1517</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>808</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>949</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfErrorStateValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfErrorStateValue
        Parent Container CanIfMirroringSupport
        Description Specifies the value to which ErrorStatePtr is set when
                    the API CanIf_GetControllerErrorState is called.
        Multiplicity 1
        Type EcucEnumerationParamDef
        Range CAN_ERRORSTATE_ACTIVE
              CAN_ERRORSTATE_PASSIVE
              CAN_ERRORSTATE_BUSOFF
        Default Value CAN_ERRORSTATE_ACTIVE
        Post-Build Variant Value  false
        Value Configuration Class
          Pre-compile time X All Variants
          Link time        --
          Post-build time  --
        Scope / Dependency scope: ECU
                                  CanIfCanControllerErrorStateSupported
      </description>
      <comment>
        Specifies the value reported to the Mirror module when calls to the
        Driver are not dispatched from CanIf_GetControllerErrorState().
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_CANGETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1517</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERERRORSTATE</srcid><srcstatus/><internalId>1534</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91001.ReturnValue.NotSupportedByDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>809</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>950</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.TxMirrorBufferSize</id>
      <status>approved</status>
      <source>EB</source>
      <version>3</version>
      <description>
        Name TxMirrorBufferSize
        Parent Container CanIfMirroringSupport
        Description Specifies the length of the CanIf_MirrorBuffPayload array.
                    Value will be round up to a multiple of 8 and will be used
                    to determine the maximum number of PDUs to be buffered.
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0..4294967295
        Default Value --
        Post-Build Variant Value  false
        Value Configuration Class
          Pre-compile time X All Variants
          Link time        --
          Post-build time  --
        Scope / Dependency scope: ECU
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>951</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxMirrorBuffers</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Container Name CanIfTxMirrorBuffers
        Parent Container CanIfMirroringSupport
        Description Contains Tx Mirror buffer information in a multicore configuration.
        Only relevant if CanIfBusMirroringSupport and CanIfMultiCoreSupport are enabled.
      </description>
      <comment>
        This is a configuration parameter requirement without functional specification.
      </comment>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>952</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxMirrorBufferSizePart</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfTxMirrorBufferSizePart
        Parent Container CanIfTxMirrorBuffers
        Description Specifies the length of the CanIf_MirrorBuffPayload_&lt;idx&gt;
                    array for a specific partition.
                    Value will be round up to a multiple of 8 and will be used
                    to determine the maximum number of PDUs to be buffered on
                    that partition.
        Multiplicity 1
        Type EcucIntegerParamDef
        Range 0..4294967295
        Default Value --
        Post-Build Variant Value  false
        Value Configuration Class
          Pre-compile time X All Variants
          Link time        --
          Post-build time  --
        Scope / Dependency scope: ECU
          dependecy: CanIfMultiCoreSupport
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>953</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxBufPartRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfTxBufPartRef
        Parent Container CanIfTxMirrorBuffers
        Description Specifies the partition reference used for determining what buffer
                    will each controller use for storing PDU data.
        Multiplicity 1
        Type EcucReferenceDef
        Post-Build Variant Value  true
        Value Configuration Class:
          Pre-compile   X   VARIANT-PRE-COMPILE
          Link time     X   VARIANT-LINK-TIME
          Post Build    X   VARIANT-POST-BUILD
        Scope/Dependency: 
          scope: local
          dependecy: CanIfMultiCoreSupport
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02023_Err_CanIfTxMirrorBuffers_InvalidPartition</srcid><srcstatus/><internalId>1682</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>954</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Mirroring.FullBuffer</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the payload buffer is full (TxMirrorBufferSize was exceeded), CanIf shall
        report the development error code CANIF_E_PDU_INSTANCE_LOST to the Det_ReportError
        service of the DET module.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6804</srcid><srcstatus/><internalId>1195</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_1</srcid><srcstatus/><internalId>1518</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2</srcid><srcstatus/><internalId>1522</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_2_1</srcid><srcstatus/><internalId>1523</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_3</srcid><srcstatus/><internalId>1524</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4</srcid><srcstatus/><internalId>1527</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_1</srcid><srcstatus/><internalId>1528</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_2</srcid><srcstatus/><internalId>1529</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_3</srcid><srcstatus/><internalId>1530</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_Buffer_TX_4_4</srcid><srcstatus/><internalId>1531</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>955</internalId></specobject>

    <specobject>
      <id>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: CanIf_GetControllerMode
        Syntax: Std_ReturnType CanIf_GetControllerMode(
                                uint8 ControllerId,
                                CanIf_ControllerModeType* ControllerModePtr
                              )
        Service ID[hex]: 0x04
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in):    ControllerId Abstracted CanIf ControllerId which is assigned to a CAN
                                         controller, which is requested for current operation mode.
                                         ControllerModePtrPointer to a memory location, where the
                                         current mode of the CAN controller will be stored.
        Parameters (inout): None
        Parameters (out):   None
        Return value: Std_ReturnType E_OK: Controller mode request has been accepted.
                                     E_NOT_OK: Controller mode request has not been accepted.
        Description: This service reports about the current status of the requested CAN controller.
      </description>
      <comment>
        See dev.CanIf.GetControllerModeSignature
      </comment>
      <verifycrit>
        EC valid:   CanIfBusMirroringSupport is set to FALSE,
                    the second parameter of the function is of type
                    CanIf_ControllerModeType*.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1544</srcid><srcstatus/><internalId>1125</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_APIS_MIRROR</srcid><srcstatus/><internalId>1327</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30844</srcid><srcstatus/><internalId>1438</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30242</srcid><srcstatus/><internalId>1460</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30265</srcid><srcstatus/><internalId>1461</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31176</srcid><srcstatus/><internalId>1579</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30295</srcid><srcstatus/><internalId>1718</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00229</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>956</internalId></specobject>

    <specobject>
      <id>CanIf.EB.GetControllerMode.Signature.Mirroring.ON</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: CanIf_GetControllerMode
        Syntax: Std_ReturnType CanIf_GetControllerMode(
                                uint8 ControllerId,
                                Can_ControllerStateType * ControllerModePtr
                              )
        Service ID[hex]: 0x04
        Sync/Async: Synchronous
        Reentrancy: Non Reentrant
        Parameters (in): ControllerId Abstracted CanIf ControllerId which is assigned to a
                         CAN controller, which is requested for current operation mode.
        Parameters (inout): None
        Parameters (out):   ControllerModePtr Pointer to a memory location, where the current
                                              mode of the CAN controller will be stored.
        Return value: Std_ReturnType E_OK: Controller mode request has been accepted.
                                     E_NOT_OK: Controller mode request has not been accepted.
        Description: This service calls the corresponding CAN Driver service for obtaining the
                     current status of the CAN controller.
      </description>
      <comment>
        See dev.CanIf.GetControllerModeSignature
      </comment>
      <verifycrit>
        EC valid:   CanIfBusMirroringSupport is set to TRUE,
                    the second parameter of the function is of type
                    Can_ControllerStateType*.
        EC invalid: 1. CanIfBusMirroringSupport is set to TRUE,
                       the second parameter of the function is of type
                       CanIf_ControllerModeType*.
                    2. CanIfBusMirroringSupport is set to FALSE,
                       the second parameter of the function is of type
                       Can_ControllerStateType*.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1541</srcid><srcstatus/><internalId>1124</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_API_GETCONTROLLERMODESIG</srcid><srcstatus/><internalId>1535</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_API_GETTRCVMODE</srcid><srcstatus/><internalId>1536</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MIRROR_RX</srcid><srcstatus/><internalId>1537</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00229</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>484</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>957</internalId></specobject>

    <specobject>
      <id>CanIf.EB.User_TxConfirmation.Signature.Result.ON</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: &lt;User_TxConfirmation&gt;
        Syntax:       void &lt;User_TxConfirmation&gt;(
                                PduIdType TxPduId,
                                Std_ReturnType result
                                )
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in):    TxPduId   ID of the I-PDU that has been transmitted.
                            result    E_OK: The PDU was transmitted. E_NOT_OK: Transmission of the PDU failed.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:  The lower layer communication interface module confirms the transmission of a PDU, or the
                      failure to transmit a PDU.
      </description>
      <comment>
        See dev.CanIf.User_TxConfirmationSignature
      </comment>
      <verifycrit>
        EC valid:   CanIfPublicTxConfResultSupport is set to TRUE,
                    the second parameter result of the function of type
                    Std_ReturnType is present.
        EC invalid: 1. CanIfPublicTxConfResultSupport is set to TRUE,
                       the second parameter result of the function of type
                       Std_ReturnType is absent.
                    2. CanIfPublicTxConfResultSupport is set to FALSE,
                       the second parameter result of the function of type
                       Std_ReturnType is present.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanIf_Types.h_445</srcid><srcstatus/><internalId>1119</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1990</srcid><srcstatus/><internalId>1133</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4416</srcid><srcstatus/><internalId>1162</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4623</srcid><srcstatus/><internalId>1166</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIfPublicSingleCtrlOpt_Enabled</srcid><srcstatus/><internalId>1348</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_CANIF_TXCONFIRMATION</srcid><srcstatus/><internalId>1597</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>416</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>958</internalId></specobject>

    <specobject>
      <id>CanIf.EB.User_TxConfirmation.Signature.Result.OFF</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: &lt;User_TxConfirmation&gt;
        Syntax:       void &lt;User_TxConfirmation&gt;(
                                PduIdType TxPduId,
                                Std_ReturnType result
                                )
        Sync/Async:         Synchronous
        Reentrancy:         Reentrant for different PduIds. Non reentrant for the same PduId.
        Parameters (in):    TxPduId   ID of the I-PDU that has been transmitted.
                            result    E_OK: The PDU was transmitted. E_NOT_OK: Transmission of the PDU failed.
        Parameters (inout): None
        Parameters (out):   None
        Return value:       None
        Description:  The lower layer communication interface module confirms the transmission of a PDU, or the
                      failure to transmit a PDU.
      </description>
      <comment>
        See dev.CanIf.User_TxConfirmationSignature
      </comment>
      <verifycrit>
        EC valid:   CanIfPublicTxConfResultSupport is set to FALSE,
                    the second parameter result of the function of type
                    Std_ReturnType is absent.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanIf_Types.h_433</srcid><srcstatus/><internalId>1118</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1993</srcid><srcstatus/><internalId>1134</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_Transmit300Hths</srcid><srcstatus/><internalId>1544</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30213</srcid><srcstatus/><internalId>1745</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>236</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>959</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Metadata.Config.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfMetaDataSupport is enabled(see CanIf.ECUC_CanIf_00824), CanIf shall distinguish if a MetaDataItem of type
        CAN_ID_32 is configured in EcuC for each of its own configured PDU and shall store this
        information to be available at runtime.
      </description>
      <comment>
        A PDU which has such a configuration in EcuC will be reffered to as a "PDU with metadata".
      </comment>
      <verifycrit>
        EC valid: 1. For PDUs with metadata, Can_Write() is called with a CanId combined from CanIfTxPduCanId and Metadata
                     based on CanIfTxPduCanIdMask.
                  2. For PDUs without metadata, Can_Write() is called with the CanId from the CanIfTxPduCanId parameter.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_740</srcid><srcstatus/><internalId>1301</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_1356</srcid><srcstatus/><internalId>1304</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>960</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Metadata.Config.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanIfTxPduCanId parameter can be omitted if that PDU has metadata
        (see CanIf.EB.Metadata.Config.1).
      </description>
      <comment>
        The CANID can be fully obtained from the metadata.
      </comment>
      <verifycrit>
        EC valid:   No error in Tresos if PDU has metadata and CanIfTxPduCanId is left empty.
        EC invalid: Error in Tresos if PDU doesn't have metadata and CanIfTxPduCanId is empty.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_1928</srcid><srcstatus/><internalId>1262</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>961</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Metadata.Config.3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a TX PDU has metadata (see CanIf.EB.Metadata.Config.1) and parameter CanIfTxPduCanId
        configured then CanIfTxPduCanIdMask must also be configured.
      </description>
      <comment>
        If a TX PDU has metadata and also a static CANID configured, then the mask is needed to distinguish
        which bits are taken from CANID and which are taken from metadata.
      </comment>
      <verifycrit>
        EC valid:   No Error in tresos Studio if PDU has metadata, CanIfTxPduCanId and CanIfTxPduCanIdMask
                    configured.
        EC invalid: Error in tresos Studio if PDU has metadata and CanIfTxPduCanId, but no
                    CanIfTxPduCanIdMask configured.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_2031</srcid><srcstatus/><internalId>1264</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00856</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>758</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>962</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Metadata.Config.4</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If an RX PDU has metadata (see CanIf.EB.Metadata.Config.1) then the CanIfRxPduCanIdMask
        parameter must be configured (see CanIf.ECUC_CanIf_00822) or the CanIfRxPduCanIdRange
        container enabled (see CanIf.ECUC_CanIf_00743).
      </description>
      <comment>
        If an RX PDU has metadata then it must fit in a range which can be defined through the
        CanIfRxPduCanIdRange container or by applying a mask (CanIfRxPduCanIdMask).
      </comment>
      <verifycrit>
        EC valid:   No Error in tresos Studio if a RX PDU has metadata and CanIfRxPduCanIdRange or
                    CanIfRxPduCanIdMask configured.
        EC invalid: Error in tresos Studio if a RX PDU has metadata and CanIfRxPduCanIdRange or
                    CanIfRxPduCanIdMask not configured.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_1288</srcid><srcstatus/><internalId>1259</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_RX</srcid><srcstatus/><internalId>1508</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_CANID_RANGE</srcid><srcstatus/><internalId>1510</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00847</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>751</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>963</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Metadata.Config.5</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If a RX PDU has metadata (see CanIf.EB.Metadata.Config.1) and CanIfRxPduCanIdMask parameter
        configured (see CanIf.ECUC_CanIf_00822) then CanIf shall apply CanIfRxPduCanIdMask to
        CanIfRxPduCanId before using the configured CanId.
      </description>
      <comment>
        CanIf shall support the ability to filter incoming messages using the CanIfRxPduCanIdMask.
        The filtering shall be done by comparing the incoming CanId with the stored CanIfRxPduCanId
        after applying the CanIfRxPduCanIdMask to both IDs.
      </comment>
      <verifycrit>
        EC valid:   EcuC_SetMetaDataCanId() is called with correct parameters if the CanId of the
                    received PDU is correct.
        EC invalid: EcuC_SetMetaDataCanId() is not called if the CanId of the received PDU is incorrect.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_1385</srcid><srcstatus/><internalId>1305</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_1401</srcid><srcstatus/><internalId>1306</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_RX</srcid><srcstatus/><internalId>1508</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_CANID_MASKED</srcid><srcstatus/><internalId>1509</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_MIXED</srcid><srcstatus/><internalId>1512</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>964</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Metadata.Functional.1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIf_Transmit() is called for a PDU with metadata, CanIf shall call
        EcuC_GetMetaDataCanId() to retrieve the metadata information for that PDU.
      </description>
      <comment>
        Metadata is needed to compose the CANID for a PDU with metadata.
        See also CanIf.SWS_CanIf_00855 and CanIf.SWS_CanIf_00854.
      </comment>
      <verifycrit>
        EC valid:   EcuC_GetMetaDataCanId() is called with correct parameters.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1770</srcid><srcstatus/><internalId>1126</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_TX</srcid><srcstatus/><internalId>1507</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>965</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Metadata.Functional.2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Upon reception of a PDU with metadata (see CanIf.EB.Metadata.Config.1) and
        CanIfRxPduCanIdMask configured, CanIf shall apply the CanIfRxPduCanIdMask to the incoming
        CanId and CanIfRxPduCanId before comparing the two IDs.
      </description>
      <comment>
        CanIf shall support the ability to filter incoming messages using the CanIfRxPduCanIdMask.
        The filtering shall be done by comparing the incoming CanId with the stored CanIfRxPduCanId
        after applying the CanIfRxPduCanIdMask to both IDs.
      </comment>
      <verifycrit>
        EC valid:   EcuC_SetMetaDataCanId() is called with correct parameters if the CanId of the
                    received PDU is correct.
        EC invalid: EcuC_SetMetaDataCanId() is not called if the CanId of the received PDU is incorrect.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_5450</srcid><srcstatus/><internalId>1170</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_RX</srcid><srcstatus/><internalId>1508</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_CANID_MASKED</srcid><srcstatus/><internalId>1509</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_MIXED</srcid><srcstatus/><internalId>1512</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>966</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Metadata.Functional.3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Upon reception of a PDU with metadata (see CanIf.EB.Metadata.Config.1), CanIf shall place
        the CanId in the MetaDataItem of type CAN_ID_32 by calling EcuC_SetMetaDataCanId().
      </description>
      <comment>
        Metadata is forwarded to other channels through EcuC.
      </comment>
      <verifycrit>
        EC valid:   EcuC_SetMetaDataCanId() is called with correct parameters if the CanId of the
                    received PDU is correct.
        EC invalid: EcuC_SetMetaDataCanId() is not called if the CanId of the received PDU is incorrect.
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3909</srcid><srcstatus/><internalId>1152</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_METADATA_RX</srcid><srcstatus/><internalId>1508</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_CANID_MASKED</srcid><srcstatus/><internalId>1509</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_METADATA_RX_MIXED</srcid><srcstatus/><internalId>1512</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00848</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>752</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>967</internalId></specobject>

    <specobject>
      <id>CanIf.EB.RemoveTemplateStructure</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Remove template folder from generated folder and move all the generated files to specific folders
        by their types so that the generated files are not immediately deleted afterwards. Change linking
        files accordingly.
      </description>
      <comment>
        There will be a new structure created for the generated files, according to their types.
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/plugin.xml.m4_166</srcid><srcstatus/><internalId>1308</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>968</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfSoftwareFilteringSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfSoftwareFilteringSupport
        Parent container CanIfPublicCfg
        Description Enables/disable support for Software filtering.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value TRUE
        Post-Build Variant Value FALSE
        Value Configuration Class:
          Pre-compile   X   All Variants
          Link time     --  --
          Post Build    --  --
        Scope/Dependency: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_993</srcid><srcstatus/><internalId>1226</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>969</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfPublicTxConfResultSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfPublicTxConfResultSupport
        Parent container CanIfUpperLayerConfig
        Description Enables/disable supporting result within Tx Confirmation callback.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value FALSE
        Post-Build Variant Value FALSE
        Value Configuration Class:
          Pre-compile   X   All Variants
          Link time     --  --
          Post Build    --  --
        Scope/Dependency: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2184</srcid><srcstatus/><internalId>1244</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>970</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfCanDriverCompatibility</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        There shall be a pre-compile-time parameter (CanIfCanDriverCompatibility)
        that specifies with which AUTOSAR Revision of the CAN driver, CanIf shall be compatible with.
        The enumeration parameter shall have the following range:
        ASR402: CanIf behaves as specified in AUTOSAR 4.0 Rev.2 in regards to the Can module.
        ASR403: CanIf behaves as specified in AUTOSAR 4.0 Rev.3 in regards to the Can module.
        ASR422: CanIf behaves as specified in AUTOSAR 4.2 Rev.2 in regards to the Can module.
        ASR431: CanIf behaves as specified in AUTOSAR 4.3 Rev.1 in regards to the Can module.
        ASR440: CanIf behaves as specified in AUTOSAR 4.4 Rev.0 in regards to the Can module.
        ASR21_11: CanIf behaves as specified in AUTOSAR R21-11 in regards to the Can module.
      </description>
      <comment>
        ASR402: The interface to Can driver is according to ASR 4.0 Rev.2 specification (Wakeup and CanIf_CancelTxConfirmation)
        ASR403: This is the default AUTOSAR revision of the module and of this parameter.
        ASR422: The interface to Can driver is according to ASR 4.2 Rev.2 specification (RxIndication)
        ASR431 and ASR440: The interface to Can driver is according to ASR 4.3 Rev.1 and respectively, ASR 4.4 Rev.0 specification (ControllerModeIndication)
        ASR21_11: The interface to Can driver is according to AUTOSAR R21-11 specification (CAN TimeStamp)
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1033</srcid><srcstatus/><internalId>1229</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ComTest_NoWuCheck</srcid><srcstatus/><internalId>1334</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CAN_44_TX_RX</srcid><srcstatus/><internalId>1395</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_44_CHECKWAKEUP</srcid><srcstatus/><internalId>1396</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_44_DRIVER_NOK</srcid><srcstatus/><internalId>1397</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ComTest_NoCheckWu</srcid><srcstatus/><internalId>1703</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>971</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfCtrlDrvNameRef.InvalidReference</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfCtrlDrvNameRef shall throw an error if it does not reference a valid CAN driver configuration and CanIfPublicMultipleDrvSupport is true.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01006_Err_MultipleDriverSupport</srcid><srcstatus/><internalId>1634</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>972</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfCtrlDrvNameRef.MultiReference</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfCtrlDrvNameRef shall throw an error if a driver is referenced more than once and CanIfPublicMultipleDrvSupport is true.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01008_Err_MultipleDriverSupport_DrvRef</srcid><srcstatus/><internalId>1636</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>973</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfCtrlDrvNameRef.InvalidVendorIdInfix</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfCtrlDrvNameRef shall throw an error if the VendorId and VendorApiInfix in the CAN driver are not populated and CanIfPublicMultipleDrvSupport is true.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01008_Err_MultipleDriverSupport_DrvRef</srcid><srcstatus/><internalId>1636</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>974</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfCtrlDrvInitHohConfigRef.InvalidRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfCtrlDrvInitHohConfigRef shall throw an error if it does not reference a valid HOH configuration.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01006_Err_MultipleDriverSupport</srcid><srcstatus/><internalId>1634</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01007_Err_MultipleDriverSupport_Hoh</srcid><srcstatus/><internalId>1635</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>975</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfCtrlDrvInitHohConfigRef.MultiRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfCtrlDrvInitHohConfigRef shall throw an error if a HOH configuration is referrenced more than once..
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01008_Err_MultipleDriverSupport_DrvRef</srcid><srcstatus/><internalId>1636</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>976</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfPublicHohTranslationOpt.MultiDriver</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        HOH CanObjedctId optimization can only be done with one CAN driver.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01007_Err_MultipleDriverSupport_Hoh</srcid><srcstatus/><internalId>1635</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>977</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfInitHohCfg.MultiDriver</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfInitHohCfg shall throw an error if the number of driver configurations in CanIfCtrlDrvCfg doesn't match the number of HOH configurations in CanIfInitHohCfg.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01007_Err_MultipleDriverSupport_Hoh</srcid><srcstatus/><internalId>1635</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>978</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfUseCddHandleIds</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfUseCddHandleIds
        Parent Container CanIfUpperLayerConfig
        Description Enables/disables the usage of handle ids from the Cdd configuration.
                    If disabled, CanIfTxPduSourcePduID/CanIfRxPduTargetPduID will be used.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value FALSE
        Post-Build Variant Value TRUE
        Value Configuration Class:
          Pre-compile   --  --
          Link time     --  --
          Post Build    X   All Variants
        Scope/Dependency: local
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2461</srcid><srcstatus/><internalId>1247</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>979</internalId></specobject>

    <specobject>
      <id>CanIf.EB.UseCddComIfHandleId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Configuration parameter CanIfUseCddHandleIds decides, for Pdus that have a Cdd as an upper layer,
        where the handle ids are taken from. If enabled, the handle ids will be taken from
        CDD/CddComStackContribution/CddComIfUpperLayerContribution/CddComIfUpperLayerRx(or Tx)Pdu/CddComIfHandleId,
        otherwise, handle ids will be manually specified inside CanIfTxPduSourcePduID/CanIfRxPduTargetPduID.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.UseCddComIfHandleId.HandleIds</srcid><srcstatus/><internalId>981</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.UseCddComIfHandleId.TargetPduId</srcid><srcstatus/><internalId>982</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>980</internalId></specobject>

    <specobject>
      <id>CanIf.EB.UseCddComIfHandleId.HandleIds</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfUseCddHandleIds is enabled, for each Pdu that has a Cdd as an upper layer,
        CanIf will use the handle id specified in the configuration parameter CddComIfHandleId
        from the Cdd entry that references that Pdu.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_725</srcid><srcstatus/><internalId>1299</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_950</srcid><srcstatus/><internalId>1302</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212</srcid><srcstatus/><internalId>1387</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31214</srcid><srcstatus/><internalId>1388</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>980</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>981</internalId></specobject>

    <specobject>
      <id>CanIf.EB.UseCddComIfHandleId.TargetPduId</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfUseCddHandleIds is disabled, for each Pdu that has a Cdd as an upper layer,
        CanIf will use the handle id specified in the configuration parameter CanIfTxPduSourcePduID for Tx Pdu
        or CanIfRxPduTargetPduID for Rx Pdus.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_732</srcid><srcstatus/><internalId>1300</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_957</srcid><srcstatus/><internalId>1303</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_31212_Dlc</srcid><srcstatus/><internalId>1391</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_31214_Dlc</srcid><srcstatus/><internalId>1392</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>980</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>982</internalId></specobject>

    <specobject>
      <id>CanIf.EB.ParameterDependenciesExtendedCheck</id>
      <status>approved</status>
      <source>EB</source>
      <version>2</version>
      <description>
        If CanIfPublicPnSupport is set to TRUE, parameters
        CanIfDispatchUserCheckTrcvWakeFlagIndicationUL/CanIfDispatchUserCheckTrcvWakeFlagIndicationName,
        CanIfDispatchUserClearTrcvWufFlagIndicationUL/CanIfDispatchUserClearTrcvWufFlagIndicationName,
        CanIfDispatchUserConfirmPnAvailabilityUL/CanIfDispatchUserConfirmPnAvailabilityName needs to be configured.
        If CanIfDispatchUserCheckTrcvWakeFlagIndicationUL or CanIfDispatchUserClearTrcvWufFlagIndicationUL
        or CanIfDispatchUserConfirmPnAvailabilityUL is set to CAN_SM, parameter
        CanSMPncSupport needs to be set to TRUE and atleast one CanSMTransceiverId needs to be configured.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02004_Err_Invalid_CanSMNoTrcv</srcid><srcstatus/><internalId>1658</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02005_Err_Invalid_PnNoULConf</srcid><srcstatus/><internalId>1659</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>983</internalId></specobject>

    <specobject>
      <id>CanIf.EB.MultipleTrcv</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For each CanTrcv driver a unique set of function pointers are generated by using the
        VendorId and ApiInfix from the tranceiver driver.
      </description>
      <comment>
        The naming convention is as follows: &lt;CAN Trcv Driver module name&gt;&lt;vendorID&gt;&lt;
        Vendor specific API name&gt;&lt;driver abbreviation&gt;_function name
      </comment>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/src/CanIf_Cfg.c_225</srcid><srcstatus/><internalId>1120</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TrcvModeIndValidTrcvId</srcid><srcstatus/><internalId>1352</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndInvalidTrcvId</srcid><srcstatus/><internalId>1353</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30420_MultiIds</srcid><srcstatus/><internalId>1354</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30428_MultiIds</srcid><srcstatus/><internalId>1355</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30430_MultiIds</srcid><srcstatus/><internalId>1356</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30432_MultiIds</srcid><srcstatus/><internalId>1357</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvWakeFlagIndValidTrcvId</srcid><srcstatus/><internalId>1359</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CheckTrcvWakeFlagValid</srcid><srcstatus/><internalId>1363</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ClearTrcvWufFlagValid</srcid><srcstatus/><internalId>1364</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_ReadReceivedData</srcid><srcstatus/><internalId>1367</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_SetControllerMode</srcid><srcstatus/><internalId>1368</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeIndValid_UL_CDD</srcid><srcstatus/><internalId>1369</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TrcvModeInd</srcid><srcstatus/><internalId>1378</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30420</srcid><srcstatus/><internalId>1379</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30428</srcid><srcstatus/><internalId>1380</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30430</srcid><srcstatus/><internalId>1381</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30432</srcid><srcstatus/><internalId>1382</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>984</internalId></specobject>

    <specobject>
      <id>CanIf.EB.WakeupInconsistencyError</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfCtrlWakeupSupport is enabled for a CanIf controller configuration, but CanWakeupFunctionalityAPI
        is disabled for the Can controller referenced by that CanIf controller configuration (CanIfCtrlCanCtrlRef),
        CanIf shall throw an error that specifies that CanWakeupFunctionalityAPI needs to also be enabled.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01009_Err_Invalid_WUConfig</srcid><srcstatus/><internalId>1637</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>985</internalId></specobject>

    <specobject>
      <id>CanIf.EB.TxBufferMemorySize</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The required Tx-Buffer memory shall not exceed the configured Tx-Buffer memory
        (CanIfPublicMaxTxBufferSize).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_487</srcid><srcstatus/><internalId>1209</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01010_Err_Invalid_BufferMemorySize</srcid><srcstatus/><internalId>1638</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>986</internalId></specobject>

    <specobject>
      <id>CanIf.EB.MaxTxNotifyPdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The number of enabled TxPdu read status notification shall not exceed the configured
        CanIfPublicMaxTxNotifyPdus.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01011_Err_Invalid_MaxTxNotifyPdus</srcid><srcstatus/><internalId>1639</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>987</internalId></specobject>

    <specobject>
      <id>CanIf.EB.MaxDynTxPdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The number of dynamic Tx-Pdus shall not exceed the configured CanIfPublicMaxDynTxPdus.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01012_Err_Invalid_MaxDynTxPdus</srcid><srcstatus/><internalId>1640</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>988</internalId></specobject>

    <specobject>
      <id>CanIf.EB.MaxCtrl</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The number of configured Can controllers (CanIfCtrlCfgs) shall not exceed the
        configured CanIfPublicMaxCtrl.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01013_Err_Invalid_MaxCtrl</srcid><srcstatus/><internalId>1641</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>989</internalId></specobject>

    <specobject>
      <id>CanIf.EB.MaxHths</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The number of configured Hths (CanIfHthCfgs) shall not exceed the configured CanIfPublicMaxHths.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01014_Err_Invalid_MaxHths</srcid><srcstatus/><internalId>1642</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>990</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfSoftwareFilteringSupport.hrhSoftwareFilterEnabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Parameter CanIfHrhSoftwareFilter cannot be True for any HRH if the value of CanIfSoftwareFilteringSupport is False.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1025</srcid><srcstatus/><internalId>1227</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01016_Err_Invalid_SWFilteringDisabling</srcid><srcstatus/><internalId>1644</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>991</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfSoftwareFilteringSupport.RxPduCanIdMaskConfigured</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Parameter CanIfRxPduCanIdMask cannot be configured for any Rx Pdu if the value of CanIfSoftwareFilteringSupport is False.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1028</srcid><srcstatus/><internalId>1228</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01016_Err_Invalid_SWFilteringDisabling</srcid><srcstatus/><internalId>1644</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>992</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfPublicTxConfResultSupport.Enable</id>
      <status>approved</status>
      <source>EB</source>
      <version>3</version>
      <description>
        Parameter CanIfPublicTxConfResultSupport is enabled if CanIfTxPduUserTxConfirmationName is configured.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2204</srcid><srcstatus/><internalId>1245</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>993</internalId></specobject>

    <specobject>
      <id>CanIf.EB.MaxRxNotifyPdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The number of enabled RxPdu read status notification shall not exceed the configured CanIfPublicMaxRxNotifyPdus.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01015_Err_Invalid_MaxRxNotifyPdus</srcid><srcstatus/><internalId>1643</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>994</internalId></specobject>

    <specobject>
      <id>CanIf.EB.HookOnReception</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfHookOnReceptionSupport enables a custom function call configured by CanIfHookOnReceptionFunctionName,
        which provides the Can ID, the PDU information and Controller ID of a successful reception.
      </description>
      <needscoverage>
        <needscov><needsobj>swurs</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.EB.HookOnReception.Header</srcid><srcstatus/><internalId>996</internalId></linkedfrom><linkedfrom><srcid>CanIf.EB.HookOnReception.FunctionName</srcid><srcstatus/><internalId>997</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>995</internalId></specobject>

    <specobject>
      <id>CanIf.EB.HookOnReception.Header</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfHookOnReceptionSupport is enabled, CanIfHookOnReceptionHeader shall contain the header
        that provides the required function from Cdd to be called in case of a successful reception.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanIf_Int_Cfg.h_39</srcid><srcstatus/><internalId>1117</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_HookOnReception</srcid><srcstatus/><internalId>1415</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.HookOnReception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>995</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>996</internalId></specobject>

    <specobject>
      <id>CanIf.EB.HookOnReception.FunctionName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfHookOnReceptionSupport is enabled, CanIfHookOnReceptionFunctionName shall contain the
        function name that will be called in case of a successful reception.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6320</srcid><srcstatus/><internalId>1176</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_HookOnReception</srcid><srcstatus/><internalId>1415</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.HookOnReception</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>995</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>997</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfTxPduTruncateToFrame</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name: CanIfTxPduTruncateToFrame
        Parent Container: CanIfTxPduCfg
        Description: Provides an option to truncate the TxPdu length before transmission either
                     at the CAN frame length (8B for CAN 2.0, 64B for CAN FD) or
                     at the configured PDU length in EcuC.                     
                     True:  Truncate the TxPdu to the CAN frame length (8B for CAN 2.0, 64B for CAN FD)
                     False: Truncate the TxPdu to the configured PDU length in EcuC
        Multiplicity: 1
        Type: EcucBooleanParamDef
        Default Value: true
        Post-Build Variant Value: true
        Value Configuration Class:
        Pre-compile time X VARIANT-PRE-COMPILE
        Link time        X VARIANT-LINK-TIME
        Post-build time  X VARIANT-POST-BUILD
        Scope / Dependency scope: local
      </description>
      <comment>
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_507</srcid><srcstatus/><internalId>1210</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>998</internalId></specobject>
    <specobject>
      <id>CanIf.EB.CanIfTxPduTruncateToFrame.Availability</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfTxPduTruncateToFrame is disabled when CanIfTxPduTruncation is OFF for a respective CanIfTxPdu.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</srcid><srcstatus/><internalId>1413</internalId></linkedfrom><linkedfrom><srcid>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</srcid><srcstatus/><internalId>1414</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_534</srcid><srcstatus/><internalId>1211</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>999</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfValidateWakeupOnStartedCtrlOnly</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfValidateWakeupOnStartedCtrlOnly
        Parent Container CanIfPublicCfg
        Description Enables/disables the wakeup validation mechanism only when
                    the controller is in CAN_CS_STARTED mode (handling according
                    to ASR 4.3.1). When parameter is disabled, the wakeup validation
                    will be performed only when the controller is in CANIF_CS_SLEEP or
                    when the wakeup flag was previously set.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value FALSE
        Post-Build Variant Value FALSE
        Value Configuration Class:
          Pre-compile   X   All Variants
          Link time     --  --
          Post Build    --  --
        Scope/Dependency: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1607</srcid><srcstatus/><internalId>1231</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1000</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfValidateWakeupOnStartedCtrlOnlyDisabled</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
    CanIfValidateWakeupOnStartedCtrlOnly is disabled when CanIfPublicWakeupCheckValidSupport is OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1628</srcid><srcstatus/><internalId>1232</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1001</internalId></specobject>

    <specobject>
      <id>CanIf.EB.SWS_CANIF_00286_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
    If CanIfValidateWakeupOnStartedCtrlOnly and CanIfPublicWakeupCheckValidByNM are enabled, CanIf
    shall enable the CAN wake-up validation detection by storing only the first call of CanIf_RxIndication()
    of the NM messages when the corresponding CAN Controller is in CAN_CS_STARTED state.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6216</srcid><srcstatus/><internalId>1173</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CheckWakeUpOnStartedCtrl</srcid><srcstatus/><internalId>1627</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00286</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1002</internalId></specobject>

    <specobject>
      <id>CanIf.EB.SWS_CANIF_00286_2</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
    If CanIfValidateWakeupOnStartedCtrlOnly is enabled and CanIfPublicWakeupCheckValidByNM is disabled,
    CanIf shall enable the CAN wake-up validation detection by storing the first call of CanIf_RxIndication()
    for all Rx PDUs when the corresponding CAN Controller is in CAN_CS_STARTED state.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6211</srcid><srcstatus/><internalId>1172</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CtrlOnlyOffValidSupport</srcid><srcstatus/><internalId>1626</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CheckWakeUpOnStartedCtrl</srcid><srcstatus/><internalId>1627</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00286</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1003</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DecoupledMeasurement.RxDecoupledMeasurementSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfRxDecoupledMeasurementSupport
        Parent Container CanIfDecoupledMeasurementSupport
        Description Enable measurement support for decoupled processing of reception events.
        Multiplicity 0..1
        Type EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value false
        Value Configuration Class
          Pre-compile time  X  All Variants
          Link time         -
          Post-build time   -
        Scope/ Dependency
          scope: local
          dependency: CanIfRxDecoupledMeasurementSupport requires CanIfDecoupledProcessingSupport
                      to be set to TRUE and CanIfPublicCddHeaderFile to be filled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1889</srcid><srcstatus/><internalId>1238</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1004</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DecoupledMeasurement.TxDecoupledMeasurementSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfTxDecoupledMeasurementSupport
        Parent Container CanIfDecoupledMeasurementSupport
        Description Enable the measurement support for decoupled processing of transmission
                    confirmation events.
        Multiplicity 0..1
        Type EcucBooleanParamDef
        Default Value false
        Post-Build Variant Value false
        Value Configuration Class
          Pre-compile time  X  All Variants
          Link time         -
          Post-build time   -
        Scope/ Dependency
          scope: local
          dependency: CanIfTxDecoupledMeasurementSupport requires CanIfDecoupledProcessingSupport
                      to be set to TRUE and CanIfPublicCddHeaderFile to be filled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1919</srcid><srcstatus/><internalId>1239</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1005</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfNumberOfEnqueuedRxPdusApiName
        Parent Container CanIfDecoupledMeasurementSupport
        Description This parameter defines the name of the CDD API that will be called
                    during decoupled processing via CanIf_MainFunctionRx() containing
                    the number of RxPdus added in the queue at CanIf_RxIndication().
                    API signature:
                    void CanIfNumberOfEnqueuedRxPdusApiName(
                      uint8 MainFuncId,
                      uint16 NoOfPdus);
        Multiplicity 0..1
        Type EcucFunctionNameDef
        Default Value
        Length 1-32
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Multiplicity Configuration Class
          Pre-compile time X  All Variants
          Link time        -
          Post-Build time  -
        Value Configuration Class
          Pre-compile time X  All Variants
          Link time        -
          Post-Build time  -
        Scope / Dependency
          scope: ECU
          dependency: CanIfNumberOfEnqueuedRxPdusApiName requires CanIfRxDecoupledMeasurementSupport
                      to be set to TRUE.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3995</srcid><srcstatus/><internalId>1157</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1985</srcid><srcstatus/><internalId>1241</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01017_Err_Invalid_DecoupledMeasurement</srcid><srcstatus/><internalId>1645</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxProcessing</srcid><srcstatus/><internalId>1691</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1006</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfNumberOfEnqueuedTxPdusApiName
        Parent Container CanIfDecoupledMeasurementSupport
        Description This parameter defines the name of the CDD API that will be called
                    during decoupled processing via CanIf_MainFunctionTx() containing
                    the number of TxPdus added in the queue at CanIf_TxConfirmation().
                    API signature:
                    void CanIfNumberOfEnqueuedTxPdusApiName(
                      uint8 MainFuncId,
                      uint16 NoOfPdus);
        Multiplicity 0..1
        Type EcucFunctionNameDef
        Default Value
        Length 1-32
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Multiplicity Configuration Class
          Pre-compile time X  All Variants
          Link time        -
          Post-Build time  -
        Value Configuration Class
          Pre-compile time X  All Variants
          Link time        -
          Post-Build time  -
        Scope / Dependency
          scope: ECU
          dependency: CanIfNumberOfEnqueuedTxPdusApiName requires CanIfTxDecoupledMeasurementSupport
                      to be set to TRUE.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_4064</srcid><srcstatus/><internalId>1160</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2056</srcid><srcstatus/><internalId>1243</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01017_Err_Invalid_DecoupledMeasurement</srcid><srcstatus/><internalId>1645</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1007</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DecoupledMeasurement.NumberOfRxPdusExceedingQueueApiName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfNumberOfRxPdusExceedingQueueApiName
        Parent Container CanIfDecoupledMeasurementSupport
        Description This parameter defines the name of the CDD API that will be called
                    during decoupled processing via CanIf_RxIndication() containing
                    the number of RxPdus that could not be added to the queue.
                    API signature:
                    void CanIfNumberOfRxPdusExceedingQueueApiName(
                      uint8 MainFuncId,
                      uint16 NoOfPdus);
        Multiplicity 0..1
        Type EcucFunctionNameDef
        Default Value
        Length 1-32
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Multiplicity Configuration Class
          Pre-compile time X  All Variants
          Link time        -
          Post-Build time  -
        Value Configuration Class
          Pre-compile time X  All Variants
          Link time        -
          Post-Build time  -
        Scope / Dependency
          scope: ECU
          dependency: CanIfNumberOfRxPdusExceedingQueueApiName requires CanIfRxDecoupledMeasurementSupport
                      to be set to TRUE.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3937</srcid><srcstatus/><internalId>1154</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1949</srcid><srcstatus/><internalId>1240</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01017_Err_Invalid_DecoupledMeasurement</srcid><srcstatus/><internalId>1645</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessingInterrupted</srcid><srcstatus/><internalId>1689</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1008</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DecoupledMeasurement.NumberOfTxPdusExceedingQueueApiName</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfNumberOfTxPdusExceedingQueueApiName
        Parent Container CanIfDecoupledMeasurementSupport
        Description This parameter defines the name of the CDD API that will be called
                    during decoupled processing via CanIf_TxConfirmation() containing
                    the number of TxPdus that could not be added to the queue.
                    API signature:
                    void CanIfNumberOfTxPdusExceedingQueueApiName(
                      uint8 MainFuncId,
                      uint16 NoOfPdus);
        Multiplicity 0..1
        Type EcucFunctionNameDef
        Default Value
        Length 1-32
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Multiplicity Configuration Class
          Pre-compile time X  All Variants
          Link time        -
          Post-Build time  -
        Value Configuration Class
          Pre-compile time X  All Variants
          Link time        -
          Post-Build time  -
        Scope / Dependency
          scope: ECU
          dependency: CanIfNumberOfTxPdusExceedingQueueApiName requires CanIfTxDecoupledMeasurementSupport
                      to be set to TRUE.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3723</srcid><srcstatus/><internalId>1146</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_2020</srcid><srcstatus/><internalId>1242</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01017_Err_Invalid_DecoupledMeasurement</srcid><srcstatus/><internalId>1645</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_TxProcessing</srcid><srcstatus/><internalId>1688</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1009</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.MultiCoreSupport</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfMultiCoreSupport
        Parent Container CanIfPublicCfg
        Description Enables/disable support for Multicore.
        Multiplicity 1
        Type EcucBooleanParamDef
        Default value FALSE
        Post-Build Variant Value FALSE
        Value Configuration Class:
          Pre-compile   X   All Variants
          Link time     --  --
          Post Build    --  --
        Scope/Dependency: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_692</srcid><srcstatus/><internalId>1214</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02001_Err_TxPdu_InvalidCanIfDefaultPartition</srcid><srcstatus/><internalId>1660</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02002_Err_TxPdu_InvalidCanIfPartition</srcid><srcstatus/><internalId>1661</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02003_Err_TxPdu_NoCanIfPartition</srcid><srcstatus/><internalId>1662</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02004_Err_TxPdu_InvalidJ1939NmDedicatedPartition</srcid><srcstatus/><internalId>1663</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02005_Err_TxPdu_InvalidJ1939NmDefaultPartition</srcid><srcstatus/><internalId>1664</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02006_Err_TxPdu_InvalidJ1939TpTxCmDedicatedPartition</srcid><srcstatus/><internalId>1665</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02007_Err_TxPdu_InvalidJ1939TpTxCmPartition</srcid><srcstatus/><internalId>1666</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02008_Err_TxPdu_InvalidJ1939TpTxDtDefaultPartition</srcid><srcstatus/><internalId>1667</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02009_Err_TxPdu_InvalidJ1939TpTxDirectDefaultPartition</srcid><srcstatus/><internalId>1668</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02010_Err_TxPdu_InvalidJ1939TpTxFcDefaultPartition</srcid><srcstatus/><internalId>1669</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02011_Err_TxPdu_InvalidJ1939NmPartition</srcid><srcstatus/><internalId>1670</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02012_Err_RxPdu_NoCanIfPartition</srcid><srcstatus/><internalId>1671</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02013_Err_RxPdu_InvalidCanIfCtrlPartition</srcid><srcstatus/><internalId>1672</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02014_Err_RxPdu_InvalidJ1939NmRxDedicatedPartition</srcid><srcstatus/><internalId>1673</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02015_Err_RxPdu_NoJ1939TpRxDirectPartition</srcid><srcstatus/><internalId>1674</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02016_Err_RxPdu_InvalidJ1939TpRxFcDedicatedPartition</srcid><srcstatus/><internalId>1675</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02017_Err_RxPdu_InvalidJ1939TpRxDtPartition</srcid><srcstatus/><internalId>1676</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02018_Err_RxPdu_InvalidJ1939NmRxDefaultPartition</srcid><srcstatus/><internalId>1677</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02019_Err_TxPdu_InvalidCtrlMaxTxNotifyPdus</srcid><srcstatus/><internalId>1678</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02020_Err_RxPdu_InvalidCtrlMaxRxNotifyPdus</srcid><srcstatus/><internalId>1679</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02021_Err_CanIfTxProcessing_InvalidPartition</srcid><srcstatus/><internalId>1680</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02022_Err_CanIfRxProcessing_InvalidPartition</srcid><srcstatus/><internalId>1681</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations><ruleid>WRN.swuts.needscoverage.count</ruleid></oreqmViolations><covstatus>covered</covstatus><internalId>1010</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.CtrlMaxRxNotifyPdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfCtrlMaxRxNotifyPdus
        Parent Container CanIfCtrlCfg
        Description This parameter defines the maximum allowed number of enabled RxPdus read
                    status notification when Muticore support is enabled. 
                    The number of configured RxPdus read status notification must not exceed
                    this value.
                    This parameter is needed only in case of post-build loadable implementation
                    using static memory allocation.
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 1..65535
        Default value
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Value Configuration Class:
          Pre-compile   X   All Variants
          Link time     --  --
          Post Build    --  --
        Scope/Dependency: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_43</srcid><srcstatus/><internalId>1207</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckRxNotifyFlagsMulticore</srcid><srcstatus/><internalId>1375</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CheckRxNotifyFlagsMulticoreReportInvalidNotifIdx</srcid><srcstatus/><internalId>1377</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02020_Err_RxPdu_InvalidCtrlMaxRxNotifyPdus</srcid><srcstatus/><internalId>1679</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1011</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.CtrlMaxTxNotifyPdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfCtrlMaxTxNotifyPdus
        Parent Container CanIfCtrlCfg
        Description This parameter defines the maximum allowed number of enabled TxPdus read
                    status notification when Muticore support is enabled. 
                    The number of configured TxPdus read status notification must not exceed
                    this value.
                    This parameter is needed only in case of post-build loadable implementation
                    using static memory allocation.
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 1..65535
        Default value
        Post-Build Variant Multiplicity false
        Post-Build Variant Value false
        Value Configuration Class:
          Pre-compile   X   All Variants
          Link time     --  --
          Post Build    --  --
        Scope/Dependency: local
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_69</srcid><srcstatus/><internalId>1208</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CheckTxNotifyFlagsMulticore</srcid><srcstatus/><internalId>1376</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02019_Err_TxPdu_InvalidCtrlMaxTxNotifyPdus</srcid><srcstatus/><internalId>1678</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1012</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.J1939DefaultPartitionRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If configured, all J1939 PDUs must refer the same partition (via EcucPduDefaultPartitionRef).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_127</srcid><srcstatus/><internalId>1286</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_157</srcid><srcstatus/><internalId>1288</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_208</srcid><srcstatus/><internalId>1292</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_237</srcid><srcstatus/><internalId>1294</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02005_Err_TxPdu_InvalidJ1939NmDefaultPartition</srcid><srcstatus/><internalId>1664</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02007_Err_TxPdu_InvalidJ1939TpTxCmPartition</srcid><srcstatus/><internalId>1666</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02008_Err_TxPdu_InvalidJ1939TpTxDtDefaultPartition</srcid><srcstatus/><internalId>1667</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02009_Err_TxPdu_InvalidJ1939TpTxDirectDefaultPartition</srcid><srcstatus/><internalId>1668</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02010_Err_TxPdu_InvalidJ1939TpTxFcDefaultPartition</srcid><srcstatus/><internalId>1669</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02011_Err_TxPdu_InvalidJ1939NmPartition</srcid><srcstatus/><internalId>1670</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02012_Err_RxPdu_NoCanIfPartition</srcid><srcstatus/><internalId>1671</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02015_Err_RxPdu_NoJ1939TpRxDirectPartition</srcid><srcstatus/><internalId>1674</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02017_Err_RxPdu_InvalidJ1939TpRxDtPartition</srcid><srcstatus/><internalId>1676</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02018_Err_RxPdu_InvalidJ1939NmRxDefaultPartition</srcid><srcstatus/><internalId>1677</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1013</internalId></specobject>

   <specobject>
      <id>CanIf.EB.Multicore.J1939DedicatedPartitionRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If configured, all J1939 PDUs must refer the same partition (via EcucPduDedicatedPartitionRef).
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_119</srcid><srcstatus/><internalId>1285</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_148</srcid><srcstatus/><internalId>1287</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_200</srcid><srcstatus/><internalId>1291</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_228</srcid><srcstatus/><internalId>1293</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02004_Err_TxPdu_InvalidJ1939NmDedicatedPartition</srcid><srcstatus/><internalId>1663</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02006_Err_TxPdu_InvalidJ1939TpTxCmDedicatedPartition</srcid><srcstatus/><internalId>1665</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02007_Err_TxPdu_InvalidJ1939TpTxCmPartition</srcid><srcstatus/><internalId>1666</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02011_Err_TxPdu_InvalidJ1939NmPartition</srcid><srcstatus/><internalId>1670</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02012_Err_RxPdu_NoCanIfPartition</srcid><srcstatus/><internalId>1671</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02014_Err_RxPdu_InvalidJ1939NmRxDedicatedPartition</srcid><srcstatus/><internalId>1673</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02015_Err_RxPdu_NoJ1939TpRxDirectPartition</srcid><srcstatus/><internalId>1674</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02016_Err_RxPdu_InvalidJ1939TpRxFcDedicatedPartition</srcid><srcstatus/><internalId>1675</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02017_Err_RxPdu_InvalidJ1939TpRxDtPartition</srcid><srcstatus/><internalId>1676</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1014</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.CtrlDefaultPartitionRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If configured, the EcucPduDefaultPartitionRef must be the same as the CanControllerEcucPartitionRef
        of the corresponding controller.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_103</srcid><srcstatus/><internalId>1284</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_182</srcid><srcstatus/><internalId>1290</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02001_Err_TxPdu_InvalidCanIfDefaultPartition</srcid><srcstatus/><internalId>1660</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02002_Err_TxPdu_InvalidCanIfPartition</srcid><srcstatus/><internalId>1661</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02003_Err_TxPdu_NoCanIfPartition</srcid><srcstatus/><internalId>1662</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02013_Err_RxPdu_InvalidCanIfCtrlPartition</srcid><srcstatus/><internalId>1672</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1015</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.CtrlDedicatedPartitionRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If configured, the EcucPduDedicatedPartitionRef  must be the same as the CanControllerEcucPartitionRef
        of the corresponding controller.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_98</srcid><srcstatus/><internalId>1283</internalId></linkedfrom><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_181</srcid><srcstatus/><internalId>1289</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02002_Err_TxPdu_InvalidCanIfPartition</srcid><srcstatus/><internalId>1661</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02003_Err_TxPdu_NoCanIfPartition</srcid><srcstatus/><internalId>1662</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_02013_Err_RxPdu_InvalidCanIfCtrlPartition</srcid><srcstatus/><internalId>1672</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1016</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.CanIfRxProcessing.CanIfPartitionRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfPartitionRef
        Parent Container CanIfRxProcessing
        Description Reference to the EcuCPartition.
        Multiplicity 0..1
        Type EcucReferenceDef
        Post-Build Variant Value  true
        Value Configuration Class:
          Pre-compile   X   VARIANT-PRE-COMPILE
          Link time     X   VARIANT-LINK-TIME
          Post Build    X   VARIANT-POST-BUILD
        Scope/Dependency: 
          scope: local
          dependecy: CanIfMultiCoreSupport
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_768</srcid><srcstatus/><internalId>1217</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02022_Err_CanIfRxProcessing_InvalidPartition</srcid><srcstatus/><internalId>1681</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1017</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.CanIfTxProcessing.CanIfPartitionRef</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfPartitionRef
        Parent Container CanIfTxProcessing
        Description Reference to the EcuCPartition.
        Multiplicity 0..1
        Type EcucReferenceDef
        Post-Build Variant Value  true
        Value Configuration Class:
          Pre-compile   X   VARIANT-PRE-COMPILE
          Link time     X   VARIANT-LINK-TIME
          Post Build    X   VARIANT-POST-BUILD
        Scope/Dependency: 
          scope: local
          dependecy: CanIfMultiCoreSupport
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_893</srcid><srcstatus/><internalId>1222</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02021_Err_CanIfTxProcessing_InvalidPartition</srcid><srcstatus/><internalId>1680</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1018</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.CanIfRxProcessing.SamePartitionOnMainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfPartitionRef is configured, all RxPdus belonging to a certain MainFunction
        must refer the same partion via EcucPduDefaultPartitionRef or EcucPduDedicatedPartitionRef.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_256</srcid><srcstatus/><internalId>1295</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02022_Err_CanIfRxProcessing_InvalidPartition</srcid><srcstatus/><internalId>1681</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1019</internalId></specobject>

    <specobject>
      <id>CanIf.EB.Multicore.CanIfTxProcessing.SamePartitionOnMainFunction</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfPartitionRef is configured, all TxPdus belonging to a certain MainFunction
        must refer the same partion via EcucPduDefaultPartitionRef or EcucPduDedicatedPartitionRef.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_macros/CanIf_Checks.m_270</srcid><srcstatus/><internalId>1296</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_02021_Err_CanIfTxProcessing_InvalidPartition</srcid><srcstatus/><internalId>1680</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1020</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfPublicMaxTxPdus</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Name CanIfPublicMaxTxPdus
        Parent Container CanIfPublicCfg
        Description Maximum number of Tx Pdus across all controllers and variants.
        Multiplicity 0..1
        Type EcucIntegerParamDef
        Range 0..65535
        Default Value --
        Post-Build Variant Value  false
        Value Configuration Class
          Pre-compile time X All Variants
          Link time        --
          Post-build time  --
        Scope / Dependency
          scope: ECU
          dependency: CanIfPublicMaxTxPdus requires
                        CanIfPublicTxConfResultSupport to be set to TRUE.
                        CanIfTxPduUserTxConfirmationName to exist for at least one upper layer.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1400</srcid><srcstatus/><internalId>1230</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_UL_TXCONFIRMATION_CTRL_MODE_STOPPED</srcid><srcstatus/><internalId>1598</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01020_Err_Invalid_MaxTxPdusConfig</srcid><srcstatus/><internalId>1648</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1021</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfPublicMaxTxPdus.InvalidValue</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfPublicMaxTxPdus shall throw an error message if the number of configured Tx Pdus
        exceeds CanIfPublicCfg/CanIfPublicMaxTxPdus.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01020_Err_Invalid_MaxTxPdusConfig</srcid><srcstatus/><internalId>1648</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1022</internalId></specobject>

  <specobject>
      <id>CanIf.EB.CanIfSecurityEventRefs.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfEnableSecurityEventReporting is enabled, at least one reference has to be added.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01021_Err_Invalid_SecEvEnaNoEvConf</srcid><srcstatus/><internalId>1649</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1023</internalId></specobject>

  <specobject>
      <id>CanIf.EB.CanIfSecurityEventRefs_CANIF_SEV_ERRORSTATE_BUSOFF.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CANIF_SEV_ERRORSTATE_BUSOFF reference is enabled, it shall point to a valid event 
        and the reference must be unique accross all CanIf security events.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01022_Err_Invalid_SecEvEnaEvNotUnique</srcid><srcstatus/><internalId>1650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1024</internalId></specobject>

  <specobject>
      <id>CanIf.EB.CanIfSecurityEventRefs_CANIF_SEV_ERRORSTATE_PASSIVE.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CANIF_SEV_ERRORSTATE_PASSIVE reference is enabled, it shall point to a valid event 
        and the reference must be unique accross all CanIf security events.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01022_Err_Invalid_SecEvEnaEvNotUnique</srcid><srcstatus/><internalId>1650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1025</internalId></specobject>

  <specobject>
      <id>CanIf.EB.CanIfSecurityEventRefs_CANIF_SEV_TX_ERROR_DETECTED.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CANIF_SEV_TX_ERROR_DETECTED reference is enabled, it shall point to a valid event 
        and the reference must be unique accross all CanIf security events.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01022_Err_Invalid_SecEvEnaEvNotUnique</srcid><srcstatus/><internalId>1650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1026</internalId></specobject>

  <specobject>
      <id>CanIf.EB.CanIfSecurityEventRefs_CANIF_SEV_RX_ERROR_DETECTED.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CANIF_SEV_RX_ERROR_DETECTED reference is enabled, it shall point to a valid event 
        and the reference must be unique accross all CanIf security events.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01022_Err_Invalid_SecEvEnaEvNotUnique</srcid><srcstatus/><internalId>1650</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1027</internalId></specobject>

  <specobject>
      <id>CanIf.EB.CanEnableSecurityEventReporting.Warning</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfEnableSecurityEventReporting is enabled, CanEnableSecurityEventReporting should be also enabled.
      </description>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_Extension.xdm.m4_3250</srcid><srcstatus/><internalId>1275</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01021_Err_Invalid_SecEvEnaNoEvConf</srcid><srcstatus/><internalId>1649</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1028</internalId></specobject>

  <specobject>
      <id>CanIf.EB.MultiCoreSecurityEventReporting.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIfEnableSecurityEventReporting and CanIfMultiCoreSupport should not be enabled at the same time.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01021_Err_Invalid_SecEvEnaNoEvConf</srcid><srcstatus/><internalId>1649</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1029</internalId></specobject>

    <specobject>
         <id>CanIf.EB.SWS_CANIF_91009.CanIf_ErrorNotification</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ErrorNotification(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERROR_NO_INIT</srcid><srcstatus/><internalId>1502</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RX_ERROR_DETECTED</srcid><srcstatus/><internalId>1505</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1030</internalId></specobject>

    <specobject>
         <id>CanIf.EB.SWS_CANIF_91008.CanIf_ControllerErrorStatePassive</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
      If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
      (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_ControllerErrorStatePassive(),
      then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_ERROR_NO_INIT</srcid><srcstatus/><internalId>1502</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.ASR40.SWS_CanIf_00661</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>133</internalId></provcov>
         </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1031</internalId></specobject>

    <specobject>
      <id>CanIf.EB.MultipleDriverSecurityEventReporting.Invalid</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If CanIfEnableSecurityEventReporting and CanIfPublicMultipleDrvSupport are enabled and 
        CanIfCanDriverCompatibility is set to 402 or 403 an error should be displayed.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01021_Err_Invalid_SecEvEnaNoEvConf</srcid><srcstatus/><internalId>1649</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
  <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1032</internalId></specobject>

    <specobject>
      <id>CanIf.EB.CanIfTrcvDrvCfg.CanSMReference</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        CanIf should check if the CanIfTrcvCfg container is referenced in the CanSMManagerNetwork for any CAN network configurations or not, if it's
        not referenced then both CanIfTrcvWakeupSourceInRef and CanIfTrcvWakeupSourceOutRef will be ignored and the relative
        tranceiver strucutre will be generated with value 0 for both.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanSM_CanTrcv_NoRef</srcid><srcstatus/><internalId>1618</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CanSM_CanTrcv_Ref</srcid><srcstatus/><internalId>1619</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_1458</srcid><srcstatus/><internalId>1307</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1033</internalId></specobject>

      <specobject>
         <id>CanIf.EB.Config_CanIfBusATxIndication</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
         Name : CanIfBusATxIndication
         Parent Container : CanIfPublicCfg
         Description : Defines the name of the Tx Bus-Adapter specific callout function.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_TX</srcid><srcstatus/><internalId>1386</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01025_Err_Invalid_BusAFunctionsNames</srcid><srcstatus/><internalId>1653</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1633</srcid><srcstatus/><internalId>1233</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1034</internalId></specobject>

      <specobject>
         <id>CanIf.EB.Config_CanIfBusARxIndication</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
         Name : CanIfBusARxIndication
         Parent Container : CanIfPublicCfg
         Description : Defines the name of the Rx Bus-Adapter user specific callout function.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_RX</srcid><srcstatus/><internalId>1385</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01025_Err_Invalid_BusAFunctionsNames</srcid><srcstatus/><internalId>1653</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1663</srcid><srcstatus/><internalId>1234</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1035</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfBusATxIndication_GenerateAPI</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Based on configuration parameter CanIfPublicCfg/CanIfBusATxIndication,
        an API function should be generated having the configured name. 
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_TX</srcid><srcstatus/><internalId>1386</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanIf_Cfg.h.m4_856</srcid><srcstatus/><internalId>1115</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1036</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfBusATxIndication_API</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
         The generated API (CanIfPublicCfg/CanIfBusATxIndication) should be called when the CanIf_Transmit() is invoked, after argument and state checking.
         The data flow shall be conditioned by the return of this callout.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_TX</srcid><srcstatus/><internalId>1386</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1907</srcid><srcstatus/><internalId>1131</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1037</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfBusATxIndication_API_ReturnFalse</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
         If generated API (CanIfPublicCfg/CanIfBusATxIndication) returns FALSE, the frame shall be discarded by CanIf. In this case the function CanIf_Transmit()
         shall return E_OK to the upper layer.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_TX</srcid><srcstatus/><internalId>1386</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1973</srcid><srcstatus/><internalId>1132</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1038</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfBusARxIndication_GenerateAPI</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        Based on configuration parameter CanIfPublicCfg/CanIfBusARxIndication,
        an API function should be generated having the configured name.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_RX</srcid><srcstatus/><internalId>1385</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanIf_Cfg.h.m4_897</srcid><srcstatus/><internalId>1116</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1039</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfBusARxIndication_API</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        The generated API should be called when the CanIf_RxIndication() is invoked, after SW filtering.
        The data flow shall be conditioned by the return of this callout.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_RX</srcid><srcstatus/><internalId>1385</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6311</srcid><srcstatus/><internalId>1175</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1040</internalId></specobject>

      <specobject>
         <id>CanIf.EB.Config_CanIfBusAHeaderFile</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
           Name : CanIfBusAHeaderFile
           Parent Container : CanIfPublicCfg
           Description : Defines the name of Bus-Adapter header file that will be included in the source code.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_RX</srcid><srcstatus/><internalId>1385</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_DataInterception_TX</srcid><srcstatus/><internalId>1386</internalId></linkedfrom><linkedfrom><srcid>TS_GenTest_01024_Err_Invalid_BusAHeaderFile</srcid><srcstatus/><internalId>1652</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1693</srcid><srcstatus/><internalId>1235</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1041</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfBusAHeaderFile_Inclusion</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
        CanIf shall include the configured CanIfBusAHeaderFile header file if CanIfBusATxIndication or CanIfBusARxIndication is configured.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_DataInterception_RX</srcid><srcstatus/><internalId>1385</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_DataInterception_TX</srcid><srcstatus/><internalId>1386</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate/include/CanIf_Cfg.h.m4_37</srcid><srcstatus/><internalId>1114</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1042</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CANIF403</id>
         <status>approved</status>
         <source>EB</source>
         <version>2</version>
         <description>
      If CanIfValidateWakeupOnStartedCtrlOnly is set to OFF and CanIf_RxIndication() is called
      for a CAN controller, which CCMSM equals CANIF_CS_SLEEP and
      CANIF_PUBLIC_WAKEUP_CHECK_VALIDATION_SUPPORT is enabled, a wake up validation
      event has to be stored within CanIf for that CAN controller.
      </description>
         <needscoverage>
           <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_6205</srcid><srcstatus/><internalId>1171</internalId></linkedfrom></coveredby></needscov>
           <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_WuValidInSleepMode</srcid><srcstatus/><internalId>1614</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
         <providescoverage>
            <provcov>
               <linksto>CanIf.SWS_CanIf_00286</linksto>
               <dstversion>1</dstversion>
            <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
         </providescoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1043</internalId></specobject>

      <specobject>
         <id>CanIf.EB.SWS_CANIF_00870</id>
         <status>approved</status>
         <source>AUTOSAR_SWS_CANInterface.pdf, V6.0.0</source>
         <version>1</version>
         <description>
       Caveats of CanIf_SetBaudrate():
         - The call context is on task level (polling mode).
         - CanIf must be initialized after Power ON.
      </description>
         <comment>
        Basically this means:
          If the switch CANIF_PUBLIC_DEV_ERROR_DETECT is enabled and the CanIf has not been initialized
          (by a call to CanIf_Init()) prior to a call to CanIf API CanIf_SetBaudrate(),
          then the API shall report CANIF_E_UNINIT to Det_ReportErrorStatus() and return E_NOT_OK.
      </comment>
         <releases>
            <release>AUTOSAR 4.1.1</release>
         </releases>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_CanIf_SetBaudrate_NOINIT</srcid><srcstatus/><internalId>1444</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1044</internalId></specobject>

      <specobject>
         <id>CanIf.EB.Config_CanIfMulticoreWakeupExtension</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
         Name : CanIfMulticoreWakeupExtension
         Parent Container : CanIfPublicCfg
         Description : Feature available only when CanIfMultiCoreSupport is enabled.
                       CanIfMulticoreWakeupExtension Enable/disable the wakeup support in Multicore context.
                       A Schm_Call function will be generated for each configured Can driver and Can transceiver.
                       It will be called by CanIf_CheckWakeup() to check if specific Can Driver or Can transceiver
                       signals a wakeup event.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MulticoreDriverWakeup</srcid><srcstatus/><internalId>1696</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_MulticoreTrcvWakeup</srcid><srcstatus/><internalId>1697</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_719</srcid><srcstatus/><internalId>1215</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1045</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfMulticoreWakeupExtension_WakeupCanDriver</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
           When configuration parameter CanIfMulticoreWakeupExtension is enabled, CanIf_CheckWakeup()
           will make synchronous cross-core calls via CanIf_CallSchM_CanControllerWakeup[] for Can_CheckWakeup()
           through a generated Schm_Call function that is specific for each Can driver.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MulticoreDriverWakeup</srcid><srcstatus/><internalId>1696</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3092</srcid><srcstatus/><internalId>1136</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1046</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfMulticoreWakeupExtension_WakeupCanTransceiver</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
           When configuration parameter CanIfMulticoreWakeupExtension is enabled, CanIf_CheckWakeup()
           will make synchronous cross-core calls via CanIf_CallSchM_CanTrcvWakeup[] for CanTrcv_CheckWakeup()
           through a generated Schm_Call function that is specific for each Can transceiver.
      </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_MulticoreTrcvWakeup</srcid><srcstatus/><internalId>1697</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_3165</srcid><srcstatus/><internalId>1139</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1047</internalId></specobject>

      <specobject>
         <id>CanIf.EB.CanIfGlobalTimeSupportConsistency</id>
         <status>approved</status>
         <source>EB</source>
         <version>1</version>
         <description>
           CanIf shall throw an error if CanIfGlobalTimeSupport is enabled and CanGlobalTimeSupport is disabled.
         </description>
         <needscoverage>
            <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_GenTest_01026_Err_Invalid_CanIfGlobalTimeSupport_Config</srcid><srcstatus/><internalId>1654</internalId></linkedfrom></coveredby></needscov>
            <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_1755</srcid><srcstatus/><internalId>1237</internalId></linkedfrom></coveredby></needscov>
         <containerCovstatus>covered</containerCovstatus></needscoverage>
      <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1048</internalId></specobject>

  </specobjects>
    <specobjects doctype="man">

    <specobject>
      <id>CanIf.man.ExternalHeaderFile</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Check that the header file CanIf.h only contains extern declarations
        of constants, global data and services that are specified in the CanIf SWS.
      </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00672</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>632</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1049</internalId></specobject>

    <specobject>
      <id>CanIf.man.ConfigurationConsistency</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        t.b.d.
      </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00131</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>228</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1050</internalId></specobject>

    <specobject>
      <id>CanIf.man.InterruptContext</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        For the following functions:
        - CanIf_CheckWakeup()
        - CanIf_CheckValidation()
        - CanIf_TxConfirmation()
        - CanIf_RxIndication()
        - CanIf_CancelTxConfirmation()
        - CanIf_ControllerBusOff()
        - CanIf_ConfirmPnAvailability()
        - CanIf_ClearTrcvWufFlagIndication()
        - CanIf_CheckTrcvWakeFlagIndication()
        - CanIf_ControllerModeIndication()
        - CanIf_TrcvModeIndication()
        - &lt;User&gt;_ConfirmPnAvailability()
        - &lt;User&gt;_ClearTrcvWufFlagIndication()
        - &lt;User&gt;_CheckTrcvWakeFlagIndication()

        check that:
        - there is no call to any Os functions other than those that are explicitly
          allowed to be called in category 1 interrupt context.
        - there is no call to any other function that is not itself defined to be
          callable in interrupt context.

        refer to ASCPROJECT-989 for more details.
      </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00401_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>79</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00407_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>83</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00413_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>87</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00422_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>92</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00427_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>97</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00432_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>101</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00818_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>211</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00807_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>205</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00811_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>208</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00703_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>174</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00709_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>178</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00822_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>215</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00793_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>198</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00799_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>202</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1051</internalId></specobject>

    <specobject>
      <id>CanIf.man.DataProtection</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        Check that the exclusive areas used in the module source
        comply with the data protection mechnism described in the module design.
      </description>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanIf.DataProtection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1315</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1052</internalId></specobject>

    <specobject>
      <id>CanIf.man.MemMap</id>
      <status>approved</status>
      <source>EB manual test</source>
      <version>1</version>
      <description>
        - Check that all function definitions and declarations are enclosed by a
          CANIF_START_SEC_CODE and CANIF_STOP_SEC_CODE symbol.
        - Check that all global variables are enclosed by a memory section
          according to the respective symbol property, including:
          -- constness
          -- variable size
          -- initializationcharacteristics
      </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00278_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>67</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1053</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanIf.EB.DBGINST001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Every public API of the module shall have debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanIf_DBGINST_001</srcid><srcstatus/><internalId>1316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1054</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DBGINST002</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the entry instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanIf_DBGINST_001</srcid><srcstatus/><internalId>1316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1055</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DBGINST003</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The parameter of a API shall be available in the exit instrumentation.
        If the API has a return value, the very first parameter of the macro shall contain the expected return value.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanIf_DBGINST_001</srcid><srcstatus/><internalId>1316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1056</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DBGINST004</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The default implementation of the debug instrumentation shall be an empty macro.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanIf_DBGINST_001</srcid><srcstatus/><internalId>1316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1057</internalId></specobject>

    <specobject>
      <id>CanIf.EB.DBGINST005</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The module shall include the header files Base_Dbg.h in order to allow changing the default implementation of the debug instrumentation.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanIf_DBGINST_001</srcid><srcstatus/><internalId>1316</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1058</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanIf.EB.PBCFGM101</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        Service name: CanIf_IsValidConfig
        Syntax: Std_ReturnType CanIf_IsValidConfig( void* ConfigPtr )
        Sync/Async: Synchronous
        Reentrancy: Reentrant
        Parameters (in): ConfigPtr, post build configuration manager
        configuration.
        Parameters (inout): None
        Parameters (out): None
        Return value: Returns E_OK if the CanIf configuration is valid otherwise E_NOT_OK. A
        null pointer is interpreted as invalid configuration.
        Description: This function determines if the CanIf configuration is valid. This
        function can be called also before the CanIf is initialized. No error reporting
        is necessary within this function.
      </description>
      <comment> </comment>
      <!-- Can be tested by an conformance and a compile test -->
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1317</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_30883</srcid><srcstatus/><internalId>1340</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1059</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PBCFGM102</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        A configuration is valid
        - if the platform signature in the post build configuration equals the value
          determined by the macro TS_PlatformSigIsValid.
        - if the link time signature in the post build configuration equals the link time
          signature in the link time configuration file.
        - if the compile time signature in the post build configuration equals the value of
          the macro CANIF_CFG_SIGNATURE.
        - if the compile time signature of Published information in the post build configuration
          equals the value of the macro CANIF_PUBLIC_INFO_SIGNATURE.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1317</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1060</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PBCFGM104</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          CfgSignature.
        - the CanIf_Cfg.h file shall contain the macro
          CANIF_CFG_SIGNATURE.
        - the MCG shall generate this signature value of compile time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of compile time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1317</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_General</srcid><srcstatus/><internalId>1325</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1061</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PBCFGM104_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the compile time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          PublicInfoSignature.
        - the CanIf_Cfg.h file shall contain the macro
          CANIF_PUBLIC_INFO_SIGNATURE.
        - The MCG shall generate this signature value from the list of parameters of
          configuration class 'PublishedInformation' except 'Release'. The XPath function
          asc:getConfigSignature(nodeset) shall be used to determine the signature out of the
          list of parameters. The list of parameters shall be determined with the function
          asc:getConfigClassNodeList(cassString).
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1317</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_NO_PN_SUPPORT</srcid><srcstatus/><internalId>1339</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1062</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PBCFGM105</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For generalized consistency of the post build configuration versus the link time
        configuration:
        - the post build configuration structure shall contain the uint32 value
          LcfgSignature.
        - the link time configuration shall contain the uint32 value
          CanIf_LcfgSignature.
        - the MCG shall generate this signature value of link time parameters. The x-path
          function asc:getConfigSignature(nodeset) shall be used to determine the signature out
          of a list of parameters. The list of link time parameters shall determined with the
          function asc:getConfigClassNodeList(cassString).
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1317</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_LCFG_C</srcid><srcstatus/><internalId>1683</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1063</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PBCFGM106</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        For Platform verification:
        - the CanIf post build configuration structure shall contain the value
          uint32 PlatformSignature. This uint32 must be the first value of the post build
          configuration structure to guarantee the correct access not disturbed by any padding
          bytes.
        - the MCG shall generate this signature for the selected target. The generator shall
          use the x-path function asc:getPlatformSignature() to determine this value.
      </description>
      <comment>
        See also:
        https://infohub.automotive.elektrobit.com/display/PRJEBTRESOS/PostBuild#PostBuild-Consistencypostbuildconfig
        https://issue.ebgroup.elektrobit.com/browse/ASCBASE-1485
      </comment>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1317</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1064</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PBCFGM107</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The PbcfgM support shall be enabled or disabled via the macro
        CANIF_PBCFGM_SUPPORT_ENABLED defined in the file
        CanIf_Cfg.h.
        If the PbcfgM configuration references the CanIf configuration
        the macro is set to STD_ON otherwise, or if no PbcfgM configuration is
        available it is set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_IsValidConfig</srcid><srcstatus/><internalId>1317</internalId></linkedfrom><linkedfrom><srcid>CanIf_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1319</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1065</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PBCFGM108</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If the CanIf is referenced by the PbcfgM, the parameter regarding the
        relocatable feature, shall not be editable and the MCG shall use the configuration of
        the PbcfgM.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1319</internalId></linkedfrom><linkedfrom><srcid>CanIf_Test_PBcfgM_On</srcid><srcstatus/><internalId>1320</internalId></linkedfrom></coveredby></needscov>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/config/CanIf_EBParameters.xdm.m4_987</srcid><srcstatus/><internalId>1225</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1066</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PBCFGM110</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanIf_Init() function must be extended to enable the PbcgfM
        features.
        The initialization function shall obtain the CanIf configuration
        from the PbcfgM if the PbcfgM support is enabled within this CanIf
        and the initialization function is called with a null pointer.
        The validity of the configuration shall be checked by the function
        CanIf_IsValidConfig(). The validity shall be check regardless the PbcfgM
        support is enabled or not.
        If no valid configuration can be obtained the initialization function shall
        return, leaving the CanIf uninitialized.
        In the case error reporting is enabled and no valid configuration can be obtained
        an erroneous parameter shall be indicated.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_VerifyInitWithPcfgM</srcid><srcstatus/><internalId>1318</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1067</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PostBuild_1</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanIf module shall compile and build an executable even in the absence
        of a post build configuration, i.e. without any post build generated .c and .h files
        available.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_ComTest_NoPBCfg</srcid><srcstatus/><internalId>1338</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_Gen_00000_OnlyPbCfg</srcid><srcstatus/><internalId>1628</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1068</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PbcfgM_General_3</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanIf shall provide the following macros in the header file
        CanIf_Cfg.h:
        - CANIF_RELOCATABLE_CFG_ENABLE which is set to STD_ON
          if relocatable config shall be enabled, otherwise it's set to STD_OFF.
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_PBcfgM_On</srcid><srcstatus/><internalId>1320</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1069</internalId></specobject>

    <specobject>
      <id>CanIf.EB.PbcfgM_General_6</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        If PbcfgM support is enabled CanIf shall define the following macros in
        CanIf_PBCfg.c:
        - TS_PB_CFG_LAYOUT_TYPE: Shall expand to the type definition of the Postbuild
          configuration layout type (e.g. CanIf_ConstConfigLayoutType)
        - TS_PB_CFG_NAME: Shall expand to the name of the structure defining the Postbuild
          configuration layout (e.g. CanIf_ConfigLayout)
      </description>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf_Test_PBcfgM_Off</srcid><srcstatus/><internalId>1319</internalId></linkedfrom><linkedfrom><srcid>CanIf_Test_PBcfgM_On</srcid><srcstatus/><internalId>1320</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1070</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanIf.EB.PDULENGTHTYPE001</id>
      <status>approved</status>
      <source>EB</source>
      <version>1</version>
      <description>
        The CanIf module shall support the following values of PduLengthType:
        [UINT32, UINT16]
      </description>
      <verifycrit>
        Use case 1 - Modules not capable of handling more than 64 kbytes of data:
          - use PduLengthType value 'UINT32' with conformance test
          - verify successful test run, verify absence of metric violations
            (MISRA-C:2012, static code analysis, compiler warnings)
        Use case 2 - Modules capable of handling more than 64 kbytes of data:
          - use conformance test which handles more than 64 kbytes of data
          - apply "boundary" tests using data length of:
            [&lt;&lt;65535,65535, 65536, &gt;131072][bytes]
      </verifycrit>
      <needscoverage>
        <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CANIF_Transmit_UINT32_PduLengthType</srcid><srcstatus/><internalId>1601</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_RxIndication_UINT32_PduLengthType</srcid><srcstatus/><internalId>1602</internalId></linkedfrom><linkedfrom><srcid>TS_CANIF_CancelTxConfirmation_UINT32_PduLengthType</srcid><srcstatus/><internalId>1603</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1071</internalId></specobject>

  </specobjects>
    <specobjects doctype="swurs">

    <specobject>
      <id>CanIf.EB.Interface.Consistency</id>
       <status>approved</status>
       <source>EB</source>
       <version>1</version>
       <description>
        The module shall provide a mechanism to guarantee consistency of interfaces and
        types between its implementation and its code stub.
       </description>
       <comment>
        The code stub of a module shall provide the same external view than the module itself.
        This is mandatory because unit test of modules test against the code stubs of
        adjacent modules. Inconsistent stubs may result in the situation that incompatible
        interfaces are not detected as unit test stage.
       </comment>
       <verifycrit>
        Create a compile test with two permutations that call all interfaces of a module
        (in both permutations).
        p0: Behave like a regular compile test; call the module generator and compile against
        the implementation of the module.
        p1: Do not generate module code and do not compile the implementation of the module.
        Instead the module shall be replaced with its own code stub.
       </verifycrit>
       <needscoverage>
          <needscov><needsobj>swuts</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>TS_CanIf_VerifyCodeStub</srcid><srcstatus/><internalId>1321</internalId></linkedfrom></coveredby></needscov>
       <containerCovstatus>covered</containerCovstatus></needscoverage>
       
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1072</internalId></specobject>

  </specobjects>
    <specobjects doctype="dev">
    <specobject>
      <id>dev.CanIf.ConsChck</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>18</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00021</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>249</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1073</internalId></specobject>
    <specobject>
      <id>dev.CanIf.software</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00645</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>615</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00646</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>616</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00629</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>378</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00852</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>755</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00644</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>387</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00630</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>379</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00628</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>377</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00825</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>725</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00826</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>726</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1074</internalId></specobject>
    <specobject>
      <id>dev.CanIf.DebugAndTrace</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00565</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>250</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00566</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>251</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00567</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>252</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00568</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>253</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1075</internalId></specobject>
    <specobject>
      <id>dev.CanIf.Init</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00301</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>254</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1076</internalId></specobject>
    <specobject>
      <id>dev.CanIf.BaudRate</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00775</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>255</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00786</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>256</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00778</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>257</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00779</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>258</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00780</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>259</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00776</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>260</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00787</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>261</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00782</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>262</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00783</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>263</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00784</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>264</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00294_Baudrate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>265</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ChangeBaudrate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>134</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckBaudrate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>135</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1077</internalId></specobject>
    <specobject>
      <id>dev.CanIf.PostBuildOnly</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00460</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>103</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00461</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>104</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1078</internalId></specobject>
    <specobject>
      <id>dev.CanIf.SoftwareFilterType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>132</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00619</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>373</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1079</internalId></specobject>
    <specobject>
      <id>dev.CanIf.NoTTCanSupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00675</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>391</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1080</internalId></specobject>
    <specobject>
      <id>dev.CanIf.TxBuffer</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00837</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>717</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00833</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>407</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00834</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>408</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00835.CanIf_TxBufferSize_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>714</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1081</internalId></specobject>
    <specobject>
      <id>dev.CanIf.WakeupValidation</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>271</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00286</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>738</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1082</internalId></specobject>
    <specobject>
      <id>dev.CanIf.BlockTxConfirmation</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>306</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00073_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>590</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1083</internalId></specobject>
    <specobject>
      <id>dev.CanIf.ReadRxPduDataAcceptance</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>335</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00324_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>505</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00324_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>506</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1084</internalId></specobject>
    <specobject>
      <id>dev.CanIf.LPdu2ControllerAssignment</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>361</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00046</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>266</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1085</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CANIF_E_STOPPED</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>399</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00382</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>538</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00723</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>187</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.CANIF_E_STOPPED</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>57</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1086</internalId></specobject>
    <specobject>
      <id>dev.CanIf.InvalidatedWakeupSource</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>428</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00681</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>267</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1087</internalId></specobject>
    <specobject>
      <id>dev.CanIf.TriggerTransmit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>446</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00882</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>783</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00881</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>782</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00883</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>784</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00884</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>785</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00885</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>786</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00886</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>787</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00844</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>798</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00890</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>790</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00842</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00889</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>789</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00888</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>788</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00891</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>791</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00840</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1088</internalId></specobject>
    <specobject>
      <id>dev.UseCanIfPduModeTypeInsteadCanIf_PduSetModeTypeAndCanIf_PduGetModeType</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>491</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>590</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00073_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>437</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00490</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>268</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00491</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>269</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00492</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>270</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1089</internalId></specobject>
    <specobject>
      <id>dev.CanIf.GetControllerModeSignature</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>511</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00229</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>21</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1090</internalId></specobject>
    <specobject>
      <id>dev.CanIf.GetTrcvModeSignature</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>531</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00288</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>225</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00288</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>489</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1091</internalId></specobject>
    <specobject>
      <id>dev.CanIf.SEV_ErrorCounter</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>576</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00917</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>848</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1092</internalId></specobject>
    <specobject>
      <id>dev.CanIf.MaxPdu</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>592</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00829</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>729</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1093</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CanIf_GetControllerRxErrorCounter</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>608</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>832</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00907</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>825</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00908</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>826</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1094</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CanIf_DeInit</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>625</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>813</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1095</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CanIfWakeupSupport</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>640</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00843</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>797</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00892</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>799</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>464</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1096</internalId></specobject>
    <specobject>
      <id>dev.CanIf.PartiallyImplemented</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>664</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>854</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>855</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>455</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00893</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>800</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00382</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>538</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00895</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>804</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1097</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CanIfPBVariantValue</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>689</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00647</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00654</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>389</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00591</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>349</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1098</internalId></specobject>
    <specobject>
      <id>dev.CanIf.ParameterMultiplicity</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>710</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00820</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>404</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00819</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>796</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1099</internalId></specobject>
    <specobject>
      <id>dev.CanIf.ConfigParametersChanged</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>725</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00902</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>816</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1100</internalId></specobject>
    <specobject>
      <id>dev.CanIf.Changed_ServiceID</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>744</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>411</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00764</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>676</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1101</internalId></specobject>
    <specobject>
      <id>dev.CanIf.ChangedParameters</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>766</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>470</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>469</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>476</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>485</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1102</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CanIfRxPduCfg</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>783</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00249</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>330</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1103</internalId></specobject>
    <specobject>
      <id>dev.CanIf.ControllerMode</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>797</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00317</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>500</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1104</internalId></specobject>
    <specobject>
      <id>dev.CanIf.NoTransceiverConfigured</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>817</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>528</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>531</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>533</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>535</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1105</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CanIf_GetVersionInfo</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>835</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00661</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>625</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1106</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CanIfMaxBufferSize</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>849</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00828</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>728</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1107</internalId></specobject>
    <specobject>
      <id>dev.CanIf.MetadataRxBuffer</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>865</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00851</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>754</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1108</internalId></specobject>
    <specobject>
      <id>dev.CanIf.PBMultiplicity</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>884</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00822</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>719</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00823</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>721</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1109</internalId></specobject>
    <specobject>
      <id>dev.CanIf.OptionalConfigParameters</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>904</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00824</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>723</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00838</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>732</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1110</internalId></specobject>
    <specobject>
      <id>dev.CanIf.CheckWakeupReturnValues</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>921</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00678</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>635</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00720</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>658</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1111</internalId></specobject>
    <specobject>
      <id>dev.CanIf.PBVariantValue</id>
      <status>approved</status>
      <source>EB release notes</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/public/changelog/Deviations.xml</sourcefile>
      <sourceline>942</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00623</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>374</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00599</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00592</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1112</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/CanIf_Cfg.h.m4_32</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate/include/CanIf_Cfg.h.m4</sourcefile>
      <sourceline>32</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1113</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/CanIf_Cfg.h.m4_37</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate/include/CanIf_Cfg.h.m4</sourcefile>
      <sourceline>37</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfBusAHeaderFile_Inclusion</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1114</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/CanIf_Cfg.h.m4_856</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate/include/CanIf_Cfg.h.m4</sourcefile>
      <sourceline>856</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfBusATxIndication_GenerateAPI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1036</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1115</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/CanIf_Cfg.h.m4_897</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate/include/CanIf_Cfg.h.m4</sourcefile>
      <sourceline>897</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfBusARxIndication_GenerateAPI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1039</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1116</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/CanIf_Int_Cfg.h_39</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate/include/CanIf_Int_Cfg.h</sourcefile>
      <sourceline>39</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.HookOnReception.Header</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>996</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1117</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/include/CanIf_Types.h_433</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate/include/CanIf_Types.h</sourcefile>
      <sourceline>433</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1118</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate/include/CanIf_Types.h_445</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate/include/CanIf_Types.h</sourcefile>
      <sourceline>445</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1119</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate/src/CanIf_Cfg.c_225</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate/src/CanIf_Cfg.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1120</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_89</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>89</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00464</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1121</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_93</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00903</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1122</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1338</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1338</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00857</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>759</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1123</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1541</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1541</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1124</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1544</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1544</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1125</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1770</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1770</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1126</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1777</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1777</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00854</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>756</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1127</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1778</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1778</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00844</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>750</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1128</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1784</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1784</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00855</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>757</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1129</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1904</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1904</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanIf.Preemption2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1310</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1130</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1907</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1907</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfBusATxIndication_API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1037</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1131</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1973</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1973</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfBusATxIndication_API_ReturnFalse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1038</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1132</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1990</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1990</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1133</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_1993</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>1993</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1134</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_2628</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>2628</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00849</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>753</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1135</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3092</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3092</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfMulticoreWakeupExtension_WakeupCanDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1046</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1136</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF679_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1137</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3128</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3128</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF679_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1138</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3165</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3165</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfMulticoreWakeupExtension_WakeupCanTransceiver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1047</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1139</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3237</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3237</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1140</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3613</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3613</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1141</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3614</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3614</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1142</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3615</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3615</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1143</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3616</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3616</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1144</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3714</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3714</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledProcessing.TriggerMainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1145</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3723</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3723</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfTxPdusExceedingQueueApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1009</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1146</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3730</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3730</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing.FullQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1147</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3854</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3854</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00906.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>823</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1148</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3855</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3855</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00906.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1149</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3856</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3856</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00906.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1150</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3857</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3857</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00906.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1151</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3909</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3909</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1152</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3928</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3928</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledProcessing.TriggerMainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1153</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3937</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3937</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfRxPdusExceedingQueueApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1008</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1154</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3944</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3944</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing.FullQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1155</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3977</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3977</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing.MainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1156</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_3995</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>3995</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1157</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4002</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4002</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1158</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4047</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4047</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing.MainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>937</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1159</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4064</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4064</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1007</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1160</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4069</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4069</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1161</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4416</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4416</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1162</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4417</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4417</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1163</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4428</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4428</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>666</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1164</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4443</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4443</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00918</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1165</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4623</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4623</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1166</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4624</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4624</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1167</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4635</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4635</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>666</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1168</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_4871</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>4871</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF487</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1169</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_5450</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>5450</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1170</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6205</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6205</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF403</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1043</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1171</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6211</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6211</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00286_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1003</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1172</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6216</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6216</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00286_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1002</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1173</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6296</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6296</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00896</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>805</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1174</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6311</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6311</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfBusARxIndication_API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1040</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1175</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6320</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6320</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.HookOnReception.FunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>997</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1176</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6343</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6343</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00911.Availability</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1177</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6365</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6365</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00912</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1178</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6398</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6398</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91005.ReturnValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1179</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6428</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6428</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00898</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>806</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1180</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6438</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6438</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00899</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>807</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1181</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6452</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6452</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91001.ReturnValue.ProperlySupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>810</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1182</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6459</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6459</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91001.ReturnValue.NotSupportedByDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>809</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1183</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6490</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6490</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00909</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1184</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6500</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6500</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00910</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1185</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6514</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6514</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91004.ReturnValue.ProperlySupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>835</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1186</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6520</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6520</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91004.ReturnValue.NotSupportedByDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>834</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1187</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6603</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6603</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00915</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1188</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6611</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6611</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00916</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1189</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6671</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6671</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00917.ErrorCounter_BoundaryValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1190</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6726</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6726</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00894.TruncateToFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>802</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1191</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6748</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6748</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00894.TruncateToPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1192</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6755</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6755</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfDetReportRuntimeError</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>907</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1193</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6757</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6757</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1194</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_6804</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>6804</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1195</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7068</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7068</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00922</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1196</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7078</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7078</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00923</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1197</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7088</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7088</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00924</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>863</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1198</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7118</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7118</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00926</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>866</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1199</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7128</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7128</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00927</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1200</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7167</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7167</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00929</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1201</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7177</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7177</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00930</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1202</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7187</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7187</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00931</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>872</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1203</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7228</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7228</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00933</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>875</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1204</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7238</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7238</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00934</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>876</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1205</internalId></specobject>
    <specobject>
      <id>src/Autosar/src/CanIf.c.m4_7248</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/src/CanIf.c.m4</sourcefile>
      <sourceline>7248</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00935</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>877</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1206</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_43</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlMaxRxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1011</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1207</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_69</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlMaxTxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1012</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1208</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_487</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>487</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.TxBufferMemorySize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>986</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1209</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_507</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>507</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduTruncateToFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>998</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1210</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_534</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>534</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduTruncateToFrame.Availability</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>999</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1211</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_622</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>622</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfDetReportRuntimeErrorParam</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>906</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1212</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_664</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>664</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfDecoupledProcessingSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>923</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1213</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_692</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>692</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1214</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_719</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>719</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfMulticoreWakeupExtension</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1045</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1215</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_747</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>747</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfRxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1216</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_768</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>768</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CanIfRxProcessing.CanIfPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1017</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1217</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_787</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>787</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfRxProcessing.CanIfRxPduProcessingRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1218</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_809</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>809</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfRxPduQueueSize</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1219</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_837</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>837</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxPayloadQueueSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1220</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_872</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>872</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1221</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_893</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>893</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CanIfTxProcessing.CanIfPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1018</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1222</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_912</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>912</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTxProcessing.CanIfTxPduProcessingRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1223</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_935</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>935</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduQueueSize</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1224</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_987</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>987</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1066</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1225</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_993</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>993</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfSoftwareFilteringSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>969</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1226</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1025</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1025</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfSoftwareFilteringSupport.hrhSoftwareFilterEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>991</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1227</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1028</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1028</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfSoftwareFilteringSupport.RxPduCanIdMaskConfigured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>992</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1228</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1033</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1033</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfCanDriverCompatibility</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1229</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1400</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1400</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxTxPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1021</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1230</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1607</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1607</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfValidateWakeupOnStartedCtrlOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1000</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1231</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1628</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1628</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfValidateWakeupOnStartedCtrlOnlyDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1001</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1232</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1633</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1633</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusATxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1034</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1233</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1663</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1663</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusARxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1035</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1234</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1693</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1693</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusAHeaderFile</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1041</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1235</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1723</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1723</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00854</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1236</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1755</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1755</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfGlobalTimeSupportConsistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1048</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1237</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1889</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1889</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.RxDecoupledMeasurementSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1004</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1238</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1919</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1919</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.TxDecoupledMeasurementSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1005</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1239</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1949</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1949</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfRxPdusExceedingQueueApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1008</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1240</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_1985</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>1985</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1241</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2020</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2020</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfTxPdusExceedingQueueApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1009</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1242</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2056</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2056</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1007</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1243</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2184</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2184</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicTxConfResultSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>970</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1244</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2204</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2204</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicTxConfResultSupport.Enable</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>993</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1245</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2260</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2260</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00879</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1246</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2461</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2461</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfUseCddHandleIds</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>979</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1247</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2511</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2511</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1248</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2534</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2534</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1249</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_EBParameters.xdm.m4_2558</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_EBParameters.xdm.m4</sourcefile>
      <sourceline>2558</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1250</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_111</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.TxCancelCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>229</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1251</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_260</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>260</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>463</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1252</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_344</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>344</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00524</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>594</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1253</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_498</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>498</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00790</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>793</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1254</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_619</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>619</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00695_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>646</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1255</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_657</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>657</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00456_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>578</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1256</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_749</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>749</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00830</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>730</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1257</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_1255</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>1255</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00822_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>720</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1258</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_1288</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>1288</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1259</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_1359</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>1359</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00846</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>814</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1260</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_1434</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>1434</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00339.CanIf_ReadRxNotifStatus.Caveat</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>71</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1261</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_1928</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>1928</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1262</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_1997</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>1997</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00823_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>722</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1263</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_2031</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>2031</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1264</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_2131</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>2131</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00840</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>777</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1265</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_2146</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>2146</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00845</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>811</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1266</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_2213</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>2213</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00842</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>778</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1267</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_2463</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>2463</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00827</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>727</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1268</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_2787</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>2787</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00614</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>370</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1269</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3050</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3050</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00824_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1270</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3115</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3115</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00613</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>369</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1271</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3162</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3162</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00456_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>579</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1272</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3212</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3212</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00848</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>839</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1273</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3222</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3222</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00849</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1274</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3250</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3250</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanEnableSecurityEventReporting.Warning</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1028</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1275</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3255</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3255</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00853</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1276</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3279</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3279</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00852</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1277</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3303</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3303</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00851</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>842</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1278</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3328</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3328</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00850</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1279</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3484</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3484</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>462</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1280</internalId></specobject>
    <specobject>
      <id>src/Autosar/config/CanIf_Extension.xdm.m4_3493</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/config/CanIf_Extension.xdm.m4</sourcefile>
      <sourceline>3493</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>462</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1281</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_33</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>33</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00663</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>626</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1282</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_98</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1016</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1283</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_103</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>103</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1284</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_119</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1285</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_127</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>127</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1286</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_148</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1287</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_157</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>157</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1288</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_181</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>181</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1016</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1289</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_182</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>182</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1290</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_200</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>200</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1291</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_208</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>208</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1292</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_228</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>228</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1293</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_237</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>237</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1294</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_256</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>256</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CanIfRxProcessing.SamePartitionOnMainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1019</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1295</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_macros/CanIf_Checks.m_270</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_macros/CanIf_Checks.m</sourcefile>
      <sourceline>270</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CanIfTxProcessing.SamePartitionOnMainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1020</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1296</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_434</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>434</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanIf.PostBuildConfigurationData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1313</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1297</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_642</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>642</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>dsn.CanIf.PBconfig.bufferindex</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swdd</linkdestdoctype><linkerror/><internalId>1314</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1298</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_725</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>725</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId.HandleIds</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>981</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1299</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_732</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>732</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId.TargetPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>982</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1300</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_740</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>740</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1301</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_950</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>950</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId.HandleIds</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>981</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1302</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_957</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>957</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId.TargetPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>982</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1303</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_1356</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>1356</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1304</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_1385</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>1385</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1305</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_1401</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>1401</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1306</internalId></specobject>
    <specobject>
      <id>src/Autosar/generate_var/xgen/CanIf.xgen_1458</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/generate_var/xgen/CanIf.xgen</sourcefile>
      <sourceline>1458</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTrcvDrvCfg.CanSMReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1307</internalId></specobject>
  </specobjects>
    <specobjects doctype="impl">
    <specobject>
      <id>src/Autosar/plugin.xml.m4_166</id>
      <status>approved</status>
      <source>EB source code</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/src/Autosar/plugin.xml.m4</sourcefile>
      <sourceline>166</sourceline>
      <version>1</version>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.RemoveTemplateStructure</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>968</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1308</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd">
    <specobject>
      <id>dsn.CanIf.Preemption1</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/project/design/pdf/CanIf_Design-profiled.xml</sourcefile>
      <sourceline>2315</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanIf.EB_INTREQ_CanIf_0002</srcid><srcstatus/><internalId>1</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1309</internalId></specobject>
    <specobject>
      <id>dsn.CanIf.Preemption2</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/project/design/pdf/CanIf_Design-profiled.xml</sourcefile>
      <sourceline>2328</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/src/CanIf.c.m4_1904</srcid><srcstatus/><internalId>1130</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1310</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Interaction limitations">
    <specobject>
      <id>dsn.CanIf.Interaction1</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/project/design/pdf/CanIf_Design-profiled.xml</sourcefile>
      <sourceline>2676</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanIf.EB_INTREQ_CanIf_0001</srcid><srcstatus/><internalId>0</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1311</internalId></specobject>
    <specobject>
      <id>dsn.CanIf.Interaction2</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/project/design/pdf/CanIf_Design-profiled.xml</sourcefile>
      <sourceline>2696</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>lim</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>lim.CanIf.EB_INTREQ_CanIf_0003</srcid><srcstatus/><internalId>2</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1312</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Post-build time">
    <specobject>
      <id>dsn.CanIf.PostBuildConfigurationData</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/project/design/pdf/CanIf_Design-profiled.xml</sourcefile>
      <sourceline>2850</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_434</srcid><srcstatus/><internalId>1297</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00144</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>735</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1313</internalId></specobject>
    <specobject>
      <id>dsn.CanIf.PBconfig.bufferindex</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/project/design/pdf/CanIf_Design-profiled.xml</sourcefile>
      <sourceline>3055</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>impl</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>src/Autosar/generate_var/xgen/CanIf.xgen_642</srcid><srcstatus/><internalId>1298</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00835.CanIf_TxBufferSize_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>715</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1314</internalId></specobject>
  </specobjects>
    <specobjects doctype="swdd" title="Protection of run-time data">
    <specobject>
      <id>dsn.CanIf.DataProtection</id>
      <status>approved</status>
      <source>EB design</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/doc/Autosar/project/design/pdf/CanIf_Design-profiled.xml</sourcefile>
      <sourceline>4018</sourceline>
      <version>1</version>
      <needscoverage>
        <needscov><needsobj>man</needsobj><objcovstatus>covered</objcovstatus><coveredby><linkedfrom><srcid>CanIf.man.DataProtection</srcid><srcstatus/><internalId>1052</internalId></linkedfrom></coveredby></needscov>
      <containerCovstatus>covered</containerCovstatus></needscoverage>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00673</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>633</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00033</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>425</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00199_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>475</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00064</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>429</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1315</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CanIf_DBGINST_001</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_DbgInst_Trace_APIs.c</sourcefile>
      <sourceline>40</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
   Test Dbg
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
  VP: Successful compilation test.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DBGINST001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1054</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DBGINST002</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1055</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DBGINST003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1056</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DBGINST004</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1057</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DBGINST005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1058</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1316</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanIf_Test_IsValidConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the function CanIf_IsValidConfig() is implemented as specified.
  
Test Object: 
    CanIf_IsValidConfig()
  
Test Precondition: 
    The CanIf module is not initialized.
  
Test Execution: 
    01: Call the function CanIf_IsValidConfig() with an NULL_PTR.
    02: VP:
        The function must have returned with E_NOT_OK.
    03: Create an invalid configuration regarding the endianness and alignment.
    04: Call the function CanIf_IsValidConfig() with this invalid configuration.
    05: VP(CanIf.EB.PBCFGM106):
        The function must have returned with E_NOT_OK.
    The following 3 steps are only executed if the module has a link-time configuration:
        06: Create an invalid configuration regarding the link time configuration.
        07: Call the function CanIf_IsValidConfig() with this invalid configuration.
        08: VP(CanIf.EB.PBCFGM105):
                The function must have returned with E_NOT_OK.
    09: Create an invalid configuration regarding the compile time configuration.
    10: Call the function CanIf_IsValidConfig() with this invalid configuration.
    11: VP(CanIf.EB.PBCFGM104):
        The function must have returned with E_NOT_OK.
    12: Create an invalid configuration regarding the published information configuration.
    13: Call the function CanIf_IsValidConfig() with this invalid configuration.
    14: VP(CanIf.EB.PBCFGM104_1):
        The function must have returned with E_NOT_OK.
    15: Call the function CanIf_IsValidConfig() with a valid configuration.
    16: VP:
        The function must have returned with E_OK.
    17: VP(CanIf.EB.PBCFGM107):
        Check if CANIF_PBCFGM_SUPPORT_ENABLED is set to STD_ON.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PBCFGM101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1059</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1060</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1061</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM104_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1062</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1063</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM106</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1064</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1065</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1317</internalId></specobject>
    <specobject>
      <id>CanIf_Test_VerifyInitWithPcfgM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_PbcfgM_Main_Impl_Test.c</sourcefile>
      <sourceline>225</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CanIf can be initialized via the PbcfgM.
  
Test Object: 
    CanIf_IsValidConfig()
  
Test Precondition: 
    The CanIf module must not have been initialized.
  
Test Execution: 
    01: Create an invalid configuration regarding the endianness and alignment.
    02: Call the function CanIf_Init() with this invalid configuration.
    03: VP:
        A Det call must have been performed correctly.
    04: Create an invalid configuration regarding the compile time configuration.
    05: Call the function CanIf_Init() with this invalid configuration.
    06: VP:
        A Det call must have been performed correctly.
    The following 3 steps are only executed if the module has a link-time configuration:
        07: Create an invalid configuration regarding the link time configuration.
        08: Call the function CanIf_Init() with this invalid configuration.
        09: VP:
            A Det call must have been performed correctly.
    10: Create an invalid configuration regarding the published information configuration.
    11: Call the function CanIf_Init() with this invalid configuration.
    12: VP:
        A Det call must have been performed correctly.
    13: Initialize the PbcfgM_GetConfig() stub that way that it can return a valid function.
    14: Call the function CanIf_Init() with a null pointer.
    15: VP:
        The function PbcfgM_GetConfig() must have been called once.
    16: VP:
        No Det call must have been performed.
    17: VP:
        The module internal configuration pointer CanIf_RootPtr must equal
        the pointer supplied to the initialization function
    18: PbcfgM_GetConfig shall return E_NOT_OK.
        set the configuration pointer which is returned to NULL_PTR
    19: Call CanIf_Init with NULL_PTR.
    20: VP(CanIf.EB.PBCFGM110):
        Check if Det error is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PBCFGM110</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1067</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1318</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanIf_Test_PBcfgM_Off</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_PbcfgM_Off_Compile_Test.c</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      Verify that if PbcfgM support is disabled then CanIf_PBCfg.c shall define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
      CANIF_PBCFGM_SUPPORT_ENABLED shall be set to STD_OFF.
      CANIF_RELOCATABLE_CFG_ENABLE shall be set to STD_OFF.
    
Test Object: None.
Test Precondition: 
      - PbcfgM configuration does not refer to module CanIf (or no config exists)
      - Include CanIf_PBcfg.c only for step 01 and 02.
      - Include CanIf_Cfg.h for step 03.
    
Test Execution: 
        01: VP(CanIf.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exists.
        02: VP(CanIf.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME has the value
            CanIf_ConfigLayoutType and CANIF_CONFIG_NAME respectively.
        03: VP (CanIf.EB.PBCFGM107):
            Verify that CANIF_PBCFGM_SUPPORT_ENABLED is set to STD_OFF.
        04: VP(CanIf.EB.PBCFGM108, CanIf.EB.RelocatablePBCfg):
            CANIF_RELOCATABLE_CFG_ENABLE shall be STD_OFF
    
Test Input: 
    
Test Output: 
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1070</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM107</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1065</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1066</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1319</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanIf_Test_PBcfgM_On</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_PbcfgM_On_Compile_Test.c</sourcefile>
      <sourceline>24</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
      1.)
      Verify that CANIF_RELOCATABLE_CFG_ENABLE is defined
      in the header file CanIf_Cfg.h.
      2.)
      Verify that if PbcfgM support is enabled then CanIf_PBCfg.c shall NOT define
      TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME.
    
Test Object: None.
Test Precondition: 
        - CANIF_PBCFGM_SUPPORT_ENABLED = STD_ON
    
Test Execution: 
        ------------------------ 1.) ---------------------
        01: VP (CanIf.EB.PbcfgM_General_3,
                CanIf.EB.PBCFGM108,
                CanIf.EB.RelocatablePBCfg):
            Verify that CANIF_RELOCATABLE_CFG_ENABLE is set to STD_ON.
        ------------------------ 2.) ---------------------
        02: Include CanIf_PBcfg.c.
        03: VP(CanIf.EB.PbcfgM_General_6):
            Check that symbols TS_PB_CFG_LAYOUT_TYPE and TS_PB_CFG_NAME exist.
    
Test Input: 
        None.
    
Test Output: 
        Binary file.
    &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PbcfgM_General_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1069</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PbcfgM_General_6</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1070</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM108</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1066</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1320</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CanIf_VerifyCodeStub</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/build/reqm/common_req/CanIf_VerifyStub_testspec.h</sourcefile>
      <sourceline>7</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the code stub of the module is consistent with the
    implementation.
  
Test Object: 
    Relocatable post-build configuration macros generation.
  
Test Precondition: 
    Permutation [VerifyStub == true]:
      - Unit test contains its own code stub
      - Module is excluded from generation and compilation
    Permutation [VerifyStub == false]:
      - unit test excludes its own code stub
  
Test Execution: 
    01: Invoke all module APIs
    02: VP(CanIf.EB.Interface.Consistency):
        Unit test compiles (implicitly tested)
  
Test Input: 
  
Test Output: 
    Test is correctly generated and compiled.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Interface.Consistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1072</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1321</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_CanSM_Cbk</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_CanSM_Cbk/source/application/Appl.c</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This compile test verifies if CanIf compiles if
    all Can controller related indication functions are dispatched
    to a CDD instead of CanSM.
    Only the transceiver mode indication shall be dispatched to CanSM.
    Note:
    This is a regression test to verify the bugfix done in ASCCANIF-1147.
  
Test Object: 
    Fix done in ASCCANIF-1147. (inclusion of CanSM_Cbk.h)
  
Test Precondition: 
    - Parameter CanIfDispatchUserCtrlBusOffUL set to value CDD.
    - Parameter CanIfDispatchUserCtrlModeIndicationUL set to value CDD.
    - Parameter CanIfPublicPnSupport set to value false.
    - Parameter CanIfDispatchUserTrcvModeIndicationUL set to value CAN_SM.
  
Test Execution: 
  
Test Input: 
  
Test Output: 
    Compiles successfully and without warnings.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF233</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00686</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1322</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30353</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_Cbk/source/application/Appl.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Configuration like in CanIf_ComTest_AllOptDetOn.
    Verify that callback functions are available when CanIf_Cbk.h is included.
  
Test Object: 
    Compile test: CanIf_Cbk.h
  
Test Precondition: 
  
Test Execution: 
    Include only CanIf_Cbk.h and not CanIf.h and call the different callback functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00121</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>35</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00409</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>85</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1323</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_MULTICORE_PARTITIONING</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_DecoupledMulticore/source/application/CanIf_ComTest_MulticorePartitioning.c</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test checks that the CanIf module's generator generates a
   syntactically and semantically valid basic software module
   description (BSWMD) when the generator mode "generate_swcd" is
   invoked. It further tests that the partition distribution is
   correctly generated by the RTE generator based on the CanIf module's
   generated BSWMD.

Test Object: None.
Test Precondition: None.
Test Execution: 
  Ts5 build environment steps:
    The module configuration generator produces the BSWMD containing
    the information on the required partitions. This information
    is then used by the RTE generator to create the required APIs
    for these partitions. This implicitly verifies that the BSWMD
    is syntactically and semantically correct. CanIf's static code
    makes use of these APIs (and the respective #defines) thus causing
    compile/link errors if the BSWMD does not contain the correct
    information.

Test Input: 
  Usage of a common ASR configuration having all adjacent ASR modules
  configured.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>889</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.BSWMDGeneration_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>890</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1324</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_General</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_General/source/application/Appl.c</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check for file inclusions and function prototypes.
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
  
Test Input: 
  
Test Output: 
    Compiles successfully and without warnings.
    This implicitly covers requirement CanSM.ASR40.CANIF278_1
    which relies on successful MemMap generation.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00116</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>34</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00219</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>479</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00226_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>482</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>459</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00464</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>109</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00122_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>37</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00122.PBcfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>39</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00643_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>129</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00643_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>130</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00278_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>66</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00462</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>105</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00463_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>107</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00208</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>62</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF233</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>915</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1061</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00911.Availability</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>830</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1325</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_HandleIdGenerator</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_HandleIdGenerator/source/application/CanIf_ComTest_HandleIdGenerator.c</sourcefile>
      <sourceline>18</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that invoking the handle ID autocalc wizard creates a valid configuration
    (i.e., a configuration adhering to the constraints of the module's generator (e.g., zero-based,
    dense, and unique)) out of an invalid configuration (i.e., a configuration violating the
    constraints of the module's generator (e.g., not zero-based, not dense, and not unique)).

    The handle IDs for the following parameters are checked by this
    test:
    - CanIfRxPduId
    - CanIfTxPduId
    - CanIfCtrlId
    - CanIfRxPduTargetPduID
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
  
Test Input: 
  
Test Output: 
    Binary file.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.HandleIdGenerator</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>896</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1326</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_APIS_MIRROR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_Mirror/source/application/Appl.c</sourcefile>
      <sourceline>19</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests checks that the function prototypes are as expected by Mirror
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
  
Test Input: 
  
Test Output: 
    Compiles successfully and without warnings.
    This implicitly covers requirement CanSM.ASR40.CANIF278_1
    which relies on successful MemMap generation.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00288.MirroringEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>490</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1327</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31234</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCanTrcv/source/application/Appl.c</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    General configuration as in test case CanIf_ComTest_AllOptDetOn however:
    No CanIfTransceiverDrvConfig container configured.
  
Test Object: 
    Compile test: No CanTrcv configured
  
Test Precondition: 
  
Test Execution: 
    Omitted functions (transceiver related functions) will be defined in the test source file so
    that a linker error will be generated if the CanIf still defines them.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00730</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>660</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1328</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31352</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>54</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation with all optional functions included.
    DET is enabled
    A transceiver channel supporting wakeup is configured
  
Test Object: 
    Compile test: All functions, Det on
  
Test Precondition: 
  
Test Execution: 
    Add calls to all functions to make sure that the linker doesn't omit the different functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1329</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31391</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>99</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation with all optional functions included.
    DET is disabled
    Relocatable Postbuild configuration disabled
    A transceiver channel supporting wakeup is configured
  
Test Object: 
    Compile test: All optional functions, Det off
  
Test Precondition: 
  
Test Execution: 
    Add calls to all functions to make sure that the linker doesn't omit the different functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1330</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31866</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>146</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation without all optional functions
    without transceiver in configuration
    Tx buffering disabled
    DET is enabled
    Relocatable Postbuild configuration enabled
    EcuM is not available
    Can callouts are disabled
  
Test Object: 
    Compile test: No optional functions, Det on
  
Test Precondition: 
  
Test Execution: 
    Omitted functions will be defined in the test source file so that a linker error will be
    generated if the CanIf still defines them.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00738</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>663</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00330</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>511</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00340</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00357</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00428</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1331</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31377</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>244</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation without all optional functions
    without transceiver in configuration
    Tx buffering disabled
    DET is disabled
    EcuM is not available
    Can callouts are disabled
  
Test Object: 
    Compile test: No optional functions, Det off
  
Test Precondition: 
  
Test Execution: 
    Omitted functions will be defined in the test source file so that a linker error will be
    generated if the CanIf still defines them.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00738</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>663</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00330</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>511</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00340</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00357</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00428</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1332</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ComTest_NoValidWu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>316</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation with wakeup handling enabled but wakeup validation disabled
  
Test Object: 
    Compile test: Wakeup support enabled, wakeup validation disabled
  
Test Precondition: 
  
Test Execution: 
    Omitted function CanIf_CheckValidation() will be defined in the test source
    file so that a linker error will be generated if the CanIf still defines it.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00226_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00659</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1333</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ComTest_NoWuCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>356</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation with wakeup handling disabled but wakeup validation disabled
  
Test Object: 
    Compile test: Wakeup support disabled
                  CanIfCanDriverCompatibility set to ASR402
  
Test Precondition: 
  
Test Execution: 
    Omitted function CanIf_CheckWakeup() will be defined in the test source
    file so that a linker error will be generated if the CanIf still defines it.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>461</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfCanDriverCompatibility</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1334</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31868</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>397</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanIfPublicCfg.CanIfVersionInfoApi = false
    Rest of the configuration copied from CanIf_ComTest_AllOptDetOn
    CanIf_GetVersionInfo() is defined as static function.
  
Test Object: 
    Compile test: CanIf_GetVersionInfo()
  
Test Precondition: 
  
Test Execution: 
    Compile test with a test function that calls CanIf_GetVersionInfo().
    CanIf_GetVersionInfo() is defined as static function.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1335</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanOnlyWakeup</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>435</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Wakeup support is enabled and only wakeup device is the CAN controller:
    - CanIfCtrlWakeupSupport = true
    - CanIfTrcvWakeupSupport = false
    The CAN Transceiver Driver does not provide a CanTrcv_CheckWakeup() function.
  
Test Object: 
    Compile test: CanIf_CheckWakeup()
  
Test Precondition: 
  
Test Execution: 
    Compile test with a test function that calls CanIf_CheckWakeup().
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1336</internalId></specobject>
    <specobject>
      <id>TS_CANIF_API_SetBaudrate</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoCheckWu/source/application/Appl.c</sourcefile>
      <sourceline>473</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that API function CanIf_Setbaudrate is only provided if CanIfSetBaudrateApi=true
  
Test Object: 
    CanIf_SetBaudrate()
  
Test Precondition: 
  
Test Execution: 
    Compile test with a test function that calls CanIf_SetBaudrate().
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00867</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>769</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00871</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>772</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00838_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1337</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanIf_ComTest_NoPBCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoPBCfg/source/application/CanIf_ComTest_NoPBCfg.c</sourcefile>
      <sourceline>22</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test shall prove that that the CanIf also compiles without any post build information
  
Test Object: 
    Compile test
  
Test Precondition: 
        * Set TS_CANIF_COMPILE_WITH_POSTBUILD to FALSE in the merged make file to prevent the compilation
          of the post build C file.
        * The merged make file holds a rule which removes all post build files after generation
  
Test Execution: 
        The test run is successful when the CanIf compiles under sticking to the precondition.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1068</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1338</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_NO_PN_SUPPORT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoPnSupport/source/application/Appl.c</sourcefile>
      <sourceline>92</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    General configuration as in test case CanIf_ComTest_AllOptDetOn however:
    CanIfPublicPnSupport set to false
  
Test Object: 
    Compile test: partial network support deactivated
  
Test Precondition: 
  
Test Execution: 
    Omitted functions (transceiver related functions) will be defined in the test source file so
    that a linker error will be generated if the CanIf still defines them.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00754</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>669</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00771</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>681</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00808</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>696</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00812</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>699</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00813</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>700</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM102</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1060</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM104</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1061</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBCFGM104_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1062</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1339</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30883</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoRxPdus/source/application/Appl.c.m4</sourcefile>
      <sourceline>47</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    General configuration as in test case CanIf_ComTest_AllOptDetOn however:
    - No Rx PDUs configured
    - Rx indication callback disabled
    - Read Rx data and read Rx notification API disabled
    - Support of PbcfgM enabled
  
Test Object: 
    Compile test: No Rx PDUs
  
Test Precondition: 
  
Test Execution: 
    Add calls to all configured functions to make sure that the linker doesn't omit the different
    functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PBCFGM101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1059</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MMapIsValidFunctionToMemSection</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>903</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1340</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_NO_POLLING_SUPPORT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoTxConfirmPollingSupport/source/application/Appl.c</sourcefile>
      <sourceline>95</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    General configuration as in test case CanIf_ComTest_AllOptDetOn however:
    CanIfPublicTxConfirmPollingSupport set to false
  
Test Object: 
    Compile test: partial network support deactivated
  
Test Precondition: 
  
Test Execution: 
    Omitted functions (transceiver related functions) will be defined in the test source file so
    that a linker error will be generated if the CanIf still defines them.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00754</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>669</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00771</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>681</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00808</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>696</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00812</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>699</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00813</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>700</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1341</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_NoTxConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoTxConfirmation/source/application/Appl.c</sourcefile>
      <sourceline>23</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that code compiles if both &amp;lt;UL&amp;gt;_TxConfirmation() and CanIf_GetTxNotifStatus() are disabled.
  
Test Object: 
    - &amp;lt;UL&amp;gt;_TxConfirmation()
    - CanIf_GetTxNotifStatus()
  
Test Precondition: 
  
Test Execution: 
    01: VP (CanIf.SWS_CanIf_00438):
        Check that code compiles if both &amp;lt;UL&amp;gt;_TxConfirmation() and CanIf_GetTxNotifStatus() are disabled.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00438</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>569</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1342</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30885</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoTxPdus/source/application/Appl.c</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    General configuration as in test case CanIf_ComTest_AllOptDetOn however:
    - No Tx PDUs configured
    - Tx confirmation and cancel Tx confirmation callbacks disabled
    - Read Tx notification and set dynamic Tx ID API disabled
  
Test Object: 
    Compile test: No Tx PDUs
  
Test Precondition: 
  
Test Execution: 
    Add calls to all configured functions to make sure that the linker doesn't omit the different
    functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00428</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00438</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>569</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00472</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>584</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00357</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1343</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_NoUpperLayerCbks</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NoUpperLayerCbks/source/application/Appl.c</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    the following configuration shall be tested:
    - All upper layer (CAN_NM, CAN_TP and PDUR) have all their
      callback functions disabled:
      o No &lt;UL&gt;_RxIndication without CanId
      o No &lt;UL&gt;_RxIndication with CanId
      o No &lt;UL&gt;_TxConfirmation
      o No &lt;UL&gt; DLC passed notification
      o No &lt;UL&gt; DLC failed notification
  
Test Object: 
    Compile test: No upper layer callbacks
  
Test Precondition: 
  
Test Execution: 
    Add calls to receive and transmit related functions to make sure that the linker
    doesn't omit the different
    functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00438</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>569</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1344</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_NonLegacySymbolicNameValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_NonLegSymbolicNameValues/source/application/Appl.c</sourcefile>
      <sourceline>24</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Checking the symbolic name macros generated when CANIF_PROVIDE_LEGACY_SYMBOLIC_NAMES is not defined
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
  
Test Input: 
  
Test Output: 
   All symbolic name Macros generated should be defined as per Autosar 4.0 rev3
   and the values should be :
   CanIfConf_CanIfTxPduCfg_CanIfTxPduCfg_0      0U
   CanIfConf_CanIfTxPduCfg_CanIfTxPduCfg_1      1U
   CanIfConf_CanIfTxPduCfg_CanIfTxPduCfg_2      2U
   CanIfConf_CanIfTxPduCfg_CanIfTxPduCfg_3      3U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_0      0U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_1      1U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_2      2U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_3      3U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_4      4U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_5      5U
   CanIfConf_CanIfCtrlDrvCfg_0_CanIfCtrlCfg_0   0U
   CanIfConf_CanIfTrcvDrvCfg_0_CanIfTrcvCfg_0   0U
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00591</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00597</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>354</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00433</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>568</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00704</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00710</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>655</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00647</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00654</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CtrlIdSymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>884</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1345</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_PN_Trcv_Infix</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_PNTrcvInfix/source/application/Tests.c</sourcefile>
      <sourceline>29</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that if CanTrcvConfigSet list contains an element named the same, CanTrcvConfigSet,
    no matter what version of Autosar CanTrcv is, the vendor information will be correctly taken from
    the Common Published Information.

    
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
  
Test Input: 
  
Test Output: 
    Binary file.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PBSelectable.FileName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1346</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_SCHM</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_SchM/source/application/CanIf_ComTest_SchM.c</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   This test checks that the CanIf module's generator generates a
   syntactically and semantically valid basic software module
   description (BSWMD) when the generator mode "generate_swcd" is
   invoked. It further tests that the SchM exclusive area API is
   correctly generated by the RTE generator based on the CanIf module's
   generated BSWMD.

Test Object: None.
Test Precondition: None.
Test Execution: 
  Ts5 build environment steps:
    The module configuration generator produces the BSWMD containing
    the information on the required exclusive areas.  This information
    is then used by the RTE generator to create the required SchM API
    for these exclusive areas. This implicitly verifies that the BSWMD
    is syntactically and semantically correct.  CanIf's static code
    makes use of this API (and the respective #defines) thus causing
    compile/link errors if the BSWMD does not contain the correct
    information.

Test Input: 
  Usage of a common ASR configuration having all adjacent ASR modules
  configured.

Test Output: 
&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.BSWMDGeneration_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>888</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.BSWMDGeneration_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>889</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1347</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_CanIfPublicSingleCtrlOpt_Enabled</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_SingleCanController/source/application/Tests.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
     Check that code compiles if CanIfPublicSingleCtrlOpt is enabled
  
Test Object: 
  
Test Precondition: 
  
Test Execution: 
    Add calls to receive and transmit related functions to make sure that the linker
    doesn't omit the different functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00542</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>600</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1348</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_SymbolicNameValues</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_SymbolicNameValues/source/application/Appl.c</sourcefile>
      <sourceline>26</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that macros are generated for configuration parameters which are specified as 
    SYMBOLICNAMEVALUES.
  
Test Object: 
    Symbolic name value config parameters
  
Test Precondition: 
  
Test Execution: 
  
Test Input: 
  
Test Output: 
   All symbolic name Macros should be defined and the values should be :
   CanIfConf_CanIfTxPduCfg_CanIfTxPduCfg_0      0U
   CanIf_CanIfTxPduCfg_0                        0U
   CanIfConf_CanIfTxPduCfg_CanIfTxPduCfg_1      1U
   CanIf_CanIfTxPduCfg_1                        1U
   CanIfConf_CanIfTxPduCfg_CanIfTxPduCfg_2      2U
   CanIf_CanIfTxPduCfg_2                        2U
   CanIfConf_CanIfTxPduCfg_CanIfTxPduCfg_3      3U
   CanIf_CanIfTxPduCfg_3                        3U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_0      0U
   CanIf_CanIfRxPduCfg_0                        0U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_1      1U
   CanIf_CanIfRxPduCfg_1                        1U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_2      2U
   CanIf_CanIfRxPduCfg_2                        2U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_3      3U
   CanIf_CanIfRxPduCfg_3                        3U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_4      4U
   CanIf_CanIfRxPduCfg_4                        4U
   CanIfConf_CanIfRxPduCfg_CanIfRxPduCfg_5      5U
   CanIf_CanIfRxPduCfg_5                        5U
   CanIfConf_CanIfCtrlDrvCfg_0_CanIfCtrlCfg_0   0U
   CanIf_CanIfCtrlDrvCfg_0_CanIfCtrlCfg_0       0U
   CanIfConf_CanIfTrcvDrvCfg_0_CanIfTrcvCfg_0   0U
   CanIf_CanIfTrcvDrvCfg_0_CanIfTrcvCfg_0       0U
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00591</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>22</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00597</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>354</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00654</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>24</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00433</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>568</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00704</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>176</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00710</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>655</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00647</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>388</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CtrlIdSymbolicNameValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>884</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1349</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_47_TIMESTAMP</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_TimeStamp/source/application/Tests.c</sourcefile>
      <sourceline>45</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that time stamp APIs are provided if CanIfGlobalTimeSupport=true
  
Test Object: 
    CanIf_GetCurrentTime()
    CanIf_EnableEgressTimeStamp()
    CanIf_GetEgressTimeStamp()
    CanIf_GetIngressTimeStamp()
  
Test Precondition: 
  
Test Execution: 
    Compile test with a test function that calls time stamp APIs.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00854</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>859</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>860</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91011</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>865</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>869</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91013</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>874</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00925</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>864</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00928</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>868</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00932</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>873</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00936</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>878</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1350</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_ComTest_TrcvAvailability</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Compile/IN/CanIf_ComTest_TrcvAvailability/source/application/Appl.c</sourcefile>
      <sourceline>35</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    General configuration as in test case CanIf_ComTest_AllOptDetOn however:
    No CanIfTransceiverDrvConfig container configured.
  
Test Object: 
    Compile test: Availability of a CanTrcv
  
Test Precondition: 
  
Test Execution: 
    Omitted functions (transceiver related functions) will be defined in the test source file so
    that a linker error will be generated if the CanIf still defines them.
    The 4 permutations of the test verify that the necessary functions are available / omitted
    based on the configuration:
    * No transceiver support
    * Transceiver support without wakeup
    * Transceiver support with wakeup
    * Transceiver support with wakeup and validation
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00730</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>660</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1351</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_TrcvModeIndValidTrcvId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the upper layer TransceiverModeIndication() callback for CanSM is called correctly.
    The test is executed for different transceiver drivers and transceiver channels.
  
Test Object: 
    TransceiverModeIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Simulate the ModeIndication from TrcvDrv: 0_Infix0, channel 0.
    03: VP (CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00697):
        The CanSM callback was called with correct TransceiverId.
    04: Simulate the ModeIndication from TrcvDrv: 0_Infix0, channel 1.
    05: VP (CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00697):
        The CanSM callback was called with correct TransceiverId.
    06: Simulate the ModeIndication from TrcvDrv: 0_Infix0, channel 2.
    07: VP (CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00697):
        The CanSM callback was called with correct TransceiverId.
    08: Simulate the ModeIndication from TrcvDrv: 1_Infix1, channel 0.
    09: VP (CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00697):
        The CanSM callback was called with correct TransceiverId.
    10: Simulate the ModeIndication from TrcvDrv: 1_Infix1, channel 1.
    11: VP (CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00697):
        The CanSM callback was called with correct TransceiverId.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00693</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>641</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00697</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>648</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1352</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TrcvModeIndInvalidTrcvId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>253</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify invalid transceiver index DET error checking and reporting for callback functions
    CanIf_TrcvModeIndication_*() if multiple drivers are enabled.
  
Test Object: 
    TransceiverModeIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Invoke ModeIndication with invalid transceiver id.
    03: VP (CanIf.SWS_CanIf_00706):
        check DET, that there was an entry for invalid parameter transceiver.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00706</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>653</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1353</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30420_MultiIds</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>317</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the transceiver mode can be set via the API CanIf_SetTrcvMode(). The test is
    executed for different transceiver drivers and transceiver channels.
  
Test Object: 
    CanIf_SetTrcvMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Set expected result values for CanTrcv stub.
    03: Call CanIf_SetTrcvMode() for TrcvDrv: 0_Infix0 with different modes.
    04: VP (CanIf.SWS_CanIf_00287, CanIf.SWS_CanIf_00655):
        Check the return values of CanIf_SetTrcvMode().
    05: Call CanIf_SetTrcvMode() for TrcvDrv: 1_Infix1 with different modes.
    06: VP (CanIf.SWS_CanIf_00287, CanIf.SWS_CanIf_00655):
        Check the return values of CanIf_SetTrcvMode().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00287</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1354</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30428_MultiIds</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>508</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the transceiver mode can be read via the API CanIf_GetTrcvMode().
    The test is executed for different transceiver drivers and transceiver channels.
  
Test Object: 
    CanIf_GetTrcvMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Set expected result values for CanTrcv stub.
    03: Call CanIf_GetTrcvMode() for TrcvDrv: 0_Infix0 with different modes.
    04: VP (CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled, CanIf.SWS_CanIf_00655):
        Check the return values and modes of CanIf_GetTrcvMode().
    05: Call CanIf_GetTrcvMode() for TrcvDrv: 1_Infix1 with different modes.
    06: VP (CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled, CanIf.SWS_CanIf_00655):
        Check the return values and modes of CanIf_GetTrcvMode().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1355</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30430_MultiIds</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>709</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the wakeup reason can be read via the API
    CanIf_GetTrcvWakeupReason(). The test is executed for different transceiver
    drivers and transceiver channels
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Set expected result values for CanTrcv stub.
    03: Call CanIf_GetTrcvWakeupReason() for TrcvDrv: 0_Infix0 with different parameters.
    04: VP (CanIf.SWS_CanIf_00289, CanIf.SWS_CanIf_00655):
        Check the return values and results of CanIf_GetTrcvWakeupReason().
    05: Call CanIf_GetTrcvWakeupReason() for TrcvDrv: 1_Infix1 with different parameters.
    06: VP (CanIf.SWS_CanIf_00289, CanIf.SWS_CanIf_00655):
        Check the return values and results of CanIf_GetTrcvWakeupReason().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00289</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1356</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30432_MultiIds</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>975</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the wakeup mode can be set via the API CanIf_SetTrcvWakeupMode().
    The test is executed for different transceiver drivers and transceiver channels.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Set expected result values for CanTrcv stub.
    03: Call CanIf_SetTrcvWakeupMode() for TrcvDrv: 0_Infix0 with different parameters.
    04: VP (CanIf.SWS_CanIf_00290, CanIf.SWS_CanIf_00655):
        Check the return values and results of CanIf_SetTrcvWakeupMode().
    05: Call CanIf_SetTrcvWakeupMode() for TrcvDrv: 1_Infix1 with different parameters.
    06: VP (CanIf.SWS_CanIf_00290, CanIf.SWS_CanIf_00655):
        Check the return values and results of CanIf_SetTrcvWakeupMode().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1357</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TrcvApiInvalidTrcvId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1178</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf Transceiver API functions report a DET error when given an invalid
    TransceiverId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetTrcvWakeupMode() with an invalid TransceiverId.
    02: VP (CanIf.SWS_CanIf_00535):
        Check Return Value CanIf_SetTrcvWakeupMode(), and if there is an DET entry.
    03: Call CanIf_GetTrcvWakeupReason() with an invalid TransceiverId.
    04: VP (CanIf.SWS_CanIf_00537):
        Check Return Value CanIf_GetTrcvWakeupReason(), and if there is an DET entry.
    05: Call CanIf_SetTrcvMode() with an invalid TransceiverId.
    06: VP (CanIf.SWS_CanIf_00538):
        Check Return Value CanIf_SetTrcvMode(), and if there is an DET entry.
    07: Call CanIf_GetTrcvMode() with an invalid TransceiverId.
    08: VP (CanIf.SWS_CanIf_00364):
        Check Return Value CanIf_GetTrcvMode(), and if there is an DET entry.
    09: Call CanIf_SetTrcvMode() with an invalid TrcvMode.
    10: VP (CanIf.SWS_CanIf_00648):
        Check Return Value CanIf_SetTrcvMode(), and if there is an DET entry.
    11: Call CanIf_SetTrcvWakeupMode() with an invalid TrcvWakeupMode.
    12: VP (CanIf.SWS_CanIf_00536):
        Check Return Value CanIf_SetTrcvWakeupMode(), and if there is an DET entry.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00535</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>596</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00538</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>599</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00364</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>530</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00537</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>598</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00655</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>621</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00648</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>617</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00536</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>597</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1358</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TrcvWakeFlagIndValidTrcvId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1316</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the upper layer ConfirmPnAvailability(), CheckTrcvWakeFlagIndication()
    and ClearTrcvWufFlagIndication() callback for CanSM are called correctly. The test is executed
    for different transceiver drivers and transceiver channels.
  
Test Object: 
    Passing on calls to upper layer
  
Test Precondition: 
  
Test Execution: 
    01: VP (CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00803,
            CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00792):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    02: VP (CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00803,
            CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00792):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    03: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00826):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    04: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00797):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    05: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00797):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    06: VP (CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00803,
            CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00792):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    07: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00797):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    08: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00797):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    09: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00826):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    10: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00797):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    11: VP (CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00803,
            CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00792):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    12: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00826):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    13: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00826):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    14: VP (CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00803,
            CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00792):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    15: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00826):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    16: VP : Verify no DET was reported
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00753</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>668</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00757</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>670</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00759</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>671</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00788</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>683</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00797</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>687</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00800</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>689</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00803</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>692</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00814</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>701</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00819</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00820</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00821</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>705</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00823</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>706</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00826</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>709</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00792</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>795</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1359</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ConfirmPnIndInvalidTrcvId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1546</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  
Test Object: 
    error handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: VP (CanIf.SWS_CanIf_00815, CanIf.SWS_CanIf_00816):
        Invoke CanIf_ConfirmPnAvailability() with invalid transceiver id and verify that
         DET CANIF_E_PARAM_TRANSCEIVER is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00815</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>702</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00816</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>703</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1360</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckTrcvIndInvalidTrcvId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1600</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  
Test Object: 
    error handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: VP (CanIf.SWS_CanIf_00763, CanIf.SWS_CanIf_00809):
        Invoke CanIf_CheckTrcvWakeFlagIndication() with invalid transceiver id and verify that
        DET CANIF_E_PARAM_TRANSCEIVER is reported and CanSM_CheckTransceiverWakeFlagIndication()
        is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00763</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>675</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00809</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>697</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1361</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ClearTrcvIndInvalidTrcvId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1656</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  
Test Object: 
    error handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: VP (CanIf.SWS_CanIf_00762, CanIf.SWS_CanIf_00805):
        Invoke CanIf_ClearTrcvWufFlagIndication() with invalid
        transceiver id and verify that DET CANIF_E_PARAM_TRANSCEIVER is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00762</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>674</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00805</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>694</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1362</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckTrcvWakeFlagValid</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1710</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  
Test Object: 
    error handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: VP (CanIf.SWS_CanIf_00765):
        Call CanIf_CheckTrcvWakeFlag with each configured transceiver and channel and verify that
        the correct CanTrcv_CheckTrcvWakeFlag function is called with the corresponding transceiver
        Id.
    03: VP (CanIf.SWS_CanIf_00765):
        Check DET was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00765</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>677</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1363</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ClearTrcvWufFlagValid</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1795</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  
Test Object: 
    error handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: VP (CanIf.SWS_CanIf_00766):
        Call CanIf_ClearTrcvWufFlag with each configured transceiver
        and channel and verify that the correct CanTrcv_ClearTrcvWufFlag function is called with
        the corresponding transceiver Id.
    03: VP (CanIf.SWS_CanIf_00766):
        Check DET was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00766</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>678</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1364</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckTrcvWakeFlagInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1881</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify CanIf_CheckTrcvWakeFlag reports to DET if called with invalid transceiver Id.
  
Test Object: 
    error handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Call CanIf_CheckTrcvWakeFlag with an invalid transceiver Id.
    03: VP (CanIf.SWS_CanIf_00761, CanIf.SWS_CanIf_00765, CanIf.SWS_CanIf_00770):
        Verify DET error CANIF_E_PARAM_TRCV is reported for service Id 0x1e.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00761</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>673</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00765</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>677</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00770</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>680</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1365</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ClearTrcvWufFlagInvalid</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1934</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
  
Test Object: 
    error handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Call CanIf_ClearTrcvWufFlag with an invalid transceiver Id.
    03: VP (CanIf.SWS_CanIf_00760, CanIf.SWS_CanIf_00769):
        Verify DET error CANIF_E_PARAM_TRCV is reported for service Id 0x1e.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00760</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>672</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00769</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>679</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1366</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ReadReceivedData</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>1985</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that CanIf_ReadRxPduData accepts a request regardless of the
    corresponding CCMSM or channel mode.
  
Test Object: 
    CanIf_ReadRxPduData()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanIf module.
    02: Put the controller mode to CANIF_CS_STARTED and Pdu mode to CANIF_ONLINE.
    03: Indicate Rx frame.
    04: VP (CanIf.SWS_CanIf_00324.ApiAcceptance, CanIf.SWS_CanIf_00297):
        Call CanIf_ReadRxPduData() and check that it returned E_OK and verify the data received.
    05: Make a transition of controller mode to CANIF_CS_STOPPED.
    06: VP (CanIf.SWS_CanIf_00324.ApiAcceptance CanIf.SWS_CanIf_00297):
        Call CanIf_ReadRxPduData() and check that it returned E_OK and verify the data received.
    07: Make a transition of Pdu mode to CANIF_OFFLINE and controller mode to
        CANIF_CS_STARTED.
    08: VP (CanIf.SWS_CanIf_00324.ApiAcceptance CanIf.SWS_CanIf_00297):
        Call CanIf_ReadRxPduData() and check that it returned E_OK and verify the data received.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00324.ApiAcceptance</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>507</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00297</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>496</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1367</internalId></specobject>
    <specobject>
      <id>TS_CANIF_SetControllerMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds/source/application/Tests.c</sourcefile>
      <sourceline>2110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that Can_SetControllerMode is called from CanIf_SetControllerMode with
    corresponding controller Id.
  
Test Object: 
    Can_SetControllerMode()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanIf module.
    02: Loop the steps 03 to 04 for all the available controllers.
    03: Call CanIf_SetControllerMode for the controller.
    04: VP (CanIf.SWS_CanIf_00308):
        Check if Can_SetControllerMode is called with proper Can controller id and state.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00308</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>497</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1368</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_TrcvModeIndValid_UL_CDD</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_2Trcv_MultIds_UL_CDD/source/application/Tests.c</sourcefile>
      <sourceline>96</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the configured upper layer callback functions for ConfirmPnAvailability(),
    CheckTrcvWakeFlagIndication() and ClearTrcvWufFlagIndication() are called correctly.
    The test is executed for different transceiver drivers and transceiver channels.
  
Test Object: 
    Passing on calls to upper layer
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00801, CanIf.SWS_CanIf_00804,
           CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00791):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    02: VP(CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00801, CanIf.SWS_CanIf_00804,
           CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00791):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    03: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00824, CanIf.SWS_CanIf_00827):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    04: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00794, CanIf.SWS_CanIf_00795,
            CanIf.SWS_CanIf_00798, CanIf.ECUC_CanIf_00789, ):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    05: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00794, CanIf.SWS_CanIf_00795,
            CanIf.SWS_CanIf_00798, CanIf.ECUC_CanIf_00789, ):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    06: VP(CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00801, CanIf.SWS_CanIf_00804,
           CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00791):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    07: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00794, CanIf.SWS_CanIf_00795,
            CanIf.SWS_CanIf_00798, CanIf.ECUC_CanIf_00789, ):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    08: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00794, CanIf.SWS_CanIf_00795,
            CanIf.SWS_CanIf_00798, CanIf.ECUC_CanIf_00789, ):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    09: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00824, CanIf.SWS_CanIf_00827):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    10: VP (CanIf.SWS_CanIf_00757, CanIf.SWS_CanIf_00788, CanIf.SWS_CanIf_00794, CanIf.SWS_CanIf_00795,
            CanIf.SWS_CanIf_00798, CanIf.ECUC_CanIf_00789, ):
        Invoke CanIf_ClearTrcvWufFlagIndication and verify callout forwarding to user function.
    11: VP(CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00801, CanIf.SWS_CanIf_00804,
           CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00791):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    12: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00824, CanIf.SWS_CanIf_00827):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    13: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00824, CanIf.SWS_CanIf_00827):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    14: VP(CanIf.SWS_CanIf_00759, CanIf.SWS_CanIf_00800, CanIf.SWS_CanIf_00801, CanIf.SWS_CanIf_00804,
           CanIf.SWS_CanIf_00814, CanIf.ECUC_CanIf_00791):
        Invoke CanIf_CheckTrcvWakeFlagIndication and verify callout forwarding to user function.
    15: VP (CanIf.SWS_CanIf_00753, CanIf.ASR40.ECUC_CanIf_00819, CanIf.ASR40.ECUC_CanIf_00820,
            CanIf.SWS_CanIf_00821, CanIf.SWS_CanIf_00823, CanIf.SWS_CanIf_00824, CanIf.SWS_CanIf_00827):
        Invoke CanIf_ConfirmPnAvailability and verify callout forwarding to user function.
    16: Verify no DET was reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00753</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>668</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00757</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>670</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00759</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>671</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00788</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>683</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00794</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>684</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00795</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>685</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00798</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>688</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00800</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>689</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00801</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>690</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00804</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>693</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00814</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>701</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00819</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>218</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00820</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>25</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00821</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>705</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00823</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>706</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00824</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>707</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00827</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>710</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00791</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>794</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00789</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>792</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1369</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_TrcvModeInd_1Trcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_1Trcv_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>67</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that that the CanSM transceiver mode indication function is called
    if CanIf_TrcvModeIndication() is called.
  
Test Object: 
    CanIf_TrcvModeIndication()
  
Test Precondition: 
    Module is initialized.
  
Test Execution: 
    01: Call CanIf_TrcvModeIndication(0,CANTRCV_TRCVMODE_NORMAL) /
        CanIf_TrcvModeIndication(0,CANTRCV_TRCVMODE_NORMAL)
    02: VP (CanIf.SWS_CanIf_00712, CanIf.SWS_CanIf_00695_1, CanIf.SWS_CanIf_00693,
            CanIf.SWS_CanIf_00697):
        Check that CanSM_TransceiverModeIndication(0,CANTRCV_TRCVMODE_NORMAL) is called 1x.
    03: Call CanIf_TrcvModeIndication(1,CANTRCV_TRCVMODE_STANDBY) /
        CanIf_TrcvModeIndication(1,CANTRCV_TRCVMODE_STANDBY)
    04: VP (CanIf.SWS_CanIf_00712, CanIf.SWS_CanIf_00695_1, CanIf.SWS_CanIf_00693,
            CanIf.SWS_CanIf_00697):
        Check that CanSM_TransceiverModeIndication(1,CANTRCV_TRCVMODE_STANDBY) is called 1x.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00712</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>657</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00693</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>641</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00695_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>644</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00697</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>648</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1370</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30420_1Trcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_1Trcv_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>164</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Set new modes for the different transceivers
  
Test Object: 
    CanIf_SetTrcvMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetTrcvMode for different transceivers with different requested modes.
    02: VP (CanIf.SWS_CanIf_00287, CanIf.SWS_CanIf_00358):
        Verify that CanTrcv_SetOpMode() of the corresponding CanTrcv driver is called with the
        correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00287</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00358</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>527</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1371</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30428_1Trcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_1Trcv_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>308</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Request transceiver modes for the different transceivers
  
Test Object: 
    CanIf_GetTrcvMode()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanIf Module.
    02: Call CanIf_GetTrcvMode for different transceivers.
    03: VP (CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled, CanIf.SWS_CanIf_00363):
        Verify that CanTrcv_GetOpMode() is called with correct parameters and the return value
        and current mode are correctly propagated to the caller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00363</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1372</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30430_1Trcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_1Trcv_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>463</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Request transceiver wakeup reason for different transceivers
  
Test Object: 
    CanIf_GetTrcvWakeupReason()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanIf Module.
    02: Call CanIf_GetTrcvWakeupReason for different transceivers.
    03: VP (CanIf.SWS_CanIf_00289, CanIf.SWS_CanIf_00368):
        Verify that CanTrcv_GetBusWuReason() is called with correct parameters and the return value
        and current mode are correctly propagated to the caller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00289</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00368</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>532</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1373</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30432_1Trcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_1Trcv_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>660</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Set new transceiver wakeup mode for the different transceivers
  
Test Object: 
    CanIf_SetTrcvWakeupMode()
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanIf Module.
    02: Call CanIf_SetTrcvWakeupMode for different transceivers and with different requested modes.
    03: VP (CanIf.SWS_CanIf_00290, CanIf.SWS_CanIf_00372):
        Verify that CanTrcv_SetWakeupMode() is called with correct parameters and the return value
        and current mode are correctly propagated to the caller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00372</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>534</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1374</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckRxNotifyFlagsMulticore</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_1Trcv_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>804</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that notification flags are set properly on message receive in multicore context. Notification flag array
    is larger than 1 byte.
  
Test Object: 
    CanIf_ReadRxNotifStatus()
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Loop over RxLPdus.
    02: Put the controller mode to CANIF_CS_STARTED and Pdu mode to CANIF_ONLINE.
    03: Prepare hardware object.
    04: Simulate reception to set notification flag.
    05: Read notification flag.
    06: Check that flag was set correctly.
    07: Check that no notification flag has been set for these RxLPdus.
    08: Resume with RxLPdus that have the notification feature enabled.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlMaxRxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1011</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1375</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckTxNotifyFlagsMulticore</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_1Trcv_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>939</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that notification flags are set properly on message transmit for LPdu with notification index
    greater than 7 (flag array larger than one byte).
  
Test Object: 
    CanIf_ReadTxNotifStatus()
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Put the controller mode to CANIF_CS_STARTED and Pdu mode to CANIF_ONLINE.
    02: Simulate successful message transmission.
    03: Confirm the transmission and set the Tx notification flag.
    04: Read notification flag.
    05: Check that flag was set correctly.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlMaxTxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1012</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1376</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckRxNotifyFlagsMulticoreReportInvalidNotifIdx</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_1Trcv_DetOff/source/application/Tests.c.m4</sourcefile>
      <sourceline>1008</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that an invalid notification index will be reported to Det by CanIf_ReadRxNotifStatus() API.
  
Test Object: 
    CanIf_ReadRxNotifStatus()
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Put the controller mode to CANIF_CS_STARTED and Pdu mode to CANIF_ONLINE.
    02: Simulate reception on a PDU with notification feature disabled.
    03: Attempt to read notification flag.
    04: Check that an error was reported regarding the invalid notification ID.
    05: Check that there is NO notification returned.
    06: Prepare hardware object.
    07: Simulate reception.
    08: Read notification flag.
    09: Check that the flag was corectly set and read.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlMaxRxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1011</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00336_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>519</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1377</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_TrcvModeInd</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_2Trcv_DetOn/source/application/Tests.c</sourcefile>
      <sourceline>64</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that that the CanSM transceiver mode indication function is called
    if CanIf_TrcvModeIndication() is called.
  
Test Object: 
    CanIf_TrcvModeIndication()
  
Test Precondition: 
    Module is initialized.
  
Test Execution: 
    01: Call CanIf_TrcvModeIndication(0,CANTRCV_TRCVMODE_NORMAL) /
        CanIf_TrcvModeIndication(0,CANTRCV_TRCVMODE_NORMAL)
    02: VP (CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00695_1, CanIf.SWS_CanIf_00697,
            CanIf.SWS_CanIf_00712):
        Check that CanSM_TransceiverModeIndication(0,CANTRCV_TRCVMODE_NORMAL) is called 1x.
    03: Call CanIf_TrcvModeIndication(1,CANTRCV_TRCVMODE_STANDBY) /
        CanIf_TrcvModeIndication(1,CANTRCV_TRCVMODE_STANDBY)
    04: VP (CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00695_1, CanIf.SWS_CanIf_00697,
            CanIf.SWS_CanIf_00712):
        Check that CanSM_TransceiverModeIndication(1,CANTRCV_TRCVMODE_STANDBY) is called 1x.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00712</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>657</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00693</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>641</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00695_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>644</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00697</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>648</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1378</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30420</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_2Trcv_DetOn/source/application/Tests.c</sourcefile>
      <sourceline>170</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the transceiver mode can be set via the API CanIf_SetTrcvMode().
    The test is executed for different transceiver drivers and transceiver channels.
  
Test Object: 
    CanIf_SetTrcvMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Set expected result values for CanTrcv stub.
    03: Call CanIf_SetTrcvMode() for TrcvDrv: 0_Infix0 with different modes.
    04: VP (CanIf.SWS_CanIf_00287, CanIf.SWS_CanIf_00358):
        Verify that CanTrcv_SetOpMode() is called with the correct parameters and return
        value of CanTrcv_SetOpMode is propagated to the caller.
    05: Call CanIf_SetTrcvMode() for TrcvDrv: 1_Infix1 with different modes.
    06: VP (CanIf.SWS_CanIf_00287, CanIf.SWS_CanIf_00358):
        Verify that CanTrcv_SetOpMode() is called with the correct parameters and return
        value of CanTrcv_SetOpMode is propagated to the caller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00287</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00358</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>527</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1379</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30428</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_2Trcv_DetOn/source/application/Tests.c</sourcefile>
      <sourceline>362</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Request transceiver modes for the different transceivers
  
Test Object: 
    CanIf_GetTrcvMode()
  
Test Precondition: 
  
Test Execution: 
    Use all possible modes at least once during a successful call, simulate at least one failed
    call.
    01: Call CanIf_Init() for initialization of the module.
    02: Set expected result values for CanTrcv stub.
    03: Call CanIf_GetTrcvMode() for TrcvDrv: 0_Infix0 with different modes.
    04: VP (CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled, CanIf.SWS_CanIf_00363):
        Verify that CanTrcv_GetOpMode() is called with the correct parameters and return
        value of CanTrcv_GetOpMode is propagated to the caller.
    05: Call CanIf_GetTrcvMode() for TrcvDrv: 1_Infix1 with different modes.
    06: VP (CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled, CanIf.SWS_CanIf_00363):
        Verify that CanTrcv_GetOpMode() is called with the correct parameters and return
        value of CanTrcv_GetOpMode is propagated to the caller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00363</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>529</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1380</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30430</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_2Trcv_DetOn/source/application/Tests.c</sourcefile>
      <sourceline>569</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Request transceiver wakeup reason for different transceivers
  
Test Object: 
    CanIf_GetTrcvWakeupReason()
  
Test Precondition: 
  
Test Execution: 
    Use all possible reasons at least once during a successful call, simulate at least one failed
    call.
    01: Call CanIf_Init() for initialization of the module.
    02: Set expected result values for CanTrcv stub.
    03: Call CanIf_GetTrcvWakeupReason() for TrcvDrv: 0_Infix0 with different parameters.
    04: VP (CanIf.SWS_CanIf_00289, CanIf.SWS_CanIf_00368):
        Verify that CanTrcv_GetBusWuReason() is called with the correct parameters and return
        value of CanTrcv_GetBusWuReason is propagated to the caller.
    05: Call CanIf_GetTrcvWakeupReason() for TrcvDrv: 1_Infix1 with different parameters.
    06: VP (CanIf.SWS_CanIf_00289, CanIf.SWS_CanIf_00368):
        Verify that CanTrcv_GetBusWuReason() is called with the correct parameters and return
        value of CanTrcv_GetBusWuReason is propagated to the caller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00289</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00368</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>532</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1381</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30432</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_2Trcv_DetOn/source/application/Tests.c</sourcefile>
      <sourceline>822</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Set new transceiver wakeup mode for the different transceivers
  
Test Object: 
    CanIf_SetTrcvWakeupMode()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Set expected result values for CanTrcv stub.
    03: Call CanIf_SetTrcvWakeupMode() for TrcvDrv: 0_Infix0 with different parameters.
    04: VP (CanIf.SWS_CanIf_00290, CanIf.SWS_CanIf_00372):
        Verify that CanTrcv_SetWakeupMode() is called with the correct parameters and return
        value of CanTrcv_SetWakeupMode is propagated to the caller.
    05: Call CanIf_SetTrcvWakeupMode() for TrcvDrv: 1_Infix1 with different parameters.
    06: VP (CanIf.SWS_CanIf_00290, CanIf.SWS_CanIf_00372):
        Verify that CanTrcv_SetWakeupMode() is called with the correct parameters and return
        value of CanTrcv_SetWakeupMode is propagated to the caller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00372</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>534</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleTrcv</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>984</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1382</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31099</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_HohGaps/source/application/Tst_31099.c</sourcefile>
      <sourceline>106</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate a message reception for an unused HRH with software filtering being enabled.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Initialize all stubs.
    03: Simulate several message receptions on an unused HRH HRH_1_1 with software
        filtering enabled.
    04: VP (CanIf.SWS_CanIf_00389):
        Verify that CanIf end the receive indication for that call of CanIf_RxIndication,
        if Software Filtering rejects the received L-PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SoftwareFilter.RejectPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1383</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31100</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Basic_HohGaps/source/application/Tst_31100.c</sourcefile>
      <sourceline>106</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate a message reception for an unused HRH with software filtering being disabled.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Initialize all stubs.
    03: Simulate several message receptions on an unused HRH HRH_0_3 with software
        filtering enabled.
    04: VP (CanIf.SWS_CanIf_00389):
        Verify that CanIf end the receive indication for that call of CanIf_RxIndication,
        if Software Filtering rejects the received L-PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1384</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_DataInterception_RX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_BusAdapter/source/application/Tests.c.m4</sourcefile>
      <sourceline>349</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that BusA user callout is called to intercept received data flow.
  
Test Object: 
    CanIf_RxIndication()
    CANIF_BUSA_RX_INDICATION()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
    BusA user callouts are configured and its .h is included. 
  
Test Execution: 
    01: call Tst_SetAndCheckCtrlModes() to start the controller.
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
    02: Set the return of BusA Rx callout stub BusA_Indication_Rx() to TRUE.
:-/,m4_ifelse( :else: )\-:m4_dnl
    02: Set the return of BusA Rx callout stub BusA_Indication_Rx() to FALSE.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
    03: Call CanIf_RxIndication() to simulate the reception of a message.
    04 Verify that BusA_Indication_Rx() is called and the data passed to it.
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
    05: Verify that PduR_CanIfRxIndication() is called with the right PduId and Data.
:-/,m4_ifelse( :else: )\-:m4_dnl
    05: Verify that PduR_CanIfRxIndication() isn't called due to BusA_Indication_Rx() returning FALSE
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusARxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1035</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfBusARxIndication_API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1040</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfBusARxIndication_GenerateAPI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1039</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusAHeaderFile</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1041</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfBusAHeaderFile_Inclusion</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1385</internalId></specobject>
    <specobject>
      <id>TS_CANIF_DataInterception_TX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_BusAdapter/source/application/Tests.c.m4</sourcefile>
      <sourceline>460</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that BusA user callout is called to intercept during transmission and
    The data flow shall be conditioned by the return of these callouts.
  
Test Object: 
    CanIf_Transmit()
    CANIF_BUSA_TX_INDICATION()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
    BusA user callouts are configured and its .h is included. 
  
Test Execution: 
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
    01: Set the return of BusA Tx callout stub BusA_Indication_Tx() to TRUE.
:-/,m4_ifelse( :else: )\-:m4_dnl
    01: Set the return of BusA Tx callout stub BusA_Indication_Tx() to FALSE.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
    02: Call CanIf_Transmit() with PDU PduR_TxPdu_0, and it returns successfully.
    03 Verify that BusA_Indication_Tx() is called and the data passed to it.
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
    04: Check that Can_Write() is called with the correct parameters.
:-/,m4_ifelse( :else: )\-:m4_dnl
    04: Check that Can_Write() is not called.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusATxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1034</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfBusATxIndication_API</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1037</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfBusATxIndication_GenerateAPI</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1036</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusAHeaderFile</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1041</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfBusAHeaderFile_Inclusion</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1042</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfBusATxIndication_API_ReturnFalse</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1038</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1386</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31212</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CDD_CanId/source/application/Tests.c.m4</sourcefile>
      <sourceline>185</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate correct transmission events for all upper layers including the call to the
    CanIf_TxConfirmation function.
  
Test Object: 
   CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful transmission (CanIf_Transmit followed by
        CanIf_TxConfirmation) for all four configured upper layers.
    02: VP(CanIf.ASR40.SWS_CanIf_00011_4, CanIf.SWS_CanIf_00439):
        PduR_CanIfTxConfirmation() must be called with the corresponding PduRDestPduHandleId.
    03: VP(CanIf.ASR40.SWS_CanIf_00011_2, CanIf.SWS_CanIf_00550):
        CanTp_TxConfirmation() must be called with the corresponding CanTpTxNPduConfirmationPduId.
    04: VP(CanIf.ASR40.SWS_CanIf_00011_1, CanIf.SWS_CanIf_00543):
        CanNm_TxConfirmation() must be called with the corresponding CanNmTxConfirmationPduId.
    05: VP(CanIf.EB.User_TxConfirmation, CanIf.SWS_CanIf_00551, CanIf.SWS_CanIf_00542):
        CddId_TxConfirmation() must be called with the corresponding CanIfTxPduSourcePduID.
    06: VP(CanIf.SWS_CanIf_00542):
        CddId_TxConfirmation() shall be accepted from CanIf as the User_TxConfirmation()
        callback for the CDD.
    07: VP(CanIf.SWS_CanIf_00542):
        The short name of CanIfUserUpperLayerConfig shall be used as prefix of the
        &lt;User&gt;_TxConfirmation function(configured as CddId).
    08: VP(CanIf.ASR40.SWS_CanIf_00011_3):
        For flow control frame CanTp_TxConfirmation() must be called with the corresponding
        CanTpTxFcNPduConfirmationPduId.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>891</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00542</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>600</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00439</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>570</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00543</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00550</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00551</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>604</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00671</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>390</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId.HandleIds</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>981</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1387</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31214</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CDD_CanId/source/application/Tests.c.m4</sourcefile>
      <sourceline>429</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   Call CanIf_RxIndication for the Rx PDUs assigned to the configured upper layers.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
    CanIfUpperLayerUseCanId must be enabled.
  
Test Execution: 
    01: Simulate a successful reception for each configured upper layer.
    02: VP (CanIf.SWS_CanIf_00012, CanIf.ASR40.PduIdUsage.Calls, CanIf.SWS_CanIf_00442,
           CanIf.SWS_CanIf_00441):
        PduR_CanIfRxIndication() must be called with the corresponding IPdu id.
    03: VP (CanIf.SWS_CanIf_00012,  CanIf.ASR40.PduIdUsage.Calls, CanIf.SWS_CanIf_00448,
           CanIf.SWS_CanIf_00441):
        CanTp_RxIndication() must be called with the corresponding NPdu id.
    04: VP (CanIf.SWS_CanIf_00012,  CanIf.ASR40.PduIdUsage.Calls, CanIf.SWS_CanIf_00445,
           CanIf.SWS_CanIf_00441):
        CanNM_RxIndication() must be called with the corresponding IPdu id.
    05: VP (CanIf.SWS_CanIf_00012,  CanIf.ASR40.PduIdUsage.Calls, CanIf.SWS_CanIf_00557,
           CanIf.SWS_CanIf_00441):
        CDD RxIndication must be called with the corresponding CDD Rx indication id.
    06: VP (CanIf.SWS_CanIf_00552):
        The short name of CanIfUserUpperLayerConfig shall be used as prefix of the
        &lt;User&gt;_RxIndication function(configured as CddId).
    07: VP (CanIf.SWS_CanIf_00012,  CanIf.ASR40.PduIdUsage.Calls, CanIf.SWS_CanIf_00441):
        CddId_RxIndication() shall be accepted from CanIf as the User_RxIndication() call-back
        for the CDD.
    08: VP(CanIf.EB.CanIfUpperLayerUseCanId):
        The CddId_RxIndication shall provide an additional parameter called CanId
        (CanIfUpperLayerUseCanId is enabled).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.PduIdUsage.Calls</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>30</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00552</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>605</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00441</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>571</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00442</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>572</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00445</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>573</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00448</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>574</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00557</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>609</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfUpperLayerUseCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>893</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId.HandleIds</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>981</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1388</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31218</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CDD_CanId/source/application/Tests.c.m4</sourcefile>
      <sourceline>658</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call CanIf_RxIndication for the Rx PDUs assigned to the configured upper layers and trigger DLC
    check errors.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_RxIndication with correct DLC for Rx NPdu (configured upper layer: PduR).
    02: The upper layer shall be informed in case of valid DLC value.
    03: VP (CanIf.EB.DlcPassedNotification):
        User_PassedDlcCheck shall be used to inform the upper layer about a valid DLC value.
    04: Only one DLC passed call-out per upper layer shall be used.
    05: Call CanIf_RxIndication with invalid (too short) DLC for Rx NPdu
        (configured upper layer: PduR).
    06: The upper layer shall be informed in case of invalid DLC value.
    07: VP (CanIf.EB.DlcErrorNotification):
        User_DlcErrorNotification shall be used to inform upper layer about an invalid DLC value.
    08: Only one DLC failed call-out per upper layer shall be used.
    09: VP (CanIf.ASR40.SWS_CanIf_00418):
        If DLC of CanIf_RxIndication() has invalid value, Det must be called with
        error code CANIF_E_PARAM_DLC.
    10: Call CanIf_RxIndication with correct DLC for Rx NPdu (configured upper layer: CanTp).
    11: The upper layer shall be informed in case of valid DLC value.
    12: VP (CanIf.EB.DlcPassedNotification):
        User_PassedDlcCheck shall be used to inform the upper layer about a valid DLC value.
    13: Only one DLC passed call-out per upper layer shall be used.
    14: Call CanIf_RxIndication with invalid (too short) DLC for Rx NPdu
        (configured upper layer: CanTp).
    15: The upper layer shall be informed in case of invalid DLC value.
    16: VP (CanIf.EB.DlcErrorNotification):
        User_DlcErrorNotification shall be used to inform upper layer about an invalid DLC value.
    17: Only one DLC failed call-out per upper layer shall be used.
    18: VP (CanIf.ASR40.SWS_CanIf_00418):
        If DLC of CanIf_RxIndication() has invalid value, Det must be called with
        error code CANIF_E_PARAM_DLC.
    19: Call CanIf_RxIndication with correct DLC for Rx NPdu (configured upper layer: CanNm).
    20: The upper layer shall be informed in case of valid DLC value.
    21: VP (CanIf.EB.DlcPassedNotification):
        User_PassedDlcCheck shall be used to inform the upper layer about a valid DLC value.
    22: Only one DLC passed call-out per upper layer shall be used.
    23: Call CanIf_RxIndication with invalid (too short) DLC for Rx NPdu
        (configured upper layer: CanNm).
    24: The upper layer shall be informed in case of invalid DLC value.
    25: VP (CanIf.EB.DlcErrorNotification):
        User_DlcErrorNotification shall be used to inform upper layer about an invalid DLC value.
    26: Only one DLC failed call-out per upper layer shall be used.
    27: VP (CanIf.ASR40.SWS_CanIf_00418):
        If DLC of CanIf_RxIndication() has invalid value, Det must be called with error
        code CANIF_E_PARAM_DLC.
    28: Call CanIf_RxIndication with correct DLC for Rx NPdu (configured upper layer: CddId).
    29: The upper layer shall be informed in case of valid DLC value.
    30: VP (CanIf.EB.DlcPassedNotification):
        User_PassedDlcCheck shall be used to inform the upper layer about a valid DLC value.
    31: Only one DLC passed call-out per upper layer shall be used.
    32: Call CanIf_RxIndication with  invalid (too short) DLC for Rx NPdu
        (configured upper layer: CddId).
    33: The upper layer shall be informed in case of invalid DLC value.
    34: VP (CanIf.EB.DlcErrorNotification):
        User_DlcErrorNotification shall be used to inform upper layer about an invalid DLC value.
    35: Only one DLC failed call-out per upper layer shall be used.
    36: VP (CanIf.ASR40.SWS_CanIf_00418):
        If DLC of CanIf_RxIndication() has invalid value, Det must be called with
        error code CANIF_E_PARAM_DLC.
  
Test Input: 
  
Test Output: 
    For those Rx PDUs with correct length:
    - The correct upper layer receive indication function is called with the correct PDU ID.
    - The DLC check passed notification function of the corresponding upper layer is called with the
    correct PDU ID.

    For the Rx PDUs with incorrect length:
    - The upper layer receive indication function is not called.
    - The DLC check failed ("DLC error") notification function is called with the correct PDU ID.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00418</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DlcErrorNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>894</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DlcPassedNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1389</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanIdTypeEnum_32</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CDD_CanId/source/application/Tests.c.m4</sourcefile>
      <sourceline>959</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that the type used to store the Can Id is generated
    as 32bit data type.
  
Test Object: 
    CanIfPublicCanIdTypeEnum
  
Test Precondition: 
    - configuration parameter CanIfPublicCanIdTypeEnum is set to value UINT32.
  
Test Execution: 
    01: Assign a value greater than 2^16 to a variable of type Can_IdType
    02: VP (CanIf.EB.CanIfPublicCanIdTypeEnum):
        Value stored as Can_IdType is equal to the original value.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicCanIdTypeEnum</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>883</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1390</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31212_Dlc</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CDD_CanId_Dlc/source/application/Tests.c</sourcefile>
      <sourceline>177</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that non-standard upper layers can be supported correctly for the
    message transmission path.
  
Test Object: 
   CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful transmission (CanIf_Transmit followed by
        CanIf_TxConfirmation) for all four configured upper layers.
    02: VP(CanIf.ASR40.SWS_CanIf_00011_4, CanIf.SWS_CanIf_00439):
        PduR_CanIfTxConfirmation() must be called with the corresponding PduRDestPduHandleId.
    03: VP(CanIf.ASR40.SWS_CanIf_00011_2, CanIf.SWS_CanIf_00550):
        CanTp_TxConfirmation() must be called with the corresponding CanTpTxNPduConfirmationPduId.
    04: VP(CanIf.ASR40.SWS_CanIf_00011_1, CanIf.SWS_CanIf_00543):
        CanNm_TxConfirmation() must be called with the corresponding CanNmTxConfirmationPduId.
    05: VP(CanIf.EB.User_TxConfirmation, CanIf.SWS_CanIf_00551, CanIf.SWS_CanIf_00542):
        CddId_TxConfirmation() must be called with the corresponding CanIfTxPduSourcePduID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>237</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>238</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>239</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00011_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>240</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>891</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00542</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>600</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00439</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>570</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00543</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>601</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00550</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>603</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00551</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>604</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00671</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>390</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId.TargetPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>982</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1391</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31214_Dlc</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CDD_CanId_Dlc/source/application/Tests.c</sourcefile>
      <sourceline>399</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: None.
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
    CanIfUpperLayerUseCanId must be enabled.
  
Test Execution: 
    01: Simulate a successful reception for each configured upper layer.
	02: Call CanIf_RxIndication() for for the configured receive events. 
    03: VP (CanIf.SWS_CanIf_00441, CanIf.SWS_CanIf_00552):
           Check that the correct upper layer callback function is called with the correct information.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00552</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>605</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00441</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>571</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.UseCddComIfHandleId.TargetPduId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>982</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1392</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31218_Dlc</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CDD_CanId_Dlc/source/application/Tests.c</sourcefile>
      <sourceline>566</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that DLC check notification functions are called for the different
    upper layers during the message reception.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_RxIndication() for reception of event with correct DLC.
	02: no DLC check notification function called
    03: Call CanIf_RxIndication() for reception of event with invalid DLC (too short).
    04: no DLC check notification function called
    05: reception event with correct DLC
    06: no DLC check notification function called
    07: reception event with invalid DLC (too short)
    08: DLC check failed notification function called
    09: reception event with correct DLC
    10: upper layer receive indication called
    11: no DLC check notification function called
    12: DLC check failed notification function called
    13: reception event with correct DLC
    14: upper layer receive indication called
    15: reception event with invalid DLC (too short)
    16: upper layer receive indication not called again
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DlcErrorNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>894</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DlcPassedNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>895</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1393</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanIdTypeEnum_16</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CDD_CanId_Dlc/source/application/Tests.c</sourcefile>
      <sourceline>783</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks that the type used to store the Can Id is generated
    as 16bit data type.
  
Test Object: 
    CanIfPublicCanIdTypeEnum
  
Test Precondition: 
    - configuration parameter CanIfPublicCanIdTypeEnum is set to value UINT16.
  
Test Execution: 
    01: Assign a value greater than 2^16 to a variable of type Can_IdType
    02: VP (CanIf.EB.CanIfPublicCanIdTypeEnum):
        Value stored as Can_IdType differs from the original value
        (because of truncation).
    03: Assign a value greater than 2^8 but smaller than 2^16 to a variable
        of type Can_IdType
    04: VP (CanIf.EB.CanIfPublicCanIdTypeEnum):
        Value stored as Can_IdType is equal to the original value
        (proof that type is of size 16bit and not 8bit).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicCanIdTypeEnum</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>883</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1394</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_CAN_44_TX_RX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can44/source/application/Tests.c</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify the transmission and reception with the driver compatibility set to ASR440.
  
Test Object: 
    Message transmit and reception
  
Test Precondition: 
    - CanIf is initialized and controller under test is started
  
Test Execution: 
    00: VP(CanIf.SWS_CanIf_00687):
        Start the controller.
    01: Simulate a successful transmission for a PDU.
    02: VP(CanIf.SWS_CanIf_00699, CanIf.EB.CanIfCanDriverCompatibility);
        Can_Write() API is called.
    03: Simulate a successful reception for a PDU.
    04: VP(CanIf.SWS_CanIf_00699, CanIf.EB.CanIfCanDriverCompatibility);
        PduR_CanIfRxIndication() API is called with the corresponding PDU-ID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfCanDriverCompatibility</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00687</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>636</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1395</internalId></specobject>
    <specobject>
      <id>TS_CANIF_44_CHECKWAKEUP</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can44/source/application/Tests.c</sourcefile>
      <sourceline>198</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the Can_CheckWakeup API is called properly on ASR440.
  
Test Object: 
    Check Wakeup
  
Test Precondition: 
    - CanIf is initialized
    - Used controllers are stopped
  
Test Execution: 
    01: Call Check wakeup.
    02: VP(CanIf.EB.CanIfCanDriverCompatibility);
        CanIf calls the driver with Can_CheckWakeup().
    03: Check that CanIf_CheckWakeup() returns E_NOT_OK when Can_CheckWakeup() returns CAN_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfCanDriverCompatibility</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1396</internalId></specobject>
    <specobject>
      <id>TS_CANIF_44_DRIVER_NOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can44/source/application/Tests.c</sourcefile>
      <sourceline>290</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that if Can_SetControllerMode API is called properly and
	returns E_NOT_OK, CanIf will also return E_NOT_OK.
  
Test Object: 
    Check that if driver returns E_NOT_OK, CanIf returns E_NOT_OK
  
Test Precondition: 
    - CanIf is initialized
    - Used controllers are stopped
  
Test Execution: 
    01: Set the return value of Can_SetControllerMode to E_NOT_OK
    02: Call CanIf_SetControllerMode to stop the controller
    03: VP(CanIf.EB.CanIfCanDriverCompatibility):
        Can_SetControllerMode is called, but it returns E_NOT_OK and
        consequently, CanIf_SetControllerMode returns E_NOT_OK
    04: Call CanIf_SetControllerMode to start the controller
    05: VP(CanIf.EB.CanIfCanDriverCompatibility):
        Can_SetControllerMode is called, but it returns E_NOT_OK and
        consequently, CanIf_SetControllerMode returns E_NOT_OK
    06: Call CanIf_SetControllerMode make the controller go to sleep
    07: VP(CanIf.EB.CanIfCanDriverCompatibility):
        Can_SetControllerMode is called, but it returns E_NOT_OK and
        consequently, CanIf_SetControllerMode returns E_NOT_OK
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfCanDriverCompatibility</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1397</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_ExtCanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>142</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Extended Can Id Configured Pdus accept Extended Can Id with and without FD flag set.
    Verify that other Rx message types are ignored.
  
Test Object: 
    Message reception
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01 VP(CanIf.EB.PBSelectable.Master): Check that CanIf_PBcfg.h exists and can be included
    02 VP(CanIf.EB.PBSelectable.FileName): Verify that files CanIf_V1_PBcfg.h and
       CanIf_V2_PBcfg.h exist.
    03 VP(CanIf.EB.PBSelectable.TypeName): Verify that types CanIf_V2_ConstConfigLayoutType
       and CanIf_V2_ConfigLayoutType exist.
    04 VP(CanIf.EB.PBSelectable.TypeName, CanIf.EB.PBSelectable.FileName): Verify that configuration
       variables CanIf_V1_ConfigLayout and CanIf_V2_ConfigLayout exist.
       Check indirectly (via usage of CanIf_V1_ConfigLayout and CanIf_V2_ConfigLayout)
       that files CanIf_V1_PBcfg.c and CanIf_V2_PBcfg.c have been included and were compiled.
    05 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard Can Id Rx
       messages
    06 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard FD Can Id Rx
       messages
    07 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard No FD Can Id
       Rx messages
    08 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended Can Id Rx
       messages
    09 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended FD Can Id Rx
       messages
    10 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended No FD Can Id
       Rx messages
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00596</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBSelectable.TypeName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>913</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBSelectable.FileName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>912</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.PBSelectable.Master</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>914</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1398</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_StdCanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>268</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Standard Can Id Configured Pdus accept Standard Can Id with and without FD flag set.
    Verify that other Rx message types are ignored.
  
Test Object: 
    Message reception
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard Can Id Rx
       messages
    02 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard FD Can Id Rx
       messages
    03 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard No FD Can Id
       Rx messages
    04 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended Can Id Rx
       messages
    05 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended FD Can Id Rx
       messages
    06 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended No FD Can Id
       Rx messages
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00596</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1399</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_ExtFdCanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>367</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Extended Fd Can Id Configured Pdus shall accept only Extended Can Id with FD flag
    set.
    Verify that other Rx message types are ignored.
  
Test Object: 
    Message reception
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard Can Id Rx
       messages
    02 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard FD Can Id Rx
       messages
    03 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard No FD Can Id
       Rx messages
    04 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended Can Id Rx
       messages
    05 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended FD Can Id Rx
       messages
    06 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended No FD Can Id
       Rx messages
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00596</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1400</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_StdFdCanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>466</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Standard Fd Can Id Configured Pdus shall accept only Standard Can Id with FD flag
    set.
    Verify that other Rx message types are ignored.
  
Test Object: 
    Message reception
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard Can Id Rx
       messages
    02 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard FD Can Id Rx
       messages
    03 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard No FD Can Id
       Rx messages
    04 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended Can Id Rx
       messages
    05 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended FD Can Id Rx
       messages
    06 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended No FD Can Id
       Rx messages
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00596</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1401</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_ExtNoFdCanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>561</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Extended no Fd Can Id Configured Pdus shall accept only Extended Can Id without FD
    flag set.
    Verify that other Rx message types are ignored.
  
Test Object: 
    Message reception
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard Can Id Rx
       messages
    02 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard FD Can Id Rx
       messages
    03 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard No FD Can Id
       Rx messages
    04 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended Can Id Rx
       messages
    05 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended FD Can Id Rx
       messages
    06 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended No FD Can Id
       Rx messages
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00596</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1402</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_StdNoFdCanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>660</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Standard no Fd Can Id Configured Pdus shall accept only Standard Can Id without FD
    flag set.
    Verify that other Rx message types are ignored.
  
Test Object: 
    Message reception
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard Can Id Rx
       messages
    02 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard FD Can Id Rx
       messages
    03 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Standard No FD Can Id
       Rx messages
    04 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended Can Id Rx
       messages
    05 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended FD Can Id Rx
       messages
    06 VP (CanIf.ECUC_CanIf_00596): test correct acceptance criteria for Extended No FD Can Id
       Rx messages
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00596</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>353</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1403</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_FdDlcCheckFailed</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>759</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Fd Can Id Configured Pdus shall reject Rx messages with FD flag set and with their
    DLCs less than the configured Rx Pdu's DLC.
  
Test Object: 
    Data length of the received CAN L-PDUs used by the CAN Interface.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: Vary the Dlc for a Extended Rx message.
    02 VP (CanIf.ECUC_CanIf_00599): test correct rejection criteria for the Extended Can Id
       Rx message with the previously set Dlc.
    03: Vary the Dlc for a Standard Rx message.
    04 VP (CanIf.ECUC_CanIf_00599): test correct rejection criteria for the Standard Can Id
       Rx message with the previously set Dlc.
    05: Vary the Dlc for a Extended Fd Rx message.
    06 VP (CanIf.ECUC_CanIf_00599): test correct rejection criteria for the  Extended Fd Can
       Id Rx message with the previously set Dlc.
    07: Vary the Dlc for a Standard Fd Rx message.
    08 VP (CanIf.ECUC_CanIf_00599): test correct rejection criteria for the  Standard Fd Can
       Id Rx message with the previously set Dlc.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00599</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1404</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_FdDlcCheckPass</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>892</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Fd Can Id Configured Pdus shall accept Rx messages with FD flag set and with their
    DLCs greater than the than the configured Rx Pdu's DLC an less or equal that the referenced
    EcuC Pdu/PduLength (CanIfRxPduRef).
  
Test Object: 
    Data length of the received CAN L-PDUs used by the CAN Interface.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: Vary the Dlc for a Extended Rx message.
    02 VP (CanIf.SWS_CanIf_00829): test correct acceptance criteria for the Extended Can Id
       Rx message with the previously set Dlc.
    03: Vary the Dlc for a Standard Rx message.
    04 VP (CanIf.SWS_CanIf_00829): test correct acceptance criteria for the Standard Can Id
       Rx message with the previously set Dlc.
    05: Vary the Dlc for a Extended Fd Rx message.
    06 VP (CanIf.SWS_CanIf_00829): test correct acceptance criteria for the  Extended Fd Can
       Id Rx message with the previously set Dlc.
    07: Vary the Dlc for a Standard Fd Rx message.
    08 VP (CanIf.SWS_CanIf_00829): test correct acceptance criteria for the  Standard Fd Can
       Id Rx message with the previously set Dlc.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00829</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>711</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1405</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_RxTests_FdDlcTrimmed</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>1027</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Fd Can Id Configured Pdus shall accept Rx messages with FD flag set and with their
    DLCs greater than the referenced EcuC Pdu/PduLength (CanIfRxPduRef).
    Test that the CanIf module will trim the Rx messages's Dlc to the referenced EcuC Pdu/PduLength
    (CanIfRxPduRef) and use this value to call PduR.
  
Test Object: 
    Data length of the received CAN L-PDUs used by the CAN Interface.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: Vary the Dlc for a Extended Rx message.
    02 VP (CanIf.EB.CanIfRxIndicationPduLength): test correct trimming of Rx Dlc for the Extended
       Can Id Rx message with the previously set Dlc.
    03: Vary the Dlc for a Standard Rx message.
    04 VP (CanIf.EB.CanIfRxIndicationPduLength): test correct trimming of Rx Dlc for the Standard
       Can Id Rx message with the previously set Dlc.
    05: Vary the Dlc for a Extended Fd Rx message.
    06 VP (CanIf.EB.CanIfRxIndicationPduLength): test correct trimming of Rx Dlc for the  Extended
       Fd Can Id Rx message with the previously set Dlc.
    07: Vary the Dlc for a Standard Fd Rx message.
    08 VP (CanIf.EB.CanIfRxIndicationPduLength): test correct trimming of Rx Dlc for the  Standard
       Fd Can Id Rx message with the previously set Dlc.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfRxIndicationPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>910</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1406</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_TxTests_DetChkSetDynamicTx1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>1158</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If API CanIf_SetDynamicTxId gets invoked with a Can Id representing a Can message
    with flexible data rate (STANDARD_FD_CAN or EXTENDED_FD_CAN) and the previously
    configured Can Id for the given Pdu Id is of Can 2.0 message format (STANDARD_CAN
    or EXTENDED_CAN), then CanIf_SetDynamicTxId shall call Det_ReportError() passing
    the error code CANIF_E_PARAM_CANID.
  
Test Object: 
    Det checks for STANDARD_CAN or EXTENDED_CAN Tx Pdus.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: Set CAN ID of dynamic Tx L-PDU.
    02 VP(CanIf.EB.CanIfSetDynamicTxIdFdDetCheck.1): Det will be triggered -&gt; check correct call.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfSetDynamicTxIdFdDetCheck.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>908</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1407</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_TxTests_DetChkSetDynamicTx2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>1255</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    If CanIf_SetDynamicTxId gets invoked with a Can Id representing a Can 2.0 message
    (STANDARD_CAN or EXTENDED_CAN and the previously configured Can Id for the given
    Pdu Id is of flexible data rate (STANDARD_FD_CAN or EXTENDED_FD_CAN),
    then CanIf_SetDynamicTxId shall call Det_ReportError() passing
    the error code CANIF_E_PARAM_CANID.
  
Test Object: 
    Det checks for STANDARD_CAN or EXTENDED_CAN Tx Pdus.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: Set CAN ID of dynamic Tx L-PDU.
    02 VP(CanIf.EB.CanIfSetDynamicTxIdFdDetCheck.1): Det will be triggered -&gt; check correct call.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfSetDynamicTxIdFdDetCheck.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>909</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1408</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_TxTests_FdBuffering</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>1353</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verify that Fd Can Id Configured Tx L-Pdus are buffered when the CanIf Tx buffering is set to
    True and CAN_BUSY is returned by a call of Can_Write().
    Mirroring is performed correctly as well.
  
Test Object: 
    Management of buffering of Tx Pdus by CAN Interface.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: Enable mirroring
    02: VP (CanIf.SWS_CanIf_00835, CanIf.SWS_CanIf_00836): perform transmission and check it is
        accepted.
    03: VP (CanIf.SWS_CanIf_00835, CanIf.SWS_CanIf_00836): check that the message was sent.
    04: VP (CanIf.SWS_CanIf_00835, CanIf.SWS_CanIf_00836, CanIf.SWS_CanIf_00188_1, CanIf.SWS_CanIf_00188_2): check that the
        message was sent with correct data (including the corresponding CanId - FD/EXTENDED flag set in the CanId).
    05: Set Can driver's Can_Write API return value to busy.
    06: Perform transmission and check it is accepted.
    07: Set Can driver's Can_Write API return value to ok.
    08: simulate call from Can Driver announcing the data was sent out on bus.
    09: VP (CanIf.SWS_CanIf_00905.Provision.CANID): check that the CanId is provided correctly
    10: VP (CanIf.SWS_CanIf_00835, CanIf.SWS_CanIf_00836): check that the Can_Write API was triggered
        by call to CanIf_TxConfirmation hence buffered data was sent out on bus.
    11: VP (CanIf.SWS_CanIf_00835, CanIf.SWS_CanIf_00836): check that the message was sent with correct
    12: VP (CanIf.SWS_CanIf_00835, CanIf.SWS_CanIf_00836): check that the Can_Write API was triggered
        by call to CanIf_TxConfirmation hence buffered data was sent out on bus.
    13: VP (CanIf.SWS_CanIf_00835, CanIf.SWS_CanIf_00836): check that the message was sent with correct
        data.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00835</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>713</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00836</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>716</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00188_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00188_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>468</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1409</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_TxTests_FdBufferOverwrite</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>1558</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that buffered Fd Can Id Configured Tx L-Pdus are overwritten with the most recent
    payload in case Can_Write responds CAN_BUSY when called.
  
Test Object: 
    Management of buffering of Tx Pdus by CAN Interface.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: set Can driver's Can_Write API return value to busy.
    02: perform transmission and check it is accepted.
    03: simulate call from Can Driver announcing the data was sent out on bus.
    04 VP (CanIf.SWS_CanIf_00068): check that the Can_Write API was triggered by call to
       CanIf_TxConfirmation hence buffered data was sent out on bus.
    05 VP (CanIf.SWS_CanIf_00068): check that the message was sent with the most recent data in the
       buffer.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00068</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1410</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_TxTests_ExtFdTxCancel</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>1690</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Can Flexible Data messages: verify that old data does not overwrite more recent data in buffer
    because of TX cancellation.
    Use Extended Flexible Data Can Ids.
  
Test Object: 
    CanIf_CancelTxConfirmation().
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: send TxPdu_ExtFDCanShdBuff2 (Can_Write returns CAN_OK).
    02: VP: check that the message was sent.
    03: send TxPdu_ExtFDCanShdBuff1 (Can_Write returns CAN_BUSY).
    04: VP: check that the Can_Write API was called - although no data should be actually written on
            Can module registers.
    05: send TxPdu_ExtFDCanShdBuff2 (Can_Write returns CAN_BUSY).
    06: VP: check that the Can_Write API was called - although no data should be actually written on
            Can module registers.
    07: Call CanIf_CancelTxConfirmation to cancel of the TX L-PDU TxPdu_ExtFDCanShdBuff2.
    08: VP: Tx Pdu's TxPdu_ExtFDCanShdBuff1 new data is sent on bus.
    09: VP (CanIf.ASR40.SWS_CanIf_00176): check sent data on bus.
    10: Call CanIf_TxConfirmation to indicate that TX L-PDU TxPdu_ExtFDCanShdBuff1 has been
        transmitted.
    11: VP (CanIf.ASR40.SWS_CanIf_00176): Verify that old data is not buffered and Can_Write called to send
           TX L-PDU TxPdu_ExtFDCanShdBuff2 with newer data.
    12: VP (CanIf.ASR40.SWS_CanIf_00176): check sent data on bus.
    13: VP (CanIf.ASR40.SWS_CanIf_00176): check that PduR_CanIfTxConfirmation has been called with the
           correct parameters for TX L-PDU TxPdu_ExtFDCanShdBuff1.
    14: Call CanIf_TxConfirmation to indicate that TX L-PDU TxPdu_ExtFDCanShdBuff1 has been
        transmitted.
        This will not trigger sending of data since it was sent already.
    15: VP (CanIf.ASR40.SWS_CanIf_00176): check that PduR_CanIfTxConfirmation has been called with the
           correct parameters for TX L-PDU TxPdu_ExtFDCanShdBuff2.
    16: VP: no other API called (Can_Write API already called for the pending messages).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1411</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_TxTests_StdFdTxCancel</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_FlexibleData/source/application/CanIf_ConTest_CanFd.c</sourcefile>
      <sourceline>1886</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Can Flexible Data messages: verify that old data does not overwrite more recent data in buffer
    because of TX cancellation.
    Use Standard Flexible Data Can Ids.
  
Test Object: 
    CanIf_CancelTxConfirmation().
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: send TxPdu_StdFDCanShdBuff2 (Can_Write returns CAN_OK).
    02: VP: check that the message was sent.
    03: send TxPdu_StdFDCanShdBuff1 (Can_Write returns CAN_BUSY).
    04: VP: check that the Can_Write API was called - although no data should be actually written on
            Can module registers.
    05: send TxPdu_StdFDCanShdBuff2 (Can_Write returns CAN_BUSY).
    06: VP: check that the Can_Write API was called - although no data should be actually written on
            Can module registers.
    07: Call CanIf_CancelTxConfirmation to cancel of the TX L-PDU TxPdu_StdFDCanShdBuff2.
    08: VP: Tx Pdu's TxPdu_StdFDCanShdBuff1 new data is sent on bus.
    09: VP (CanIf.ASR40.SWS_CanIf_00176): check sent data on bus.
    10: Call CanIf_TxConfirmation to indicate that TX L-PDU TxPdu_StdFDCanShdBuff1 has been
        transmitted.
    11: VP (CanIf.ASR40.SWS_CanIf_00176): Verify that old data is not buffered and Can_Write called to send
       TX L-PDU TxPdu_StdFDCanShdBuff2 with newer data.
    12: VP (CanIf.ASR40.SWS_CanIf_00176): check sent data on bus.
    13: VP (CanIf.ASR40.SWS_CanIf_00176): check that PduR_CanIfTxConfirmation has been called with the
       correct parameters for TX L-PDU TxPdu_StdFDCanShdBuff1.
    14: Call CanIf_TxConfirmation to indicate that TX L-PDU TxPdu_StdFDCanShdBuff1 has been
        transmitted.
        This will not trigger sending of data since it was sent already.
    15: VP: check that PduR_CanIfTxConfirmation has been called with the correct parameters for TX L-PDU
            TxPdu_StdFDCanShdBuff2.
    16: VP: no other API called (Can_Write API already called for the pending messages).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1412</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>CanIf_ConTest_CanFd_TxTests_DetChkNoFdPdus</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_Truncation/source/application/CanIf_ConTest_CanTruncation.c.m4</sourcefile>
      <sourceline>119</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    API CanIf_Transmit for configured STANDARD_CAN or EXTENDED_CAN Tx Pdus cannot be invoked with
    parameter PduInfoPtr.SduLength bigger than 8.
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
    In case CanIfTxPduTruncation is enabled and CanIfTxPduTruncateToFrame is True, Det will be called and CanIf_Transmit will return E_OK,
    limiting the length of the pdu to the maximum supported (considering the CAN pdu type) and only then proceeding with the transmission.
:-/m4_ifelse( :elif: ),PM_Permutation,p1,\-:m4_dnl
    In case CanIfTxPduTruncation is enabled and CanIfTxPduTruncateToFrame is false, CanIf_Transmit will return E_OK, limiting the length
    of the pdu to the length of the global PDU and only then proceeding with the transmission.
:-/m4_ifelse( :elif: ),m4_ifelse(PM_Permutation,p2,t,m4_ifelse(PM_Permutation,p3,t)),t,\-:m4_dnl
    In case CanIfTxPduTruncation is disabled and CanIfDetReportRuntimeError is enabled, CanIf shall report the runtime error
    CANIF_E_TXPDU_LENGTH_EXCEEDED and CanIf_Transmit return E_NOT_OK without further actions regardless of the value of CanIfTxPduTruncateToFrame.
:-/m4_ifelse( :elif: ),PM_Permutation,p4,\-:m4_dnl
    In case CanIfTxPduTruncation is disabled and CanIfDetReportRuntimeError is disabled, CanIf shall
    not report the runtime error CANIF_E_TXPDU_LENGTH_EXCEEDED and CanIf_Transmit return E_NOT_OK
    without further actions regardless of the value of CanIfTxPduTruncateToFrame.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Object: 
    Pdu truncation options and Det checks for STANDARD_FD_CAN or EXTENDED_FD_CAN Tx Pdus.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: perform transmission request of messages.
    02: check the return of CanIf_Transmit.
m4_ifelse(PM_Permutation,p4,\-:m4_dnl
    03: Det will not be triggered
:-/,m4_ifelse( :else: )\-:m4_dnl
    03: check if Det will be triggered -&gt; check correct call.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
    04: Check if Can_Write is called (transmission is done with correct length, 64 bytes) or not, i.e. no more
        action is done.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTransmitNonFdDetCheck</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>904</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduTruncateToFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>998</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00845</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>811</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00894.TruncateToFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>802</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00894.TruncateToPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduTruncateToFrame.Availability</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>999</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfDetReportRuntimeError</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>907</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfDetReportRuntimeErrorParam</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>906</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1413</internalId></specobject>
    <specobject>
      <id>CanIf_ConTest_CanFd_TxTests_DetChkFdPdus</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Can_Truncation/source/application/CanIf_ConTest_CanTruncation.c.m4</sourcefile>
      <sourceline>343</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
    In case CanIfTxPduTruncation is enabled and CanIfTxPduTruncateToFrame is True, Det will be called and CanIf_Transmit will return E_OK,
    limiting the length of the pdu to the maximum supported (considering the CAN pdu type) and only then proceeding with the transmission.
:-/m4_ifelse( :elif: ),PM_Permutation,p1,\-:m4_dnl
    In case CanIfTxPduTruncation is enabled and CanIfTxPduTruncateToFrame is false, CanIf_Transmit will return E_OK, limiting the length
    of the pdu to the length of the global PDU and only then proceeding with the transmission.
:-/m4_ifelse( :elif: ),m4_ifelse(PM_Permutation,p2,t,m4_ifelse(PM_Permutation,p3,t)),t,\-:m4_dnl
    In case CanIfTxPduTruncation is disabled and CanIfDetReportRuntimeError is enabled, CanIf shall report the runtime error
    CANIF_E_TXPDU_LENGTH_EXCEEDED and CanIf_Transmit return E_NOT_OK without further actions regardless of the value of CanIfTxPduTruncateToFrame.
:-/m4_ifelse( :elif: ),PM_Permutation,p4,\-:m4_dnl
    In case CanIfTxPduTruncation is disabled and CanIfDetReportRuntimeError is disabled, CanIf shall not
    report the runtime error CANIF_E_TXPDU_LENGTH_EXCEEDED and CanIf_Transmit return E_NOT_OK without further
    actions regardless of the value of CanIfTxPduTruncateToFrame.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Object: 
    Pdu truncation options and Det checks for STANDARD_FD_CAN or EXTENDED_FD_CAN Tx Pdus.
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: perform transmission request of messages.
    02: check the return of CanIf_Transmit.
m4_ifelse(PM_Permutation,p4,\-:m4_dnl
    03: Det will not be triggered
:-/,m4_ifelse( :else: )\-:m4_dnl
    03: check if Det will be triggered -&gt; check correct call.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
    04: Check if Can_Write is called (transmission is done with correct length, 64 bytes) or not, i.e. no more
        action is done.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTransmitFdDetCheck</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>905</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduTruncateToFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>998</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00845</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>811</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00900</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>812</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00894.TruncateToFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>802</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00894.TruncateToPduLength</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>803</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduTruncateToFrame.Availability</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>999</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfDetReportRuntimeError</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>907</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfDetReportRuntimeErrorParam</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>906</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1414</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_HookOnReception</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_CddHookOnRx/source/application/Tests.c</sourcefile>
      <sourceline>102</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate a reception on 2 different HRHs and test that
    a CDD custom function is called on success.
  
Test Object: 
    Message reception
  
Test Precondition: 
    - 2 HRHs configured, 1 with Can NO_FD and 1 with Can FD
    - Each HRH has assigned one Rx PDU
  
Test Execution: 
    01: Simulate the reception of a CAN 2.0 PDU through this HRH (CanIfHrhCfg_0).
    02: VP (CanIf.EB.HookOnReception.FunctionName):
        Cdd_HookOnReceptionFct() was called with the correct Can ID, data and Controller ID.
    03: Check if UL (PduR) was called for RxIndication
    04: Simulate the reception of a FD PDU through this HRH (CanIfHrhCfg_1).
    05: VP (CanIf.EB.HookOnReception.FunctionName):
        Cdd_HookOnReceptionFct() was called with the correct Can ID, data and Controller ID.
    06: Check if UL (PduR) was called for RxIndication
    07: Simulate the reception of a PDU with an invalid Can ID.
    08: VP(CanIf.EB.HookOnReception.FunctionName):
        Cdd_HookOnReceptionFct() was not called since the reception was unsuccessful.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.HookOnReception.Header</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>996</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.HookOnReception.FunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>997</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1415</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_ConTest_AccessToPnSupport_DependentOf_403_and_422_Trcv_UsedTrcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_DifferentAccess_PnSupport_403_and_422_Trcv/source/application/CanIf_ConTest_DifferentAccess_PnSupport_403_and_422_Trcv.c</sourcefile>
      <sourceline>44</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test uses 2 CAN Tranceivers:
     - the first one is a 4.0.3 CanTrcv
     - the second one is a 4.2.2 Cantrcv
  
Test Object: 
    This test checks that if CanIfPublicPnSupport and CanTrcvHwPnSupport are set to TRUE,
    CanIf_ClearTrcvWufFlag() calls CanTrcv_ClearTrcvWufFlag() and
    CanIf_CheckTrcvWakeFlag() calls CanTrcv_CheckWakeFlag(),
    for 4.0.3 CanTrcv and also for 4.2.2 CanTrcv, without throwing DET errors.
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CAN interface.
    02: Call CanIf_ClearTrcvWufFlag() API for 403 CanTrcv
    03: Check that if CanIfPublicPnSupport and CanTrcvHwPnSupport are set to TRUE
        CanIf_ClearTrcvWufFlag() calls CanTrcv_ClearTrcvWufFlag(),
        and no DET error is thrown (like in the case of CanIf_ClearTrcvWufFlag_HlpNoPn() API)
    04: Call CanIf_ClearTrcvWufFlag() API for 422 CanTrcv
    05: Check that if CanIfPublicPnSupport and CanTrcvHwPnSupport are set to TRUE
        CanIf_ClearTrcvWufFlag() calls CanTrcv_ClearTrcvWufFlag(),
        and no DET error is thrown (like in the case of CanIf_ClearTrcvWufFlag_HlpNoPn() API)
    06: Call CanIf_CheckTrcvWakeFlag() API for 403 CanTrcv
    07: Check that if CanIfPublicPnSupport and CanTrcvHwPnSupport are set to TRUE
        CanIf_CheckTrcvWakeFlag() calls CanTrcv_CheckWakeFlag(),
        and no DET error is thrown (like in the case of CanIf_CheckWakeFlag_HlpNoPn() API)
    08: Call CanIf_CheckTrcvWakeFlag() API for 422 CanTrcv
    09: Check that if CanIfPublicPnSupport and CanTrcvHwPnSupport are set to TRUE
        CanIf_CheckTrcvWakeFlag() calls CanTrcv_CheckWakeFlag(),
        and no DET error is thrown (like in the case of CanIf_CheckWakeFlag_HlpNoPn() API)
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00730</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>660</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1416</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_ConTest_AccessToPnSupport_DependentOfUsedTrcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_DifferentAccess_PnSupport_Single_Trcv/source/application/CanIf_ConTest_DifferentAccess_PnSupport_Trcv.c</sourcefile>
      <sourceline>42</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    General configuration as in test case CanIf_ComTest_AllOptDetOn however:
    * in p0, VendorSpecific container from a 4.0.3 CanTrcv is used
      (VendorSpecific is placed at the same level as CanTrcvGeneral)
    * in p1, VendorSpecific container from a 4.2.2 CanTrcv is used
      (VendorSpecific is placed within CanTrcvGeneral container)
    * in p2, VendorSpecific container from a 4.0.3 CanTrcv is used
      (VendorSpecific is placed within CanTrcvGeneral container)
    * in p3, VendorSpecific container from a 4.2.2 CanTrcv is used
      (VendorSpecific is placed at the same level as CanTrcvGeneral)
    * in p4, 4.0.3 CanTrcv is used
      (VendorSpecific container is not used)
    * in p5, 4.2.2 CanTrcv is used
      (VendorSpecific container is not used)
  
Test Object: 
    The 6 permutations of the test verify that CanTrcv_ClearTrcvWufFlag and CanTrcv_CheckWakeFlag functions are
    present in the CanIf_CanTrcvConfig structure if:
    p0 permutation
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/VendorSpecific/CanTrcvPnSupport is also set to TRUE in 4.0.3 CanTrcv configuration
    p1 permutation
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable is also set to TRUE in 4.2.2 CanTrcv configuration
    p2 permutation
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable is also set to TRUE in 4.0.3 CanTrcv configuration
    p3 permutation
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/VendorSpecific/CanTrcvPnSupport is also set to TRUE in 4.2.2 CanTrcv configuration
    p4 permutation
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcvHwPnSupport is also set to TRUE in 4.0.3 CanTrcv configuration
    p5 permutation
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcvHwPnSupport is also set to TRUE in 4.2.2 CanTrcv configuration
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CAN interface.
    02: Call CanIf_ClearTrcvWufFlag() API for 403 CanTrcv
    03: Check that if CanIfPublicPnSupport and CanTrcvHwPnSupport are set to TRUE
        CanIf_ClearTrcvWufFlag() calls CanTrcv_ClearTrcvWufFlag(),
        and no DET error is thrown (like in the case of CanIf_ClearTrcvWufFlag_HlpNoPn() API)
    04: Call CanIf_CheckTrcvWakeFlag() API for 403 CanTrcv
    05: Check that if CanIfPublicPnSupport and CanTrcvHwPnSupport are set to TRUE
        CanIf_CheckTrcvWakeFlag() calls CanTrcv_CheckWakeFlag(),
        and no DET error is thrown (like in the case of CanIf_CheckWakeFlag_HlpNoPn() API)
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00730</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>660</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1417</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30441</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_DispatchConfig/source/application/Tests.c.m4</sourcefile>
      <sourceline>133</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the wakeup notification callback is called if CanIf_CheckWakeup is called and a
    wakeup is signalled.
  
Test Object: 
    CanIf_CheckWakeup()
  
Test Precondition: 
    CAN Interface is initialized
    Controller 0 is in SLEEP mode
    CanIfCanDriverCompatibility must be set to ASR402
  
Test Execution: 
    01: Initialize CanIf.
    02: Call CanIf_CheckWakeup for ECUM_WKSOURCE_CAN_0.
    03: Simulate a wakeup event during the CanTrcv wakeup polling function
    04: VP (CanIf.EB.SetWakeupEvent, CanIf.EB.CanIfDispatchUserSetWakeupEventName):
        Verify that &amp;lt;User_SetWakeupEvent&amp;gt;() is called with the correct wakeup event
        (ECUM_WKSOURCE_CAN_0).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SetWakeupEvent</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>885</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfDispatchUserSetWakeupEventName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>886</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1418</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30442</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_DispatchConfig/source/application/Tests.c.m4</sourcefile>
      <sourceline>258</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the wakeup validation notification function is called during the next message
    reception.
  
Test Object: 
    CanIf_CheckValidation()
  
Test Precondition: 
    Previous test case(TS_CANIF_30441) was successful
  
Test Execution: 
    01: Restart controller 0.
    02: Simulate a message reception on controller 0.
    03: Call CanIf_CheckValidation for ECUM_WKSOURCE_CAN_0.
    04: VP (CanIf.ECUC_CanIf_00531, CanIf.SWS_CanIf_00564, CanIf.ECUC_CanIf_00549):
        Verify that &amp;lt;User_ValidationWakeupEvent&amp;gt;() is called due to the message reception
        when validation is checked.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00531</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>342</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00564</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>614</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00549</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>345</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1419</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30444</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_DispatchConfig/source/application/Tests.c.m4</sourcefile>
      <sourceline>375</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the configured bus-off notification function is called in case of a bus-off event.
  
Test Object: 
    CanIf_ControllerBusOff()
  
Test Precondition: 
    Previous test case(TS_CANIF_30442)  was successful
  
Test Execution: 
    01: Call CanIf_Transmit to start a message transmission. (Tx L-PDU 8)
    02: Simulate a bus-off event for controller 0.
    03: VP (CanIf.ECUC_CanIf_00525, CanIf.SWS_CanIf_00724, CanIf.SWS_CanIf_00560,
            CanIf.ECUC_CanIf_00547):
        Verify that &amp;lt;User_ControllerBusOff&amp;gt;() is called due to the bus-off event.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00525</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>337</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00724</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>659</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00560</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>612</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00547</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1420</internalId></specobject>
    <specobject>
      <id>TS_CANIF_UserControllerModeIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_DispatchConfig/source/application/Tests.c.m4</sourcefile>
      <sourceline>475</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that that the user configured controller mode indication function is called
    if CanIf_ControllerModeIndication() is called.
  
Test Object: 
    CanIf_ControllerModeIndication()
  
Test Precondition: 
    Module is initialized.
  
Test Execution: 
    01: Call CanIf_ControllerModeIndication(0,CANIF_CS_STARTED).
    02: VP (CanIf.SWS_CanIf_00711, CanIf.ASR40.SWS_CanIf_00687, CanIf.SWS_CanIf_00689, CanIf.SWS_CanIf_00690,
            CanIf.SWS_CanIf_00691, CanIf.SWS_CanIf_00692, CanIf.ECUC_CanIf_00683,
            CanIf.ECUC_CanIf_00684):
        Check that User_ControllerModeIndication(0,CANIF_CS_STARTED) is called 1x.
    03: Call CanIf_ControllerModeIndication(1,CANIF_CS_STOPPED).
    04: VP (CanIf.SWS_CanIf_00711, CanIf.ASR40.SWS_CanIf_00687, CanIf.SWS_CanIf_00689, CanIf.SWS_CanIf_00690,
            CanIf.SWS_CanIf_00691, CanIf.SWS_CanIf_00692, CanIf.ECUC_CanIf_00683,
            CanIf.ECUC_CanIf_00684):
        Check that User_ControllerModeIndication(1,CANIF_CS_STOPPED) is called 1x.
    05: Call CanIf_ControllerModeIndication(2,CANIF_CS_SLEEP).
    06: VP (CanIf.SWS_CanIf_00711, CanIf.ASR40.SWS_CanIf_00687, CanIf.SWS_CanIf_00689, CanIf.SWS_CanIf_00690,
            CanIf.SWS_CanIf_00691, CanIf.SWS_CanIf_00692, CanIf.ECUC_CanIf_00683,
            CanIf.ECUC_CanIf_00684):
        Check that User_ControllerModeIndication(2,CANIF_CS_SLEEP) is called 1x.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00711</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>656</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00687</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>248</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00689</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>637</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00690</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>638</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00691</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>639</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00692</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>640</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00683</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>392</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00684</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>393</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1421</internalId></specobject>
    <specobject>
      <id>TS_CANIF_UserTrcvModeIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_DispatchConfig/source/application/Tests.c.m4</sourcefile>
      <sourceline>593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that that the user configured transceiver mode indication function is called
    if CanIf_TrcvModeIndication() is called.
  
Test Object: 
    CanIf_TrcvModeIndication()
  
Test Precondition: 
    Module is initialized.
  
Test Execution: 
    01: Call CanIf_TrcvModeIndication(0,CANTRCV_TRCVMODE_NORMAL).
    02: VP (CanIf.SWS_CanIf_00712, CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00695_1,
            CanIf.SWS_CanIf_00696, CanIf.SWS_CanIf_00698, CanIf.ECUC_CanIf_00685,
            CanIf.ECUC_CanIf_00685):
        Check that User_TrcvModeIndication(0,CANTRCV_TRCVMODE_NORMAL) is called 1x.
    03: Call CanIf_TrcvModeIndication(1,CANTRCV_TRCVMODE_STANDBY).
    04: VP (CanIf.SWS_CanIf_00712, CanIf.SWS_CanIf_00693, CanIf.SWS_CanIf_00695_1,
            CanIf.SWS_CanIf_00696, CanIf.SWS_CanIf_00698, CanIf.ECUC_CanIf_00685,
            CanIf.ECUC_CanIf_00685):
        Check that User_TrcvModeIndication(1,CANTRCV_TRCVMODE_STANDBY) is called 1x.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00712</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>657</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00693</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>641</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00695_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>644</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00696</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>647</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00698</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>649</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00685</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>394</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00686</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>395</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1422</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_ReceiveDuplicateId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_DuplicateRxCanId/source/application/Tests.c</sourcefile>
      <sourceline>98</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Receive through 2 different HRHs with the same Id
  
Test Object: 
    Message reception
  
Test Precondition: 
    - 2 HRHs configured with the IDs 0 and different types
    - Each HRH has assigned one Rx PDU with the PduR as upper layer
  
Test Execution: 
    01: Simulate the reception of a CAN 2.0 PDU through this HRH.
    02: VP (CanIf.SWS_CanIf_00135, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00415):
        PduR_CanIfRxIndication() was called with the correct data and PDU ID.
    03: Simulate the reception of a FD PDU through this HRH.
    04: VP (CanIf.SWS_CanIf_00135, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00415,CanIf.EB.CanIfDuplicateCanIfRxPduCanId):
        PduR_CanIfRxIndication() was called with the correct data and PDU ID.
    05: Simulate the reception of a PDU that has a duplicate CanID on the same HRH.
    06: VP (CanIf.SWS_CanIf_00135, CanIf.SWS_CanIf_00415, CanIf.EB.CanIfDuplicateCanIfRxPduCanId):
        PduR_CanIfRxIndication() was called with the correct data and PDU ID.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfDuplicateCanIfRxPduCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>911</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1423</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30871</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_EmptyCallouts/source/application/Tests.c</sourcefile>
      <sourceline>237</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that disabling RxIndication/TxConfirmation callouts is possible.
  
Test Object: 
    Tx/Tx callback configuration
  
Test Precondition: 
    Previous test case (TS_CANIF_30871) was successful
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Call CanIf_SetControllerMode to start controller 2.
    03: Simulate a message reception on controller 2.
    04: Verify that RxIndication functions of no modules are called.
    05: Simulate a message transmission on controller 2.
    06: VP (CanIf.SWS_CanIf_00438):
        Verify that TxConfirmation functions of no modules are called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00438</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>569</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1424</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CONTROLLERMODETYPE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_EmptyCallouts/source/application/Tests.c</sourcefile>
      <sourceline>352</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanIf_ControllerModeType enumeration values
  
Test Object: 
    CanIf_ControllerModeType enum
  
Test Precondition: 
    CanIf.h included
  
Test Execution: 
    01: Assign CANIF_CS_UNINIT to a variable of CanIf_ControllerModeType.
    02: VP(CanIf.ASR40.ControllerModeType):
        Check that CanIf_ControllerModeType variable equals 0.
    03: Assign CANIF_CS_SLEEP to a variable of CanIf_ControllerModeType.
    04: VP(CanIf.ASR40.ControllerModeType):
        Check that CanIf_ControllerModeType variable equals 1.
    05: Assign CANIF_CS_STARTED to a variable of CanIf_ControllerModeType.
    06: VP(CanIf.ASR40.ControllerModeType):
        Check that CanIf_ControllerModeType variable equals 2.
    07: Assign CANIF_CS_STOPPED to a variable of CanIf_ControllerModeType.
    08: VP(CanIf.ASR40.ControllerModeType):
        Check that CanIf_ControllerModeType variable equals 3.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.ControllerModeType</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>231</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1425</internalId></specobject>
    <specobject>
      <id>TS_CANIF_PDUMODETYPE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_EmptyCallouts/source/application/Tests.c</sourcefile>
      <sourceline>429</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanIf_PduModeType enumeration values
  
Test Object: 
    CanIf_PduModeType enum
  
Test Precondition: 
    CanIf.h included
  
Test Execution: 
    01: Assign CANIF_OFFLINE to a variable of CanIf_PduModeType.
    02: VP(CanIf.SWS_CanIf_00137):
        Check that CanIf_PduModeType variable equals 0.
    03: Assign CANIF_TX_OFFLINE to a variable of CanIf_PduModeType.
    04: VP(CanIf.SWS_CanIf_00137):
        Check that CanIf_PduModeType variable equals 1.
    05: Assign CANIF_TX_OFFLINE_ACTIVE to a variable of CanIf_PduModeType.
    06: VP(CanIf.SWS_CanIf_00137):
        Check that CanIf_PduModeType variable equals 2.
    07: Assign CANIF_ONLINE to a variable of CanIf_PduModeType.
    08: VP(CanIf.SWS_CanIf_00137):
        Check that CanIf_PduModeType variable equals 3.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00137</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>734</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1426</internalId></specobject>
    <specobject>
      <id>TS_CANIF_NOTIFSTATUSTYPE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_EmptyCallouts/source/application/Tests.c</sourcefile>
      <sourceline>503</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test CanIf_NotifStatusType enumeration values
  
Test Object: 
    CanIf_NotifStatusType enum
  
Test Precondition: 
    CanIf.h included
  
Test Execution: 
    01: Assign CANIF_NO_NOTIFICATION to a variable of CanIf_NotifStatusType.
    02: VP(CanIf.SWS_CanIf_00201):
        Check that CanIf_NotifStatusType variable equals 0.
    03: Assign CANIF_TX_RX_NOTIFICATION to a variable of CanIf_NotifStatusType.
    04: VP(CanIf.SWS_CanIf_00201):
        Check that CanIf_NotifStatusType variable equals 1.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>737</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1427</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CANFD_BIT_EXTENDED_ADDR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_EmptyCallouts/source/application/Tests.c</sourcefile>
      <sourceline>555</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmit CAN frames with various CanIds (some configured for CAN FD,
    some not, standard and extended addressing) and verify that the CAN FD bit and extension ID bit is correctly
    set in call to Can_Write.
  
Test Object: 
    CAN FD bit
  
Test Precondition: 
  
Test Execution: 
    loop for some TxPdus with different CanIds and different settings of CanIdType
    01: Simulate the transmission of a Tx PDU.
    02 VP: Can_Write() was called with correct CanId, correct CAN FD bit and identifier
           extension bit set.
    03: Confirm the Pdu transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00590</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1428</internalId></specobject>
    <specobject>
      <id>TS_CANIF_SETBAUDRATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_EmptyCallouts/source/application/Tests.c</sourcefile>
      <sourceline>664</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call CanIf_SetBaudrate with various valid ControllerIds and valid/invalid BaudRateConfigIDs and
    verify that calls to Can_SetBaudrate are correct.
  
Test Object: 
    CanIf_SetBaudrate
  
Test Precondition: 
  
Test Execution: 
    loop for some ControllerIds and BaudRateConfigIDs
    01: call CanIf_SetBaudrate
    02 VP: Can_SetBaudrate was called with identical parameters,
           invalid BaudRateConfigID does not cause an error
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00868</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>770</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1429</internalId></specobject>
    <specobject>
      <id>TS_CANIF_SETBAUDRATE_NOK</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_EmptyCallouts/source/application/Tests.c</sourcefile>
      <sourceline>716</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call CanIf_SetBaudrate with valid parameter but let Can_SetBaudrate return an E_NOT_OK
  
Test Object: 
    CanIf_SetBaudrate
  
Test Precondition: 
  
Test Execution: 
    01: let Can_SetBaudrate stub return E_NOT_OK
    02 VP: call CanIf_SetBaudrate with valid parameter and check the E_NOT_OK is returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00867</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>769</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1430</internalId></specobject>
    <specobject>
      <id>TS_CANIF_SETBAUDRATE_INVALID</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_EmptyCallouts/source/application/Tests.c</sourcefile>
      <sourceline>759</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call CanIf_SetBaudrate with invalid ControllerIds and verify that error is reported
  
Test Object: 
    CanIf_SetBaudrate
  
Test Precondition: 
  
Test Execution: 
    loop for some invalid ControllerIds
    01: call CanIf_SetBaudrate
    02 VP: CANIF_E_PARAM_CONTROLLERID error is reported to DET, E_NOT_OK is returned
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00869</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>771</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1431</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_E_NOT_SLEEP_DET</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorRepMultCtrl/source/application/Tests.c</sourcefile>
      <sourceline>81</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the Det error CANIF_E_NOT_SLEEP is reported if CanIf_CheckWakeup
    is called for a controller that is not in sleep.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_CheckWakeup for the controller, before transition to sleep mode.
    02: CanIf_CheckWakeup returns E_NOT_OK
    03: VP (CanIf.EB.CANIF679_2):
        The Det error CANIF_E_NOT_SLEEP is reported.
    04: Move the controller to the mode SLEEP.
    05: Simulate ControllerModeIndication
    06: VP(CanIf.ASR40.SWS_CanIf_00541):
        Controller mode is as expected.
    07: Force the Can_CheckWakeup() to return E_NOT_OK.
    08: Call CanIf_CheckWakeup for the controller (no wakeup).
    09: VP(CanIf.ASR40.SWS_CanIf_00678):
        CanIf_CheckWakeup returns E_NOT_OK.
    10: VP (CanIf.EB.CANIF679_2):
        The Det error CANIF_E_NOT_SLEEP is not reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF679_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00541</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00678</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfDispatchUserSetWakeupEventName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>886</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1432</internalId></specobject>
    <specobject>
      <id>TS_CANIF_BusOff_InvalidCtrlId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorRepMultCtrl/source/application/Tests.c</sourcefile>
      <sourceline>204</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ControllerBusOff reports a DET error when called with invalid CanIfControllerId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIfPublicSingleCtrlOpt is disabled.
  
Test Execution: 
    01: Call CanIf_ControllerBusOff with an invalid CanIfControllerId.
    02: VP(CanIf.SWS_CanIf_00429):
        Check if Det error CANIF_E_PARAM_CONTROLLER is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00429</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>566</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1433</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ControllerModeIndication_InvalidCtrl_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorRepMultCtrl/source/application/Tests.c</sourcefile>
      <sourceline>251</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ControllerModeIndication reports a DET error if CanController id has an
    invalid value.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIfPublicSingleCtrlOpt is disabled.
  
Test Execution: 
    01: Call CanIf_ControllerModeIndication with an invalid CanController id.
    02: VP(CanIf.SWS_CanIf_00700):
        Check if Det error CANIF_E_PARAM_CONTROLLER is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00700</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>651</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1434</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_InvalidSduDataPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorRepMultCtrl/source/application/Tests.c</sourcefile>
      <sourceline>299</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CancelTxConfirmation reports a DET error when given a NULL_PTR in SduDataPtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY is disabled.
  
Test Execution: 
    01: Call CanIf_CancelTxConfirmation with a NULL_PTR in SduDataPtr.
    02: VP(CanIf.EB.CancelTxConfirmation.SduDataPtr.DetCheck):
        Check if Det error CANIF_E_PARAM_POINTER is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CancelTxConfirmation.SduDataPtr.DetCheck</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>900</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1435</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_InvalidDLC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorRepMultCtrl/source/application/Tests.c</sourcefile>
      <sourceline>351</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CancelTxConfirmation reports a DET error when given an invalid value in the
    SduLength.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY is disabled.
  
Test Execution: 
    01: Call CanIf_CancelTxConfirmation with an invalid value in SduLength.
    02: VP(CanIf.EB.CancelTxConfirmationDLC):
        Check if Det error CANIF_E_PARAM_DLC is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CancelTxConfirmationDLC</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>899</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1436</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_InvalidPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorRepMultCtrl/source/application/Tests.c</sourcefile>
      <sourceline>405</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CancelTxConfirmation reports a DET error when given an invalid PduId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY is disabled.
  
Test Execution: 
    01: Call CanIf_CancelTxConfirmation with an invalid value in PduId.
    02: VP(CanIf.ASR40.SWS_CanIf_00424):
        Check if Det error CANIF_E_PARAM_LPDU is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00424</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1437</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30844</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>311</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when CanIf_SetControllerMode / CanIf_GetControllerMode is
    called before the CAN Interface is initialized.
    Verify that the correct Det parameters are used for each function.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_SetControllerMode.
    02: VP (CanIf.SWS_CanIf_00003, CanIf.ASR40.SWS_CanIf_00661.CanIf_SetControllerMode):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_SetControllerMode returns
        E_NOT_OK.
    03: Call CanIf_GetControllerMode.
    04: VP (CanIf.EB.GetControllerMode.Signature.Mirroring.OFF, CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerMode):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_GetControllerMode returns
        E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetControllerMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>136</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>137</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1438</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ClearTrcvWufFlag_NOINIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>393</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported if CanIf_ClearTrcvWufFlag
    is called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_ClearTrcvWufFlag without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_ClearTrcvWufFlag):
        Verify that CANIF_E_UNINIT is reported to the DET with correct API Id and error Id
        and callout is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ClearTrcvWufFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>153</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1439</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckTrcvWakeFlag_NOINIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>443</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported if CanIf_ChecktrcvWakeFlagIndication
    is called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_CheckTrcvWakeFlag without initialization
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckTrcvWakeFlag):
        Verify that CANIF_E_UNINIT is reported to the DET with correct API Id and error Id
        and callout is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckTrcvWakeFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>154</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1440</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ClearTrcvWufFlagIndication_NOINIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>493</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported if CanIf_ClearTrcvWufFlagIndication
    is called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_ClearTrcvWufFlagIndication without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_ClearTrcvWufFlagIndication, CanIf.SWS_CanIf_00806):
        Verify that CANIF_E_UNINIT is reported to the DET with correct API Id and error Id
        and callout is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ClearTrcvWufFlagIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>160</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00806</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>695</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1441</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckTrcvWakeFlagIndication_NOINIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>543</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported if CanIf_ChecktrcvWakeFlagIndication
    is called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_ChecktrcvWakeFlagIndication without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckTrcvWakeFlagIndication, CanIf.SWS_CanIf_00810):
        Verify that CANIF_E_UNINIT is reported to the DET with correct API Id and error Id
        and callout is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckTrcvWakeFlagIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>161</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00810</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>698</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1442</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanIf_ConfirmPnAvailability_NOINIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported if CanIf_ConfirmPnAvailability
    is called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_ConfirmPnAvailability without initialization
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_ConfirmPnAvailability, CanIf.SWS_CanIf_00817):
        Verify that CANIF_E_UNINIT is reported to the DET with correct API Id and error Id
        and callout is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ConfirmPnAvailability</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>159</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00817</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>704</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1443</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanIf_SetBaudrate_NOINIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>643</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported if CanIf_SetBaudrate
    is called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_SetBaudrate without initialization
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_SetBaudrate, CanIf.SWS_CanIf_00867):
        Verify that CANIF_E_UNINIT is reported to the DET with correct API Id and error Id
        and callout is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetBaudrate</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>164</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00867</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>769</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00870</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1044</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1444</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30843</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>690</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when CanIf_Transmit / CanIf_CancelTransmit
    is called before the CAN Interface is initialized.
    Verify that the correct Det parameters are used for each function.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_Transmit without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_Transmit, CanIf.ASR40.SWS_CanIf_00005):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_Transmit returns E_NOT_OK.
    03: Call CanIf_CancelTransmit without initialization.
    04: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_CancelTransmit):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_CancelTransmit returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_Transmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>138</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_CancelTransmit</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>139</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1445</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30842</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>764</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when one of the CanIf_ReadXxx functions is called before
    the CAN Interface is initialized.
    Verify that the correct Det parameters are used for each function.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_ReadRxPduData without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadRxPduData, CanIf.ASR40.SWS_CanIf_00194):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_ReadRxPduData returns E_NOT_OK.
    03: Call CanIf_ReadTxNotifStatus without initialization.
    04: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadTxNotifStatus, CanIf.ASR40.SWS_CanIf_00202):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_ReadTxNotifStatus returns
        CANIF_NO_NOTIFICATION.
    05: Call CanIf_ReadRxNotifStatus without initialization.
    06: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadRxNotifStatus, CanIf.ASR40.SWS_CanIf_00230):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_ReadRxNotifStatus returns
        CANIF_NO_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadRxPduData</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>140</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadTxNotifStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>141</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ReadRxNotifStatus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>142</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1446</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30841</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>868</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when a PDU mode function is called before the CAN Interface
    is initialized.
    Verify that the correct Det parameters are used for each function.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_SetPduMode without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_SetPduMode, CanIf.SWS_CanIf_00008):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_SetPduMode returns E_NOT_OK.
    03: Call CanIf_GetPduMode without initialization.
    04: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_GetPduMode, CanIf.SWS_CanIf_00009):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_GetPduMode returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetPduMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>143</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetPduMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>144</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1447</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30840</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>946</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when CanIf_SetDynamicTxId is called before the CAN
    Interface is initialized.
    Verify that the correct Det parameters are used for each function.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_SetDynamicTxId without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_SetDynamicTxId, CanIf.ASR40.SWS_CanIf_00189):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_SetDynamicTxId returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetDynamicTxId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>145</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1448</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30839</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1000</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when a transceiver handling function is called before the
    CAN Interface is initialized.
    Verify that the correct Det parameters are used for each function.
  
Test Object: 
    CanIf transceiver functions
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_SetTrcvMode without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_SetTrcvMode, CanIf.SWS_CanIf_00287):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_SetTrcvMode returns E_NOT_OK.
    03: Call CanIf_GetTrcvMode without initialization.
    04: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTrcvMode, CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_GetTrcvMode returns
        E_NOT_OK.
    05: Call CanIf_GetTrcvWakeupReason without initialization.
    06: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTrcvWakeupReason, CanIf.SWS_CanIf_00289):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_GetTrcvWakeupReason returns
        E_NOT_OK.
    07: Call CanIf_SetTrcvWakeupMode without initialization.
    08: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_SetTrcvWakeupMode, CanIf.SWS_CanIf_00290):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_SetTrcvWakeupMode returns
        E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00287</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00289</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetTrcvMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>146</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTrcvMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>147</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTrcvWakeupReason</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>148</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_SetTrcvWakeupMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>149</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1449</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30838</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1125</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when a wakeup polling function is called before the CAN
    Interface is initialized.
    Verify that the correct Det parameters are used for each function.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_CheckWakeup without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckWakeup):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_CheckWakeup returns E_NOT_OK.
    03: Call CanIf_CheckValidation without initialization.
    04: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckValidation, CanIf.SWS_CanIf_00178):
        Verify that CANIF_E_UNINIT is reported to the DET and CanIf_CheckValidation returns
        E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckWakeup</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>150</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_CheckValidation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>151</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1450</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30837</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1200</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a DET error is reported when a callback function is called before the CAN Interface
    is initialized.
    Verify that the correct Det parameters are used for each function.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf not initialized.
  
Test Execution: 
    01: Call CanIf_TxConfirmation without initialization.
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_TxConfirmation, CanIf.SWS_CanIf_00007):
        Verify that CANIF_E_UNINIT is reported to the DET.
    03: Call CanIf_RxIndication without initialization.
    04: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_RxIndication, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006):
        Verify that CANIF_E_UNINIT is reported to the DET.
    05: Call CanIf_CancelTxConfirmation without initialization.
    06: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_CancelTxConfirmation, CanIfCanIf.EB.Rev2.CancelTxConfirmation):
        Verify that CANIF_E_UNINIT is reported to the DET.
    07: Call CanIf_ControllerBusOff without initialization.
    08: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_ControllerBusOff, CanIf.SWS_CanIf_00218):
        Verify that CANIF_E_UNINIT is reported to the DET.
    09: Call CanIf_ControllerModeIndication without initialization.
    10: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_ControllerModeIndication, CanIf.ASR40.SWS_CanIf_00699):
        Verify that CANIF_E_UNINIT is reported to the DET.
    11: Call CanIf_TrcvModeIndication without initialization.
    12: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_TrcvModeIndication, CanIf.ASR40.SWS_CanIf_00764):
        Verify that CANIF_E_UNINIT is reported to the DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.CancelTxConfirmation</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00218</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>478</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_TxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>155</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_RxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>156</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_CancelTxConfirmation</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>157</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ControllerBusOff</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>158</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_ControllerModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>162</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_TrcvModeIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>163</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00764</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>219</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1451</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetTxConfStateDetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1354</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error is reported when CanIf_GetTxConfirmationState() is
    called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    - CAN Interface is not initialized yet.
    - CanIf_GetTxConfirmationState() is enabled in the configuration.
  
Test Execution: 
    01: Call CanIf_GetTxConfirmationState() for a valid controller.
    02: VP (CanIf.SWS_CanIf_00734, CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTxConfirmationState):
        - CanIf_GetTxConfirmationState() returns CANIF_NO_NOTIFICATION.
        - CanIf_GetTxConfirmationState() reports the development error
          CANIF_E_UNINIT.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00734</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>661</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetTxConfirmationState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>152</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1452</internalId></specobject>
    <specobject>
      <id>TS_CANIF_EnableBusMirroringDetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1417</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error is reported when CanIf_EnableBusMirroring() is
    called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    - CanIfBusMirroringSupport configured as TRUE.
    - CAN Interface is not initialized yet.
  
Test Execution: 
    01: Call CanIf_EnableBusMirroring() with incorrect ID
    02: VP (CanIf.SWS_CanIf_91005.ReturnValue, CanIf.ASR40.SWS_CanIf_00661.CanIf_EnableBusMirroring):
        - CanIf_EnableBusMirroring() returns E_NOT_OK.
        - CanIf_EnableBusMirroring() reports the development error
          CANIF_E_UNINIT.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_EnableBusMirroring</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>165</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91005.ReturnValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1453</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetControllerErrorStateDetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1479</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error is reported when CanIf_GetControllerErrorState() is
    called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    - CAN Interface is not initialized yet.
  
Test Execution: 
    01: Call CanIf_GetControllerErrorState() with an invalid pointer
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerErrorState):
        - GetControllerErrorState() returns E_NOT_OK.
        - GetControllerErrorStateg() reports the development error
          CANIF_E_UNINIT.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerErrorState</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>166</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1454</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetControllerTxErrorCounterDetUninit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1536</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a Det error is reported when CanIf_GetControllerTxErrorCounter() is
    called before the CAN Interface is initialized.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    - CAN Interface is not initialized yet.
  
Test Execution: 
    01: Call CanIf_GetControllerTxErrorCounter() with an invalid pointer
    02: VP (CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerTxErrorCounter):
        - GetControllerTxErrorCounter() returns E_NOT_OK.
        - GetControllerTxErrorCounter() reports the development error
          CANIF_E_UNINIT.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00661.CanIf_GetControllerTxErrorCounter</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>167</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1455</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30240</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetControllerMode reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetControllerMode with an invalid value in Controller.
    02: VP (CanIf.SWS_CanIf_00003, CanIf.SWS_CanIf_00311):
        Verify that CANIF_E_PARAM_CONTROLLERID reported to the DET module and
        CanIf_SetControllerMode returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1456</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30241</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1649</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetControllerMode reports a DET error when given an invalid Controller mode.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetControllerMode with an invalid Controller mode value.
    02: VP (CanIf.SWS_CanIf_00774, CanIf.SWS_CanIf_00003):
        Check if Det error CANIF_E_PARAM_CONTROLLERMODE was reported and CanIf_SetControllerMode
        returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00774</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>682</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1457</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ControllerModeIndication_InvCtrl</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1705</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ControllerModeIndication reports a DET error when given an value other than 0
    for Controller, if single controller optimization is enabled.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIfPublicSingleCtrlOpt is enabled.
  
Test Execution: 
    01: Call CanIf_ControllerModeIndication with an value Controller id 1, which is configured.
    02: VP (CanIf.SWS_CanIf_00700):
        Verify that CANIF_E_PARAM_CONTROLLER reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00700</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>651</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1458</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ControllerModeIndication_InvMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1753</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the behavior of the API callback service
    CanIf_ControllerModeIndication() if invoked with an invalid
    value for parameter ControllerMode.
  
Test Object: 
    CanIf_ControllerModeIndication()
  
Test Precondition: 
    - Module is initialized.
    - DET is enabled
  
Test Execution: 
    01: Bring controller 0 to mode CANIF_CS_STARTED
    02: Call CanIf_SetControllerMode with mode CANIF_CS_STOPPED
    03: Invoke the mode indication with CANIF_CS_UNINIT
    04: VP (CanIf.EB.CanIf_ControllerModeIndicationDetCheck):
        Check that CanIf_ControllerModeIndication reports to DET with:
        ErrorId := CANIF_E_PARAM_CTRLMODE
    05: VP (CanIf.EB.CanIf_ControllerModeIndicationDetCheck):
        Check that CanSM_ControllerModeIndication was not invoked
    06: VP (CanIf.EB.CanIf_ControllerModeIndicationDetCheck):
        CanIf does not change the internal controller mode
        (still set to CANIF_CS_STARTED)
  
Test Input: 
  
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIf_ControllerModeIndicationDetCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>901</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1459</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30242</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1845</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetControllerMode reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetControllerMode with an invalid value in Controller.
    02: VP (CanIf.EB.GetControllerMode.Signature.Mirroring.OFF, CanIf.SWS_CanIf_00313):
        Verify that CANIF_E_PARAM_CONTROLLERID is reported to the DET module and
        CanIf_GetControllerMode returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1460</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30265</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1902</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetControllerMode reports a DET error when given an invalid
    ControllerModePtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetControllerMode with an invalid value in ControllerModePtr (NULL_PTR).
    02: VP (CanIf.EB.GetControllerMode.Signature.Mirroring.OFF, CanIf.SWS_CanIf_00656):
        Verify that CANIF_E_PARAM_POINTER is reported to the DET module and
        CanIf_GetControllerMode returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00656</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>622</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1461</internalId></specobject>
    <specobject>
      <id>TS_CANIF_Init_INVALID_PTR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>1959</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_Init reports a DET error when given an invalid ConfigPtr .
  
Test Object: 
    Det reporting
  
Test Precondition: 
    PBCfgM usage must be disabled.
  
Test Execution: 
    01: Call CanIf_Init with an invalid value in ConfigPtr (NULL_PTR).
    02: VP (CanIf.ASR40.SWS_CanIf_00302):
        Check if CANIF_E_PARAM_POINTER is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00302</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>69</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1462</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30244</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2006</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_Transmit reports a DET error when given an invalid CanTxPduId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Transmit with an invalid value in CanTxPduId.
    02: VP (CanIf.ASR40.SWS_CanIf_00005, CanIf.SWS_CanIf_00319):
        Verify that CANIF_E_INVALID_TXPDUID is reported to the DET module and CanIf_Transmit
        returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00319</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>502</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1463</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30245</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2063</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_Transmit reports a DET error when given an invalid PduInfoPtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Transmit with PduInfoPtr as NULL_PTR.
    02: VP (CanIf.ASR40.SWS_CanIf_00005, CanIf.SWS_CanIf_00320):
        Verify that CANIF_E_PARAM_POINTER is reported to the DET module and CanIf_Transmit returns
        E_NOT_OK.
    03: Call CanIf_Transmit with SduDataPtr as NULL_PTR.
    04: VP (CanIf.ASR40.SWS_CanIf_00005, CanIf.SWS_CanIf_00320):
        Verify that CANIF_E_PARAM_POINTER is reported to the DET module and CanIf_Transmit returns
        E_NOT_OK.
    05: Call CanIf_Transmit with SduLength being an invalid DLC.
    06: VP (CanIf.ASR40.SWS_CanIf_00005, CanIf.SWS_CanIf_00320):
        Check that CANIF_E_PARAM_DLC is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00320</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>503</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1464</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTransmitInvPduId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2151</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CancelTransmit reports a Det error when given an invalid
    CanTxPduId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_CancelTransmit() with an invalid Tx PDU ID.
    02: VP (CanIf.ASR40.SWS_CanIf_00652):
        Verify that CanIf_CancelTransmit() returns E_NOT_OK and CANIF_E_INVALID_TXPDUID is reported
        to the Det module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00652</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>131</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1465</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30246</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2206</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ReadRxPduData reports a DET error when given an invalid CanRxPduId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_ReadRxPduData with an invalid value in CanRxPduId.
    02: VP (CanIf.ASR40.SWS_CanIf_00194, CanIf.SWS_CanIf_00325):
        Verify that CANIF_E_INVALID_RXPDUID reported to the DET and CanIf_ReadRxPduData returns
        E_NOT_OK.
    03: Call CanIf_ReadRxPduData with a valid CanRxPduId but not configured for this API.
    04: VP (CanIf.ASR40.SWS_CanIf_00194, CanIf.SWS_CanIf_00325):
        Verify that CANIF_E_INVALID_RXPDUID reported to the DET and CanIf_ReadRxPduData returns
        E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00325</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>508</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1466</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30247</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2280</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ReadRxPduData reports a DET error when given an invalid PduInfoPtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_ReadRxPduData with PduInfoPtr as NULL_PTR.
    02: VP (CanIf.ASR40.SWS_CanIf_00194, CanIf.SWS_CanIf_00326):
        Verify that CANIF_E_PARAM_POINTER reported to the DET and CanIf_ReadRxPduData
        returns E_NOT_OK.
    03: Call CanIf_ReadRxPduData with SduDataPtr as NULL_PTR.
    04: VP (CanIf.ASR40.SWS_CanIf_00194, CanIf.SWS_CanIf_00326):
        Verify that CANIF_E_PARAM_POINTER reported to the DET and CanIf_ReadRxPduData
        returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00326</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>509</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1467</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30248</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2352</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ReadTxNotifStatus reports a DET error when given an invalid CanTxPduId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_ReadTxNotifStatus with an invalid value for CanTxPduId.
    02: VP (CanIf.SWS_CanIf_00331_1):
        Verify that CANIF_E_INVALID_TXPDUID reported to the DET module.
    03: Call CanIf_ReadTxNotifStatus with a valid CanTxPduId but not configured for this API.
    04: VP (CanIf.SWS_CanIf_00331_2):
        Verify that CANIF_E_INVALID_TXPDUID reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00331_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>513</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00331_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>514</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1468</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30249</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2418</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ReadRxNotifStatus reports a DET error when given an invalid CanRxPduId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_ReadRxNotifStatus with an invalid value in CanRxPduId.
    02: VP (CanIf.SWS_CanIf_00336_1):
        Verify that CANIF_E_INVALID_RXPDUID reported to the DET.
    03: Call CanIf_ReadRxNotifStatus with a valid CanRxPduId but not configured for this API.
    04: VP (CanIf.SWS_CanIf_00336_3):
        Verify that CANIF_E_INVALID_RXPDUID reported to the DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00336_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>517</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00336_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>519</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1469</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30250</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2484</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetPduMode reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetPduMode with an invalid value in Controller.
    02: VP (CanIf.SWS_CanIf_00008, CanIf.SWS_CanIf_00341):
        Verify that CANIF_E_PARAM_CONTROLLERID reported to the DET and CanIf_SetPduMode
        returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00341</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>521</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1470</internalId></specobject>
    <specobject>
      <id>TS_CANIF_PduModeRequest_InvPduMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2540</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetPduMode reports a DET error when given an invalid PduMode.
  
Test Object: 
    CanIf_SetPduMode - Det reporting
  
Test Precondition: 
    - CanIf is initalized
  
Test Execution: 
    01: Call CanIf_SetPduMode() with an invalid numeric value for parameter PduModeRequest.
    02: VP (CanIf.SWS_CanIf_00860):
        CanIf_SetPduMode() returns E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00860):
        CanIf_SetPduMode() reports a DET error with CANIF_E_PARAM_PDU_MODE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00860</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>762</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1471</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30252</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2602</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetPduMode reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetPduMode with an invalid value in Controller.
    02: VP (CanIf.SWS_CanIf_00009):
        CanIf_GetPduMode() returns E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00346):
        CanIf_GetPduMode() reports a DET error with CANIF_E_PARAM_CONTROLLERID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1472</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30266</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2662</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetPduMode reports a DET error when given an invalid PduModePtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetPduMode with an PduModePtr as NULL_PTR.
    02: VP (CanIf.SWS_CanIf_00009):
        CanIf_GetPduMode() returns E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00657):
        CanIf_GetPduMode() reports a DET error with CANIF_E_PARAM_POINTER.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00657</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>623</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1473</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30856</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2722</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetVersionInfo reports a DET error when given an invalid Versioninfo.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetVersionInfo with Versioninfo as NULL_PTR.
    02: VP (CanIf.SWS_CanIf_00158, CanIf.ASR40.SWS_CanIf_00658):
        Verify that CANIF_E_PARAM_POINTER reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>454</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00658</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>132</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1474</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30254</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2773</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetDynamicTxId reports a DET error when given an invalid CanTxPduId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetDynamicTxId with an invalid value in CanTxPduId.
    02: VP (CanIf.SWS_CanIf_00352):
        Verify that CANIF_E_INVALID_TXPDUID reported to the DET module.
    03: Call CanIf_SetDynamicTxId with a valid CanTxPduId but PDU is static.
    04: VP (CanIf.SWS_CanIf_00352):
        Verify that CANIF_E_INVALID_TXPDUID reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00352</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>523</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1475</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30255</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2831</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetDynamicTxId reports a DET error when given an invalid CanId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetDynamicTxId with an invalid value in CanId (extended id).
    02: VP (CanIf.SWS_CanIf_00353):
        Verify that CANIF_E_PARAM_CANID reported to the DET module.
    03: Call CanIf_SetDynamicTxId with an invalid value in CanId (standard id).
    04: VP (CanIf.SWS_CanIf_00353):
        Verify that CANIF_E_PARAM_CANID reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00353</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>524</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1476</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30848</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2889</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetTrcvMode reports a DET error when given an invalid Transceiver.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetTrcvMode with an invalid value in Transceiver.
    02: VP (CanIf.SWS_CanIf_00287, CanIf.SWS_CanIf_00538):
        Verify that CANIF_E_PARAM_TRCV reported to the DET and CanIf_SetTrcvMode returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00287</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>488</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00538</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>599</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1477</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TrcvModeIndication_InvTrcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2943</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_TrcvModeIndication reports a DET error when given an invalid Transceiver.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_TrcvModeIndication with an invalid value in Transceiver.
    02: VP (CanIf.SWS_CanIf_00706, CanIf.ASR40.SWS_CanIf_00764):
        Verify that CANIF_E_PARAM_TRCV is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00706</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>653</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00764</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>245</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1478</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30851</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>2995</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetTrcvMode reports a DET error when given an invalid Transceiver.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetTrcvMode with an invalid value in Transceiver.
    02: VP (CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled, CanIf.SWS_CanIf_00364):
        Verify that CANIF_E_PARAM_TRCV reported to the DET and CanIf_GetTrcvMode returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00364</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>530</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1479</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetTrcvModeNullPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3050</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetTrcvMode reports a Det error when given an invalid
    TransceiverModePtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetTrcvMode() with NULL_PTR as parameter.
    02: VP (CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled, CanIf.SWS_CanIf_00650):
        Verify that CanIf_GetTrcvMode() returns E_NOT_OK and CANIF_E_PARAM_POINTER is
        reported to the Det.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00288.MirroringDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>226</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00650</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>619</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1480</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30850</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3111</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetTrcvWakeupReason reports a DET error when given an invalid Transceiver.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetTrcvWakeupReason with an invalid value in Transceiver.
    02: VP (CanIf.SWS_CanIf_00289, CanIf.SWS_CanIf_00537):
        Verify that CANIF_E_PARAM_TRCV reported to the DET and CanIf_GetTrcvWakeupReason
        returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00289</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00537</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>598</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1481</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetTrcvWuReasonNullPtr</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3168</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetTrcvWakeupReason() reports a Det error when given an
    invalid TrcvWuReasonPtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetTrcvWakeupReason() with NULL_PTR as parameter.
    02: VP (CanIf.SWS_CanIf_00289, CanIf.SWS_CanIf_00649):
        Verify that CanIf_GetTrcvWakeupReason() returns E_NOT_OK and CANIF_E_PARAM_POINTER is
        reported to the Det.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00289</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>491</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00649</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>618</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1482</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30849</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3229</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetTrcvWakeupMode reports a DET error when given an invalid
    Transceiver.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetTrcvWakeupMode with an invalid value in Transceiver.
    02: VP (CanIf.SWS_CanIf_00290, CanIf.SWS_CanIf_00535):
        Verify that CanIf_SetTrcvWakeupMode() returns E_NOT_OK and CANIF_E_PARAM_TRCV is
        reported to the Det.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00290</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>492</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00535</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>596</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1483</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30853</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3286</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CheckWakeup reports a DET error when given an invalid WakeupSource.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_CheckWakeup several times with empty wakeupsource.
    02: VP (CanIf.SWS_CanIf_00398):
        Verify that CANIF_E_PARAM_WAKEUPSOURCE is reported to the DET and CanIf_CheckWakeup
        returns E_NOT_OK.
    03: Call CanIf_CheckWakeup several times with no CAN related bits set in wakeupsource.
    04: VP (CanIf.SWS_CanIf_00398):
        Verify that CANIF_E_PARAM_WAKEUPSOURCE is reported to the DET and CanIf_CheckWakeup
        returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00398</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>551</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1484</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30854</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3352</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CheckValidation reports a DET error when given an invalid WakeupSource.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_CheckValidation several times with empty wakeupsource.
    02: VP (CanIf.SWS_CanIf_00178, CanIf.SWS_CanIf_00404):
        Verify that CANIF_E_PARAM_WAKEUPSOURCE is reported to the DET and CanIf_CheckValidation
        returns E_NOT_OK.
    03: Call CanIf_CheckValidation several times with no CAN related bits set in wakeupsource.
    04: VP (CanIf.SWS_CanIf_00178, CanIf.SWS_CanIf_00404):
        Verify that CANIF_E_PARAM_WAKEUPSOURCE is reported to the DET and CanIf_CheckValidation
        returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00404</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>552</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1485</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetTxConfStateDetCtrlId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3422</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetTxConfirmationState() reports a Det error when given
    an invalid ControllerId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    - CanIf_GetTxConfirmationState() is enabled in the configuration.
    - CAN Interface is initialized.
  
Test Execution: 
    01: Call CanIf_GetTxConfirmationState() for an invalid controller.
    02: VP (CanIf.SWS_CanIf_00734, CanIf.SWS_CanIf_00736):
        Verify that CanIf_GetTxConfirmationState() returns CANIF_NO_NOTIFICATION and
        CANIF_E_PARAM_CONTROLLERID is reported to DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00734</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>661</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00736</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>662</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1486</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30257</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3483</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_TxConfirmation reports a DET error when given an invalid CanTxPduId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_TxConfirmation with an invalid value in CanTxPduId.
    02: VP (CanIf.SWS_CanIf_00410):
        Verify that CANIF_E_PARAM_LPDU is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00410</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>554</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1487</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30258</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3530</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_RxIndication reports a DET error when given an invalid Hrh.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_RxIndication with an invalid value in Hrh.
    02: VP (CanIf.ASR40.SWS_CanIf_00416, CanIf.SWS_CanIf_00416_1):
        Verify that CANIF_E_PARAM_HRH is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00416</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00416_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>559</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1488</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30259</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3583</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_RxIndication reports a DET error when given an invalid CanId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_RxIndication with an invalid value in CanId.
    02: VP (CanIf.ASR40.SWS_CanIf_00417, CanIf.SWS_CanIf_00417, CanIf.SWS_CanIf_00877_CanId,
            CanIf.SWS_CanIf_00877_CanIdType):
        Verify that CANIF_E_PARAM_CANID is reported to the DET module.
    03: Call CanIf_RxIndication with an invalid value in CanId (standard).
    04: VP (CanIf.ASR40.SWS_CanIf_00417, CanIf.SWS_CanIf_00417):
        Verify that CANIF_E_PARAM_CANID is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00417</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>227</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00417</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>560</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00877_CanId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00877_CanIdType</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1489</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30260</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3657</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_RxIndication reports a DET error when given an invalid CanDlc.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_RxIndication with an invalid value in CanDlc.
    02: VP (CanIf.ASR40.SWS_CanIf_00418):
        Verify that CANIF_E_PARAM_DLC is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00418</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>89</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1490</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30261</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3706</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_RxIndication reports a DET error when given an invalid CanSduPtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_RxIndication with CanSduPtr as NULL_PTR.
    02: VP (CanIf.ASR40.SWS_CanIf_00419):
        Verify that CANIF_E_PARAM_POINTER is reported to the DET module.
    03: Call CanIf_RxIndication with Mailbox as NULL_PTR.
    04: VP (CanIf.SWS_CanIf_00419_2):
        Verify that CANIF_E_PARAM_POINTER is reported to the DET module.
    05: Call CanIf_RxIndication with PduInfoPtr as NULL_PTR.
    06: VP (CanIf.SWS_CanIf_00419_1):
         Verify that CANIF_E_PARAM_POINTER is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00419</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>90</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00419_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>562</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00419_2</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>563</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1491</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30262</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3797</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CancelTxConfirmation reports a DET error when given an invalid PduInfoPtr.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_CancelTxConfirmation with PduInfoPtr as NULL_PTR.
    02: VP (CanIf.ASR40.SWS_CanIf_00828):
        Verify that CANIF_E_PARAM_POINTER is reported to the Det module.
    03: Call CanIf_CancelTxConfirmation with SduDataPtr as NULL_PTR.
    04: VP (CanIf.ASR40.SWS_CanIf_00828):
        Verify that CANIF_E_PARAM_POINTER is reported to the Det module.
    05: Call CanIf_CancelTxConfirmation with SduLength being an invalid DLC.
    06: Verify that CANIF_E_PARAM_DLC is reported to the Det module.
    07: Call CanIf_CancelTxConfirmation with PduInfoPtr-&amp;gt;id being an invalid CAN ID (extended).
    08: Verify that CANIF_E_PARAM_CANID is reported to the Det module.
    09: Call CanIf_CancelTxConfirmation with PduInfoPtr-&amp;gt;id being an invalid CAN ID (standard).
    10: Verify that CANIF_E_PARAM_CANID is reported to the Det module.
    11: Call CanIf_CancelTxConfirmation with PduInfoPtr-&amp;gt;swPduHandle being invalid.
    12: VP (CanIf.ASR40.SWS_CanIf_00424):
        Verify that CANIF_E_PARAM_LPDU is reported to the Det module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00828</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>217</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00424</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>94</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1492</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30263</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3912</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ControllerBusOff reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_ControllerBusOff with an invalid value in Controller.
    02: VP (CanIf.SWS_CanIf_00429):
        Verify that CANIF_E_PARAM_CONTROLLER is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00429</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>566</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1493</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ClearTrcvWufFlag_NoPnTrcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>3959</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ClearTrcvWufFlag reports a DET error
    if the underlying CanTrcv driver does not support partial network.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_ClearTrcvWufFlag with valid transceiver Id.
    02: VP:
        Verify that CanIf_ClearTrcvWufFlag return E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00769):
        Verify that CANIF_E_PARAM_TRCV is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00769</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>679</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1494</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckTrcvWakeFlag_NoPnTrcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>4015</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CheckTrcvWakeFlag reports a DET error
    if the underlying CanTrcv driver does not support partial network.
  
Test Object: 
    Det reporting
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_CheckTrcvWakeFlag with valid transceiver Id.
    02: VP:
        Verify that CanIf_CheckTrcvWakeFlag return E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00770):
        Verify that CANIF_E_PARAM_TRCV is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00770</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>680</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1495</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30296</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>4073</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if the transmit request is rejected when called in PDU channel mode
    CANIF_OFFLINE mode, even if the CAN controller is started.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    CanIf shall be initialized.
  
Test Execution: 
    01: Bring the controller to CANIF_CS_STARTED.
    02: Bring the Pdu mode to CANIF_OFFLINE.
    03: Call CanIf_Transmit when Pdu mode is CANIF_OFFLINE.
    04: VP(CanIf.EB.CANIF382):
        Verify that CanIf_Transmit() returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF382</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>539</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1496</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30846</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>4151</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Development error: CANIF_E_INVALID_DLC.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    DLC check enabled in the configuration, controller started
  
Test Execution: 
    01: Call CanIf_SetControllerMode to set the mode to CANIF_CS_STARTED.
    02: Check if correct data is copied into CanIf_RxBuffer.
    03: Simulate the reception of a of Rx-PDU 1 with wrong DLC 7 (smaller than configured DLC).
    04: VP (CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00168, CanIf.ASR42.SWS_CanIf_00168,
            CanIf.ASR40.DlcCheck.NoRxIndication, CanIf.ASR40.DlcCheck.NoRxBuffer):
        Verify that CANIF_E_INVALID_DLC is reported to DET, PduR_CanIfRxIndication is not called and
        data received is not buffered.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR42.SWS_CanIf_00168</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.DlcCheck.NoRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.DlcCheck.NoRxBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>224</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1497</internalId></specobject>
    <specobject>
      <id>TS_CANIF_InvalidDLC</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>4270</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Development error: CANIF_E_INVALID_DLC reported to DET.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    DLC check enabled in the configuration, controller started
  
Test Execution: 
    Simulate the reception of a PDU which is expected but give it a DLC smaller than expected.

    01: Start the controller under test by calling CanIf_SetControllerMode().
    02: Set the PDU mode to ONLINE by calling CanIf_SetPduMode().
    03: Receive Rx PDU 5 with a correct DLC to ensure correct test implementation.
    04: VP (CanIf.SWS_CanIf_00026):
        This would not report error CANIF_E_INVALID_DLC to DET.
    05: Receive Rx PDU 5 with a wrong DLC (too short).
    06: VP (CanIf.ASR40.SWS_CanIf_00168, CanIf.ASR42.SWS_CanIf_00168):
        This would report error CANIF_E_INVALID_DLC to DET.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00168</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>222</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR42.SWS_CanIf_00168</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>325</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1498</internalId></specobject>
    <specobject>
      <id>TS_CANIF_Transmit_InvalidCanId</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_ErrorReporting/source/application/Tests.c.m4</sourcefile>
      <sourceline>4363</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_Transmit reports a DET error when translate callout function
    returned an invalid CanId.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    - Translate function which provides the invalid CanId was configured.
    - Controller is started and PDU mode is set to ONLINE.
  
Test Execution: 
    01: Call CanIf_Transmit with a valid CanIfTxPduId.
    02: Check if it returned E_NOT_OK.
    03: VP(CanIf.EB.CanIfTranslateTxCanIdFuncDetCheck):
        Check if Det is reported with CANIF_E_PARAM_CANID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTranslateTxCanIdFuncDetCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1499</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_UL_CDD_RXINDICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_GenUpperLayer/source/application/Tests.c</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if specific Rx-LPdus call their configured &lt;UL&gt;_RxIndication
    function.
    a) There are 2 Rx-LPdus assigned to upper layer CanTp. One Pdu has its RxIndication
       enabled (RxLPdu0), the other one (RxLPdu5) does not use a RxIndication.
       This checks the RxIndication function pointers of signature
       &lt;UL&gt;_RxIndication(Pdu_IdType, PduInfoPtr*).
    b) There are 2 Rx-LPdus assigned to 2 upper layer CDDs. One CDD has its RxIndication
       enabled (referenced by RxLPdu9), the other one (referenced by RxLPdu11) does
       not use a RxIndication.
       This checks the RxIndication function pointers of signature
       &lt;UL&gt;_RxIndication(Pdu_IdType, PduInfoPtr*, Can_IdType).
  
Test Object: 
    Partial networking
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Call CanIf_RxIndication() for a CanTp-Rx-PDU where optional parameter
        CanIfRxPduUserRxIndicationUL is disabled.
    02: VP (CanIf.SWS_CanIf_00557):
        CanIf does not call any function.
    03: Call CanIf_RxIndication() for a CanTp-Rx-PDU where optional parameter
        CanIfRxPduUserRxIndicationUL is enabled.
    04: VP (CanIf.SWS_CanIf_00557):
        CanIf calls CanTp_RxIndication().
    05: Call CanIf_RxIndication() for a Cdd-Rx-PDU which references
        to a Cdd with no RxIndcation configured (CanIfRxPduUserRxIndicationName)
        and CanIfUpperLayerUseCanId enabled.
    06: VP (CanIf.SWS_CanIf_00557):
        CanIf does not call any function.
    07: Call CanIf_RxIndication() for a Cdd-Rx-PDU which references
        to a Cdd with a RxIndcation configured (CanIfRxPduUserRxIndicationName)
        and CanIfUpperLayerUseCanId enabled.
    08: VP (CanIf.SWS_CanIf_00557):
        CanIf calls the function defined by CanIfRxPduUserRxIndicationName.
    09: Call CanIf_RxIndication() for a CanTSyn-Rx-PDU which references
        to a CanTSyn with a RxIndication configured (CanIfRxPduUserRxIndicationName)
        and CanIfUpperLayerUseCanId enabled.
    10: VP (CanIf.SWS_CanIf_00880):
        CanIf calls the function defined by CanIfRxPduUserRxIndicationName.
    11: Call CanIf_RxIndication() for a J1939Nm-Rx-PDU where optional parameter
        CanIfRxPduUserRxIndicationUL is enabled.
    12: VP (CanIf.SWS_CanIf_00859):
         CanIf calls the function defined by CanIfRxPduUserRxIndicationName.
    13,15,17,19: Call CanIf_RxIndication() for a J1939Tp-Rx-PDU where optional parameter
       CanIfRxPduUserRxIndicationUL is enabled.
    14,16,18,20: VP (CanIf.SWS_CanIf_00554):
         CanIf calls the function defined by CanIfRxPduUserRxIndicationName.
    21: Call CanIf_RxIndication() for a Xcp-Rx-PDU where optional parameter CanIfRxPduUserRxIndicationUL is enabled.
    22: VP (CanIf.SWS_CanIf_00555): CanIf calls Xcp_CanIfRxIndication().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00557</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>609</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00880</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>781</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00859</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>761</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00554</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>606</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00555</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>607</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1500</internalId></specobject>
    <specobject>
      <id>TS_CANIF_UL_TXCONFIRMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_GenUpperLayer/source/application/Tests.c</sourcefile>
      <sourceline>484</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    This test checks if specific Tx-LPdus call their configured &lt;UL&gt;_TxConfirmation
    function.
    There are 3 Tx-LPdus under test:
    1.) TxLPdu1 does not any TxConfirmation (CanIfTxPduUserTxConfirmationUL disabled)
    2.) TxLPdu0 indicates its TxConfirmation to PduR (CanIfTxPduUserTxConfirmationUL
        enabled and set to PDUR)
    3.) TxLPdu2 indicates its TxConfirmation to a CDD but this CDD has no TxConfirmation
        configured in the UpperLayerCfg (CanIfTxPduUserTxConfirmationName disabled).
    This checks the TxConfirmation function pointers in the upper layer configuration.
  
Test Object: 
    Partial networking
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is disabled.
    02: VP (CanIf.SWS_CanIf_00551):
        CanIf does not call any function.
    03: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and set to value PDUR.
    04: VP (CanIf.SWS_CanIf_00551):
        CanIf calls PduR_CanIfTxConfirmation().
    05: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and referencing a CDD with
        no TxConfirmation configuration.
    06: VP (CanIf.SWS_CanIf_00551):
        CanIf does not call any function.
    07: Call CanIf_TxConfirmation() for a CanTSyn-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    08: VP (CanIf.SWS_CanIf_00879):
        CanIf calls CanTSyn_TxConfirmation().
    09: Call CanIf_TxConfirmation() for a J1939Nm-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    10: VP (CanIf.SWS_CanIf_00858):
        CanIf calls J1939Nm_TxConfirmation().
    11,13,15,17: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    12,14,16,18: VP (CanIf.SWS_CanIf_00544):
         CanIf calls J1939Tp_TxConfirmation().
    19: Call CanIf_TxConfirmation() for a Xcp-Tx-PDU where optional parameter CanIfTxPduUserTxConfirmationUL is enabled.
    20: VP (CanIf.SWS_CanIf_00556): CanIf calls Xcp_CanIfTxConfirmation().
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00551</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>604</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00879</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00858</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>760</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00544</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>602</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00556</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>608</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1501</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_ERROR_NO_INIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_IdsM/source/application/Tests.c.m4</sourcefile>
      <sourceline>57</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that when the CanIf_ControllerErrorStatePassive and ***** are called, 
    but CanIf is not initialized, DET will be called for reporting the error
  
Test Object: 
    CanIf_ControllerErrorStatePassive()
    CanIf_ErrorNotification()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_ControllerErrorStatePassive before CanIf is initialized
m4_ifelse(PM_enableDevErrorDetect,true,\-:m4_dnl
    02: VP (SWS_CANIF_91008.CanIf_ControllerErrorStatePassive):
        Verify that Det is called for reporting the UNINIT error.
:-/,m4_ifelse( :else: )\-:m4_dnl
    02: Det will not be triggered
:-/m4_ifelse( :endif: ))
    03: Call CanIf_ErrorNotification before CanIf is initialized
m4_ifelse(PM_enableDevErrorDetect,true,\-:m4_dnl
    04: VP (SWS_CANIF_91009.CanIf_ErrorNotification):
        Verify that Det is called for reporting the UNINIT error.
:-/,m4_ifelse( :else: )\-:m4_dnl
    04: Det will not be triggered
:-/m4_ifelse( :endif: ))
m4_ifelse(PM_Permutation,p3,\-:m4_dnl
    05: Initalize CanIf and stubs.
    06: Check that CanIf_ControllerErrorStatePassive does nothing if the event is disabled
        or function is called with parameter values that do not lead to an IdsM call
        and DET is disabled.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_91008.CanIf_ControllerErrorStatePassive</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1031</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_91009.CanIf_ErrorNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1030</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00848</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>839</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>857</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>856</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1502</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ERRORSTATE_BUSOFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_IdsM/source/application/Tests.c.m4</sourcefile>
      <sourceline>164</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that when the CanIf_ControllerBusOff is called, IdsM will be
    notified of the event.
  
Test Object: 
    CanIf_ControllerBusOff()
  
Test Precondition: 
    Module is initialized.
  
Test Execution: 
    01: Call CanIf_ControllerBusOff with valid controller
    02: Check that upper layer (CanSM) is notified about the bus-off
    03: VP(SWS_CANIF_00918):
        Verify that IdsM is called with the correct event id and context data.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00918</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>850</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00913</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>845</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00849</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00853</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>844</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1503</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ERRORSTATE_PASSIVE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_IdsM/source/application/Tests.c.m4</sourcefile>
      <sourceline>240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Set new modes for the different transceivers
  
Test Object: 
    CanIf_ControllerErrorStatePassive()
  
Test Precondition: 
  
Test Execution: 
    01: Initalize CanIf and stubs.
    02: Call CanIf_ControllerErrorStatePassive for controller 0 and with
        RxErrorCounter &gt; 127 and TxErrorCounter &gt; 127
    03: VP (ErrorCounter_BoundaryValue):
        Verify that IdsM is called with the correct event id and context data.
    04: Call CanIf_ControllerErrorStatePassive for controller 0 and with
        RxErrorCounter = 127 and TxErrorCounter &gt; 127
    05: VP (ErrorCounter_BoundaryValue):
        Verify that IdsM is called with the correct event id and context data.
    06: Call CanIf_ControllerErrorStatePassive for controller 0 and with
        RxErrorCounter &gt; 127 and TxErrorCounter = 127
    07: VP (ErrorCounter_BoundaryValue):
        Verify that IdsM is called with the correct event id and context data.
    08: Call CanIf_ControllerErrorStatePassive with an invalid controller id.
m4_ifelse(PM_enableDevErrorDetect,true,\-:m4_dnl
    09: VP(SWS_CANIF_00919):
        Verify that Det is called for reporting the CONTROLLERID parameter error.
:-/,m4_ifelse( :else: )\-:m4_dnl
    09: Det will not be triggered
:-/m4_ifelse( :endif: ))
    10: Call CanIf_ControllerErrorStatePassive with valid counters and check that
   	   	IdsM is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00917.ErrorCounter_BoundaryValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>849</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00919</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>851</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00849</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00852</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>843</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1504</internalId></specobject>
    <specobject>
      <id>TS_CANIF_RX_ERROR_DETECTED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_IdsM/source/application/Tests.c.m4</sourcefile>
      <sourceline>365</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Receive error notifications from driver and check IdsM reporting
  
Test Object: 
    CanIf_ErrorNotification()
  
Test Precondition: 
  
Test Execution: 
    01: Initalize CanIf and stubs.
    02: Call CanIf_ErrorNotification notifying about CAN_ERROR_CHECK_FORM_FAILED.
    03: VP(SWS_CANIF_00916):
        Verify that IdsM is called with the correct event id and context data.
    04: Call CanIf_ErrorNotification notifying about CAN_ERROR_BUS_LOCK.
    05: VP(SWS_CANIF_00916):
        Verify that IdsM is called with the correct event id and context data.
    06: Call CanIf_ErrorNotification with an invalid CAN error.
m4_ifelse(PM_enableDevErrorDetect,true,\-:m4_dnl
    07: VP(SWS_CANIF_00921):
        Verify that Det is called for reporting the CAN_ERROR parameter error.
:-/,m4_ifelse( :else: )\-:m4_dnl
    07: Det will not be triggered
:-/m4_ifelse( :endif: ))
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00916</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>847</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00921</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>853</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_91009.CanIf_ErrorNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1030</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00849</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00851</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>842</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1505</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TX_ERROR_DETECTED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_IdsM/source/application/Tests.c.m4</sourcefile>
      <sourceline>471</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Receive error notifications from driver and check IdsM reporting
  
Test Object: 
    CanIf_ErrorNotification()
  
Test Precondition: 
    Initialize CanIf Module.
  
Test Execution: 
    01: Call CanIf_ErrorNotification notifying about CAN_ERROR_BIT_MONITORING1.
    02: VP(SWS_CANIF_00915):
        Verify that IdsM is called with the correct event id and context data.
    03: Call CanIf_ErrorNotification notifying about CAN_ERROR_OVERLOAD.
    04: VP(SWS_CANIF_00915):
        Verify that IdsM is called with the correct event id and context data.
    05: Call CanIf_ErrorNotification with an invalid controller id.
m4_ifelse(PM_enableDevErrorDetect,true,\-:m4_dnl
    06: VP(SWS_CANIF_00920):
        Verify that Det is called for reporting the CONTROLLERID parameter error.
:-/,m4_ifelse( :else: )\-:m4_dnl
    06: Det will not be triggered
:-/m4_ifelse( :endif: ))
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00915</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>846</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00920</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>852</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91010</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>858</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00849</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>840</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00850</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>841</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1506</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_METADATA_TX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>270</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Simulate transmission events for PDUs with metadata.
  
Test Object: 
   CanIf_Transmit()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful transmission for a PDU with Metadata, CanId and CanIdMask.
    02: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00592, CanIf.ECUC_CanIf_00823_1, CanIf.SWS_CanIf_00854, CanIf.EB.Metadata.Config.1, CanIf.EB.Metadata.Config.3, CanIf.EB.Metadata.Functional.1):
        EcuC_GetMetaDataCanId() must be called with the corresponding PDU-ID.
        Can_Write() is called with a CanId combined from CanIfTxPduCanId and Metadata based on CanIfTxPduCanIdMask.

    03: Simulate a successful transmission for a PDU with Metadata and no CanId.
    04: VP(CanIf.ECUC_CanIf_00824_1, CanIf.SWS_CanIf_00855, CanIf.EB.Metadata.Config.2, CanIf.EB.Metadata.Functional.1):
        EcuC_GetMetaDataCanId() must be called with the corresponding PDU-ID.
        Can_Write() is called with a CANID provided in the metadata.

    05: Simulate a successful transmission for a PDU with no Metadata configured.
    06: VP(CanIf.EB.Metadata.Config.1):
        EcuC_GetMetaDataCanId() is not called.
        Can_Write() is called with the CanId from the CanIfTxPduCanId parameter.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00824_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00592</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>350</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00823_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>722</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00855</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>757</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00854</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>756</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00844</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>750</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>960</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>961</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>962</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>965</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1507</internalId></specobject>
    <specobject>
      <id>TS_CANIF_METADATA_RX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>447</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
   Simulate reception events for PDUs with metadata.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask.
    02: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.4, CanIf.EB.Metadata.Config.5, CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    03: Simulate a successful reception for a PDU with Metadata and CanId Range.
    04: VP(CanIf.ECUC_CanIf_00824_1, CanIf.EB.Metadata.Config.4, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    05: Simulate a successful reception for a PDU with no Metadata configured.
    06: VP(CanIf.EB.Metadata.Config.1):
        EcuC_SetMetaDataCanId() is not called.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00824_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00822_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>720</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1508</internalId></specobject>
    <specobject>
      <id>TS_CANIF_METADATA_RX_CANID_MASKED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>595</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   Simulate reception events for PDUs with metadata, where all configured IDs in the HrH are
   configured with CanIfRxPduCanIdMask, purpose of this test is to get sure that the search algorithm is working
   correctly, also to get sure it fails to find IDs which are not configured/related.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask that will fit to
        the configured ID 501.
    02: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.5,
           CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    03: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask that will fit to
        the configured ID 505.
    04: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.5,
           CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    05: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask that will fit to
        the configured ID 510.
    06: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.5,
           CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    07: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask that will fit to
        the configured ID 520.
    08: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.5,
           CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    09: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask that will fit to
        the configured ID 591.
    10: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.5,
           CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    11: Simulate a successful reception for a PDU that not will fit to any configured ID.
    12: VP(CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must not be called.
        PduR_CanIfRxIndication() must not be called.

    13: Simulate a successful reception for a PDU that not will fit to any configured ID.
    14: VP(CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must not be called.
        PduR_CanIfRxIndication() must not be called.

    15: Simulate a successful reception for a PDU that not will fit to any configured ID.
    16: VP(CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must not be called.
        PduR_CanIfRxIndication() must not be called.

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00824_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00822_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>720</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1509</internalId></specobject>
    <specobject>
      <id>TS_CANIF_METADATA_RX_CANID_RANGE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>833</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   Simulate reception events for PDUs with CanId Range,where all configured IDs in the HrH are
   configured with CanId range, purpose of this test is to get sure that the search algorithm is working
   correctly, also to get sure it fails to find IDs which are not configured/related.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful reception for a PDU that will match a CanId Range.
    02: VP(CanIf.EB.Metadata.Config.4):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    03: Simulate a successful reception for a PDU that will match a CanId Range.
    04: VP(CanIf.EB.Metadata.Config.4):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    05: Simulate a successful reception for a PDU that will match a CanId Range.
    06: VP(CanIf.EB.Metadata.Config.4):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    07: Simulate a successful reception for a PDU that will match a CanId Range.
    08: VP(CanIf.EB.Metadata.Config.4):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    09: Simulate a successful reception for a PDU that not will fit to any configured ID.
    10: PduR_CanIfRxIndication() &amp; EcuC_SetMetaDataCanId() must not be called.

    11: Simulate a successful reception for a PDU that not will fit to any configured ID.
    12: PduR_CanIfRxIndication() &amp; EcuC_SetMetaDataCanId() must not be called.

    13: Simulate a successful reception for a PDU that not will fit to any configured ID.
    14: PduR_CanIfRxIndication() &amp; EcuC_SetMetaDataCanId() must not be called.

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>963</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1510</internalId></specobject>
    <specobject>
      <id>TS_CANIF_METADATA_RX_CANID</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>1012</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   Simulate reception events for PDUs without metadata,where all configured IDs in the HrH are CanIds without
   metadata, purpose of this test is to get sure that the search algorithm is working correctly, also to get
   sure it fails to find IDs which are not configured/related.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful reception for a PDU without Metadata.
    02: PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    03: Simulate a successful reception for a PDU without Metadata.
    04: PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    05: Simulate a successful reception for a PDU without Metadata.
    06: PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    07: Simulate a successful reception for a PDU without Metadata.
    08: PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    09: Simulate a successful reception for a PDU without Metadata.
    10: PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    11: Simulate a successful reception for a PDU that not will fit to any configured ID.
    12: PduR_CanIfRxIndication() must not be called.

    13: Simulate a successful reception for a PDU that not will fit to any configured ID.
    14: PduR_CanIfRxIndication() must not be called.

    15: Simulate a successful reception for a PDU that not will fit to any configured ID.
    16: PduR_CanIfRxIndication() must not be called.

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00211</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>477</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1511</internalId></specobject>
    <specobject>
      <id>TS_CANIF_METADATA_RX_MIXED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>1182</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
   Simulate reception events for PDUs with metadata (Mask and range) and without metadata, purpose of this test
   is to get sure that the search algorithm is working correctly, also to get sure it fails to find IDs which
   are not configured/related.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask.
    02: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.4, CanIf.EB.Metadata.Config.5, CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    03: Simulate a successful reception for a PDU with no Metadata configured.
    04: PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    05: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask.
    06: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.4, CanIf.EB.Metadata.Config.5, CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    07: Simulate a successful reception for a PDU with Metadata and CanId Range.
    08: VP(CanIf.ECUC_CanIf_00824_1, CanIf.EB.Metadata.Config.4, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    09: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask.
    10: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.4, CanIf.EB.Metadata.Config.5, CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    11: Simulate a successful reception for a PDU with Metadata and CanId Range.
    12: VP(CanIf.ECUC_CanIf_00824_1, CanIf.EB.Metadata.Config.4, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    13: Simulate a successful reception for a PDU with Metadata, CanId and CanIdMask.
    14: VP(CanIf.ECUC_CanIf_00824_1, CanIf.ECUC_CanIf_00822_1, CanIf.EB.Metadata.Config.4, CanIf.EB.Metadata.Config.5, CanIf.EB.Metadata.Functional.2, CanIf.EB.Metadata.Functional.3):
        EcuC_SetMetaDataCanId() must be called with the corresponding PDU-ID.
        PduR_CanIfRxIndication() must be called with the corresponding PDU-ID.

    15: Simulate a successful reception for a PDU that not will fit to any configured ID.
    16: PduR_CanIfRxIndication() &amp; EcuC_SetMetaDataCanId() must not be called.

    17: Simulate a successful reception for a PDU that not will fit to any configured ID.
    18: PduR_CanIfRxIndication() &amp; EcuC_SetMetaDataCanId() must not be called.

    19: Simulate a successful reception for a PDU that not will fit to any configured ID.
    20: PduR_CanIfRxIndication() &amp; EcuC_SetMetaDataCanId() must not be called.

    21: Simulate a successful reception for a PDU that not will fit to any configured ID.
    22: PduR_CanIfRxIndication() &amp; EcuC_SetMetaDataCanId() must not be called.

    23: Simulate a successful reception for a PDU that not will fit to any configured ID.
    24: PduR_CanIfRxIndication() &amp; EcuC_SetMetaDataCanId() must not be called.

  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00824_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>724</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00822_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>720</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Config.5</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>964</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>966</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Metadata.Functional.3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>967</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1512</internalId></specobject>
    <specobject>
      <id>TS_CANIF_METADATA_NO_SW_FILTERING_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>1460</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   Simulate reception events for PDUs where SW filter is diabled for the HrH , purpose of this test is
   to get sure that no search is done and just the first index is considered.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful reception for a PDU ID = 5 on Hrh "TST_HRH_4_STD".
    02: PduR_CanIfRxIndication() must be called with the first PDU-ID (TST_RX_PDUID_5_targetPduId_CanId).

    03: Simulate a successful reception for a PDU ID = 6 on Hrh "TST_HRH_4_STD".
    04: PduR_CanIfRxIndication() must be called with the first PDU-ID (TST_RX_PDUID_5_targetPduId_CanId) not PduId 6.

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00632</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1513</internalId></specobject>
    <specobject>
      <id>TS_CANIF_METADATA_NO_SW_FILTERING_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>1552</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   Simulate reception events for PDUs where SW filter is diabled for the HrH , purpose of this test is
   to get sure that no search is done and just the first index is considered.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 

    01: Simulate a successful reception for a PDU ID = 7 on Hrh "TST_HRH_5_STD".
    02: EcuC_SetMetaDataCanId() must be called with the the first PDU-ID (TST_RXPDU_7_METADATA_WITH_CAN).
        PduR_CanIfRxIndication() must be called with the first PDU-ID (TST_RX_PDUID_7_targetPduId_METADATA_WITH_CANID).

    03: Simulate a successful reception for a PDU ID = 8 on Hrh "TST_HRH_5_STD".
    04: EcuC_SetMetaDataCanId() must be called with the the first PDU-ID (TST_RXPDU_7_METADATA_WITH_CAN).
        PduR_CanIfRxIndication() must be called with the first PDU-ID (TST_RX_PDUID_7_targetPduId_METADATA_WITH_CANID).

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00632</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1514</internalId></specobject>
    <specobject>
      <id>TS_CANIF_METADATA_HRH_NOT_USED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Metadata/source/application/Tests.c</sourcefile>
      <sourceline>1657</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate a message reception for an unused HRH while enabling software filtering and Metadata support.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Initialize internal counters and start controller 1.
    03: Simulate several message receptions on an unused HRH HRH_1_1 with software
        filtering enabled.
    04: VP (CanIf.SWS_CanIf_00389):
        EcuC_SetMetaDataCanId() and PduR_CanIfRxIndication() must not be called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SoftwareFilter.RejectPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1515</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_API_CANGETCONTROLLERTXERRORCOUNTER</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrErrorMultCtrl/source/application/Tests.c</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check the availability and behavior of CanIf_GetControllerTxErrorCounter
  
Test Object: 
    CanIf_GetControllerTxErrorCounter()
  
Test Precondition: 
    CanIfCanTxErrorCounterSupported configured as TRUE.
    Stub returns the value 231.
  
Test Execution: 
    00: VP(CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanTxErrorCounterSupported):
        No calls made to Can
    01: Call CanIf_GetControllerTxErrorCounter() with incorrect ID
    02: VP(CanIf.SWS_CanIf_00909):
        DET is reported with CANIF_E_PARAM_CONTROLLERID
    03: Call CanIf_GetControllerTxErrorCounter() with an invalid pointer
    04: VP(CanIf.SWS_CanIf_00910):
        DET is reported with CANIF_E_PARAM_POINTER
    04: VP(CanIf.SWS_CanIf_91004.ReturnValue.ProperlySupported):
        Call forwarded to Can
    05: Call CanIf_GetControllerTxErrorCounter() with proper parameters
    06: VP(CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxErrorCounterValue):
        The value is the one from the configuration
    07: The returned value is not tied to Mirroring being enabled:
        Enable mirroring, call CanIf_GetControllerTxErrorCounter(),
        disable mirroring, call CanIf_GetControllerTxErrorCounter(),
        verify that the values are the same (stub returns the same value).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanTxErrorCounterSupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00909</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00910</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91004.ReturnValue.ProperlySupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>835</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxErrorCounterValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00847</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1516</internalId></specobject>
    <specobject>
      <id>TS_CANIF_API_CANGETCONTROLLERERRORSTATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrErrorMultCtrl/source/application/Tests.c</sourcefile>
      <sourceline>197</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check the availability and behavior of CanIf_GetControllerErrorState()
  
Test Object: 
    CanIf_GetControllerErrorState()
  
Test Precondition: 
    CanIfCanControllerErrorStateSupported configured as TRUE.
    Stub returns the value CAN_ERRORSTATE_ACTIVE.
  
Test Execution: 
    00: VP(CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanControllerErrorStateSupported):
        No calls made to Can
    01: Call CanIf_GetControllerErrorState() with incorrect ID
    02: VP(CanIf.SWS_CanIf_00898):
        DET is reported with CANIF_E_PARAM_CONTROLLERID
    03: Call CanIf_GetControllerErrorState() with an invalid pointer
    04: VP(CanIf.SWS_CanIf_00899):
        DET is reported with CANIF_E_PARAM_POINTER
    04: Call CanIf_GetControllerErrorState() with proper parameters
    05: VP(CanIf.SWS_CanIf_91001.ReturnValue.ProperlySupported):
        Call is forwarded to Can
    06: The returned value is not tied to Mirroring being enabled:
        Enable mirroring, call CanIf_GetControllerErrorState(), disable
        mirroring, call CanIf_GetControllerErrorState(), verify that
        the values are the same (stub returns the same value).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanControllerErrorStateSupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>949</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00898</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>806</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00899</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>807</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91001.ReturnValue.ProperlySupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>810</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfErrorStateValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00847</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1517</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>240</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the frames are reported correctly when the mirror payload buffer
    size is less than the sum of sizes of all Pdus.
    CANIF_E_PDU_INSTANCE_LOST is reported when mirror buffer is full.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Enable mirroring
    02: Call CanIf_Transmit() for Tx PduR_TxPdu_0 and
        Check Can_Write() is called with the correct parameters
    03: Call CanIf_Transmit() for Tx PduR_TxPdu_1 and
        Check Can_Write() is called with the correct parameters
    04: Call CanIf_Transmit() for Tx PduR_TxPdu_2 and
        Check Can_Write() is called with the correct parameters
    05: Call CanIf_Transmit() for Tx PduR_TxPdu_3 and
        Check Can_Write() is called with the correct parameters
    06: Call CanIf_Transmit() for Tx PduR_TxPdu_4 and return E_OK
        Check Can_Write() is called with the correct parameters
    07: Check Det_ReportError() is called with CANIF_E_PDU_INSTANCE_LOST.
    08: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1.
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    09: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    09: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
        Mirrored frame of PduR_TxPdu_1 is correct.
    10: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1
    11: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_3
    12: Check that mirror frame of PduR_TxPdu_4 is not reported
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.TxMirrorBufferSize</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>951</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1518</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_1_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>447</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the frames are reported correctly when the mirror payload buffer
    size is less than the sum of sizes of all Pdus.
    CANIF_E_PDU_INSTANCE_LOST is reported when mirror buffer is full.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() for Tx PduR_TxPdu_4 and
        Check Can_Write() is called with the correct parameters
    02: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_0.
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    03: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    03: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
        Mirrored frame of PduR_TxPdu_0 is correct.
    04: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_0.
    05: Call CanIf_Transmit() for Tx PduR_TxPdu_3 and
        Check Can_Write() is called with the correct parameters.
    06: Call CanIf_Transmit() for Tx PduR_TxPdu_0 and
        Check Can_Write() is called with the correct parameters.
    07:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_3
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    08: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    08: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_3 is correct.
    08: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_3
    09: Call CanIf_Transmit() for Tx PduR_TxPdu_1 and
        Check Can_Write() is called with the correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1519</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_1_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>620</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the frames are reported correctly when the mirror payload buffer
    size is less than the sum of sizes of all Pdus.
    CANIF_E_PDU_INSTANCE_LOST is reported when mirror buffer is full.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_0
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    02: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    02: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_0 is correct.
    03: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_0.
    04:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_2
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    05: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    05: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_2 is correct.
    06:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_4
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    07: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    07: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd)::
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_4 is correct.
    08: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    09: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    09: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_1 is correct.
    10: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1520</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_1_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>765</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the frames are reported correctly when the mirror payload buffer
    size is less than the sum of sizes of all Pdus.
    CANIF_E_PDU_INSTANCE_LOST is reported when mirror buffer is full.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() for Tx PduR_TxPdu_0 with different data and
        Check Can_Write() is called with the correct parameters
    02:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_0
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    03: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    03: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_0 is correct.
    04: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_0
    05: Call CanIf_Transmit() for Tx PduR_TxPdu_1 with different data and
        Check Can_Write() is called with the correct parameters
    06:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    07: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    07: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_1 is correct.
    08: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1521</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>901</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that CanIf_Transmit() reports CANIF_E_PDU_INSTANCE_LOST when mirror buffer is full.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() for Tx PduR_TxPdu_0  and
        Check Can_Write() is called with the correct parameters
    02: Call CanIf_Transmit() for Tx PduR_TxPdu_1 and
        Check Can_Write() is called with the correct parameters
    03: Call CanIf_Transmit() for Tx PduR_TxPdu_2 and
        Check Can_Write() is called with the correct parameters
    04: Call CanIf_Transmit() for Tx PduR_TxPdu_3 and
        Check Can_Write() is called with the correct parameters
    05: Call CanIf_Transmit() trying to transmit Tx CddId_TxPdu_0
        and Check Can_Write() is called with the correct parameters
    06: Check Det_ReportError() is called with CANIF_E_PDU_INSTANCE_LOST.
    07:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_0
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    08: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    08: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_0 is correct.
    09: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_0
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxMirrorBufferSizePart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>953</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxBufPartRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1522</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_2_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>1135</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that CanIf_Transmit() reports CANIF_E_PDU_INSTANCE_LOST when mirror buffer is full and
    the already stored ones are reported correctly.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    02: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    02: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_1 is correct.
    03: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1
    04:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_2
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    05: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    05: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_2 is correct.
    06:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_3
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    07: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    07: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_3 is correct.
m4_ifelse(PM_UlCddReporting,yes,\-:m4_dnl
    08: 08: Call CanIf_TxConfirmation() for the PduR_TxPdu_2
    09: CddId_TxPdu_0 frame not mirrored.
    10: Call CanIf_TxConfirmation() for the CddId_TxPdu_0
    11: Mirror frame check for the PduR_TxPdu_0
    12: Call CanIf_TxConfirmation() for the CddId_TxPdu_1
    13: CddId_TxPdu_1 frame not mirrored
:-/,m4_ifelse( :else: )\-:m4_dnl
    08: Call CanIf_TxConfirmation() for the CddId_TxPdu_0
    09: CddId_TxPdu_0 frame not mirrored
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1523</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>1310</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
     Test verifies frames reported while mirror is deactivated for the controller are not mirrored.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() for Tx PduR_TxPdu_0  and
        Check Can_Write() is called with the correct parameters
    02: Call CanIf_Transmit() for Tx PduR_TxPdu_1 and
        Check Can_Write() is called with the correct parameters
    03: Call CanIf_Transmit() for Tx PduR_TxPdu_2 and
        Check Can_Write() is called with the correct parameters
    04: Call CanIf_Transmit() for Tx PduR_TxPdu_3 and
        Check Can_Write() is called with the correct parameters
    05: Disable mirroring for ControllerId 0   CddId_TxPdu_0
    06: Call CanIf_Transmit() for Tx CddId_TxPdu_0 (returns with E_Ok)and
        Check Can_Write() is called with the correct parameters
    07: No DET CANIF_E_PDU_INSTANCE_LOST reported
    08: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_0
    09: PduR_TxPdu_0 frame is not mirrored.
    10: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_0
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1524</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_3_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>1466</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
     Test verifies frames reported while mirror is deactivated for the controller are not mirrored.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1
    02: PduR_TxPdu_1 is not mirrored.
    03: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1
    04: Enable mirror for controllerId 0
    05: Call CanIf_Transmit() for Tx PduR_TxPdu_0 with different data and
        Check Can_Write() is called with the correct parameters
    06: Call CanIf_Transmit() for Tx PduR_TxPdu_1 with different data and
        Check Can_Write() is called with the correct parameters
    07: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_3
    08: PduR_TxPdu_3 is not mirrored.
    09: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_4
    10: PduR_TxPdu_4 is not mirrored.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1525</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_3_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>1585</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
     Test verifies frames reported while mirror is deactivated for the controller are not mirrored.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_2
    02: PduR_TxPdu_2 is not mirrored.
    03: Call CanIf_TxConfirmation() to confirm the correct transmission of CddId_TxPdu_0
    04: CddId_TxPdu_0 is not mirrored
        Upper layer Tx confirmation is called for the correct PDU
    05:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_0
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    06: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    06: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_0 is correct.
    07: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_0
    08:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    09: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    09: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_1 is correct.
    10:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1526</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>1715</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Test verifies that CANIF_E_PDU_INSTANCE_LOST is reported when mirror buffer is full when Pdus from the middle of the buffer have been sent.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() for Tx PduR_TxPdu_0  and
        Check Can_Write() is called with the correct parameters
    02: Call CanIf_Transmit() for Tx PduR_TxPdu_1 and
        Check Can_Write() is called with the correct parameters
    03: Call CanIf_Transmit() for Tx PduR_TxPdu_2 and
        Check Can_Write() is called with the correct parameters
    04: Call CanIf_Transmit() for Tx PduR_TxPdu_3 and
        Check Can_Write() is called with the correct parameters
    05:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    06: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    06: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_1 is correct.
    07: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1
    08: Call CanIf_Transmit() for Tx PduR_TxPdu_1 again with different data and DLC of 2 byte.
        Check Can_Write() is called with the correct parameters
    09: Call CanIf_Transmit() trying to transmit Tx CddId_TxPdu_0
        and Check Can_Write() is called with the correct parameters
    11: Check Det_ReportError() is called with CANIF_E_PDU_INSTANCE_LOST.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1527</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_4_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>1898</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Test verifies that CANIF_E_PDU_INSTANCE_LOST is reported when mirror buffer is full when Pdus from the middle of the buffer have been sent.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    02: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    02: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_1 is correct.
    03: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1
    04:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_0
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    05: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    05: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_0 is correct.
    06: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_0
    07:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_2
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    08: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    08: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_2 is correct.
    09:Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_3
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    10: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    10: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
         Mirrored frame of PduR_TxPdu_3 is correct.
    11: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_4
    12: PduR_TxPdu_4 is not mirrored
    13: Call CanIf_Transmit() to transmit PDU PduR_TxPdu_1
    14: Call CanIf_Transmit() to transmit PDU PduR_TxPdu_4
    15: Bus off on controller, PduR_TxPdu_1 and PduR_TxPdu_4 are cleared
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1528</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_4_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>2094</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that when mirroring is disabled after transmit, no frame will be forwarded to UL.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Enable mirroring
    02: Call CanIf_Transmit() to transmit PDU PduR_TxPdu_0
    03: Call CanIf_Transmit() to transmit PDU PduR_TxPdu_3
    04: Call CanIf_Transmit() to transmit PDU PduR_TxPdu_2
    05: Call CanIf_Transmit() to transmit PDU PduR_TxPdu_1
    06: Call CanIf_TxConfirmation() for the PduR_TxPdu_0
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    07: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    07: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd):
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
        Mirror frame check for the PduR_TxPdu_0
        Mirrored frame of PduR_TxPdu_1 is correct.
    08: PduR confirmation check for the PduR_TxPdu_0
    09: Call CanIf_Transmit() to transmit PDU PduR_TxPdu_0
    10: Disable mirroring
    11: Call CanIf_TxConfirmation() to see that the frame is not forwarded to UL
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.TxMirrorBufferSize</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>951</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1529</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_4_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>2284</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the receiving new transmit request for frames already stored in the Mirror buffer
    without receiving a TX confirmation will result in overwriting the already stored payload and transmission
    of the stored one but only when the size of the new frame can be inserted into the payload buffer.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Enable mirroring
    02: Call CanIf_Transmit() for Tx PduR_TxPdu_0 and
        Check Can_Write() is called with the correct parameters
    03: Call CanIf_Transmit() for Tx PduR_TxPdu_1 and
        Check Can_Write() is called with the correct parameters
    04: Call CanIf_Transmit() for Tx PduR_TxPdu_2 and
        Check Can_Write() is called with the correct parameters
    05: Call CanIf_Transmit() for Tx PduR_TxPdu_4 and return E_OK
        Check Can_Write() is called with the correct parameters
    06: Check Det_ReportError() is called with CANIF_E_PDU_INSTANCE_LOST.
    07: Call CanIf_Transmit() for PduR_TxPdu_4 and
          Check Can_Write() is called with the correct parameters.
    08: Call CanIf_Transmit() for PduR_TxPdu_4 with greater payload and
        no available size in the buffer Check Can_Write() is called with the correct parameters.
    09: Check Det_ReportError() is called with CANIF_E_PDU_INSTANCE_LOST.
    10: Call CanIf_Transmit() for Tx PduR_TxPdu_1 with different Sdu again and return E_OK
        Check Can_Write() is called with the correct parameters
    11: Call CanIf_TxConfirmation() for PduR_TxPdu_1
    12: Check UL is called with correct parameters.
    13: Call CanIf_TxConfirmation() for PduR_TxPdu_4
    14: PduR_TxPdu_4 is not mirrored
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.TxMirrorBufferSize</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>951</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1530</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_Buffer_TX_4_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrTxPayloadBuff/source/application/Tests.c.m4</sourcefile>
      <sourceline>2516</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the receiving new transmit request for frames already stored in the Mirror buffer
     with bigger Sdu without receiving a TX confirmation will result in overwriting the already stored payload.
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Enable mirroring
    02: Call CanIf_Transmit() for Tx PduR_TxPdu_0 and
        Check Can_Write() is called with the correct parameters
    03: Call CanIf_Transmit() for Tx PduR_TxPdu_1 with 6 bytes Sdu
        Check Can_Write() is called with the correct parameters
    04: Call CanIf_Transmit() for Tx PduR_TxPdu_1 with 8 bytes Sdu
        Check Can_Write() is called with the correct parameters
    05: Check that DET is missing which indicates that frame is stored correctly.
    06: Call CanIf_TxConfirmation() for tx PduR_TxPdu_1.
    07: Check that frame is reported to UL with last stored Sdu correctly.
    08: Check that PduR_CanIfTxConfirmation() was called for PduR_TxPdu_1.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Mirroring.FullBuffer</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>955</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.TxMirrorBufferSize</linksto>
          <dstversion>3</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>951</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1531</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_API_ENABLEMIRROR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>352</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check the availability and behavior of the interfaces necessary for Mirroring
  
Test Object: 
    CanIf_EnableBusMirroring()
  
Test Precondition: 
    CanIfBusMirroringSupport configured as TRUE.
  
Test Execution: 
    01: Call CanIf_EnableBusMirroring() with incorrect ID
    02: VP(CanIf.ECUC_CanIf_00847):
        Without CanIfBusMirroringSupport configured as TRUE,
        CanIf_EnableBusMirroring() wouldn't be available.
    03: VP(CanIf.SWS_CanIf_91005.ReturnValue): E_NOT_OK is returned
    04: VP(CanIf.SWS_CanIf_00912): DET is reported
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91005.ReturnValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>837</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00912</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>831</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00847</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1532</internalId></specobject>
    <specobject>
      <id>TS_CANIF_API_GETCONTROLLERTXERRORCOUNTER</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>424</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check the availability and behavior of CanIf_GetControllerTxErrorCounter
  
Test Object: 
    CanIf_GetControllerTxErrorCounter()
  
Test Precondition: 
    CanIfCanTxErrorCounterSupported configured as FALSE.
    CanIfTxErrorCounterValue configured as 39.
  
Test Execution: 
    00: VP(CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanTxErrorCounterSupported):
        No calls made to Can
    01: Call CanIf_GetControllerTxErrorCounter() with incorrect ID
    02: VP(CanIf.SWS_CanIf_00909):
        DET is reported with CANIF_E_PARAM_CONTROLLERID
    03: Call CanIf_GetControllerTxErrorCounter() with an invalid pointer
    04: VP(CanIf.SWS_CanIf_00910):
        DET is reported with CANIF_E_PARAM_POINTER
    04: VP(CanIf.SWS_CanIf_91004.ReturnValue.NotSupportedByDriver):
    05: Call CanIf_GetControllerTxErrorCounter() with proper parameters
    06: VP(CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxErrorCounterValue):
        The value is the one from the configuration
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanTxErrorCounterSupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>947</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00909</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>827</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00910</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>828</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91004.ReturnValue.NotSupportedByDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>834</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxErrorCounterValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>948</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00847</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1533</internalId></specobject>
    <specobject>
      <id>TS_CANIF_API_GETCONTROLLERERRORSTATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>520</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check the availability and behavior of CanIf_GetControllerErrorState()
  
Test Object: 
    CanIf_GetControllerErrorState()
  
Test Precondition: 
    CanIfCanControllerErrorStateSupported configured as FALSE.
    CanIfErrorStateValue configured as CAN_ERRORSTATE_PASSIVE.
  
Test Execution: 
    00: VP(CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanControllerErrorStateSupported):
        No calls made to Can
    01: Call CanIf_GetControllerErrorState() with incorrect ID
    02: VP(CanIf.SWS_CanIf_00898):
        DET is reported with CANIF_E_PARAM_CONTROLLERID
    03: Call CanIf_GetControllerErrorState() with an invalid pointer
    04: VP(CanIf.SWS_CanIf_00899):
        DET is reported with CANIF_E_PARAM_POINTER
    04: VP(CanIf.SWS_CanIf_91001.ReturnValue.NotSupportedByDriver):
    05: Call CanIf_GetControllerErrorState() with proper parameters
    06: VP(CanIf.EB.ECUC_CanIf_Mirroring.CanIfErrorStateValue):
        The value is the one from the configuration
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfCanControllerErrorStateSupported</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>949</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00898</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>806</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00899</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>807</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_91001.ReturnValue.NotSupportedByDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>809</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfErrorStateValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>950</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00847</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>815</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1534</internalId></specobject>
    <specobject>
      <id>TS_CANIF_API_GETCONTROLLERMODESIG</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>616</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test verifies that the modes are translated correctly.
  
Test Object: 
    CanIf_GetControllerMode()
  
Test Precondition: 
    CanIfBusMirroringSupport configured as TRUE.
  
Test Execution: 
    01: Call CanIf_GetControllerMode(), Can returning different modes
        and check that the returned type is according to AR4.4
    02: VP(CanIf.EB.GetControllerMode.Signature.Mirroring.ON):
        The ModePtr is of type Can_ControllerStateType and the states are
        matching.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1535</internalId></specobject>
    <specobject>
      <id>TS_CANIF_API_GETTRCVMODE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>681</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that the Trcv mode is returned correctly, respecting the AR4.4 signature
  
Test Object: 
    CanIf_GetTrcvMode()
  
Test Precondition: 
    CanIfCanTxErrorCounterSupported configured as FALSE.
    CanIfTxErrorCounterValue configured as 39.
  
Test Execution: 
    01: VP(CanIf.EB.GetControllerMode.Signature.Mirroring.ON):
        The mode is returned for the controller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1536</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_RX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>728</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Tests verifies that the frames are mirrored from within CanIf_RxIndication()
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: VP(CanIf.EB.GetControllerMode.Signature.Mirroring.ON):
        CanIf_GetControllerMode() signature is according to AR4.4 specs
    02: Call CanIf_RxIndication() without enabling mirroring
    03: Frame is not mirrored
    04: Enable Mirroring
    05: Call CanIf_RxIndication()
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    06: VP(CanIf.SWS_CanIf_00903):
        The API of PM_ULReportingModule\-::-/ is called
    07: VP(CanIf.SWS_CanIf_00906.Provision.CANID,
           CanIf.SWS_CanIf_00906.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    06: VP(CanIf.EB.SWS_CANIF_00905.Cdd):
        The API of PM_ULReportingModule\-::-/ is called
    07: VP(CanIf.EB.SWS_CANIF_00906.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00906.Provision.Payload.Cdd): 
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
        Frame is mirrored correctly.
    08: Disable mirroring
    09: Call CanIf_RxIndication()
    10: No call to PM_ULReportingModule\-::-/_ReportCanFrame()
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>957</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00906.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>823</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00906.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>824</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00903</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>817</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00906.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>942</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00906.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>943</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1537</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_TX</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>868</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that frames are correctly mirrored during transmission
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CanIfBusMirroringSupport configured as TRUE.
  
Test Execution: 
    01: Enable mirroring
    01: Call CanIf_Transmit() with PDU PduR_TxPdu_0, for which the translation function returns
        a CAN ID that differs from one configured for this PDU.
    02: Check that Can_Write() was called with the correct parameters.
    03: Call CanIf_TxConfirmation() to confirm the correct transmission.
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    04: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    04: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd): 
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
        Check that the reported frame is correct
    05: Check that rogue CanIf_TxConfirmation() performs no mirroring
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1538</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_TX_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>978</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that if mirroring is disabled during transmission the frame won't be reported.
  
Test Object: 
    CanIf_EnableBusMirroring()
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Enable mirroring
    02: Call CanIf_Transmit() for a valid Tx PDU and let Can_Write() return
        CAN_OK
    03: Check Can_Write() is called with the correct parameters (translated CAN ID)
    04: Call CanIf_Transmit() for the same Tx PDU again and let Can_Write()
        return CAN_BUSY (buffer a message)
    05: Check Can_Write is called with the correct parameters (translated CAN ID)
    06: Call CanIf_Transmit() for a different Tx PDU assigned to the same HTH
        and a lower priority (higher CAN ID) as the PDU before and let
        Can_Write() return CAN_BUSY (buffer another message)
    07: Check Can_Write is called with the correct parameters
    08: Call CanIf_TxConfirmation()
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    09: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    09: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd): 
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
        Frame is not reported
    10: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is called for the buffered PDU (with the same
          parameters again)
    11: Call CanIf_TxConfirmation()
    12: VP: Frame is not reported
    13: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is called for the buffered PDU from 04 (with the same
          parameters again)
    14: Call CanIf_TxConfirmation() for the PDU from 08.
    15: - Upper layer Tx confirmation is called for the correct PDU
        - Can_Write() is not called again
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1539</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_TX_2_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1179</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the frames are reported correctly when retransmission occurs
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Enable mirroring
    02: Call CanIf_Transmit() for a valid Tx PDU and let Can_Write() return
        CAN_OK
    03: Check Can_Write() is called with the correct parameters (translated CAN ID)
    04: Call CanIf_Transmit() for the same Tx PDU again and let Can_Write()
        return CAN_BUSY (buffer a message)
    05: Check Can_Write is called with the correct parameters (translated CAN ID)
    06: Call CanIf_Transmit() for a different Tx PDU assigned to the same HTH
        and a lower priority (higher CAN ID) as the PDU before and let
        Can_Write() return CAN_BUSY (buffer another message)
    07: Disable mirroring
    08: Check Can_Write is called with the correct parameters
    09: Call CanIf_TxConfirmation()
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    10: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    10: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd): 
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
        Frame is not reported.
    11: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is called for the buffered PDU (with the same
          parameters again)
    12: Call CanIf_TxConfirmation()
    13: VP: Mirrored frame is correct
    14: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is called for the buffered PDU from 04 (with the same
          parameters again)
    15: Call CanIf_TxConfirmation() for the PDU from 08.
    16: - Upper layer Tx confirmation is called for the correct PDU
        - Can_Write() is not called again
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1540</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_TX_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1396</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the mirrored frames are correct.
    The correct frame is reported when one is cancelled
  
Test Object: 
    CanIf_Transmit()
    CanIf_TxConfirmation()
  
Test Precondition: 
    Two different Tx PDUs A and B assigned to the same HTH. (Translated) CAN ID of Tx PDU
    B is lower than the translated CAN ID of Tx PDU A.
  
Test Execution: 
    01: Call CanIf_Transmit() for a valid Tx PDU, PduR_TxPdu_1 and let Can_Write() return CAN_OK.
    02: Check Can_Write() is called with the correct parameters
        Check if the MSB of the CanId is set to 0 since it uses standard format.
    03: Call CanIf_Transmit() to request transmission of PDU PduR_TxPdu_0 to cancel PduR_TxPdu_1.
    04: Check Can_Write is called with the correct parameters
    05: Call CanIf_CancelTxConfirmation() to confirm cancellation of PduR_TxPdu_1 transmission.
    06: Check Can_Write() is called for PduR_TxPdu_1 with the translated CAN ID and the corresponding upper
        layer Tx confirmation callback is called for PduR_TxPdu_0.
    07: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_0.
m4_ifelse(PM_UlCddReporting,no,\-:m4_dnl
    08: VP(CanIf.SWS_CanIf_00905.Provision.CANID,
           CanIf.SWS_CanIf_00905.Provision.Payload):
:-/,m4_ifelse( :else: )\-:m4_dnl
    08: VP(CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd,
           CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd): 
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
        Mirrored frame is correct
    09: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1.
    10: Mirrored frame is correct
    11: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1541</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MIRROR_TX_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MirrorSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1576</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies correct mirroring when PduMode is cycled and later on interrupted by a bus-off.
  
Test Object: 
    Tx CAN ID translation
  
Test Precondition: 
    This test is also a regression test to verify the fix of the bug
    described with ASCCANIF-1286.
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() for a valid Tx PDU and let Can_Write() return
        CAN_OK.
    02: Check Can_Write() is called with the correct parameters (especially the
        translated CAN ID).
    03: Call CanIf_Transmit() for the same Tx PDU again and let Can_Write()
        return CAN_BUSY (buffer a message).
    04: VP (CanIf.SWS_CanIf_00243):
        Check Can_Write is called with the correct parameters (especially the translated CAN ID).
    05: Call CanIf_Transmit() for a different Tx PDU assigned to the same HTH
        and a lower priority (higher CAN ID) as the PDU before and let
        Can_Write() return CAN_BUSY (buffer another message).
    06: VP (CanIf.SWS_CanIf_00243):
        Check Can_Write is called with the correct parameters (especially the
        translated CAN ID).
    07: Call CanIf_TxConfirmation() for the PDU from 01. Can_Write() stub simulates a bus-off request
        when trying to re-send the buffered Pdus.
    08: VP (CanIf.SWS_CanIf_00724):
        Check that CanSM_ControllerBusOff() was called
    09: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is called for the buffered PDU from 03 (with the same
          parameters again).
    10: Disable mirroring. See that no frame is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>941</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.CANID.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>939</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00905.Provision.Payload.Cdd</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>940</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.CANID</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>820</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00905.Provision.Payload</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>821</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1542</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_Receive300Hrhs</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MoreThan255Hohs/source/application/Tests.c</sourcefile>
      <sourceline>148</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Receive through 300 different HRHs
  
Test Object: 
    Message reception
  
Test Precondition: 
    - 300 HRHs configured with the IDs 0 to 299
    - Each HRH has assigned one Rx PDU with the PduR as upper layer
    - Rx PDU IDs are equal to the HRH IDs (0..299)
  
Test Execution: 
    for all 300 HRHs:
    01: Simulate the reception of a PDU through this HRH.
    02: VP (CanIf.SWS_CanIf_00135, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006,
            CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00415):
        PduR_CanIfRxIndication() was called with the correct data and PDU ID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1543</internalId></specobject>
    <specobject>
      <id>TS_CANIF_Transmit300Hths</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MoreThan255Hohs/source/application/Tests.c</sourcefile>
      <sourceline>239</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmit via 300 different HTHs
  
Test Object: 
    Message transmission
  
Test Precondition: 
    - 300 HTHs configured with the IDs 300 to 599
    - Each HTH has assigned one Tx PDU
    - Tx PDU IDs are equal to the HTH IDs - 300 (0..299)
    - CAN IDs are equal to the Tx PDU IDs
    - CanIf is already initialized and the controller started
  
Test Execution: 
    for all 300 HTHs:
    01: Simulate the transmission of a Tx PDU assigned to the HTH.
    02: VP (CanIf.ASR40.SWS_CanIf_00005, CanIf.SWS_CanIf_00318, CanIf.SWS_CanIf_00162,
            CanIf.SWS_CanIf_00115.HohIdDerivedFromCan):
        Can_Write() was called with the correct parameters (especially HTH ID).
    03: Simulate Tx confirmation for that message.
    04: VP (CanIf.SWS_CanIf_00007, CanIf.EB.User_TxConfirmation.Signature.Result.OFF):
        PduR_CanIfTxConfirmation() called for the correct Tx PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00318</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>736</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.HohIdDerivedFromCan</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1544</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TxBufferCancel300Hths</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MoreThan255Hohs/source/application/Tests.c</sourcefile>
      <sourceline>356</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmit buffering and transmit cancellation with 300 different HTHs
  
Test Object: 
    Transmit buffering and transmit cancellation
  
Test Precondition: 
    - 300 HTHs configured with the IDs 300 to 599
    - Each HTH has assigned two Tx PDU
    - Tx PDU ID of the first Tx PDU for each HTH is equal to the HTH ID - 300
      (0..299)
    - Tx PDU ID of the second Tx PDU for each HTH is equal to the HTH ID
      (300..599)
    - CAN IDs are equal to the Tx PDU IDs
    - CanIf is already initialized and the controller started
  
Test Execution: 
    for all 300 HTHs:
    01: Simulate the transmission of the second Tx PDU (higher CAN ID) assigned to the HTH.
    02: Can_Write() was called with the correct parameters.
    03: Simulate the transmission of the first Tx PDU (lower CAN ID) assigned
        to the HTH and let Can_Write() return CAN_BUSY.
    04: Can_Write() was called with the correct parameters.
    05: Simulate a Tx cancellation for the first transmission by calling
        CanIf_CancelTxConfirmation().
    06: VP (CanIf.SWS_CanIf_00063, CanIf.EB.Rev2.CancelTxConfirmation):
        Can_Write() was called with the correct parameters, i.e. the transmission from 03.
    07: Simulate Tx confirmation for the transmission in 06 by calling CanIf_TxConfirmation().
    08: VP (CanIf.SWS_CanIf_00386, CanIf.SWS_CanIf_00668, CanIf.SWS_CanIf_00183):
        - Can_Write() was called with the correct parameters, i.e. the
          transmission from 01.
        - PduR_CanIfTxConfirmation() was called for the correct Tx PDU.
    09: Simulate Tx confirmation for the transmission in 08 by calling CanIf_TxConfirmation().
    10: VP (CanIf.SWS_CanIf_00386, CanIf.SWS_CanIf_00183):
        - Can_Write() was not called again.
        - PduR_CanIfTxConfirmation() was called for the correct Tx PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>541</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00668</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.CancelTxConfirmation</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1545</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CANFD_BIT_STANDARD_ADDR</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MoreThan255Hohs/source/application/Tests.c</sourcefile>
      <sourceline>539</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmit CAN frames with various CanIds (some configured for CAN FD,
    some not, all have standard addressing) and verify that the CAN FD bit is correctly
    set in call to Can_Write.
  
Test Object: 
    CAN FD bit
  
Test Precondition: 
  
Test Execution: 
    loop for some TxPdus with different CanIds and different settings of CanIdType
    01: Simulate the transmission of a Tx PDU.
    02 VP: Can_Write() was called with correct CanId, correct CAN FD bit and identifier
           extension bit set.
    03: Confirm the Pdu transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00590</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1546</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_MULTIDRV_TRANSMIT</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>89</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verify that the Can_Write API is called for the proper driver when a transmit request occurs.
  
Test Object: 
    Message transmit
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Simulate a successful transmission for a PDU on controller 0 which is on the first driver.
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_1_Inineon_Write() API is called which belongs to the first driver.
    03: Simulate a successful transmission for a PDU on controller 1 which is on the first driver.
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_1_Inineon_Write() API is called which belongs to the first driver.
    05: Simulate a successful transmission for a PDU on controller 2 which is on the second driver.
    06: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_2_Renesant_Write() API is called which belongs to the second driver.
    07: Simulate a second successful transmission for a PDU on controller 2 which is on the second driver.
    08: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_2_Renesant_Write() API is called which belongs to the second driver.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00124</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1547</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MULTIDRV_RXINDICATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>302</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verifies that CanIf_Rxindication() processes receptions from different drivers correctly .
  
Test Object: 
    Message reception
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Simulate a successful reception for a PDU on controller 0 which is on the first driver.
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        PduR_CanIfRxIndication() API is called with the corresponding PDU-ID.
    03: Simulate a successful reception for a PDU on controller 1 which is on the first driver.
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        PduR_CanIfRxIndication() API is called with the corresponding PDU-ID.
    05: Simulate a successful reception for a PDU on controller 2 which is on the second driver.
    06: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        PduR_CanIfRxIndication() API is called with the corresponding PDU-ID.
    07: Simulate a second successful reception for a PDU on controller 2 which is on the second driver.
    08: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        PduR_CanIfRxIndication() API is called with the corresponding PDU-ID.
    09: Simulate a third successful reception for a PDU on controller 2 which is on the second driver.
    10: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        PduR_CanIfRxIndication() API is called with the corresponding PDU-ID.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1548</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MULTIDRV_SETBAUDRATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>532</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the Can_SetBaudrate API is called for the proper driver when it is requested.
  
Test Object: 
    Set Baudrate
  
Test Precondition: 
    - CanIf is initialized
  
Test Execution: 
    01: Simulate a request to set the baudrate on controller 0 which belongs to the first driver.
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        Can_1_Inineon_SetBaudrate() API is called which belongs to the first driver.
    03: Simulate a request to set the baudrate on controller 1 which belongs to the first driver.
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        Can_1_Inineon_SetBaudrate() API is called which belongs to the first driver.
    05: Simulate a request to set the baudrate on controller 2 which belongs to the second driver.
    06: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        Can_2_Renesant_SetBaudrate() API is called which belongs to the second driver.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1549</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MULTIDRV_CHECKWAKEUP</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>644</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the Can_CheckWakeup API is called for the proper driver when it is requested.
  
Test Object: 
    Check Wakeup
  
Test Precondition: 
    - CanIf is initialized
    - Used controllers are stopped
  
Test Execution: 
    01: Call Check wakeup with a wakeup source applicable for Controller 0 (first driver).
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the first driver for Controller 0 with Can_1_Inineon_CheckWakeup().
    03: Call Check wakeup with a wakeup source applicable for Controller 1 (first driver).
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the first driver for Controller 1 with Can_1_Inineon_CheckWakeup().
    05: Call Check wakeup with a wakeup source applicable for Controller 2 (second driver).
    06: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the second driver for Controller 2 with Can_2_Renesant_CheckWakeup().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1550</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MULTIDRV_GETCONTROLLERERRORSTATE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>777</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the Can_GetControllerErrorState API is called for the proper driver when it is requested.
  
Test Object: 
    GetControllerErrorState
  
Test Precondition: 
    - CanIf is initialized
  
Test Execution: 
    01: Call CanIf_GetControllerErrorState() for Controller 0 (first driver).
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the first driver for Controller 0 with Can_1_Inineon_GetControllerErrorState().
    03: Call CanIf_GetControllerErrorState() for Controller 1 (first driver).
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the first driver for Controller 1 with Can_1_Inineon_GetControllerErrorState().
    05: Call CanIf_GetControllerErrorState() for Controller 2 (second driver).
    06: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the second driver for Controller 2 with Can_2_Renesant_GetControllerErrorState().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1551</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MULTIDRV_GETCONTROLLERTXERRORCOUNTER</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>888</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the Can_GetControllerTxErrorCounter API is called for the proper driver when it is requested.
  
Test Object: 
    GetControllerTxErrorCounter
  
Test Precondition: 
    - CanIf is initialized
  
Test Execution: 
    01: Call CanIf_GetControllerTxErrorCounter() for Controller 0 (first driver).
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the first driver for Controller 0 with Can_1_Inineon_GetControllerTxErrorCounter().
    03: Call CanIf_GetControllerTxErrorCounter() for Controller 1 (first driver).
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the first driver for Controller 1 with Can_1_Inineon_GetControllerTxErrorCounter().
    05: Call CanIf_GetControllerTxErrorCounter() for Controller 2 (second driver).
    06: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea);
        CanIf calls the second driver for Controller 2 with Can_2_Renesant_GetControllerTxErrorCounter().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1552</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MULTIDRV_CANCELTXCONFIRMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1000</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verify that the dispatcher for the API CanIf_CancelTxConfirmation() functions properly.
  
Test Object: 
    Cancel Tx confirmation
  
Test Precondition: 
    - CanIf is initialized
    - Used controllers are started
  
Test Execution: 
    01: Call the dispatcher for CanIf_CancelTxConfirmation() for the first driver (Inineon).
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_1_Inineon_Write() API is called which belongs to the first driver.
    03: Call the dispatcher for CanIf_CancelTxConfirmation() for the second driver (Renesant).
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_2_Renesant_Write() API is called which belongs to the second driver.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1553</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MULTIDRV_CONTROLLERBUSOFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1128</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verify that the dispatcher for the API CanIf_ControllerBusOff() functions properly.
  
Test Object: 
    Bus off
  
Test Precondition: 
    - CanIf is initialized
    - Used controllers are started
  
Test Execution: 
    01: Call the dispatcher for CanIf_ControllerBusOff() for the first driver (Inineon).
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        CanSM_ControllerBusOff() API is called.
    03: Call the dispatcher for CanIf_ControllerBusOff() for the second driver (Renesant).
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        CanSM_ControllerBusOff() API is called.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00124</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1554</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MULTIDRV_OFFSETTXBUFF</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleCanDrvs/source/application/Tests.c.m4</sourcefile>
      <sourceline>1239</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verify that HTH offset is considered during Tx buffering when the Can_Write API is called for the proper driver when a transmit request occurs.
  
Test Object: 
    Message transmit
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: 01: Simulate a successful transmission for a PDU on controller 2 which is on the second driver.
    02: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_2_Renesant_Write() API is called which belongs to the second driver.
    03: Simulate a transmission for a PDU on controller 2 which is on the second driver and let Can_Write() return CAN_BUSY.
    04: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_2_Renesant_Write() API is called which belongs to the second driver.
    05: Simulate a transmission for a PDU on controller 2 which is on the second driver and let Can_Write() return CAN_BUSY.
    06: VP(CanIf.SWS_CanIf_00378, CanIf.ECUC_CanIf_00612, CanIf.SWS_CanIf_00115.OverlapNumberArea, CanIf.ASR40.SWS_CanIf_00124);
        Can_2_Renesant_Write() API is called which belongs to the second driver.
    07: Call CanIf_TxConfirmation to indicate that Tx PDU 2 has been transmitted.
    08: Check that the Pdu with the highest priority in the buffer is sent.
    09: Call CanIf_TxConfirmation to indicate that Tx PDU 4 has been transmitted.
    10: Check that the Pdu with the highest priority in the buffer is sent.
    11: Call CanIf_TxConfirmation to indicate that Tx PDU 5 has been transmitted.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00378</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>536</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00612</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>368</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.OverlapNumberArea</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>446</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00124</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>40</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00699</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>650</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1555</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31144</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleHrhPDUs/source/application/Tst_31144.c</sourcefile>
      <sourceline>108</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that software filtering and reception is performed correctly in the case of Rx L-PDUs
    being assigned to single as well as multiple HRHs.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanIf and start the CanIf network.
    02: Simulate a message reception with the corresponding CAN ID for the current HRH.
    03: VP (CanIf.ASR40.SWS_CanIf_00465, CanIf.SWS_CanIf_00030_1, CanIf.SWS_CanIf_00030_2,
            CanIf.SWS_CanIf_00030_3, CanIf.SWS_CanIf_00829, CanIf.ASR40.SWS_CanIf_00057,
            CanIf.ECUC_CanIf_00632):
        - Check if message was correctly propagated to the PduR if the CAN ID shall be received or
        - Check that the message is not propagated if the HRH has no Rx PDU assigned which shall receive
        this CAN ID.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00465</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00030_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>422</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00030_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>423</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00030_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>424</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00829</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>711</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00057</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>32</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00632</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1556</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_RxRange_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_MultipleHrhPDUs/source/application/Tst_RxRange_1.c</sourcefile>
      <sourceline>111</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that range reception is performed correctly in the case of a Rx L-PDU
    is assigned to multiple HRHs.
  
Test Object: 
    Message reception
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CanIf and start network.
    For several different CAN messages (different CAN IDs) and all configured HRHs.
    02: Simulate a message reception with CAN IDs which are configured in a range for the current
        PDU range container and outside a configured range of CAN IDs.
    03: VP (CanIf.ASR40.SWS_CanIf_00465, CanIf.SWS_CanIf_00829):
        - Check if message was correctly propagated to the PduR if the CAN ID shall be received.
        - Check if message was discarded, if the CAN ID is not in range of configured CAN IDs.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00465</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>110</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00829</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>711</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1557</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30363</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_NoDLCCheck_NoTxBuffers/source/application/Tests.c.m4</sourcefile>
      <sourceline>131</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that PDUs with a DLC smaller than expected are not discarded when DLC checking is
    deactivated in the configuration.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    DLC check disabled in the configuration
  
Test Execution: 
    01: Initialize CAN interface.
    02: Move CanIf to mode CANIF_CS_STARTED.
    03: Simulate message reception for RxPdu0 (configured DLC:4) with length 2.
    04: VP (CanIf.SWS_CanIf_00830):
        Verify that CanTp_RxIndication functions is called. (The received DLC is passed)
    05: Simulate message reception for RxPdu1 (configured DLC:8) with length 7.
    06: VP (CanIf.SWS_CanIf_00830):
        Verify that CanTp_RxIndication functions is called. (The received DLC is passed)
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00830</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>712</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1558</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30416</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_NoDLCCheck_NoTxBuffers/source/application/Tests.c.m4</sourcefile>
      <sourceline>259</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that PDUs with a DLC longer than expected are not truncated to the configured length and
    that the callback in upper layer is called.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    DLC check disabled in the configuration
  
Test Execution: 
    01: Initialize CAN interface.
    02: Move CanIf to mode CANIF_CS_STARTED.
    03: Simulate message reception for RxPdu0 (configured DLC:4) with length 8.
    04: VP (CanIf.ECUC_CanIf_00617):
        Check that number of bytes corresponding to the received DLC is copied by the CAN interface.
    05: Simulate message reception for RxPdu2 (configured DLC:1) with length 2.
    06: VP (CanIf.ECUC_CanIf_00617):
        Check that number of bytes corresponding to the received DLC is copied by the CAN interface.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00830</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>712</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00617</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1559</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30368</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_NoDLCCheck_NoTxBuffers/source/application/Tests.c.m4</sourcefile>
      <sourceline>391</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission without transmit buffers
  
Test Object: 
    Message transmission
  
Test Precondition: 
    TX buffering disabled in the configuration.
  
Test Execution: 
    01: Call CanIf_Transmit for transmission of TxPdu0 (correct transmission).
    02: VP (CanIf.ASR40.SWS_CanIf_00005):
        Verify that CanIf_Transmit returns E_OK.
    03: Call CanIf_Transmit for transmission of TxPdu0 before first one is performed.
    04: VP (CanIf.ASR40.SWS_CanIf_00005):
        Verify that CanIf_Transmit returns E_NOT_OK.
    05: Call CanIf_TxConfirmation to confirm first tx request.
    06: VP (CanIf.ASR40.SWS_CanIf_00005):
        Check that Can_Write is not called when CanIf_TxConfirmation is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1560</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_NO_SW_FILTERING_SUPPORTED_READRXNOTIFYSTATUS</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_NoSWFiltering/source/application/Tests.c.m4</sourcefile>
      <sourceline>129</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ReadRxNotifStatus returns CANIF_NO_NOTIFICATION when no indication occurred.
  
Test Object: 
    CanIf_Init()
  
Test Precondition: 
    CAN interface already initialized.
    One Rx using notification status API configured.
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Initialize internal counters and start controller 1.
    03: Call CanIf_ReadRxNotifStatus.
    04: VP (CanIf.ASR40.SWS_CanIf_00230, CanIf.SWS_CanIf_00201):
        Verify that CanIf_ReadRxNotifStatus returns CANIF_NO_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00201</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>737</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1561</internalId></specobject>
    <specobject>
      <id>TS_CANIF_NO_SW_FILTERING_SUPPORTED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_NoSWFiltering/source/application/Tests.c.m4</sourcefile>
      <sourceline>208</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
   Simulate reception events for PDUs where SW filter is diabled for the HrH , purpose of this test is
   to get sure that no search is done and just the first index is considered.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Simulate a successful reception for a PDU ID = 5 on Hrh "TST_HRH_0_STD".
    02: PduR_CanIfRxIndication() must be called with the first PDU-ID (TST_RX_PDUID_5_targetPduId_CanId).

    03: Simulate a successful reception for a PDU ID = 6 on Hrh "TST_HRH_0_STD".
    04: PduR_CanIfRxIndication() must be called with the first PDU-ID (TST_RX_PDUID_5_targetPduId_CanId) not PduId 6.

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00632</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>381</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1562</internalId></specobject>
    <specobject>
      <id>TS_CANIF_NO_SW_FILTERING_SUPPORTED_HRH_NOT_USED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_NoSWFiltering/source/application/Tests.c.m4</sourcefile>
      <sourceline>300</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate a message reception for an unused HRH while enabling software filtering and Metadata support.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: Initialize internal counters and start controller 1.
    03: Simulate several message receptions on an unused HRH HRH_1_1 with software
        filtering enabled.
    04: VP (CanIf.SWS_CanIf_00389):
        EcuC_SetMetaDataCanId() and PduR_CanIfRxIndication() must not be called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SoftwareFilter.RejectPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1563</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_PnFilterBlocksTxPdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_PartialNetworking/source/application/Tests.c</sourcefile>
      <sourceline>99</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the partial networking filter blocks a Tx PDU which is not
    allowed to pass it.
  
Test Object: 
    Partial networking
  
Test Precondition: 
    - CanIf is initialized and controller under test is started
    - No transmission performed since start of the controller
  
Test Execution: 
    01: Call CanIf_Transmit() for a Tx PDU which shall be filtered out by the
         partial networking filter.
    02: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00863,
             CanIf.SWS_CanIf_00750_1, CanIf.SWS_CanIf_00878, CanIf.ECUC_CanIf_00772):
         CanIf_Transmit() returns E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
             CanIf.SWS_CanIf_00750_1):
         Can_Write() was not called.
    04: VP ( CanIf.SWS_CanIf_00866_1):
        Check if the pdu mode (CanIf_GetPduMode()) is TX_OFFLINE.
    05: Call CanIf_Transmit() for a Tx PDU which shall be filtered out by the
        partial networking filter.
    06: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
            CanIf.SWS_CanIf_00750_1, CanIf.ECUC_CanIf_00772):
        CanIf_Transmit() returns E_NOT_OK.
    07: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
            CanIf.SWS_CanIf_00750_1):
        Can_Write() was not called.
    08: Call CanIf_Transmit() for a Tx PDU which shall be filtered out by the
         partial networking filter.
    09: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
             CanIf.SWS_CanIf_00750_1,  CanIf.SWS_CanIf_00749, CanIf.ECUC_CanIf_00772):
         CanIf_Transmit() returns E_NOT_OK.
    10: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
             CanIf.SWS_CanIf_00750_1):
         Can_Write() was not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00747</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00748</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>742</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00749</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>743</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00750_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>745</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00866_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>767</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00878</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>779</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00863</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>763</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1564</internalId></specobject>
    <specobject>
      <id>TS_CANIF_PnFilterAllowsTxPdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_PartialNetworking/source/application/Tests.c</sourcefile>
      <sourceline>277</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the partial networking filter allows a Tx PDU which is allowed
    to pass it.
  
Test Object: 
    Partial networking
  
Test Precondition: 
    - CanIf is initialized and controller under test is started
    - No transmission performed since start of the controller
  
Test Execution: 
    01: Call CanIf_Transmit() for a Tx PDU which shall be allowed by the partial networking filter.
    02: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
            CanIf.SWS_CanIf_00750_2, CanIf.ECUC_CanIf_00772):
        CanIf_Transmit() returns E_OK.
    03: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
            CanIf.SWS_CanIf_00750_2, CanIf.ECUC_CanIf_00772):
        Can_Write() was called for the given Tx PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00747</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00748</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>742</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00749</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>743</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00750_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>746</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1565</internalId></specobject>
    <specobject>
      <id>TS_CANIF_NoPnFilterAfterTxConf</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_PartialNetworking/source/application/Tests.c</sourcefile>
      <sourceline>373</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the filter is disabled after the first Tx confirmation.
  
Test Object: 
    Partial networking
  
Test Precondition: 
    This test is also a regression test to verify the fix of the bug
    described with ASCCANIF-1145.
    To verify the fix it is mandatory that the following preconditions
    are fulfilled:
    - CanIfPublicReadTxPduNotifyStatusApi shall be set to 'false'
    - CanIfPublicTxBuffering shall be set to 'false'
    - CanIfPublicTxConfirmPollingSupport shall be set to 'false'
  
Test Execution: 
    01: Execute test TS_CANIF_PnFilterAllowsTxPdu() to prepare the state,
        that Partial Networking filter is active and first message was sent.
    02: Call CanIf_Transmit() for a Tx PDU which shall be filtered out by the
        partial networking filter.
    03: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
            CanIf.SWS_CanIf_00750_2, CanIf.ECUC_CanIf_00772):
        CanIf_Transmit() returns E_NOT_OK.
    04: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00749,
            CanIf.SWS_CanIf_00750_2, CanIf.ECUC_CanIf_00772):
        Can_Write() was not called.
    05: Call CanIf_TxConfirmation() for the Tx PDU sent in TS_CANIF_PnFilterAllowsTxPdu().
    06: Call CanIf_Transmit() for the Tx PDU from step 02 again.
    07: VP (CanIf.SWS_CanIf_00751, CanIf.SWS_CanIf_00752, CanIf.ECUC_CanIf_00772):
        CanIf_Transmit() returns E_OK.
    08: VP (CanIf.SWS_CanIf_00751, CanIf.SWS_CanIf_00752, CanIf.ECUC_CanIf_00772):
        Can_Write() was called for the given Tx PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00747</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00748</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>742</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00749</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>743</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00750_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>746</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00751</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>747</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00752</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>748</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1566</internalId></specobject>
    <specobject>
      <id>TS_CANIF_NoPnFilterWithoutTxPdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_PartialNetworking/source/application/Tests.c</sourcefile>
      <sourceline>484</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that no partial networking filter is used for controllers, which
    don't have a Tx PDU configured for passing a filter.
  
Test Object: 
    Partial networking
  
Test Precondition: 
    - CanIf is initialized and controller under test is started
    - No transmission performed since start of the controller
    - No Tx PDU configured with active partial networking filter for the
      controller under test
  
Test Execution: 
    01: Call CanIf_Transmit() for a Tx PDU of the controller under test.
    02: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00752,
            CanIf.ECUC_CanIf_00772):
        CanIf_Transmit() returns E_OK.
    03: VP (CanIf.SWS_CanIf_00747, CanIf.SWS_CanIf_00748, CanIf.SWS_CanIf_00752,
            CanIf.ECUC_CanIf_00772):
        Can_Write() was called for the given Tx PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00747</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>741</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00748</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>742</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00752</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>748</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1567</internalId></specobject>
    <specobject>
      <id>TS_CANIF_NoPnFilterAfterFirstRxIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_PartialNetworking/source/application/Tests.c</sourcefile>
      <sourceline>577</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the filter is disabled after a successful reception of a frame with TxPnFilter enabled.
  
Test Object: 
    Partial networking
  
Test Precondition: 
  
Test Execution: 
    01: Prepare CanIf to make the controller run
    02: Execute test TS_CANIF_PnFilterBlocksTxPdu() to see that PduUT will be filtered out by the
        partial networking filter.
    03: Call CanIf_RxIndication() for an RxPdu with Partial Networking filter activated.
    04: VP (CanIf.SWS_CanIf_00752, CanIf.ECUC_CanIf_00772):
        Call CanIf_Transmit() for the TxPdu from step 02 again. CanIf_Transmit() returns E_OK.
    05: VP (CanIf.SWS_CanIf_00752, CanIf.ECUC_CanIf_00772):
        Can_Write() was called for the given Tx PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00896</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>805</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1568</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_ConTest_ParametersRelatedTo_PnSupport_SetTo_FALSE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_PnSupport_Enabled_ButSetToFalse/source/application/CanIf_ConTest_DifferentAccess_PnSupport_Trcv.c</sourcefile>
      <sourceline>43</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    General configuration as in test case CanIf_ComTest_AllOptDetOn however:
    * in p0, CanTrcv/VendorSpecific/CanTrcvPnSupport from 4.2.2 CanTrcv exists, but is set to FALSE
    * in p1, CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable from 4.2.2 CanTrcv exists, but is set to FALSE
    * in p2, CanTrcv/CanTrcvConfigSet/CanTrcvChannel/CanTrcvHwPnSupport, CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable
             and CanTrcv/VendorSpecific/CanTrcvPnSupport, from 4.2.2 CanTrcv do not exist
    * in p3, CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable from 4.0.3 CanTrcv exists, but is set to FALSE
    * in p4, CanTrcv/VendorSpecific/CanTrcvPnSupport from 4.0.3 CanTrcv exists, but is set to FALSE
  
Test Object: 
    The 5 permutations of the test verify that CanTrcv_ClearTrcvWufFlag and CanTrcv_CheckWakeFlag functions are not
    present in the CanIf_CanTrcvConfig structure if:
    p0 permutation
    * 4.2.2 CanTrcv is used and
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/VendorSpecific/CanTrcvPnSupport exists, but is set to FALSE
    p1 permutation
    * 4.2.2 CanTrcv is used and
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable exists, but is set to FALSE
    p2 permutation
    * 4.2.2 CanTrcv is used and
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/CanTrcvConfigSet/CanTrcvChannel/CanTrcvHwPnSupport does not exists and
    * CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable does not exist and
    * CanTrcv/VendorSpecific/CanTrcvPnSupport does not exist
    p3 permutation
    * 4.0.3 CanTrcv is used and
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable exists, but is set to FALSE
    p4 permutation
    * 4.0.3 CanTrcv is used and
    * CanIfPublicPnSupport is set to TRUE in CanIf configuration and
    * CanTrcv/VendorSpecific/CanTrcvPnSupport exists, but is set to FALSE
  
Test Precondition: 
  
Test Execution: 
    01: Initialize CAN interface.
    02: Call CanIf_ClearTrcvWufFlag() API for 422 CanTrcv (p0, p1 and p2 permutations)
        and for 403 CanTrcv (p3 and p4 permutations)
    03: Check that if CanIfPublicPnSupport and CanTrcv/VendorSpecific/CanTrcvPnSupport or CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable
        or CanTrcv/CanTrcvConfigSet/CanTrcvChannel/CanTrcvHwPnSupport are set to FALSE
        CanIf_ClearTrcvWufFlag() calls CanIf_ClearTrcvWufFlag_HlpNoPn() and a DET error is thrown.
    04: Call CanIf_CheckTrcvWakeFlag() API for 422 CanTrcv (p0, p1 and p2 permutations)
        and for 403 CanTrcv (p3 and p4 permutations)
    05: Check that if CanIfPublicPnSupport and CanTrcv/VendorSpecific/CanTrcvPnSupport or CanTrcv/CanTrcvGeneral/VendorSpecific/CanTrcvHwPNSupportApiEnable
        or CanTrcv/CanTrcvConfigSet/CanTrcvChannel/CanTrcvHwPnSupport are set to FALSE
        CanIf_CheckTrcvWakeFlag() calls CanIf_CheckWakeFlag_HlpNoPn() and a DET error is thrown.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00730</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>660</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>460</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1569</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>183</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if CanIf_CancelTxConfirmation doesn't retransmit the previously buffered TxPdu, if called
    when the controller was in mode CANIF_CS_STOPPED.
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    01: Intialize CanIf, start the controller and set the Pdu mode to ONLINE.
    02: Transmit message on TxPdu8. TxConfirmation is not given.
    03: Prepare the Can_Write to return BUSY.
    04: Start transmission on TxPdu7.
    05: VP:
        Check that Can_Write was called and message is buffered.
    06: Stop the controller.
    07: Can_Write shall return OK.
    08: Call CanIf_CancelTxConfirmation for TxPdu8.
    09: VP (CanIf.ASR40.SWS_CanIf_00054):
        Check if CanIf_CancelTxConfirmation doesn't retransmit the TxPdu7 already buffered because of
        the controller mode.
    10: Restart the controller.
    11: Call CanIf_TxConfirmation for TxPdu8.
    12: VP (CanIf.ASR40.SWS_CanIf_00054):
        Check if retransmission of TxPdu8 is not performed since the CanIf_CancelTxConfirmation
        call doesn't buffer this PDU.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1570</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_2</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>348</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if CanIf_CancelTxConfirmation doesn't buffer the cancelled message, in case not associated
    buffer was configured.
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    01: Intialize CanIf, start the controller and set the Pdu mode to ONLINE.
    02: Transmit message on TxPdu6. TxConfirmation is not given.
    03: Call CanIf_CancelTxConfirmation for TxPdu6.
    04: VP (CanIf.ASR40.SWS_CanIf_00054, CanIf.SWS_CanIf_00835):
        Check if the TxPdu6 is not buffered since no associating TxBuffer is configured.
    05: Confirm TxPdu6.
    06: VP (CanIf.ASR40.SWS_CanIf_00054, CanIf.SWS_CanIf_00835):
        Check that the PDU is not retransmitted since it was not buffered.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00835</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>713</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1571</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_3</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>460</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if CanIf_CancelTxConfirmation doesn't retransmit the previously buffered TxPdu, if called
    when the controller was in mode CANIF_CS_SLEEP.
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    01: Intialize CanIf, start the controller and set the Pdu mode to ONLINE.
    02: Prepare the Can_Write to return BUSY.
    03: Start transmission on TxPdu7.
    04: VP:
        Check that Can_Write was called and message is buffered.
    05: Put the controller to SLEEP mode.
    06: Call CanIf_CancelTxConfirmation for TxPdu7.
    07: VP (CanIf.ASR40.SWS_CanIf_00054):
        Check if CanIf_CancelTxConfirmation doesn't retransmit the TxPdu7 already buffered because of
        the controller mode.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1572</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_4</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>572</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if CanIf_CancelTxConfirmation attempts to retransmit the previously buffered TxPdu.
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    01: Intialize CanIf, start the controller and set the Pdu mode to ONLINE.
    02: Prepare the Can_Write to return BUSY.
    03: Start transmission on TxPdu7.
    04: VP(CanIf.ASR40.SWS_CanIf_00054):
        Check that Can_Write was called and message is buffered.
    05: Prepare the Can_Write to return OK.
    06: Transmit message on TxPdu8. TxConfirmation is not given.
    07: Prepare the Can_Write to return BUSY.
    08: Call CanIf_TxConfirmation for TxPdu8.
    09: Check if module attempted to retransmit TxPdu7.
    10: Prepare the Can_Write to return OK.
    11: Call CanIf_CancelTxConfirmation for TxPdu7.
    12: VP (CanIf.ASR40.SWS_CanIf_00054):
        Check if the buffered TxPdu7 is retransmitted.
    13: Call CanIf_TxConfirmation for TxPdu7.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1573</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_5</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>731</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if CanIf_CancelTxConfirmation attempts to retransmit the previously buffered TxPdu.
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    01: Intialize CanIf, start the controller and set the Pdu mode to ONLINE.
    02: Prepare the Can_Write to return BUSY.
    03: Start transmission on TxPdu7.
    04: VP(CanIf.ASR40.SWS_CanIf_00054):
        Check that Can_Write was called and message is buffered.
    05: Prepare the Can_Write to return OK.
    06: Transmit message on TxPdu8. TxConfirmation is not given.
    07: Call CanIf_CancelTxConfirmation for TxPdu7.
    08: VP (CanIf.ASR40.SWS_CanIf_00054):
        Check if the buffered TxPdu8 is retransmitted.
    09: Call CanIf_CancelTxConfirmation for TxPdu8.
    10: VP (CanIf.ASR40.SWS_CanIf_00054):
        Check if the buffered TxPdu8 is retransmitted.
    11: Call CanIf_TxConfirmation for TxPdu7.
    12: Call CanIf_TxConfirmation for TxPdu8.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1574</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_6</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>895</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if CanIf_CancelTxConfirmation attempts to retransmit the previously buffered TxPdu with the
    corresponding CanId set by CanIf_SetDynamicTxId().
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    01: Intialize CanIf, start the controller and set the Pdu mode to ONLINE.
    02: Prepare the Can_Write to return BUSY.
    03: Start transmission on TxPdu7.
    04: VP(CanIf.ASR40.SWS_CanIf_00054):
        Check that Can_Write was called and message is buffered.
    05: Prepare the Can_Write to return OK.
    06: Transmit message on TxPdu8. TxConfirmation is not given.
    07: Call CanIf_CancelTxConfirmation for TxPdu7.
    08: Change CAN ID of dynamic TX L-PDU 9 (extended id).
    09: VP (CanIf.ASR40.SWS_CanIf_00054):
        Check if the buffered TxPdu8 is retransmitted.
    09: Call CanIf_CancelTxConfirmation for TxPdu8.
    10: VP (CanIf.ASR40.SWS_CanIf_00054):
        Check if the buffered TxPdu8 is retransmitted.
    11: Call CanIf_TxConfirmation for TxPdu7.
    12: Call CanIf_TxConfirmation for TxPdu8.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1575</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanIfTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>1064</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check the message transmission on all the TxPdus configured, so that the Ids configured in CanIf
    resolves to the correct Ids in Can.
  
Test Object: 
    Message transmission with shuffled configuration of CanIfTxPduRef, CanIfTrcvCanTrcvRef and
    CanIfHthIdSymRef.
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    Loop the steps 01 to 06 for all configured TxPdus.
    01: Start the controller and set the PDU mode to ONLINE.
    02: Transmit message on the TxPdu.
    03: VP (CanIf.ECUC_CanIf_00603, CanIf.ECUC_CanIf_00627):
        Check if Can_Write is called for correct PDU.
    04: Confirm the TxPdu sent.
    05: VP (CanIf.ECUC_CanIf_00603, CanIf.ECUC_CanIf_00627):
        Check if PduR_CanIfTxConfirmation is called.
    06: Start the controller.
    07: VP (CanIf.ECUC_CanIf_00636):
        Check if Can_SetControllerMode is called with appropriate Id.
        set the PDU mode to OFFLINE.
    08: Set Pdu mode to OFFLINE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00603</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>360</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00636</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00627</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1576</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanIfRxIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>1233</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check message reception on all the RxPdus configured, so that the Ids configured in CanIf
    resolves to the correct Ids in Can.
  
Test Object: 
    Message reception with shuffled configuration of CanIfCtrlCanCtrlRef, CanIfHrhIdSymRef and
    CanIfRxPduHrhIdRef.
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    Loop the steps 01 to 05 for all configured RxPdus.
    01: Start the controller and set the PDU mode to ONLINE.
    02: Simulate reception of message on the RxPdu.
    03: VP (CanIf.ECUC_CanIf_00602, CanIf.ECUC_CanIf_00634, CanIf.ECUC_CanIf_00601):
        Check if PduR_CanIfRxIndication is called for correct PDU.
    04: VP (CanIf.ECUC_CanIf_00602, CanIf.ECUC_CanIf_00634, CanIf.ECUC_CanIf_00601):
        Check if correct data was passed.
    05: Start the controller.
    06: VP (CanIf.ECUC_CanIf_00636):
        Check if Can_SetControllerMode is called with appropriate Id.
    07: Set Pdu mode to OFFLINE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00602</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>359</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00636</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>383</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00634</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00601</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>358</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1577</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanIfTrcvModeIndication</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Rev2CompatibilityDisabled/source/application/Tests.c</sourcefile>
      <sourceline>1393</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check transceiver mode switching on all the configured transceiver channels, so that Ids
    configured in CanIf resolves to correct Ids in CanTrcv.
  
Test Object: 
    CanIf_TrcvModeIndication()
  
Test Precondition: 
    CANIF_CAN_REV2_COMPATIBILITY disabled.
  
Test Execution: 
    Loop the steps 01 to 02 for all configured Trcv channels.
    01: Call CanIf_SetTrcvMode with valid CanIfTrcvId.
    02: VP (CanIf.ECUC_CanIf_00605):
        Check if CanTrcv_SetOpMode is called with expected CanTrcvId.
    03: Call CanIf_TrcvModeIndication with valid CanTrcvId.
    04: VP (CanIf.ECUC_CanIf_00605):
        Check if CanSM_TrcvModeIndication is called with expected CanIfTrcvId.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00605</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>361</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1578</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31176</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31176.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetControllerMode reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    Can Interface is initialized.
  
Test Execution: 
    01: Call CanIf_GetControllerMode() with invalid controller ID.
    02: VP (CanIf.EB.GetControllerMode.Signature.Mirroring.OFF):
        Verify that CanIf_GetControllerMode returns E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00313):
        Verify that CANIF_E_PARAM_CONTROLLERID is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00313</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>499</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1579</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31177</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31177.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ControllerBusOff reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    Can Interface is initialized.
  
Test Execution: 
    01: Call CanIf_ControllerBusOff() with invalid controller ID.
    02: VP (CanIf.SWS_CanIf_00429):
        Verify that CANIF_E_PARAM_CONTROLLERID is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00429</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>566</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1580</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31178</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31178.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetPduMode reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    Can Interface is initialized.
  
Test Execution: 
    01: Call CanIf_GetPduMode() with invalid controller ID.
    02: VP (CanIf.SWS_CanIf_00009):
        Verify that CanIf_GetPduMode returns E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00346):
        Verify that CANIF_E_PARAM_CONTROLLERID is reported to the DET module.
    Call CanIf_GetPduMode with an invalid value in Controller.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00346</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>522</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1581</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31180</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31180.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetControllerMode reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    Can Interface is initialized.
  
Test Execution: 
    01: Call CanIf_SetControllerMode() with invalid controller ID.
    02: VP (CanIf.SWS_CanIf_00003):
        Verify that CanIf_SetControllerMode returns E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00311):
        Verify that CANIF_E_PARAM_CONTROLLERID is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00311</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>498</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1582</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31181</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31181.c</sourcefile>
      <sourceline>58</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_SetPduMode reports a DET error when given an invalid Controller.
  
Test Object: 
    Det reporting
  
Test Precondition: 
    Can Interface is initialized.
  
Test Execution: 
    01: Call CanIf_SetPduMode() with invalid controller ID.
    02: VP (CanIf.SWS_CanIf_00008):
        Verify that CanIf_SetPduMode returns E_NOT_OK.
    03: VP (CanIf.SWS_CanIf_00341):
        Verify that CANIF_E_PARAM_CONTROLLERID is reported to the DET module.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00341</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>521</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1583</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31184</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31184.c</sourcefile>
      <sourceline>61</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Controller and channel mode initialization.
  
Test Object: 
    CanIf_Init()
  
Test Precondition: 
    Can Interface not initialized.
  
Test Execution: 
    01: Call CanIf_Init to initialize CanIf.
    02: VP (CanIf.ASR40.SWS_CanIf_00478, ):
        Call CanIf_GetControllerMode and check whether it returns CANIF_CS_STOPPED.
    03: Call CanIf_GetPduMode and check whether it returns CANIF_GET_OFFLINE.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00478</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1584</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31186</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31186.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate the reception of a valid PDU
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    Previous test case (TS_CANIF_31183) finished successfully.
  
Test Execution: 
    01: Call CanIf_RxIndication with the parameters of a valid Rx PDU.
    02: VP (CanIf.SWS_CanIf_00135, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006,
            CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00415):
        Verify that PduR_CanIfRxIndication is called correctly.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1585</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31190</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31190.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate the start of the transmission of a valid PDU
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    Previous test case (TS_CANIF_31186) finished successfully
  
Test Execution: 
    01: Call CanIf_Transmit with the parameters of a valid Tx PDU.
    02: VP (CanIf.ASR40.SWS_CanIf_00005):
        Verify that CanIf_Transmit returns E_OK and Can_Write is called with the correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1586</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31192</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31192.c</sourcefile>
      <sourceline>62</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Finish the started transmission (second part of test TS_CANIF_31190)
  
Test Object: 
    CanIf_TxConfirmation()
  
Test Precondition: 
    Previous test case (TS_CANIF_31190) finished successfully
  
Test Execution: 
    01: Call CanIf_TxConfirmation() to confirm the started transmission.
    02: VP (CanIf.SWS_CanIf_00383, CanIf.SWS_CanIf_00007):
        Verify that PduR_CanIfTxConfirmation is called with the correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00383</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>540</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1587</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31195</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31195.c</sourcefile>
      <sourceline>130</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Cancel a started transmission
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    Previous test case (TS_CANIF_31192) finished successfully
  
Test Execution: 
    01: Call CanIf_Transmit to send a Tx PDU 8.
    02: VP:
        Check that Can_Write returns CAN_OK and confirm transmitted data.
    03: Call CanIf_Transmit to send a Tx PDU 7 with higher priority than Tx PDU 8
    04: VP (CanIf.SWS_CanIf_00381):
        Check that Can_Write returns CAN_BUSY. (Tx PDU 7 buffered)
    05: Call CanIf_CancelTxConfirmation to indicate cancellation of the Tx PDU 8 (Tx PDU 8 buffered).
    06: VP (CanIf.EB.Rev2.CancelTxConfirmation, CanIf.ASR40.SWS_CanIf_00054, CanIf.SWS_CanIf_00381):
        Verify the lower layer call (retransmission of Tx PDU 7).
    07: Call CanIf_TxConfirmation to indicate that Tx PDU 7 has been transmitted.
    08: Call CanIf_TxConfirmation to indicate that Tx PDU 8 has been transmitted.
    09: Call CanIf_TxConfirmation to indicate that Tx PDU 7 has been transmitted.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Rev2.CancelTxConfirmation</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00054</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>31</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00381</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>537</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1588</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31197</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31197.c</sourcefile>
      <sourceline>121</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Bus Off callbacks and controller mode change.
  
Test Object: 
    CanIf_ControllerBusOff()
  
Test Precondition: 
    Previous test case (TS_CANIF_31195) finished successfully
  
Test Execution: 
    01: Start message transmission for Tx PDU 7.
    02: Start another message transmission for Tx PDU 7 (driver is busy).
    03: Call CanIf_ControllerBusOff to simulate a Bus Off event (controller is STARTED and ONLINE).
    04: VP (CanIf.SWS_CanIf_00218, CanIf.SWS_CanIf_00014, CanIf.SWS_CanIf_00653, CanIf.SWS_CanIf_00450,
            CanIf.SWS_CanIf_00558, CanIf.SWS_CanIf_00559, CanIf.ECUC_CanIf_00547):
        Verify that CanSM_ControllerBusOff is called with correct controller identifier.
    05: Call CanIf_GetControllerMode and CanIf_GetPduMode on all controllers.
    06: VP (CanIf.ASR40.SWS_CanIf_00488, CanIf.ASR40.SWS_CanIf_00298, CanIf.SWS_CanIf_00485, CanIf.SWS_CanIf_00866_2):
        Verify that controller mode is set to CANIF_CS_STOPPED and Pdu mode will move to CANIF_TX_OFFLINE
        for the controller on which the Bus Off happened.
    07: Simulate Bus Off recovery by calling CanIf_SetControllerMode with CANIF_CS_STARTED.
    08: Start a new transmission and afterwards call CanIf_TxConfirmation() for the hth for which a
        PDU was buffered at the beginning of the test.
    09: Check no call to Can_Write should be made since the buffer should have been emptied during
        the switch to stopped mode.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00488</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00218</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>478</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>418</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00653</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00298</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>68</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00485</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>586</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00450</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>575</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00558</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>610</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00559</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>611</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00547</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>344</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00866_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>768</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1589</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31201</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31201.c</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that controller wake up events are reported when polled.
  
Test Object: 
    Wakeup handling
  
Test Precondition: 
    Previous test case (TS_CANIF_31197) finished successfully: Controller is started.
  
Test Execution: 
    01: Call CanIf_SetControllerMode to put the controller into SLEEP mode via STOPPED mode.
    02: Call CanIf_CheckWakeup for the controller wakeup event and simulate a wakeup event.
    03: VP (CanIf.SWS_CanIf_00395):
        Verify that Can_CheckWakeup() is called with correct parameters.
    04: VP (CanIf.EB.Rev2.Wakeup):
        Verify that &amp;lt;user&amp;gt;_SetWakeupEvent is called according to the simulated wakeup event.
    05: Check controller and pdu mode.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1590</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31203</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_31203.c</sourcefile>
      <sourceline>68</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that EcuM_ValidateWakeupEvent() is not invoked
    if the wake-up event is not validated.
    there was no reception yet.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
    Previous test case (TS_CANIF_31201) finished successfully
  
Test Execution: 
    01: Call CanIf_SetControllerMode() to start the controller.
    02: Call CanIf_CheckValidation().
    03: VP (CanIf.SWS_CanIf_00178, CanIf.ASR40.SWS_CanIf_00681.2):
        CanIf_CheckValidation() does not invoke any API function.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00681.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1591</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_NmWuValidWithCanNmPdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_NmWuValidWithCanNmPdu.c</sourcefile>
      <sourceline>118</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a wake up validation event is generated after the first successful reception after
    a wakeup event has been noticed.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
    Previous test case (TS_CANIF_NmWuValidWithPduRPdu) finished successfully
  
Test Execution: 
    01: Simulate successful message reception by calling CanIf_RxIndication
        with valid parameters.
    02: Check that CanNm_RxIndication called with correct parameters.
    03: Call CanIf_CheckValidation.
    04: VP (CanIf.EB.CANIF680, CanIf.SWS_CanIf_00179, CanIf.SWS_CanIf_00532, CanIf.SWS_CanIf_00178,
            CanIf.SWS_CanIf_00563, CanIf.ECUC_CanIf_00741):
        Verify that EcuM_ValidateWakeupEvent is called with correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00532</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>595</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF680</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00741</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00563</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>613</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1592</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_NmWuValidWithPduRPdu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_SingleCtrl/source/application/Tst_NmWuValidWithPduRPdu.c</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a wake up validation event is not generated after the first
    successful reception after a wakeup event has been noticed if the received
    PDU does not belong to the CanNm.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
    Previous test case (TS_CANIF_31203) finished successfully
  
Test Execution: 
    01: Simulate successful message reception by calling CanIf_RxIndication
        with valid parameters.
    02: Check that PduR_CanIfRxIndication called with correct parameters.
    03: Call CanIf_CheckValidation.
    04: VP (CanIf.SWS_CanIf_00178, CanIf.ASR40.SWS_CanIf_00681.2, CanIf.ECUC_CanIf_00741):
        Verify that CanIf_CheckValidation() does not invoke any API function.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00681.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00741</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>397</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1593</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_CAN_47_TIMESTAMP</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_TimeStamp/source/application/Tests.c</sourcefile>
      <sourceline>78</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that time stamp APIs call the correct Can driver APIs.
    Verify that CanIf will call Det module with correct data.
  
Test Object: 
    CanIf_GetCurrentTime()
    CanIf_EnableEgressTimeStamp()
    CanIf_GetEgressTimeStamp()
    CanIf_GetIngressTimeStamp()
  
Test Precondition: 
    - CanIfGlobalTimeSupport is enabled.
    - CanIf is initialized.
  
Test Execution: 
    01: call CanIf_GetCurrentTime() without CanIf initialization.
    02: VP(SWS_CanIf_00922) Verify that Det module was called with TST_CANIF_E_UNINIT.
    03: call CanIf_EnableEgressTimeStamp() without CanIf initialization.
    04: VP(SWS_CanIf_00926) Verify that Det module was called with TST_CANIF_E_UNINIT.
    05: call CanIf_GetEgressTimeStamp() without CanIf initialization.
    06: VP(SWS_CanIf_00929) Verify that Det module was called with TST_CANIF_E_UNINIT.
    07: call CanIf_GetIngressTimeStamp() without CanIf initialization.
    08: VP(SWS_CanIf_00933) Verify that Det module was called with TST_CANIF_E_UNINIT.
    09: Initialize Module CanIf.
    10: call CanIf_GetCurrentTime() with invalid ControllerId.
    11: VP(SWS_CanIf_00923) Verify that Det module was called with TST_CANIF_E_PARAM_CONTROLLERID.
    12: call CanIf_GetCurrentTime() with timeStampPtr equal to NULL_PTR.
    13: VP(SWS_CanIf_00924) Verify that Det module was called with TST_CANIF_E_PARAM_POINTER.
    14: call CanIf_GetCurrentTime() with valid data.
    15: Call CanIf_EnableEgressTimeStamp() with invalid TxPduId.
    16: VP(SWS_CanIf_00927)  Verify that Det module was called with TST_CANIF_E_PARAM_LPDU.
    17: Call CanIf_EnableEgressTimeStamp() with valid TxPduId.
    18: Call CanIf_GetEgressTimeStamp() with invalid TxPduId.
    19: VP(SWS_CanIf_00930) Verify that Det module was called with TST_CANIF_E_PARAM_LPDU.
    20: Call CanIf_GetEgressTimeStamp() with timeStampPtr equal to NULL_PTR.
    21: VP(SWS_CanIf_00931) Verify that Det module was called with TST_CANIF_E_PARAM_POINTER.
    22: Call CanIf_GetEgressTimeStamp() with valid data.
    23: Call CanIf_GetIngressTimeStamp() with invalid RxPduId.
    24: VP(SWS_CanIf_00934) Verify that Det module was called with TST_CANIF_E_PARAM_LPDU.
    25: Call CanIf_GetIngressTimeStamp() with timeStampPtr equal to NULL_PTR.
    26: VP(SWS_CanIf_00935) Verify that Det module was called with TST_CANIF_E_PARAM_POINTER.
    27: Call CanIf_GetIngressTimeStamp() with valid data.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00922</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>861</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00923</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>862</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00924</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>863</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00926</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>866</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00927</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>867</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00929</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>870</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00930</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>871</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00931</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>872</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00933</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>875</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00934</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>876</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00935</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>877</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1594</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31223</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_TranslateCanIdsDyn/source/application/tests_dyn.c</sourcefile>
      <sourceline>46</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    A development error is generated if the CanIf_SetDynamicTxId is called when the module is not
    initialized and the reconfiguration of CANID shall not work.
  
Test Object: 
    Tx CAN ID translation
  
Test Precondition: 
    CAN Interface is not initialized.
  
Test Execution: 
    01: Call CanIf_SetDynamicTxId() for a dynamic PduR_DynTxPdu_0.
    02: VP(CanIf.SWS_CanIf_00355):
        Check if E_NOT_OK is returned and Det error CANIF_E_UNINIT is reported.
    03: Call CanIf_Init. Start the controller.
    04: Call CanIf_Transmit() for the dynamic Tx PDU PduR_DynTxPdu_0.
    05: VP(CanIf.SWS_CanIf_00355):
        Check if Can_Write is called with original Id and not the new translated Id.
    06: Confirm the Pdu sent and check for PduR notification.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00355</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>525</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1595</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31232</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_TranslateCanIdsDyn/source/application/tests_dyn.c</sourcefile>
      <sourceline>152</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct transmission of a message with a translated CAN ID (dynamic Tx CAN ID PDU).
  
Test Object: 
    Tx CAN ID translation
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_SetDynamicTxId() for a dynamic Tx PDU PduR_DynTxPdu_0.
    02: VP(CanIf.SWS_CanIf_00849):
        Call CanIf_Transmit() to transmit PDU PduR_DynTxPdu_0 and let the CAN ID translation
        function return a new CAN ID for this Tx PDU.
    03: VP (CanIf.EB.CanIfTranslateTxCanIdFunc, CanIf.ECUC_CanIf_00593):
        Verify that Can_Write() is called with the translated CAN ID.
    04: Call CanIf_TxConfirmation() for the transmitted Tx PDU.
    05: VP (CanIf.EB.CanIfTranslateTxCanIdFunc, CanIf.ECUC_CanIf_00593):
        Verify that PduR_CanIfTxConfirmation is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTranslateTxCanIdFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>879</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00593</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>351</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00849</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>753</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1596</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_UL_TXCONFIRMATION_CANIF_TXCONFIRMATION</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_TxConfResultSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>117</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if specific Tx-LPdus call their configured &lt;UL&gt;_TxConfirmation
    function while having the result support enabled/disabled with different combinations.
  
Test Object: 
    CanIfPublicTxConfResultSupport feature enabling and disabling.
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is disabled.
    02: CanIf does not call any function.
    03: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and set to value PDUR and
        CanIfPublicTxConfResultSupport is disabled for PDUR.
    04: CanIf calls PduR_CanIfTxConfirmation().
    05: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and referencing a CDD with
        no TxConfirmation configuration.
    06: CanIf does not call any function.
    07: Call CanIf_TxConfirmation() for a CanTSyn-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled  and with Upper layer CanTSyn given
        CanIfPublicTxConfResultSupport is disabled for CanTSyn.
    08: CanIf calls CanTSyn_TxConfirmation().
    09: Call CanIf_TxConfirmation() for a J1939Nm-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    10: VP (CanIf.EB.User_TxConfirmation.Signature.Result.ON):
        CanIf calls J1939Nm_TxConfirmation() when CanIfPublicTxConfResultSupport is enabled, then
        the return value shall be E_OK and the correct callback prototype is used.
    11: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    12: VP (CanIf.EB.User_TxConfirmation.Signature.Result.ON):
        CanIf calls J1939Nm_TxConfirmation() when CanIfPublicTxConfResultSupport is enabled, then
        the return value shall be E_OK and the correct callback prototype is used.
    13: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    14: VP (CanIf.EB.User_TxConfirmation.Signature.Result.ON):
        CanIf calls J1939Nm_TxConfirmation() when CanIfPublicTxConfResultSupport is enabled, then
        the return value shall be E_OK and the correct callback prototype is used.
    15: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    16: VP (CanIf.EB.User_TxConfirmation.Signature.Result.ON):
        CanIf calls J1939Nm_TxConfirmation() when CanIfPublicTxConfResultSupport is enabled, then
        the return value shall be E_OK and the correct callback prototype is used.
    17: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    18: VP (CanIf.EB.User_TxConfirmation.Signature.Result.ON):
        CanIf calls J1939Nm_TxConfirmation() when CanIfPublicTxConfResultSupport is enabled, then
        the return value shall be E_OK and the correct callback prototype is used.
    19: Call CanIf_TxConfirmation() for a Xcp-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is disabled.
    20: CanIf does not call any function.
    21: Call CanIf_TxConfirmation() for a Xcp-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    22: CanIf calls Xcp_CanIfTxConfirmation().

  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.ON</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>958</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1597</internalId></specobject>
    <specobject>
      <id>TS_CANIF_UL_TXCONFIRMATION_CTRL_MODE_STOPPED</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_TxConfResultSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>365</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks in case of transmission failure, if specific Tx-LPdus call their
    configured &lt;UL&gt;_TxConfirmation function in case the parameter CanIfPublicTxConfResultSupport in enabled.
    Also assures that the flags are rest.
  
Test Object: 
    CanIfPublicTxConfResultSupport feature enabling and disabling (in case of failure).
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is disabled.
    02: CanIf does not call any function.
    03: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and set to value PDUR.
    04: VP (CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk):
        CanIf does not call PduR_CanIfTxConfirmation() since CanIfPublicTxConfResultSupport is disabled for PDUR.
    05: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and referencing a CDD with
        no TxConfirmation configuration.
    06:  VP (CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk):
        CanIf does not call PduR_CanIfTxConfirmation() since CanIfPublicTxConfResultSupport is disabled for that CDD.
        Tx confirmation not called for upper layer (this CDD) since no Tx callback called when result is E_NOT_OK
        and no result support configured for the upper layer
    07: Call CanIf_TxConfirmation() for a CanTSyn-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    08:   VP (CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk):
        CanIf does not call PduR_CanIfTxConfirmation() since CanIfPublicTxConfResultSupport is disabled for CanTSyn. 
        Tx confirmation not called for upper layer CanTSyn since no Tx callback called when result is E_NOT_OK
        and no result support configured for the upper layer
    09: Call CanIf_TxConfirmation() for a J1939Nm-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    10: VP (CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk,CanIf.EB.CanIfPublicMaxTxPdus):
        CanIf calls J1939Nm_TxConfirmation() only in case CanIfPublicTxConfResultSupport is enabled, with the correct
        callback prototype.
    11: VP (CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag):    
        Tx confirmation flags are cleared.
    12: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    13: VP (CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk,CanIf.EB.CanIfPublicMaxTxPdus):
         CanIf calls J1939Tp_TxConfirmation() only in case CanIfPublicTxConfResultSupport is enabled, with the correct
        callback prototype.
    14: VP (CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag):    
        Tx confirmation flags are cleared.
    15: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    16: VP (CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk,CanIf.EB.CanIfPublicMaxTxPdus):
         CanIf calls J1939Tp_TxConfirmation() only in case CanIfPublicTxConfResultSupport is enabled, with the correct
        callback prototype.
    17: VP (CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag):    
        Tx confirmation flags are cleared.
    18: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    19: VP (CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk,CanIf.EB.CanIfPublicMaxTxPdus):
         CanIf calls J1939Tp_TxConfirmation() only in case CanIfPublicTxConfResultSupport is enabled, with the correct
        callback prototype.
    20: VP (CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag):    
        Tx confirmation flags are cleared.
    21: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    22: VP (CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk,CanIf.EB.CanIfPublicMaxTxPdus):
         CanIf calls J1939Tp_TxConfirmation() only in case CanIfPublicTxConfResultSupport is enabled, with the correct
        callback prototype..
    23: VP (CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag):    
        Tx confirmation flags are cleared.
    24: Call CanIf_TxConfirmation() for a Xcp-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is disabled.
    25: CanIf does not call any function.
    26: Call CanIf_TxConfirmation() for a Xcp-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and set to value Xcp.
    27: CanIf does not call Xcp_CanIfTxConfirmation() since CanIfPublicTxConfResultSupport is disabled for Xcp.
        Tx confirmation not called for upper layer Xcp since no Tx callback called when result is E_NOT_OK
        and no result support configured for the upper layer 
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00739.SendTxConf_NotOk</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>665</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00739.ClearTxConfFlag</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>666</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxTxPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1021</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1598</internalId></specobject>
    <specobject>
      <id>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_TxConfResultSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>960</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if specific Tx-LPdus call their configured &lt;UL&gt;_TxConfirmation
    function.
    There are 3 Tx-LPdus under test:
    1.) TxLPdu1 does not any TxConfirmation (CanIfTxPduUserTxConfirmationUL disabled)
    2.) TxLPdu0 indicates its TxConfirmation to PduR (CanIfTxPduUserTxConfirmationUL
        enabled and set to PDUR)
    3.) TxLPdu2 indicates its TxConfirmation to a CDD but this CDD has no TxConfirmation
        configured in the UpperLayerCfg (CanIfTxPduUserTxConfirmationName disabled).
    This checks the TxConfirmation function pointers in the upper layer configuration.
  
Test Object: 
    Partial networking
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is disabled.
    02: VP (CanIf.SWS_CanIf_00551):
        CanIf does not call any function.
    03: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and set to value PDUR.
    04: VP (CanIf.SWS_CanIf_00551):
        CanIf calls PduR_CanIfTxConfirmation().
    05: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and referencing a CDD with
        no TxConfirmation configuration.
    06: VP (CanIf.SWS_CanIf_00551):
        CanIf does not call any function.
    07: Call CanIf_TxConfirmation() for a CanTSyn-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    08: VP (CanIf.SWS_CanIf_00879):
        CanIf calls CanTSyn_TxConfirmation().
    09: Call CanIf_TxConfirmation() for a J1939Nm-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    10: VP (CanIf.SWS_CanIf_00858):
        CanIf calls J1939Nm_TxConfirmation().
    11,13,15,17: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    12,14,16,18: VP (CanIf.SWS_CanIf_00554):
         CanIf calls J1939Tp_TxConfirmation().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00551</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>604</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00879</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00858</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>760</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00554</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>606</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1599</internalId></specobject>
    <specobject>
      <id>TS_CANIF_UL_TXCONFIRMATION_PDU_OFFLINE_ACTIVE</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_TxConfResultSupport/source/application/Tests.c.m4</sourcefile>
      <sourceline>1149</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks if specific Tx-LPdus call their configured &lt;UL&gt;_TxConfirmation
    function.
    There are 3 Tx-LPdus under test:
    1.) TxLPdu1 does not any TxConfirmation (CanIfTxPduUserTxConfirmationUL disabled)
    2.) TxLPdu0 indicates its TxConfirmation to PduR (CanIfTxPduUserTxConfirmationUL
        enabled and set to PDUR)
    3.) TxLPdu2 indicates its TxConfirmation to a CDD but this CDD has no TxConfirmation
        configured in the UpperLayerCfg (CanIfTxPduUserTxConfirmationName disabled).
    This checks the TxConfirmation function pointers in the upper layer configuration.
  
Test Object: 
    Partial networking
  
Test Precondition: 
    - CanIf is initialized and controllers under test are started
  
Test Execution: 
    01: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is disabled.
    02: VP (CanIf.SWS_CanIf_00551):
        CanIf does not call any function.
    03: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and set to value PDUR.
    04: VP (CanIf.SWS_CanIf_00551):
        CanIf calls PduR_CanIfTxConfirmation().
    05: Call CanIf_TxConfirmation() for a PduR-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled and referencing a CDD with
        no TxConfirmation configuration.
    06: VP (CanIf.SWS_CanIf_00551):
        CanIf does not call any function.
    07: Call CanIf_TxConfirmation() for a CanTSyn-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    08: VP (CanIf.SWS_CanIf_00879):
        CanIf calls CanTSyn_TxConfirmation().
    09: Call CanIf_TxConfirmation() for a J1939Nm-Tx-PDU where optional parameter
        CanIfTxPduUserTxConfirmationUL is enabled.
    10: VP (CanIf.SWS_CanIf_00858):
        CanIf calls J1939Nm_TxConfirmation().
    11,13,15,17: Call CanIf_TxConfirmation() for a J1939Tp-Tx-PDU where optional parameter
         CanIfTxPduUserTxConfirmationUL is enabled.
    12,14,16,18: VP (CanIf.SWS_CanIf_00554):
         CanIf calls J1939Tp_TxConfirmation().
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00551</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>604</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00879</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>780</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00858</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>760</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00554</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>606</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1600</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_Transmit_UINT32_PduLengthType</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_UINT32_PduLengthType_Support/source/application/Tests.c</sourcefile>
      <sourceline>173</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    API CanIf_Transmit for configured STANDARD_CAN, EXTENDED_CAN, STANDARD_FD_CAN and
    EXTENDED_FD_CAN Tx Pdus cannot be invoked with parameter PduInfoPtr.SduLength of type UINT32.
    In case CanIfTxPduTruncation is enabled and CanIfTxPduTruncateToFrame is True, Det will be called,
    SduLength will be truncated to maximum length for the CAN pdu type and API will return E_OK.
  
Test Object: 
    CanIf_Transmit acts normally, when called with an SduLength of type UINT32
    =&gt; Det will be triggered
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: perform transmission request of messages.
    02: E_OK returned by CanIf API with pdu cut to the maximum supported length.
    03: Det will be triggered -&gt; check correct call.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1071</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00894.TruncateToFrame</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>802</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1601</internalId></specobject>
    <specobject>
      <id>TS_CANIF_RxIndication_UINT32_PduLengthType</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_UINT32_PduLengthType_Support/source/application/Tests.c</sourcefile>
      <sourceline>262</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    API CanIf_RxIndication for configured STANDARD_CAN, EXTENDED_CAN, STANDARD_FD_CAN,
    EXTENDED_FD_CAN, STANDARD_NO_FD_CAN and EXTENDED_NO_FD_CAN Rx Pdus cannot be invoked
    with parameter PduInfoPtr.SduLength of type UINT32.
    Det will be called and API will return E_NOT_OK.
  
Test Object: 
    CanIf_RxIndication acts normally, when called with an SduLength of type UINT32
    =&gt; Det will be triggered
  
Test Precondition: 
    Initialized CanIf and started Can network.
    DLC check disabled in the configuration
  
Test Execution: 
    01: Initialize CAN interface.
    02: Move CanIf to mode CANIF_CS_STARTED.
    03: Mode Pdu Mode to CANIF_ONLINE.
    04: Simulate message reception for RxPdu0 (configured DLC:4) with length 65600.
    05: Check that Det will be triggered
    06: Simulate message reception for RxPdu1 (configured DLC:8) with length 65600.
    07: Check that Det will be triggered
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1071</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1602</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmation_UINT32_PduLengthType</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_UINT32_PduLengthType_Support/source/application/Tests.c</sourcefile>
      <sourceline>371</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    This test checks the normal behavior of CanIf_CancelTxConfirmation API,
    even if, it was called with parameter a UINT32 SduLength.
    Det will be called and API will return E_NOT_OK.
  
Test Object: 
    CanIf_CancelTxConfirmation acts normally, when called with an SduLength of type UINT32
    =&gt; Det will be triggered
  
Test Precondition: 
    Initialized CanIf and started Can network.
  
Test Execution: 
    01: Call CanIf_CancelTxConfirmation with a UINT32 SduLength
    02: E_NOT_OK returned by CanIf API.
    03: Det will be triggered -&gt; check correct call.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PDULENGTHTYPE001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1071</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1603</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30339</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>286</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that controller wake up events are reported when polled.
  
Test Object: 
    Wakeup handling
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetControllerMode to put both controllers into STARTED mode.
    02: Call CanIf_SetPduMode to switch to ONLINE mode.
    Do the following for controller 2, controller 3 and both:
    03: VP(CanIf.SWS_CanIf_00865):
        Check if the Pdu Mode has changed to OFFLINE.
    04: Call CanIf_SetControllerMode to put both controllers into SLEEP mode.
    05: Call CanIf_CheckWakeup for both controller wakeup events.
    06: VP (CanIf.SWS_CanIf_00395, CanIf.SWS_CanIf_00395_1, CanIf.EB.CanIf_00395_2, CanIf.ASR40.SWS_CanIf_00720):
        Verify that Can_CheckWakeup() is called for both wakeable controllers with correct
        parameters and CanIf_CheckWakeup returns E_OK.
    07: VP (CanIf.EB.Rev2.Wakeup):
        Verify that &lt;user&gt;_SetWakeupEvent is called according to the chosen controller set with
        correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>549</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIf_00395_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>550</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00720</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00865</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>765</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1604</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30831</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>457</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that transceiver wake up events are reported when polled.
  
Test Object: 
    Wakeup handling
  
Test Precondition: 
  
Test Execution: 
    Do the following for transceiver 0, transceiver 1 and for both transceivers:
    01: Simulate wakeup for the chosen transceiver(s).
    02: Call CanIf_CheckWakeup for both transceiver wakeup events.
    03: VP (CanIf.ASR40.SWS_CanIf_00720):
        Verify that Can_CheckWakeup() is called for both wakeable controllers with correct
        parameters and CanIf_CheckWakeup returns E_OK.
    04: VP (CanIf.EB.Rev2.Wakeup):
        Verify that &lt;user&gt;_SetWakeupEvent is called according to the chosen controller set with
        correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00720</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1605</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckWakeUp</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>591</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CheckWakeup() call is rejected if all calls of CanTrcv_CheckWakeup returns
    E_NOT_OK.
  
Test Object: 
  
Test Precondition: 
    Configure two transceivers.
  
Test Execution: 
   01: Initialize CanIf.
   02: Prepare CanTrcv_CheckWakeup to return E_NOT_OK.
   03: Call CanIf_CheckWakeup for both transceiver wake up events.
   04: VP (CanIf.ASR40.SWS_CanIf_00678):
       Verify that CanIf_CheckWakeup returned E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00678</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1606</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30832</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>690</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that only the wakeup events polled for are reported (both controller and transceiver
    wakeups).
  
Test Object: 
    Wakeup handling
  
Test Precondition: 
  
Test Execution: 
    Choose different combinations of wakeup events to report: only one source (controller or
    transceiver), serveral sources, all available sources.
    Choose different combinations of wakeup events to poll in a similar way.
    For all combinations of reported and polled wakeup events do:
    01: Put all networks to sleep.
    02: Simulate wakeup for the chosen source(s).
    03: Call CanIf_CheckWakeup for the event bitmask according to the chosen combination of polled
        events.
    04: Verify that Can_CheckWakeup() and CanTrcv_CheckWakeup() only called for the given
        combination of polled events with correct parameters.
    05: VP (CanIf.EB.Rev2.Wakeup):
        Verify that &lt;user&gt;_SetWakeupEvent is called with correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1607</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30847</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>944</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a controller is not started automatically after a wakeup has been detected.
  
Test Object: 
    Wakeup handling
  
Test Precondition: 
  
Test Execution: 
    Do the following for controller 2, controller 3 and both controllers:
    01: Call CanIf_SetControllerMode to put both controller(s) into SLEEP mode.
    02: Call CanIf_CheckWakeup for all possible sources and simulate a wakeup event for the wakeup
      sources corresponding to the chosen controller(s).
    03: Check that Can_CheckWakeup() is called for both controllers with correct parameters.
    04: VP (CanIf.EB.Rev2.Wakeup):
        Verify that &lt;user&gt;_SetWakeupEvent called according to the corresponding wakeup sources
        for the chosen controllers.
    05: Can_SetControllerMode() is not called.
    06: Call CanIf_GetControllerMode for both controller(s).
    07: VP(CanIf.ASR40.SleepToStart):
        Check that CanIf_GetControllerMode does return CANIF_CS_STOPPED for the chosen
        controller(s); for the other controller (if available), CANIF_CS_SLEEP
        is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SleepToStart</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>234</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1608</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30806</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>1103</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that an upper layer wakeup callback is called independent of being in ONLINE or OFFLINE
    mode.
  
Test Object: 
    Wakeup handling
  
Test Precondition: 
  
Test Execution: 
    For all different channel modes:
    01: VP(CanIf.SWS_CanIf_00874):
        Check if the PDU mode request is accepted when controller is not started.
        CanIf_SetPduMode() shall return E_NOT_OK.
    02: Call CanIf_SetPduMode to change the controller mode.
    03: Move controllers to sleep mode.
    04: Call CanIf_CheckWakeup for all Controllers and simulate a wakeup event.
    05: VP (CanIf.EB.Rev2.Wakeup, CanIf.SWS_CanIf_00118.PduMode.WakeupNotification):
        Verify that independent of the current PDU mode &lt;user&gt;_SetWakeupEvent is called
        during each CanIf_CheckWakeup call.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00874</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>773</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00118.PduMode.WakeupNotification</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>448</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1609</internalId></specobject>
    <specobject>
      <id>TS_CANIF_DetWuCtrlNotSleep</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>1245</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the Det error CANIF_E_NOT_SLEEP is reported and
    CanIf_CheckWakeup returns with E_NOT_OK if called for a not sleeping
    controller.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    For the two modes STOPPED and STARTED do:
    01: Move the controller to the expected mode.
    02: VP (CanIf.ASR40.SWS_CanIf_00541):
        Controller mode is as expected.
    03: Call CanIf_CheckWakeup for the controller.
    04: VP (CanIf.EB.CANIF679_1):
        CanIf_CheckWakeup returns E_NOT_OK.
    05: VP (CanIf.EB.CANIF679_1):
        Verify that Det error CANIF_E_NOT_SLEEP is reported.
    06: VP:
        Check that &lt;user&gt;_SetWakeupEvent is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF679_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00541</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1610</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30338</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>1353</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a wake up validation event is generated after the first successful reception after
    a wakeup event has been noticed (controller mode during validation is STARTED).
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetControllerMode to put a controller into SLEEP mode.
    02: Call CanIf_CheckWakeup for the sleeping controller and simulate a wakeup event.
    03: VP(CanIf.EB.Rev2.Wakeup):
        Check that &lt;user&gt;_SetWakeupEvent called in upper layer with the correct parameter.
    04: Move controller to STARTED mode.
    05: Call CanIf_CheckValidation.
    06: VP (CanIf.SWS_CanIf_00178, CanIf.ASR40.SWS_CanIf_00681.2):
        CanIf_CheckValidation returns E_OK but does not trigger a wake-up indication.
    07: Call CanIf_RxIndication to simulate reception for the controller.
    08: Check that &lt;user&gt;_RxIndication called in upper layer.
    09: Call CanIf_CheckValidation.
    10: VP (CanIf.SWS_CanIf_00179, CanIf.SWS_CanIf_00532, CanIf.EB.CANIF680, CanIf.SWS_CanIf_00178):
        Verify that &lt;user&gt;_ValidateWakeupEvent is called in upper layer and CanIf_CheckValidation
        returns E_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00532</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>595</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF680</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1611</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30834</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>1502</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that only the wakeup validation events polled for are reported.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    Choose different combinations of wakeup validations to report: only one source (controller or
    transceiver), serveral sources, all available sources.
    Choose different combinations of wakeup validations to poll in a similar way.
    For all combinations of reported and polled wakeup validations do:
    01: Put all networks to sleep.
    02: Call CanIf_CheckWakeup for all available sources and simulate a wakeup event
        for all networks.
    03: VP(CanIf.EB.Rev2.Wakeup):
        Check that &lt;user&gt;_SetWakeupEvent called for all events.
    04: Start all controllers.
    05: Call CanIf_RxIndication (multiple times, if needed) to simulate
        reception of a PDU for each controller in the chosen subset of
        reported validations.
    06: Check that &lt;user&gt;_RxIndication called in upper layer.
    07: Call CanIf_CheckValidation for the event bitmask corresponding to the chosen
        subset of polled validations. (i.e. the associated output wakeup
        source).
    08: VP (CanIf.SWS_CanIf_00532, CanIf.SWS_CanIf_00178, CanIf.ASR40.SWS_CanIf_00681.2):
           If there were reported validations in the set of polled validations
           thw wake-up indication shall be called and the wakeup source must be
           set accordingly.
           Otherwise, no indication shall be triggered.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00532</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>595</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1612</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30802</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>1765</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that notifications are processed after a wakeup even though the wakeup was not yet
    successfully validated.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Put a controller into SLEEP mode.
    02: Call CanIf_CheckWakeup for the controller's wakeup event and simulate a wakeup.
    03: Move controller to STARTED mode.
    04: Start a transmission for PDU A.
    05: VP (CanIf.ASR40.WakeupValidationPduMode):
        Verify that Can_Write is called for PDU A.
    06: Trigger another transmission on the same HTH with a higher priority PDU B.
    07: Call CanIf_CancelTxConfirmation to simulate a transmit cancellation for the HTH.
    08: VP (CanIf.ASR40.WakeupValidationPduMode):
        Verify that during cancellation Can_Write is called for PDU B.
    09: Call CanIf_TxConfirmation to simulate a successful transmission of PDU B.
    10: VP (CanIf.ASR40.WakeupValidationPduMode):
        Verify that after the TX confirmation (for PDU B) PDU A is written and the upper
        layer is notified.
    11: Call CanIf_ControllerBusOff to simulate a bus-off event.
    12: VP (CanIf.ASR40.WakeupValidationPduMode):
        Verify that the (simulated) bus-off is correctly handled including a call to the upper layer.
    13: Restart the controller.
    14: Call CanIf_RxIndication for a PDU assigned to the controller.
    15: VP (CanIf.ASR40.WakeupValidationPduMode):
        Verify that &lt;user&gt;_RxIndication called in upper layer.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.WakeupValidationPduMode</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>235</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1613</internalId></specobject>
    <specobject>
      <id>TS_CANIF_WuValidInSleepMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>1972</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a wakeup validation flag is also set in sleep mode.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Put a controller into SLEEP mode.
    02: Call CanIf_CheckWakeup for the controller's wakeup event and simulate a
        wakeup.
    03: Put the controller back to SLEEP mode.
    04: VP (CanIf.EB.CANIF403):
        Check that controller mode is SLEEP
    05: Call CanIf_RxIndication for the controller.
    06: Check &lt;user&gt;_RxIndication is not called in upper layer.
    07: Call CanIf_CheckValidation for the controller under test.
    08: VP (CanIf.EB.CANIF403):
        Verify that &lt;user&gt;_ValidateWakeupEvent is called by CanIf_CheckValidation with
        the wakeup event of the controller under test.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF403</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1043</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1614</internalId></specobject>
    <specobject>
      <id>TS_CANIF_WuValidInStopMode</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>2086</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a wakeup validation flag is also set in stopped mode.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Put a controller into SLEEP mode.
    02: Call CanIf_CheckWakeup for the controller's wakeup event and simulate a
        wakeup.
    03: Controller mode is STOPPED
    04: Call CanIf_RxIndication for the woken controller.
    05: Check &lt;user&gt;_RxIndication is not called in upper layer.
    06: Call CanIf_CheckValidation for the controller under test.
    07: VP (CanIf.EB.CANIF680):
        Verify that &lt;user&gt;_ValidateWakeupEvent is called by CanIf_CheckValidation with
        the wakeup event of the controller under test.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF680</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1615</internalId></specobject>
    <specobject>
      <id>TS_CANIF_RepeatedWuValid</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>2192</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a wakeup validation resets the wakeup and wakeup validation
    flag.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Put a controller into SLEEP mode.
    02: Call CanIf_CheckWakeup for the controller's wakeup event and simulate a
        wakeup.
    03: Move controller to STARTED mode.
    04: Call CanIf_RxIndication for the woken controller.
    05: Check that &lt;user&gt;_RxIndication called in upper layer.
    06: Call CanIf_CheckValidation for the controller under test.
    07: VP (CanIf.SWS_CanIf_00179):
        Verify that &lt;user&gt;_ValidateWakeupEvent is called by CanIf_CheckValidation
        with the wakeup event of the controller under test.
    08: Call CanIf_CheckValidation for the controller under test again.
    09: VP (CanIf.ASR40.SWS_CanIf_00681.2):
        Verify that CanIf_CheckValidation() does not call any API function.
    10: Call CanIf_RxIndication for the woken controller.
    11: Check that &lt;user&gt;_RxIndication called in upper layer.
    12: Call CanIf_CheckValidation for the controller under test again.
    13: VP (CanIf.ASR40.SWS_CanIf_00681.2):
        Verify that CanIf_CheckValidation() does not call any API function.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00681.2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>171</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1616</internalId></specobject>
    <specobject>
      <id>TS_CANIF_WuValidWithoutWu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup/source/application/Tests.c</sourcefile>
      <sourceline>2328</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that no wakeup validation will be performed in modes STOPPED and
    STARTED, if there was no wakeup event.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    For the two controller Modes STOPPED and STARTED do:
    01: Put a controller into the requested mode.
    02: Call CanIf_RxIndication for the controller.
    03: VP:
        &amp;lt;user&amp;gt;_RxIndication is not called in upper layer in mode STOPPED
        and it is called in mode STARTED.
    04: Call CanIf_CheckValidation for the controller.
    05: VP (CanIf.EB.CANIF680, CanIf.ASR40.SWS_CanIf_00681.2):
        In both cases &amp;lt;user&amp;gt;_ValidateWakeupEvent must not be triggered.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF680</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1617</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_CanSM_CanTrcv_NoRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup_CanSM/source/application/Tests.c.m4</sourcefile>
      <sourceline>252</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CheckWakeup() throws DET when multiple transceivers are listed but none is referenced by CanSM.
  
Test Object: 
    Wakeup handling
  
Test Precondition: 
  CanIfTrcvDrvCfg has two transceivers listed but none is referenced by CanSMManagerNetwork.
  
Test Execution: 
    Do the following for transceiver 0, transceiver 1 and for both transceivers:
    01: Simulate wakeup for the chosen transceiver(s).
    02: Call CanIf_CheckWakeup for both transceiver wakeup events.
    03: Verify that Can_CheckWakeup() is called for both wakeable controllers with correct
        parameters and CanIf_CheckWakeup returns E_NOT_OK.
    04: VP:
           Check that Det_ReportError reports CANIF_E_PARAM_WAKEUPSOURCE.
    05: Check CanTrcv_CheckWakeup &amp; &lt;user&gt;_SetWakeupEvent are never called
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTrcvDrvCfg.CanSMReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1618</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanSM_CanTrcv_Ref</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_Wakeup_CanSM/source/application/Tests.c.m4</sourcefile>
      <sourceline>359</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CheckWakeup() doesn't throw DET when multiple transceivers are listed but only one is referenced.
  
Test Object: 
    Wakeup handling
  
Test Precondition: 
  CanIfTrcvDrvCfg has two transceivers listed but only one is referenced by CanSMManagerNetwork.
  
Test Execution: 
    Do the following for transceiver 0, transceiver 1 and for both transceivers:
    01: Simulate wakeup for the chosen transceiver(s).
    02: Call CanIf_CheckWakeup for active transceiver wakeup event.
    03: Verify that Can_CheckWakeup() is called for active transceiver controllers with correct
        parameters and CanIf_CheckWakeup returns E_OK.
    04: Check that Det_ReportError is not called.
    05: Check CanTrcv_CheckWakeup is only called for active transceiver.
    06: Verify that &lt;user&gt;_SetWakeupEvent is called according to the chosen controller set with
        correct parameters.
    07: Call CanIf_CheckWakeup for non active transceiver wakeup events and it returns E_NOT_OK.
    08: VP: Check that Det_ReportError is called with ErrorId CANIF_E_PARAM_WAKEUPSOURCE.
    09: Check CanTrcv_CheckWakeup &amp; &lt;user&gt;_SetWakeupEvent are never called
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTrcvDrvCfg.CanSMReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1033</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1619</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_CanTrcvWakeupEvent</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_WuByCanTrcvOnly/source/application/Tests.c.m4</sourcefile>
      <sourceline>78</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Wakeup by a CAN transceiver (no CAN controller configured for wakeup).
  
Test Object: 
    CanIf_CheckWakeup()
  
Test Precondition: 
  
Test Execution: 
    01: Put CAN controller assigned to the first wakeable CAN transceiver into sleep mode.
    02: Simulate successful wakeup.
    03: VP(CanIf.SWS_CanIf_00395, CanIf.SWS_CanIf_00395_1, CanIf.EB.CanIf_00395_2, CanIf.ASR40.SWS_CanIf_00720,
           CanIf.EB.Rev2.Wakeup):
        - CheckWakeup() function of the first wakeable transceiver is called.
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
        - &lt;user&gt;_SetWakeupEvent() is called with the correct event only for the wakeupsource
          configured.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>549</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIf_00395_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>550</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00720</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1620</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanTrcvWakeupEventClear_OnInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_WuByCanTrcvOnly/source/application/Tests.c.m4</sourcefile>
      <sourceline>209</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if wakeup events are cleared if CanIf_Init is called before message reception.
  
Test Object: 
    CanIf_Init() clears stored wakeup events.
  
Test Precondition: 
    CanTrcv_CheckWakeupByBus must be prepared to return E_OK.
  
Test Execution: 
    01: Put CanIf controller assigned to first wakeable CAN transceiver into sleep mode
    02: Call CanIf_CheckWakeup and check if it returned E_OK.
    03: Call CanIf_Init.
    04: Simulate the reception of a message
    05: VP (CanIf.ASR40.SWS_CanIf_00479):
        Check if the wakeup source of the previous wakeup event is not validated.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1621</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanTrcvWakeupEventClear_OnInit_1</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_WuByCanTrcvOnly/source/application/Tests.c.m4</sourcefile>
      <sourceline>322</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if wakeup events are cleared if CanIf_Init is called after message reception.
  
Test Object: 
    CanIf_Init() clears stored wakeup events.
  
Test Precondition: 
    CanTrcv_CheckWakeupByBus must be prepared to return E_OK.
  
Test Execution: 
    01: Put CanIf controller assigned to first wakeable CAN transceiver into sleep mode
    02: Call CanIf_CheckWakeup and check if it returned E_OK.
    03: Simulate the reception of a message
    04: Call CanIf_Init.
    05: VP (CanIf.ASR40.SWS_CanIf_00479):
        Check if the wakeup source of the previous wakeup event is not validated.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00479</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>115</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1622</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanTrcvWakeupEventClear_OnTransitionToSleep</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_WuByCanTrcvOnly/source/application/Tests.c.m4</sourcefile>
      <sourceline>436</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check if stored wakeup event of the first CanIf_RxIndication call is cleared
    if mode transition to SLEEP is made.
  
Test Object: 
    Switching to SLEEP clears stored wakeup events.
  
Test Precondition: 
    CanTrcv_CheckWakeupByBus must be prepared to return E_OK.
  
Test Execution: 
    01: Put CanIf controller assigned to wakeable CAN transceiver into sleep mode.
    02: Call CanIf_CheckWakeup and check if it returned E_OK.
    03: Put CanIf controller assigned to wakeable CAN transceiver into start mode.
    04: Simulate the reception of a message
    05: Put CanIf controller into sleep mode.
    06: VP (CanIf.SWS_CanIf_00756):
        Check if the wakeup source of the previous wakeup event is not validated.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00756</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>749</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1623</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanTrcvWakeupValidation</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_WuByCanTrcvOnly/source/application/Tests.c.m4</sourcefile>
      <sourceline>567</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Wakeup validation of a transceiver wakeup
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
    01: Simulate a wakeup
    02: Restart the controller under test
    03: Simulate the reception of a message
    04: VP (CanIf.SWS_CanIf_00395):
        - CanIf_CheckValidation() returns E_OK
        - &lt;user&gt;_ValidateWakeupEvent() is called with the correct wakeup source
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1624</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CanTrcvWakeupValidation_DET</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_WuByCanTrcvOnly/source/application/Tests.c.m4</sourcefile>
      <sourceline>659</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Wakeup validation of a transceiver wakeup failed because
    CanIf_CheckValidation is called with an invalid wake-up event.
  
Test Object: 
    Wakeup validation fail
  
Test Precondition: 
  
Test Execution: 
    01: Put CAN controller assigned to the second wakeable CAN transceiver into sleep mode.
    02: Simulate successful wakeup.
    03: VP(CanIf.SWS_CanIf_00395, CanIf.SWS_CanIf_00395_1, CanIf.EB.CanIf_00395_2, CanIf.ASR40.SWS_CanIf_00720,
            CanIf.EB.Rev2.Wakeup):
         - CheckWakeup() function of the second wakeable transceiver is called.
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
        - &lt;user&gt;_SetWakeupEvent() is called with the correct event only for the wakeupsource
          configured.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
    04: Restart the controller under test
    05: Simulate the reception of a message
    06: VP (CanIf.SWS_CanIf_00395):
     - CanIf_CheckValidation() returns E_NOT_OK
     - Det is called
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1625</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_CtrlOnlyOffValidSupport</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_WuOnStartedCtrlOnly/source/application/Tests.c.m4</sourcefile>
      <sourceline>170</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verify CAN wake-up validation detection by storing the first call of CanIf_RxIndication() 
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
    for all Rx PDUs 
:-/m4_ifelse( :elif: ),PM_Permutation,p1,\-:m4_dnl
    of the NM messages
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
    when the corresponding CAN Controller is in CAN_CS_STARTED state
    when CanIfValidateWakeupOnStartedCtrlOnly is enabled.
  
Test Object: 
    Wakeup validation
  
Test Precondition: 
  
Test Execution: 
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
    01: Call CanIf_SetControllerMode to put a controller into SLEEP mode.
    02: Call CanIf_RxIndication to simulate reception when the controller is not yet started.
    03: Check if reception was ignored.
    04: Call CanIf_CheckValidation.
    05: VP (CanIf.EB.CANIF680, CanIf.SWS_CanIf_00178, CanIf.EB.SWS_CANIF_00286_2,
        CanIf.EB.CanIfValidateWakeupOnStartedCtrlOnly):
        Verify that CanIf_CheckValidation returns E_OK and that &lt;user&gt;_ValidateWakeupEvent
        is not called in upper layer.
    06: Move controller to STARTED mode.
    07: Call CanIf_CheckValidation and verify that it returned E_OK.
    08: Call CanIf_RxIndication to simulate reception for the controller.
    09: Check that &lt;user&gt;_RxIndication called in upper layer.
    10: Call CanIf_CheckValidation and check if it returns E_OK.
    11: VP (CanIf.SWS_CanIf_00179, CanIf.SWS_CanIf_00532, CanIf.EB.CANIF680, CanIf.SWS_CanIf_00178, CanIf.EB.SWS_CANIF_00286_2,
        CanIf.EB.CanIfValidateWakeupOnStartedCtrlOnly, CanIf.EB.CANIF679_2):
        Verify that &lt;user&gt;_ValidateWakeupEvent is called in upper layer and CanIf_CheckValidation
        returns E_OK.
:-/m4_ifelse( :elif: ),PM_Permutation,p1,\-:m4_dnl
    01: Put controller into the STARTED mode.
    02: Call CanIf_RxIndication for the controller.
    03: VP (CanIf.EB.SWS_CANIF_00286_1, CanIf.EB.CANIF679_1, CanIf.EB.CANIF680, CanIf.EB.Rev2.Wakeup):
        _RxIndication is called in mode STARTED.
    04: Call CanIf_CheckValidation for the controller.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfValidateWakeupOnStartedCtrlOnlyDisabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1001</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00286_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1003</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00179</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>457</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF679_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>170</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00532</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>595</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00178</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>456</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00286_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1002</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF679_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>169</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfValidateWakeupOnStartedCtrlOnly</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1000</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF680</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>233</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1626</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CheckWakeUpOnStartedCtrl</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Conformance/IN/CanIf_ConTest_WuOnStartedCtrlOnly/source/application/Tests.c.m4</sourcefile>
      <sourceline>397</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CheckWakeup() call is rejected if all calls of CanTrcv_CheckWakeup returns
    E_NOT_OK.
  
Test Object: 
  
Test Precondition: 
    Configure two transceivers.
  
Test Execution: 
   01: Initialize CanIf.
   02: Prepare CanTrcv_CheckWakeup to return E_NOT_OK.
   03: Call CanIf_CheckWakeup for transceiver wake up event.
m4_ifelse(PM_Permutation,p0,\-:m4_dnl
   04: VP (CanIf.ASR40.SWS_CanIf_00678, CanIf.EB.SWS_CANIF_00286_2):
       Verify that CanIf_CheckWakeup returned E_NOT_OK.
:-/m4_ifelse( :elif: ),PM_Permutation,p1,\-:m4_dnl
   04: VP (CanIf.ASR40.SWS_CanIf_00678, CanIf.EB.SWS_CANIF_00286_1):
       Verify that CanIf_CheckWakeup returned E_NOT_OK.
:-/m4_ifelse( :endif: ))\-::-/m4_dnl
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00678</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>246</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00286_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1003</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.SWS_CANIF_00286_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1002</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1627</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_Gen_00000_OnlyPbCfg</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_00_OnlyPbCfg/source/application/CanIf_GenTest_00_OnlyPBcfg.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that the CANIF post build configuration also compiles stand alone.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
    * Set TS_BUILD_POST_BUILD_BINARY to TRUE to prevent compilation of non post build files.
    * Remove all generated CANIF C files except post build files if there are any.

Test Execution: 
    The test run is successful when the CANIF compiles under sticking to the precondition and a
    binary file is generated.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PostBuild_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1068</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1628</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_01001_Err_RxId_NotUnique_Standard</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a duplicate Rx Id of the same type (Can 2.0 ) is found in the configuration
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfDuplicateCanIfRxPduCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>911</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1629</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01002_Err_RxId_NotUnique_Standard</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>48</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a duplicate Rx Id of the same type (FD) is found in the configuration
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfDuplicateCanIfRxPduCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>911</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1630</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01003_Err_Invalid_MissingUpperLayerConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>69</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a Rx/Tx Pdu configured with CAN_TSYN or XCP
    as CanIfTxPduUserTxConfirmationUL/CanIfRxPduUserRxIndicationUL is found in the configuration and
    CAN_TSYN or XCP is not configured as CanIfUpperLayerConfig.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanTSynUpperLayerPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>918</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.XcpLayerPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>919</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1631</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01004_Err_Invalid_BufferSize</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfPublicMaxTxBuffers has a configured
    value smaller than the number of TxPdus with BASIC CanHandleType.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxTxBuffers</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>922</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1632</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01005_Err_Invalid_BufferNonAddressable</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>115</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case the sum of CanIfPublicMaxPayloadQueueSize configured
    exceeds 65535 bytes.
    Reason: It must be ensured that the buffer is addressable.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxPayloadQueueSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1633</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01006_Err_MultipleDriverSupport</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>138</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that CanIfCtrlDrvNameRef and CanIfCtrlDrvInitHohConfigRef reference valid configurations.
    Reason: The parameters must have valid references.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfCtrlDrvNameRef.InvalidReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>972</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfCtrlDrvInitHohConfigRef.InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>975</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1634</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01007_Err_MultipleDriverSupport_Hoh</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>160</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that errors are thrown for CanIfPublicHohTranslationOpt, CanIfInitHohCfg and CanIfCtrlDrvInitHohConfigRef if
    HOH CanObjedctId optimization is configured with one CAN driver,
    The number of HOH configurations in CanIfInitHohCfg don't match the number of driver configurations in CanIfCtrlDrvCfg and
    CanIfCtrlDrvInitHohConfigRef doesn't reference a valid HOH configuration.
    Reason: A HOH configuration must be valid.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicHohTranslationOpt.MultiDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>977</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfInitHohCfg.MultiDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>978</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfCtrlDrvInitHohConfigRef.InvalidRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>975</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1635</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01008_Err_MultipleDriverSupport_DrvRef</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>186</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that errors are thrown for CanIfCtrlDrvNameRef and CanIfCtrlDrvInitHohConfigRef if
    The CAN driver doesn't have the VendorId and VendorApiInfix populated if CanIfPublicMultipleDrvSupport is enabled,
    A CAN controller driver configuration is referrenced more than once and
    A HOH configuration is referrenced more than once.
    Reason: The driver configuration in CanIf must be valid.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfCtrlDrvNameRef.InvalidVendorIdInfix</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>974</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfCtrlDrvNameRef.MultiReference</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>973</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfCtrlDrvInitHohConfigRef.MultiRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>976</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1636</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01009_Err_Invalid_WUConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>212</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that in case of wrongful WakeUp configuration, CanIfCtrlWakeupSupport being enabled
    but CanWakeupFunctionalityAPI being disabled, CanIf will throw an error during generation.
    Reason: If CanWakeupFunctionalityAPI is disabled, Can_**_CheckWakeup is not provided by the driver. But because
    CanIfCtrlWakeupSupport is enabled, CanIf expects this API to be available, leading to compilation errors.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.WakeupInconsistencyError</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>985</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1637</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01010_Err_Invalid_BufferMemorySize</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>235</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfPublicMaxTxBuffersSize has a configured
    value smaller than the required Tx-Buffer memory.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.TxBufferMemorySize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>986</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1638</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01011_Err_Invalid_MaxTxNotifyPdus</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>256</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfPublicMaxTxNotifyPdus has a configured
    value smaller than the number of enabled TxPdu read status notification.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.MaxTxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>987</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1639</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01012_Err_Invalid_MaxDynTxPdus</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>277</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfPublicMaxDynTxPdus has a configured
    value smaller than the number of dynamic Tx-Pdus.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.MaxDynTxPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>988</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1640</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01013_Err_Invalid_MaxCtrl</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>298</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfPublicMaxCtrl has a configured
    value smaller than the number of configured Can controllers.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.MaxCtrl</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>989</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1641</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01014_Err_Invalid_MaxHths</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>319</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfPublicMaxHths has a configured
    value smaller than the number of configured Hths.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.MaxHths</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>990</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1642</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01015_Err_Invalid_MaxRxNotifyPdus</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>340</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfPublicMaxRxNotifyPdus has a configured
    value smaller than the number of enabled RxPdu read status notification.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.MaxRxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>994</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1643</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01016_Err_Invalid_SWFilteringDisabling</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>361</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfSoftwareFilteringSupport value is false
    while there is at least one HRH support SW filtering "CanIfHrhSoftwareFilter enabled" or
    at least one Rx Pdu has CanId mask "CanIfRxPduCanIdMask" configured.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfSoftwareFilteringSupport.hrhSoftwareFilterEnabled</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>991</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfSoftwareFilteringSupport.RxPduCanIdMaskConfigured</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>992</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1644</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01017_Err_Invalid_DecoupledMeasurement</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>384</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case:
    - CanIfNumberOfRxPdusExceedingQueueApiName or CanIfNumberOfEnqueuedRxPdusApiName is empty while
      CanIfRxDecoupledMeasurementSupport value is true.
    - no CanIfPublicCddHeaderFile is configured while CanIfRxDecoupledMeasurementSupport value is true.
    - CanIfNumberOfTxPdusExceedingQueueApiName or CanIfNumberOfEnqueuedTxPdusApiName is empty while
      CanIfTxDecoupledMeasurementSupport value is true.
    - no CanIfPublicCddHeaderFile is configured while CanIfTxDecoupledMeasurementSupport value is true.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1007</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfRxPdusExceedingQueueApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1008</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfTxPdusExceedingQueueApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1009</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1645</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01018_Err_Invalid_CDDReportingFunctionName</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>413</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CDDReportingFunctionName has a configured
    an incorrect function name if CanIfMirrorToCDDReportingEnable is enabled.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingFunctionName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>945</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1646</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01019_Err_Invalid_CDDReportingHeader</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>435</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CDDReportingHeader has a configured
    an incorrect header name if CanIfMirrorToCDDReportingEnable is enabled.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingEnable</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>944</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfMirrorToCDDReportingHeader</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>946</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1647</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01020_Err_Invalid_MaxTxPdusConfig</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>457</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfPublicMaxTxPdus has been configured
    to a value lower that the actual number of configured TxPdus.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxTxPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1021</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxTxPdus.InvalidValue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1022</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1648</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01021_Err_Invalid_SecEvEnaNoEvConf</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>479</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case 
    - CanIfEnableSecurityEventReporting is enabled, but no security event has been enabled and configured.
    - CanIfEnableSecurityEventReporting is enabled and CanIfMultiCoreSupport is enabled.
    - CanIfEnableSecurityEventReporting is enabled, CanIfPublicMultipleDrvSupport is enabled and CanIfCanDriverCompatibility
      is set to 402 or 403.
    This test shall prove that a warning will be thrown in case
    - CanIfEnableSecurityEventReporting is enabled, but CanEnableSecurityEventReporting doesn't exist or is disabled.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfSecurityEventRefs.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1023</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultiCoreSecurityEventReporting.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1029</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.MultipleDriverSecurityEventReporting.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1032</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanEnableSecurityEventReporting.Warning</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1028</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1649</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01022_Err_Invalid_SecEvEnaEvNotUnique</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>508</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case referenced security events are not
    unique.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfSecurityEventRefs_CANIF_SEV_ERRORSTATE_BUSOFF.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1024</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfSecurityEventRefs_CANIF_SEV_ERRORSTATE_PASSIVE.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1025</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfSecurityEventRefs_CANIF_SEV_TX_ERROR_DETECTED.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1026</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfSecurityEventRefs_CANIF_SEV_RX_ERROR_DETECTED.Invalid</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1027</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1650</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01023_Err_Invalid_CanIfInitHohCfgExpression</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>532</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that in case there is no CanIfHthCfg container with a valid CanIfHthIdSymRef or no CanIfHrhCfg container with a valid CanIfHrhIdSymRef , CanIf will throw an error during generation.
    Reason: CanIfHrhIdSymRef &amp; CanIfHthIdSymRef must reference a valid Can hardware object configuration.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00627</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>376</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00634</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>382</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1651</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01024_Err_Invalid_BusAHeaderFile</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>554</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that in case CanIfBusARxIndication or CanIfBusATxIndication function name are configured
    while the CanIfBusAHeaderFile is not enabled an error must be thrown.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusAHeaderFile</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1041</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1652</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01025_Err_Invalid_BusAFunctionsNames</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>575</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that in case CanIfBusARxIndication or CanIfBusATxIndication function name are configured with valid names.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusARxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1035</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfBusATxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1034</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1653</internalId></specobject>
    <specobject>
      <id>TS_GenTest_01026_Err_Invalid_CanIfGlobalTimeSupport_Config</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_01_InvalidConfiguration/source/application/Test.h</sourcefile>
      <sourceline>596</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that CanIf will throw an error in case of CanIfGlobalTimeSupport is enabled 
    and CanGlobalTimeSupport is disabled.
&lt;/para&gt;

Test Object: None.
Test Precondition: 

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfGlobalTimeSupportConsistency</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1048</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1654</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_02001_Err_Invalid_UserName</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_02_InvalidULConfiguration/source/application/Test.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfTxPduUserTxConfirmationName/CanIfRxPduUserRxIndicationName
    do not respect the API naming convention.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.UpperLayerAPINaming</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>920</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1655</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02002_Err_Invalid_UpperLayerCanIdUsage</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_02_InvalidULConfiguration/source/application/Test.h</sourcefile>
      <sourceline>49</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfUpperLayerUseCanId is configured for
    standard AUTOSAR modules as upper layer, parameter shall be used only for CDD.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfUpperLayerUseCanId</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>893</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1656</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02003_Err_Invalid_CDD_Ref</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_02_InvalidULConfiguration/source/application/Test.h</sourcefile>
      <sourceline>71</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfRxPduUpperLayerRef is configured to
    standard AUTOSAR modules and CanIfRxPduUserRxIndicationUL configured to CDD.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfRxPduUpperLayerRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>921</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1657</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02004_Err_Invalid_CanSMNoTrcv</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_02_InvalidULConfiguration/source/application/Test.h</sourcefile>
      <sourceline>93</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfDispatchUserCheckTrcvWakeFlagIndicationUL
    or CanIfDispatchUserClearTrcvWufFlagIndicationUL or CanIfDispatchUserConfirmPnAvailabilityUL is set to CAN_SM
    and no transceiver is not configured.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ParameterDependenciesExtendedCheck</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>983</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1658</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02005_Err_Invalid_PnNoULConf</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_02_InvalidULConfiguration/source/application/Test.h</sourcefile>
      <sourceline>116</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case CanIfDispatchUserCheckTrcvWakeFlagIndicationUL
    and CanIfDispatchUserClearTrcvWufFlagIndicationUL are disabled but CanIfPublicPnSupport is enabled.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ParameterDependenciesExtendedCheck</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>983</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1659</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_GenTest_02001_Err_TxPdu_InvalidCanIfDefaultPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>27</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case the EcucPduDefaultPartitionRef found
    in the configuration for the CanIf Tx Pdu is different than the CanControllerEcucPartitionRef.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1660</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02002_Err_TxPdu_InvalidCanIfPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>51</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case no EcucPduDedicatedPartition with
    EcucPduDedicatedPartitionBswModuleRef configured to CanIf nor EcucPduDefaultPartitionRef referring
    the corresponding controller partition is found in the configuration.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1016</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1661</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02003_Err_TxPdu_NoCanIfPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>77</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a CanIfTxPdu has no
    EcucPduDedicatedPartition with EcucPduDedicatedPartitionBswModuleRef configured to CanIf
    nor EcucPduDefaultPartitionRef referring the corresponding controller partition in the
    configuration.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1016</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1662</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02004_Err_TxPdu_InvalidJ1939NmDedicatedPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>104</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939NmTxPdu refers a dedicated partition
    different from the J1939 stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1663</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02005_Err_TxPdu_InvalidJ1939NmDefaultPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>128</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939NmTxPdu refers a default partition
    different from the J1939 stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1664</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02006_Err_TxPdu_InvalidJ1939TpTxCmDedicatedPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>152</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939TpTxCmNPdu refers a default partition
    different from the J1939 stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1665</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02007_Err_TxPdu_InvalidJ1939TpTxCmPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>176</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939TpTxCmPdu has no
    EcucPduDedicatedPartition with EcucPduDedicatedPartitionBswModuleRef configured to J1939Tp
    nor EcucPduDefaultPartitionRef referring the corresponding J1939 stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1666</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02008_Err_TxPdu_InvalidJ1939TpTxDtDefaultPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>202</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case the EcucPduDefaultPartitionRef for a
    J1939TpTxDtNPdu is configured to a different partition than the rest of the J1939 stack.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1667</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02009_Err_TxPdu_InvalidJ1939TpTxDirectDefaultPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>226</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case the EcucPduDefaultPartitionRef for a
    J1939TpTxDirectNPdu is configured to a different partition than the rest of the J1939 stack.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1668</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02010_Err_TxPdu_InvalidJ1939TpTxFcDefaultPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>250</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case the EcucPduDefaultPartitionRef for a
    J1939TpTxFcNPdu is configured to a different partition than the rest of the J1939 stack.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1669</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02011_Err_TxPdu_InvalidJ1939NmPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>274</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939NmTxPdu has no
    EcucPduDedicatedPartition with EcucPduDedicatedPartitionBswModuleRef configured to J1939Nm
    nor EcucPduDefaultPartitionRef referring the corresponding J1939 stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1670</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02012_Err_RxPdu_NoCanIfPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>300</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a CanIfRxPdu has no
    EcucPduDedicatedPartition with EcucPduDedicatedPartitionBswModuleRef configured to CanIf
    nor EcucPduDefaultPartitionRef referring the corresponding controller partition in the
    configuration.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1671</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02013_Err_RxPdu_InvalidCanIfCtrlPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>327</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a CanIfRxPdu has no
    EcucPduDedicatedPartition with EcucPduDedicatedPartitionBswModuleRef configured to CanIf
    and EcucPduDefaultPartitionRef is referring a different partition than the on the corresponding
    controller partition is referring to.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1016</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlDefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1015</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1672</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02014_Err_RxPdu_InvalidJ1939NmRxDedicatedPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>354</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939NmRxPdu refers a default partition
    different from the J1939 stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1673</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02015_Err_RxPdu_NoJ1939TpRxDirectPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>378</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939TpRxDirectNPdu has no
    EcucPduDedicatedPartition with EcucPduDedicatedPartitionBswModuleRef configured to J1939Nm
    nor EcucPduDefaultPartitionRef referring the corresponding J1939 stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1674</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02016_Err_RxPdu_InvalidJ1939TpRxFcDedicatedPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>404</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939TpRxFcNPdu refers a default partition
    different from the J1939 stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1675</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02017_Err_RxPdu_InvalidJ1939TpRxDtPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>428</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case a J1939TpRxDtNPdu has no
    EcucPduDedicatedPartition with EcucPduDedicatedPartitionBswModuleRef configured to J1939Nm
    and a different partition assigned to EcucPduDefaultPartitionRef than the corresponding J1939
    stack partition.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DedicatedPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1014</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1676</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02018_Err_RxPdu_InvalidJ1939NmRxDefaultPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>455</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown in case the EcucPduDefaultPartitionRef for a
    J1939NmRxNPdu is configured to a different partition than the rest of the J1939 stack.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.J1939DefaultPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1013</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1677</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02019_Err_TxPdu_InvalidCtrlMaxTxNotifyPdus</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>478</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown when CanIfTxPduReadNotifyStatus and CanIfMultiCoreSupport
    are set to true and CanIfCtrlMaxTxNotifyPdus is smaller than the number of TxPdus with CanIfTxPduReadNotifyStatus
    set to true.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlMaxTxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1012</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1678</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02020_Err_RxPdu_InvalidCtrlMaxRxNotifyPdus</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>502</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown when CanIfRxPduReadNotifyStatus and CanIfMultiCoreSupport
    are set to true and CanIfCtrlMaxRxNotifyPdus is smaller than the number of RxPdus with CanIfRxPduReadNotifyStatus
    set to true.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CtrlMaxRxNotifyPdus</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1011</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1679</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02021_Err_CanIfTxProcessing_InvalidPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>526</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown when CanIfDecoupledProcessingSupport and CanIfMultiCoreSupport
    are set to true and the CanIfPartitionRef for a CanIfTxProcessing refer a different partition than its
    corresponding TxPdus belonging to a certain MainFunction.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CanIfTxProcessing.SamePartitionOnMainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1020</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.CanIfTxProcessing.CanIfPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1018</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1680</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02022_Err_CanIfRxProcessing_InvalidPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>551</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown when CanIfDecoupledProcessingSupport and CanIfMultiCoreSupport
    are set to true and the CanIfPartitionRef for a CanIfRxProcessing refer a different partition than its
    corresponding RxPdus belonging to a certain MainFunction.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.&lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Multicore.CanIfRxProcessing.SamePartitionOnMainFunction</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1019</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.CanIfRxProcessing.CanIfPartitionRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1017</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Multicore.MultiCoreSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1010</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1681</internalId></specobject>
    <specobject>
      <id>TS_GenTest_02023_Err_CanIfTxMirrorBuffers_InvalidPartition</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Generic/IN/CanIf_GenTest_03_InvalidMulticoreConfiguration/source/application/Test.h</sourcefile>
      <sourceline>576</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
&lt;para&gt;
    This test shall prove that an error will be thrown when in CanIfTxMirrorBuffers, CanIfTxBufPartRef is configured to an
    invalid partition or a partition not referenced by a configured controller.
&lt;/para&gt;

Test Object: None.
Test Precondition: 
        -run manualRunTest.sh

Test Execution: 
    The test run is successful when the error is thrown.

Test Input: None.
Test Output: None.</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.ECUC_CanIf_Mirroring.CanIfTxBufPartRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>954</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1682</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_LCFG_C</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_01/source/application/InclusionTests.c</sourcefile>
      <sourceline>28</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the module includes CanIf_Lcfg.c.
  
Test Object: 
    CanIf_Init()
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanIf.EB.PBCFGM105):
        Check the value of generated CanIf_LcfgSignature.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.PBCFGM105</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1063</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1683</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_InitClearTxBuffers</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>238</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Tx buffers are cleared when CanIf_Init is called.
  
Test Object: 
    CanIf_Init()
  
Test Precondition: 
    At least one Tx buffer used in the configuration.
  
Test Execution: 
    01: Prepare at least one Tx buffer to show as filled.
    02: Call CanIf_Init().
    03: VP (CanIf.SWS_CanIf_00387):
        The Tx buffer(s) prepared in 01 must have been cleared by 02.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00387</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>542</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1684</internalId></specobject>
    <specobject>
      <id>TS_CANIF_40180</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>316</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ReadRxPduData does not clear the receive notification
    flag of the associated PDU.
  
Test Object: 
    CanIf_ReadRxPduData()
  
Test Precondition: 
    CAN Interface is initialized and network is running
  
Test Execution: 
    01: Initialize CanIf Module.
    02: Simulate reception of RX L-PDU 3 configured for the read data and
        notification API functions.
    03: Call CanIf_ReadRxPduData for RX L-PDU 3 which has just been received.
    04: Call CanIf_ReadRxNotifStatus for RX L-PDU 3 which was just read via
        CanIf_ReadRxPduData.
    05: VP (CanIf.SWS_CanIf_00198_1):
        Verify that CanIf_ReadRxPduData does not clear the receive notification
        flag CanIf_ReadRxNotifStatus returns CANIF_TX_RX_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00198_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>472</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1685</internalId></specobject>
    <specobject>
      <id>TS_CANIF_40178</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>417</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Simulate correct transmission events for the two additional non-standard
    upper layers including the call to the CanIf_TxConfirmation function.
  
Test Object: 
    CanIf_TxConfirmation()
  
Test Precondition: 
    CAN Interface is initialized and network is running
  
Test Execution: 
    01: Call CanIf_Transmit() for TX L-PDU of a standard upper layer, Xcp, XcpDlc.
    02: Simulate correct transmission by calling CanIf_TxConfirmation().
    03: VP (CanIf.SWS_CanIf_00438, CanIf.SWS_CanIf_00542):
        Check that the upper layer callback function is called with the correct PDU information.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00438</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>569</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00542</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>600</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1686</internalId></specobject>
    <specobject>
      <id>TS_CANIF_40176</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_01/source/application/Tests.c</sourcefile>
      <sourceline>593</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Call CanIf_RxIndication for the RX L-PDUs assigned to the two additional
    non-standard upper layers.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    CAN Interface is initialized and network is running
  
Test Execution: 
    01: Call CanIf_RxIndication to simulate message reception for
        - both RX L-PDUs of upper layer Xcp.
        - the RX L-PDU of upper layer XcpDlc.
        - one RX L-PDU of a standard upper layer.
    02: VP (CanIf.SWS_CanIf_00441, CanIf.SWS_CanIf_00552):
        Check that the correct upper layer callback function is called with the correct information.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00441</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>571</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00552</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>605</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1687</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_TxProcessing</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_3_DecoupledProcessing/source/application/Tests.c</sourcefile>
      <sourceline>181</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verify that the configured upper layer callback functions for TxConfirmation()
    are called correctly on the corresponding MainFunction().
    The test is executed for different PDUs.
  
Test Object: 
    Passing on calls to upper layer
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Init() for initialization of the module.
    02: VP (CanIf.SWS_CanIf_00383): Send the Tx PDU 4 and check if TxConfirmation is
        processed in interrupt context.
    03: Call CanIf_Transmit to send the Tx PDU 0, Tx PDU 5 and Tx PDU 7.
    04: VP(CanIf.EB.CanIfTxProcessing.CanIfTxPduProcessingRef, CanIf.EB.TxDecoupledProcessing,
           CanIf.EB.DecoupledProcessing.TriggerMainFunc):
        Call CanIf_TxConfirmation to indicate that Tx PDU 0 and Tx PDU 7 have been transmitted.
    05: VP(CanIf.EB.CanIfTxProcessing, CanIf.EB.TxDecoupledProcessing.MainFunc,
           CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName, CanIf.EB.DecoupledMeasurement.TxDecoupledMeasurementSupport):
        Check that the number of enqueued TxPdus was forwarded to CDD and that the queued
        confirmation request is forwarded to the upper layer.
    06: Call CanIf_TxConfirmation to indicate that Tx PDU 5 has been transmitted
    07: VP(CanIf.EB.TxDecoupledProcessing.MainFunc):
        Check that confirmation calls were queued and no upper layer call was performed.
    08: Send once again the Tx PDU 0 (another instance of the same PDU already queued).
    09: VP(CanIf.EB.TxDecoupledProcessing): Check that confirmation call was queued and no
        upper layer was called.
    10: VP(CanIf.EB.TxDecoupledProcessing.MainFunc,CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName,
           CanIf.EB.DecoupledMeasurement.TxDecoupledMeasurementSupport):
        Check that the number of enqueued TxPdus was forwarded to CDD and
        that all queued confirmation request are forwarded to the upper layer.
    11: Send Tx PDU 3 and Tx PDU 8.
    12: VP(CanIf.EB.TxDecoupledProcessing.MainFunc):
        No confirmation for Tx PDU 3 is forwarded to the upper layer.
    13: VP(CanIf.EB.CanIfTxPduQueueSize, CanIf.EB.TxDecoupledProcessing.FullQueue,
           CanIf.EB.DecoupledMeasurement.NumberOfTxPdusExceedingQueueApiName):
        Check if  the number of TxPdus that couldn't be added in the queue was forwarded to CDD and
        if DET is reported when the queue is full.
    14: VP(CanIf.EB.TxDecoupledProcessing, CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName):
        Forward the number of enqueued TxPdus was forwarded to CDD and
        process all the queued confirmations.
    15: VP(CanIf.EB.TxDecoupledProcessing, CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName):
        Check if the new size of the enqueued Pdus (when no confirmation request is added in the queue)
        is forwarded to CDD.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00383</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>540</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxProcessing.CanIfTxPduProcessingRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledProcessing.TriggerMainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduQueueSize</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing.FullQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing.MainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>937</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1007</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfTxPdusExceedingQueueApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1009</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.TxDecoupledMeasurementSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1005</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1688</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TxProcessingInterrupted</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_3_DecoupledProcessing/source/application/Tests.c</sourcefile>
      <sourceline>426</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the pending TxConfirmation calls are correctly dequeued even when interrupted.
  
Test Object: 
    Dequeue mechanism
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanIf.EB.DecoupledMeasurement.RxDecoupledMeasurementSupport,
           CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName):
        Check that the size of the queue is forwarded to CDD even if nothing was queued
    02: Successfully transmit PDU
    03: While dequeuing, the process is interrupted by another CanIf_Transmit
    04: VP(CanIf.EB.DecoupledMeasurement.TxDecoupledMeasurementSupport,
           CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName):
        Check that CDD is notified with the enqueued number of Pdus
    05: Confirmation forwarded to the UL
    06: The newly transmitted PDU isn't confirmed yet, nothing happens
    07: VP(CanIf.EB.DecoupledMeasurement.TxDecoupledMeasurementSupport,
           CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName):
        Check that CDD is notified with 0 since no Pdu was enqueued
    08: Confirmation arrives
    09: It's correctly dequeued and the confirmation is forwarded to the UL
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00383</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>540</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxProcessing.CanIfTxPduProcessingRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledProcessing.TriggerMainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxPduQueueSize</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>928</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing.FullQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing.MainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>937</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfRxPdusExceedingQueueApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1008</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.RxDecoupledMeasurementSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1004</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedTxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1007</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.TxDecoupledMeasurementSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1005</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1689</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TxProcessingInterruptedByTxConfirmation</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_3_DecoupledProcessing/source/application/Tests.c</sourcefile>
      <sourceline>567</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the pending TxConfirmation calls are correctly en-/dequeued even when interrupted.
  
Test Object: 
    Dequeue mechanism
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_Transmit to send the Tx PDU 3, Tx PDU 7 and Tx PDU 8
    02: VP(CanIf.EB.CanIfTxProcessing.CanIfTxPduProcessingRef, CanIf.EB.TxDecoupledProcessing,
           CanIf.EB.DecoupledProcessing.TriggerMainFunc):
        Call CanIf_TxConfirmation to indicate that Tx PDU 7 and Tx PDU 3 have been transmitted.
    03: While dequeuing, the process is interrupted by other CanIf_TxConfirmation and CanIf_Transmit calls
    04: Check that all requests are forwarded to the UL
    05: Check that no pending requests are buffered
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>925</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTxProcessing.CanIfTxPduProcessingRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>927</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledProcessing.TriggerMainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1690</internalId></specobject>
    <specobject>
      <id>TS_CANIF_RxProcessing</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_3_DecoupledProcessing/source/application/Tests.c</sourcefile>
      <sourceline>664</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the configured upper layer callback functions for RxIndication()
    are called correctly on the corresponding MainFunction().
    The test is executed for different PDUs.
  
Test Object: 
    Passing on calls to upper layer
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_RxIndication on a Rx PDU that shall process it in interrupt context.
    02: Call CanIf_RxIndication with the parameters of a valid Rx PDU on CanIfRxProcessing_0.
    03: Call CanIf_RxIndication with the parameters of a valid Rx PDU on the same CanIfRxProcessing_0.
    04: VP(CanIf.EB.RxDecoupledProcessing):
        Check that no call is forwarded to the upper layer, upper layer call performed on
        the corresponding MainFunction call.
    05: VP(CanIf.EB.RxDecoupledProcessing.FullQueue, CanIf.EB.CanIfRxPduQueueSize,
           CanIf.EB.DecoupledMeasurement.RxDecoupledMeasurementSupport,
           CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName):
        Check if CDD is called and if DET is reported when the queue is full.
    06: VP(CanIf.EB.RxDecoupledProcessing):
        Call CanIf_RxIndication with the parameters of a valid Rx PDU, processing
        shall be forwarded on the Main Function.
    07: Call CanIf_MainFunctionRx_CanIfRxProcessing_0 to process all the queued PDUs.
    08: VP (CanIf.SWS_CanIf_00135, CanIf.EB.CanIfRxProcessing,
            CanIf.EB.CanIfRxProcessing.CanIfRxPduProcessingRef, CanIf.EB.RxDecoupledProcessing,
            CanIf.EB.RxDecoupledProcessing.MainFunc, CanIf.EB.CanIfPublicMaxPayloadQueueSize,
            CanIf.EB.DecoupledProcessing.TriggerMainFunc,
            CanIf.EB.DecoupledMeasurement.RxDecoupledMeasurementSupport,
            CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName):
        Verify that CDD and CanTp_RxIndication is called correctly.
    09: Call CanIf_MainFunctionRx_CanIfRxProcessing_1 to process all the queued PDUs.
    10: VP(CanIf.EB.RxDecoupledProcessing.MainFunc,
           CanIf.EB.DecoupledMeasurement.RxDecoupledMeasurementSupport,
           CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName):
        Check that CDD and CanNm_RxIndication is called correctly.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfRxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfRxProcessing.CanIfRxPduProcessingRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfRxPduQueueSize</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxPayloadQueueSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing.FullQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing.MainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledProcessing.TriggerMainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.RxDecoupledMeasurementSupport</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1004</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledMeasurement.NumberOfEnqueuedRxPdusApiName</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1006</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1691</internalId></specobject>
    <specobject>
      <id>TS_CANIF_RxProcessingInterrupted</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_3_DecoupledProcessing/source/application/Tests.c</sourcefile>
      <sourceline>819</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the queue state is consistent even when the dequeue process is interrupted by
    CanIf_RxIndication().
  
Test Object: 
    Passing on calls to upper layer
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_RxIndication on an Rx PDU that goes to CanTp; it's queued
    02: While dequeuing the call to CanTp is interrupted by a PDU which goes to PduR
    03: RxPDU going to CanNm is queued
    04: PDU going to PduR is dequeued correctly
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfRxProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>924</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfRxProcessing.CanIfRxPduProcessingRef</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>926</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfRxPduQueueSize</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxPayloadQueueSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>931</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing.FullQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>933</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RxDecoupledProcessing.MainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>936</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.DecoupledProcessing.TriggerMainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>935</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1692</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_DecoupledBufferLimit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_4_DecoupledProcessingLimits/source/application/Tests.c.m4</sourcefile>
      <sourceline>102</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that the CanIf module can accomodate as many PDUs as configured.
    The configured buffer length is m4_eval(PM_PayloadSizeMF0+ PM_PayloadSizeMF1),
    with a queue size of PM_PDUQueueSizeConf.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: VP(CanIf.EB.CanIfRxPduQueueSize)
        VP(CanIf.EB.CanIfPublicMaxPayloadQueueSize):
        Call CanIf_RxIndication() PM_PDUQueueSizeConf times to fill the queue.
        Observe that no DET is reported.
    02: Queue size is exceeded, DET is reported.
    04: Call the associated decoupled MainFunction() in order to consume the queue
        After 10 UL indications, another RxIndication comes and it is accepted,
        since there is enough space in the queue.
    05: Observe that the upper layer (PduR) is notified PM_PDUQueueSizeConf + 1 times.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfRxPduQueueSize</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>929</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfPublicMaxPayloadQueueSize</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>930</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1693</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TxDecoupledProcessingQueueLimit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_4_DecoupledProcessingLimits/source/application/Tests.c.m4</sourcefile>
      <sourceline>244</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Test verifies that all TxConfirmations are processed correctly when the Index reaches the limit of the queue.

    Test mandated by ASCCANIF-1449.
  
Test Object: 
    Dequeue mechanism
  
Test Precondition: 
    CanIf is initialized.
  
Test Execution: 
    01: Start enough transmits along with TxConfirmations so that the queue level reaches CanIfTxPduQueueSize - 1.
    02: Call the Mainfunction to dequeue.
    03: VP(CanIf.EB.TxDecoupledProcessing), VP(CanIf.EB.TxDecoupledProcessing.MainFunc):
        TxConfirmations are processed and notifications to the upper layer are sent.
    04: Start another two transmits with TxConfirmations.
    05: VP(CanIf.EB.TxDecoupledProcessing.FullQueue):
        No DET is signaled because there is space available in the queue.
    06: VP(CanIf.EB.TxDecoupledProcessing), VP(CanIf.EB.TxDecoupledProcessing.MainFunc):
        The confirmations are processed normally.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>932</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing.FullQueue</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>934</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.TxDecoupledProcessing.MainFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>937</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1694</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_40185</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_SleepWakeup/source/application/Tst_40185.c.m4</sourcefile>
      <sourceline>82</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanIf_SetControllerMode only calls Can_SetControllerMode( ...,
    CAN_T_WAKEUP ) for those controllers, that are still in sleep mode.
  
Test Object: 
    CanIf_SetControllerMode()
  
Test Precondition: 
    None
  
Test Execution: 
    01: Call CanIf_SetControllerMode( ..., CANIF_CS_SLEEP ) for all controllers in the network.
    02: Simulate a wakeup event for the wakeable controller via CanIf_CheckWakeup.
    03: Call CanIf_SetControllerMode( ..., CANIF_CS_STOPPED ) for all controllers
        in the network as it would be done by the CanSM.
    04: VP (CanIf.EB.CANIF487, CanIf.ASR40.SWS_CanIf_00713):
        Verify that Can_SetControllerMode( ..., CAN_T_STOP ) is called for woken up controllers
        and Can_SetControllerMode( ..., CAN_T_WAKEUP ) is called for sleeping controllers.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00713</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF487</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1695</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_MulticoreDriverWakeup</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_WakeupMulticore/source/application/Test.c.m4</sourcefile>
      <sourceline>186</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that CanIf_CheckWakeup() calls Can Driver wakeup interface Can_CheckWakeup()
    through SchM_Call interfaces when CanIfMultiCoreSupport and CanIfMulticoreWakeupExtension are enabled.
  
Test Object: 
    SchM_Call_CanIf_RequiredCSEntry_CheckDriverWakeup_CanIfCtrlDrvCfg_0_CanIfCtrlCfg_2()
    SchM_Call_CanIf_RequiredCSEntry_CheckDriverWakeup_CanIfCtrlDrvCfg_0_CanIfCtrlCfg_3()
  
Test Precondition: 
    Enable CanIfMultiCoreSupport and CanIfMulticoreWakeupExtension.
  
Test Execution: 
    Do the following for controller 2, controller 3 and both controllers:
    01: Call CanIf_SetControllerMode to put both controller(s) into SLEEP mode.
    02: Call CanIf_CheckWakeup for all possible sources and simulate a wakeup event for the wakeup
      sources corresponding to the chosen controller(s).
    03: (CanIf.EB.CanIfMulticoreWakeupExtension_WakeupCanDriver)
        Check that Can_CheckWakeup() is called for both controllers with correct parameters through
        SchM_Call_CanIf_RequiredCSEntry_CheckDriverWakeup_CanIfCtrlDrvCfg_0_CanIfCtrlCfg_2() and
        SchM_Call_CanIf_RequiredCSEntry_CheckDriverWakeup_CanIfCtrlDrvCfg_0_CanIfCtrlCfg_3().
    04: VP (CanIf.EB.Rev2.Wakeup):
        Verify that &lt;user&gt;_SetWakeupEvent called according to the corresponding wakeup sources
        for the chosen controllers.
    05: Can_SetControllerMode() is not called.
    06: Call CanIf_GetControllerMode for both controller(s).
    07: VP(CanIf.ASR40.SleepToStart):
        Check that CanIf_GetControllerMode does return CANIF_CS_STOPPED for the chosen
        controller(s); for the other controller (if available), CANIF_CS_SLEEP
        is returned.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfMulticoreWakeupExtension</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1045</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfMulticoreWakeupExtension_WakeupCanDriver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1046</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00713</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF487</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1696</internalId></specobject>
    <specobject>
      <id>TS_CANIF_MulticoreTrcvWakeup</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Implementation/IN/CanIf_ImpTest_WakeupMulticore/source/application/Test.c.m4</sourcefile>
      <sourceline>359</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Check that CanIf_CheckWakeup() calls Can Trcv wakeup interface CanTrcv_CheckWakeup()
    through SchM_Call interfaces when CanIfMultiCoreSupport and CanIfMulticoreWakeupExtension are enabled.
  
Test Object: 
    Rte interface SchM_Call_CanIf_RequiredCSEntry_CheckTrcvWakeup_CanIfTrcvDrvCfg_0_CanIfTrcvCfg_0.
  
Test Precondition: 
    Enable CanIfMultiCoreSupport and CanIfMulticoreWakeupExtension.
  
Test Execution: 
    Do the following for transceiver 0, transceiver 1 and for both transceivers:
    01: Simulate wakeup for the chosen transceiver(s).
    02: Call CanIf_CheckWakeup for both transceiver wakeup events and check that it returns E_OK.
    03: CanIf.EB.CanIfMulticoreWakeupExtension_WakeupCanTransceiver
        Verify that CanTrcv_CheckWakeup() is called for both controllers through
        SchM_Call_CanIf_RequiredCSEntry_CheckTrcvWakeup_CanIfTrcvDrvCfg_0_CanIfTrcvCfg_0
        and SchM_Call_CanIf_RequiredCSEntry_CheckTrcvWakeup_CanIfTrcvDrvCfg_0_CanIfTrcvCfg_1.
    04: VP (CanIf.EB.Rev2.Wakeup):
        Verify that &lt;user&gt;_SetWakeupEvent is called according to the chosen controller set with
        correct parameters.
    05: Check that when the lower layer returns E_NOT_OK, the return value will also be returned by CanIf_CheckWakeup().
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Config_CanIfMulticoreWakeupExtension</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1045</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfMulticoreWakeupExtension_WakeupCanTransceiver</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>1047</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00720</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>247</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.Rev2.Wakeup</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>897</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1697</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_30352</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>59</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation with all optional functions included.
    DET is enabled
    A transceiver channel supporting wakeup is configured
  
Test Object: 
    Compile test: All functions, Det on
  
Test Precondition: 
  
Test Execution: 
    Add calls to all functions to make sure that the linker doesn't omit the different functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1698</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30391</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>97</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation with all optional functions included.
    DET is disabled
    Relocatable Postbuild configuration disabled
    A transceiver channel supporting wakeup is configured
  
Test Object: 
    Compile test: All optional functions, Det off
  
Test Precondition: 
  
Test Execution: 
    Add calls to all functions to make sure that the linker doesn't omit the different functions.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1699</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30866</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>136</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation without all optional functions
    without transceiver in configuration
    Tx buffering disabled
    DET is enabled
    Relocatable Postbuild configuration enabled
    EcuM is not available
    Can callouts are disabled
  
Test Object: 
    Compile test: No optional functions, Det on
  
Test Precondition: 
  
Test Execution: 
    Omitted functions will be defined in the test source file so that a linker error will be
    generated if the CanIf still defines them.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00224</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>63</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00362</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>74</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00367</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>75</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00371</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>76</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00373</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>77</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00738</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>663</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00330</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>511</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00340</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00357</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00428</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.RelocatablePBCfg</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>892</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1700</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30377</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>227</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation without all optional functions
    without transceiver in configuration
    Tx buffering disabled
    DET is disabled
    EcuM is not available
    Can callouts are disabled
  
Test Object: 
    Compile test: No optional functions, Det off
  
Test Precondition: 
  
Test Execution: 
    Omitted functions will be defined in the test source file so that a linker error will be
    generated if the CanIf still defines them.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00018</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>27</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00521</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>124</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00738</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>663</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00330</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>511</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00335</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>515</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00340</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>520</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00357</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>526</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00428</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>99</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00101</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>33</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1701</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ComTest_NoWuValid</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>293</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation with wakeup handling enabled but wakeup validation disabled
  
Test Object: 
    Compile test: Wakeup support enabled, wakeup validation disabled
  
Test Precondition: 
  
Test Execution: 
    Omitted function CanIf_CheckValidation() will be defined in the test source
    file so that a linker error will be generated if the CanIf still defines it.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00226_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>483</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00659</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>624</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1702</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ComTest_NoCheckWu</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>326</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Compilation with wakeup handling disabled but wakeup validation disabled
  
Test Object: 
    Compile test: Wakeup support disabled
                  CanIfCanDriverCompatibility set to ASR402
  
Test Precondition: 
  
Test Execution: 
    Omitted function CanIf_CheckWakeup() will be defined in the test source
    file so that a linker error will be generated if the CanIf still defines it.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00180_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>461</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfCanDriverCompatibility</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>971</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1703</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30868</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>360</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanIfPublicCfg.CanIfVersionInfoApi = false
    Rest of the configuration copied from CanIf_ComTest_AllOptDetOn
    CanIf_GetVersionInfo() is defined as static function.
  
Test Object: 
    Compile test: CanIf_GetVersionInfo()
  
Test Precondition: 
  
Test Execution: 
    Compile test with a test function that calls CanIf_GetVersionInfo().
    CanIf_GetVersionInfo() is defined as static function.
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00351</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>73</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1704</internalId></specobject>
    <specobject>
      <id>TS_CANIF_WakeupByCanOnly</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>391</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Wakeup support is enabled and only wakeup device is the CAN controller:
    - CanIfCtrlWakeupSupport = true
    - CanIfTrcvWakeupSupport = false
    The CAN Transceiver Driver does not provide a CanTrcv_CheckWakeup() function.
  
Test Object: 
    Compile test: CanIf_CheckWakeup()
  
Test Precondition: 
  
Test Execution: 
    Compile test with a test function that calls CanIf_CheckWakeup().
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00395</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>548</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1705</internalId></specobject>
    <specobject>
      <id>TS_CANIF_SetBaudrate_API</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_CompileBase/source/application/Appl.c</sourcefile>
      <sourceline>422</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that API function CanIf_Setbaudrate is only provided if CanIfSetBaudrateApi=true
  
Test Object: 
    CanIf_SetBaudrate()
  
Test Precondition: 
  
Test Execution: 
    Compile test with a test function that calls CanIf_SetBaudrate().
  
Test Input: 
  
Test Output: 
    Test is compiled and linked successfully.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00867</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>769</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00871</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>772</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00838_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>733</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1706</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_BusOffBeforeInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>322</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ControllerBusOff does not call a callout before the
    module is initialized.
  
Test Object: 
    CanIf_ControllerBusOff()
  
Test Precondition: 
    Can Interface not initialized.
  
Test Execution: 
    01: Call CanIf_ControllerBusOff.
    02: VP (CanIf.SWS_CanIf_00431):
        Check that CanSM_ControllerBusOff() is not called.
    03: If DET is enabled, check that CANIF_E_UNINIT is reported for API function
        CanIf_ControllerBusOff.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00431</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>567</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1707</internalId></specobject>
    <specobject>
      <id>TS_CANIF_ControllerModeIndicationBeforeInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>394</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ControllerModeIndication does not call a callout before the
    module is initialized.
  
Test Object: 
    CanIf_ControllerModeIndication()
  
Test Precondition: 
    Can Interface not initialized.
  
Test Execution: 
    01: Call CanIf_ControllerModeIndication.
    02: VP (CanIf.SWS_CanIf_00702):
        Check that CanSM_ControllerModeIndication() is not called.
    03: If DET is enabled, check that CANIF_E_UNINIT is reported for API function
        CanIf_ControllerModeIndication.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00702</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>652</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1708</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TrcvModeIndicationBeforeInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>465</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_TrcvModeIndication does not call a callout before the
    module is initialized.
  
Test Object: 
    CanIf_TrcvModeIndication()
  
Test Precondition: 
    Can Interface not initialized.
  
Test Execution: 
    01: Call CanIf_TrcvModeIndication.
    02: VP (CanIf.SWS_CanIf_00708):
        Check that CanSM_TrcvModeIndication() is not called.
    03: If DET is enabled, check that CANIF_E_UNINIT is reported for API function
        CanIf_TrcvModeIndication.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00708</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>654</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1709</internalId></specobject>
    <specobject>
      <id>TS_CANIF_TxConfirmationBeforeInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>537</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_TxConfirmation does not call a callout before the
    module is initialized.
  
Test Object: 
    CanIf_TxConfirmation()
  
Test Precondition: 
    Can Interface not initialized.
  
Test Execution: 
    01: Call CanIf_TxConfirmation.
    02: VP (CanIf.SWS_CanIf_00412):
        Check that PduR_CanIfTxConfirmation is not called.
    03: If DET is enabled, check that CANIF_E_UNINIT is reported for API function
        CanIf_TxConfirmation.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00412</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>555</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1710</internalId></specobject>
    <specobject>
      <id>TS_CANIF_RxIndicationBeforeInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>606</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_RxIndication does not call a callout before the
    module is initialized.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    Can Interface not initialized.
  
Test Execution: 
    01: Call CanIf_RxIndication.
    02: VP (CanIf.SWS_CanIf_00421):
        Check that PduR_CanIfRxIndication is not called.
    03: If DET is enabled, check that CANIF_E_UNINIT is reported for API function
        CanIf_RxIndication.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00421</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>564</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1711</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTxConfirmationBeforeInit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>678</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CancelTxConfirmation does not call a callout before the
    module is initialized.
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    Can Interface not initialized.
  
Test Execution: 
    01: Call CanIf_CancelTxConfirmation.
    02: VP (CanIf.ASR40.SWS_CanIf_00426):
        Check that PduR_CancelTxConfirmation is not called.
    03: If DET is enabled, check that CANIF_E_UNINIT is reported for API function
        CanIf_CancelTxConfirmation.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00426</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>95</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1712</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30293</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>760</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Controller and channel mode initialization.
  
Test Object: 
    CanIf_Init()
  
Test Precondition: 
    CAN interface not initialized.
  
Test Execution: 
    01: Initialize CanIf module.
    02: Call CanIf_GetControllerMode for checking controller modes.
    03: VP (CanIf.SWS_CanIf_00001, CanIf.SWS_CanIf_00085, CanIf.ASR40.SWS_CanIf_00476, CanIf.ASR40.SWS_CanIf_00478):
        Verify that CanIf_GetControllerMode returns CANIF_CS_STOPPED.
    04: Call CanIf_GetPduMode for checking pdu modes.
    05: VP (CanIf.SWS_CanIf_00001, CanIf.SWS_CanIf_00085, CanIf.ASR40.SWS_CanIf_00476, CanIf.ASR40.SWS_CanIf_00478,
        CanIf.SWS_CanIf_00864):
        Verify that CanIf_GetPduMode returns CANIF_OFFLINE.
    06: Call CanIf_ReadTxNotifStatus for checking TX notification status and check if it returns
        CANIF_NO_NOTIFICATION.
    07: Call CanIf_ReadRxNotifStatus for checking RX notification status and check if it returns
        CANIF_NO_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00476</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>112</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00478</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00864</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>764</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1713</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30367</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>890</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that re-initialization is possible (stopped mode).
  
Test Object: 
    CanIf_Init()
  
Test Precondition: 
    CAN interface already initialized.
    One Rx and one Tx PDU using notification status API configured.
  
Test Execution: 
    01: Start a controller.
    02: Simulate reception and transmission for PDUs with notification status API enabled so that
        notification status is set.
    03: Stop the controller.
    04: Start the controller first to set the PDU to OFFLINE.
    05: Reinitialize CanIf.
    06: Call CanIf_GetControllerMode for checking controller modes.
    07: VP (CanIf.SWS_CanIf_00001, CanIf.SWS_CanIf_00085, CanIf.ASR40.SWS_CanIf_00477, CanIf.ASR40.SWS_CanIf_00478):
        Verify that CanIf_GetControllerMode returns CANIF_CS_STOPPED.
    08: Call CanIf_GetPduMode for checking pdu modes.
    09: VP (CanIf.SWS_CanIf_00001, CanIf.SWS_CanIf_00085, CanIf.ASR40.SWS_CanIf_00477, CanIf.ASR40.SWS_CanIf_00478):
        Verify that CanIf_GetPduMode returns CANIF_OFFLINE.
    10: Call CanIf_ReadTxNotifStatus.
    11: VP (CanIf.SWS_CanIf_00001, CanIf.SWS_CanIf_00085, CanIf.ASR40.SWS_CanIf_00477, CanIf.ASR40.SWS_CanIf_00478):
        Verify that CanIf_ReadTxNotifStatus returns CANIF_NO_NOTIFICATION.
    12: Call CanIf_ReadRxNotifStatus.
    13: VP (CanIf.SWS_CanIf_00001, CanIf.SWS_CanIf_00085, CanIf.ASR40.SWS_CanIf_00477, CanIf.ASR40.SWS_CanIf_00478):
        Verify that CanIf_ReadRxNotifStatus returns CANIF_NO_NOTIFICATION.
    14: Repeat the sequence, using a null pointer in the CanIf_Init call
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00477</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>113</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00478</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>114</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1714</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30881</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>1068</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the Rx read data API buffers are emptied when CanIf_Init is called.
  
Test Object: 
    CanIf_Init()
  
Test Precondition: 
    Controller started
  
Test Execution: 
    01: Simulate reception of a PDU configured for read data API.
    02: Call CanIf_Init.
    03: Call CanIf_ReadRxPduData for the previous PDU.
    04: VP (CanIf.SWS_CanIf_00001, CanIf.SWS_CanIf_00085):
        Verify that CanIf_ReadRxPduData returns E_NOT_OK (no data available).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00001</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>409</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1715</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30407</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>1157</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CAN identifiers of dynamic Tx L-PDUs are reset by CanIf_Init
  
Test Object: 
    CanIf_Init()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_SetDynamicTxId to change the CAN ID of a dynamic Tx PDU.
    02: Call CanIf_Init.
    03: Set controller mode to CANIF_CS_STARTED.
    04: Call CanIf_Transmit for the PDU.
    05: VP (CanIf.SWS_CanIf_00085):
        Verify that the CAN Id used for transmission is the configured one.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00085</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>443</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1716</internalId></specobject>
    <specobject>
      <id>TS_CANIF_DelayedControllerModeIndications</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>1279</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Controller mode changing with delayed controller mode indications.
  
Test Object: 
    CanIf_SetControllerMode(), CanIf_ControllerModeIndication(), CanIf_GetControllerMode()
  
Test Precondition: 
    CAN controllers are initialized and stopped
  
Test Execution: 
    For all controllers do:
    01: Call CanIf_SetControllerMode(ControllerId, &amp;lt;input&amp;gt;).
    02: VP (CanIf.ASR40.SWS_CanIf_00481, CanIf.ASR40.SWS_CanIf_00714, CanIf.ASR40.SWS_CanIf_00482, CanIf.ASR40.SWS_CanIf_00585,
            ):
        Check that Can_SetControllerMode(ControllerId, &amp;lt;output&amp;gt;) was called.
    03: VP: Check that CanSM_ControllerModeIndication(ControllerId, &amp;lt;input&amp;gt;)
            has not been called.
    04: VP: Check that the CanIf controller mode is still in the previous mode using
            CanIf_GetControllerMode(ControllerId, &amp;lt;output&amp;gt;) returns the expected value.
    05: Call CanIf_ControllerModeIndication(ControllerId, &amp;lt;input&amp;gt;) to indicate the
        previously requested mode change.
    06: VP (CanIf.ASR40.SWS_CanIf_00715, CanIf.ASR40.SWS_CanIf_00717, ):
        Check that CanSM_ControllerModeIndication (ControllerId, &amp;lt;output&amp;gt;) was called.
    07: VP: Check that the CanIf mode was changed and
            CanIf_GetControllerMode(ControllerId, &amp;lt;output&amp;gt;) returns the expected value.
  
Test Input: 
    Input parameters for teststeps 01, 05.
    1. CANIF_CS_STARTED
    2. CANIF_CS_STARTED
    3. CANIF_CS_STOPPED
    4. CANIF_CS_STOPPED
    5. CANIF_CS_SLEEP
    6. CANIF_CS_SLEEP
    7. CANIF_CS_STOPPED
    8. CANIF_CS_STARTED
  
Test Output: 
    Output parameters for teststep 02.
    1. CAN_T_START
    2. CAN_T_START
    3. CAN_T_STOP
    4. CAN_T_STOP
    5. CAN_T_SLEEP
    6. CAN_T_SLEEP
    7. CAN_T_WAKEUP
    8. CAN_T_START

    Output parameters for teststeps 04.
    1. CANIF_CS_STOPPED
    2. CANIF_CS_STARTED
    3. CANIF_CS_STARTED
    4. CANIF_CS_STOPPED
    5. CANIF_CS_STOPPED
    6. CANIF_CS_SLEEP
    7. CANIF_CS_SLEEP
    8. CANIF_CS_STOPPED

    Output parameters for teststeps 06, 07.
    1. CANIF_CS_STARTED
    2. CANIF_CS_STARTED
    3. CANIF_CS_STOPPED
    4. CANIF_CS_STOPPED
    5. CANIF_CS_SLEEP
    6. CANIF_CS_SLEEP
    7. CANIF_CS_STOPPED
    8. CANIF_CS_STARTED
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00714</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00482</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00715</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00585</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00717</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF487</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00719</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00713</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00584</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00716</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00486</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00718</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1717</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30295</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>1519</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Controller mode changing.
  
Test Object: 
    CanIf_SetControllerMode(), CanIf_ControllerModeIndication(), CanIf_GetControllerMode()
  
Test Precondition: 
    CAN controllers are initialized and stopped
  
Test Execution: 
    For all controllers do:

    Call CanIf_SetControllerMode to set a mode (with the values of the list below) then:
    - check that
      - the correct call was made in the CAN driver
      - the correct call was made in the CanSM
      - the correct CanIf state is set (by calling CanIf_GetControllerMode())

    1. CANIF_CS_STARTED
    2. CANIF_CS_STARTED
    3. CANIF_CS_STOPPED
    4. CANIF_CS_STOPPED
    5. CANIF_CS_SLEEP
    6. CANIF_CS_SLEEP
    7. CANIF_CS_STOPPED
    8. CANIF_CS_STARTED

    9. Call CanIf_ControllerBusOff on the controller.

    10. Call CanIf_SetControllerMode with CANIF_CS_STARTED then CANIF_CS_STOPPED then CANIF_CS_SLEEP.
    Then call CanIf_CheckWakeup for all Controllers and simulate a wakeup event for the current
    controller. Call CanIf_GetControllerMode.
  
Test Input: 
  
Test Output: 
    Each call to CanIf_GetControllerMode returns the values that was set by the previous call to
    CanIf_SetControllerMode.

    Can_SetControllerMode is called once for each call to CanIf_SetControllerMode with the
    following value in Can_StateTransitionType:

    1. CAN_T_START
    2. CAN_T_START
    3. CAN_T_STOP
    4. CAN_T_STOP
    5. CAN_T_SLEEP
    6. CAN_T_SLEEP
    7. CAN_T_WAKEUP
    8. CAN_T_START

    9. After CanIf_ControllerBusOff is called, CanIf_GetControllerMode returns CANIF_CS_STOPPED;
    Can_SetControllerMode not called

    10. Mode switches result in CAN_T_START,  CAN_T_STOP, CAN_T_SLEEP transitions via
    Can_SetControllerMode. After Wakeup, CanIf_GetControllerMode returns CANIF_CS_STOPPED.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00481</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>117</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00714</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>181</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00482</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>118</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00715</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>182</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00585</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>127</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00717</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>184</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CANIF487</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>121</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00719</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>186</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00480</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>116</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00713</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>180</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00584</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>126</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00716</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>183</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00486</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>119</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00718</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>185</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.ModeIndHandling</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>887</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.GetControllerMode.Signature.Mirroring.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>956</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00488</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00653</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1718</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30201</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>1877</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Error during mode change.
  
Test Object: 
    CanIf_SetControllerMode()
  
Test Precondition: 
    CAN controller is started
  
Test Execution: 
    01: Call CanIf_SetControllerMode to change a controller mode from CANIF_CS_STARTED to
        CANIF_CS_STOPPED.
    02: VP (CanIf.SWS_CanIf_00003, CanIf.ASR40.SWS_CanIf_00475):
        Verify that CanIf_SetControllerMode() returns E_NOT_OK.
    03: Call CanIf_SetControllerMode to change a controller mode from CANIF_CS_STOPPED to
        CANIF_CS_SLEEP.
    04: VP (CanIf.SWS_CanIf_00003, CanIf.ASR40.SWS_CanIf_00475):
        Verify that CanIf_SetControllerMode() returns E_NOT_OK.
    05: Call CanIf_SetControllerMode to change a controller mode from CANIF_CS_SLEEP to
        CANIF_CS_STOPPED.
    06: VP (CanIf.SWS_CanIf_00003, CanIf.ASR40.SWS_CanIf_00475):
        Verify that CanIf_SetControllerMode() returns E_NOT_OK.
    07: Call CanIf_SetControllerMode to change a controller mode from CANIF_CS_STOPPED to
        CANIF_CS_STARTED.
    08: VP (CanIf.SWS_CanIf_00003, CanIf.ASR40.SWS_CanIf_00475):
        Verify that CanIf_SetControllerMode() returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00003</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>410</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00475</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>111</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1719</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30366</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>2075</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that TX buffers are cleared when switching to stopped mode.
  
Test Object: 
    CanIf_SetControllerMode()
  
Test Precondition: 
    Controllers started.
  
Test Execution: 
    01: Call CanIf_Transmit to send a PDU (Can_Write returns CAN_OK).
    02: Call CanIf_Transmit again with same PDU (Can_Write returns CAN_BUSY and PDU is buffered).
    03: Call CanIf_SetControllerMode giving the mode CANIF_CS_STOPPED.
    04: Call CanIf_SetControllerMode giving the mode CANIF_CS_STARTED.
    05: Call CanIf_TxConfirmation.
    06: VP (CanIf.SWS_CanIf_00485):
        Verify that Can_Write is not called because the TX buffers is emptied when the controller
        has been stopped.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00485</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>586</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1720</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30317</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>2263</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Normal transmission (with Tx Confirmation).
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    CAN controller is started
    Partial networking is disabled
  
Test Execution: 
    01: Start controllers 0 and 1.
    02: Trigger transmission for TX L-PDU 0 (standard CAN).
    03: VP (CanIf.SWS_CanIf_00318, CanIf.ASR40.SWS_CanIf_00005, CanIf.SWS_CanIf_00162,
            CanIf.ASR40.PduIdUsage.Apis, CanIf.SWS_CanIf_00752, CanIf.ECUC_CanIf_00772):
        Verify that Can_Write called with correct parameters and CanIf_Transmit returns E_OK.
    04: Trigger transmission for TX L-PDU 8 (extended CAN Id).
    05: VP (CanIf.SWS_CanIf_00318, CanIf.ASR40.SWS_CanIf_00005, CanIf.SWS_CanIf_00162,
            CanIf.ASR40.PduIdUsage.Apis, CanIf.SWS_CanIf_00752, CanIf.ECUC_CanIf_00772):
        Verify that Can_Write called with correct parameters and CanIf_Transmit returns E_OK.
    06: Confirm transmission of TX L-PDU 0.
    07: VP (CanIf.SWS_CanIf_00383):
        Verify that User_TxConfirmation is called by CanIf in the corresponding upper layer.
    08: Confirm transmission of TX L-PDU 8.
    09: VP (CanIf.SWS_CanIf_00383):
        Verify that User_TxConfirmation is called by CanIf in the corresponding upper layer.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00318</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>501</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00383</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>540</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00162</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>736</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.PduIdUsage.Apis</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00752</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>748</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00772</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>402</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1721</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30318</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>2455</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission with buffering (buffer available).
    Verify that
    - L-PDUs are buffered,
    - that the newer L-PDU data is used to overwrite the older data and
    - that the L-PDUs are transmitted in priority order.
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    PDU A, B and C are assigned to the same HTH.

    PDU D is assigned to another HTH.

    Priorities:
    A &amp;gt; B &amp;gt; C &amp;gt; D
  
Test Execution: 
    - Call CanIf_Transmit for PDU C -&amp;gt; Can_Write returns CAN_OK.
    - Call CanIf_Transmit for PDU D -&amp;gt; Can_Write returns CAN_OK.
    - Call CanIf_Transmit for PDU D -&amp;gt; Can_Write returns CAN_BUSY.
    - Call CanIf_Transmit for PDU B -&amp;gt; Can_Write returns CAN_BUSY.
    - Call CanIf_Transmit for PDU A -&amp;gt; Can_Write returns CAN_BUSY.
    - Call CanIf_Transmit for PDU B (with newer data) -&amp;gt; Can_Write returns CAN_BUSY.

    Now, Can_Write returns E_OK on every call.

    - Call CanIf_TxConfirmation for PDU C
    - Call CanIf_TxConfirmation for PDU D (sent next because of software overhead when retransmitting
      buffered message A)
    - Call CanIf_TxConfirmation for PDU A
    - Call CanIf_TxConfirmation for PDU D (sent next because of software overhead when retransmitting
      buffered message B)
    - Call CanIf_TxConfirmation for PDU B
  
Test Input: 
  
Test Output: 
    Expected behaviour:
    - PDU C is sent
    - PDU D is sent (written to HTH)
    - PDU D is buffered
    - PDU B is buffered
    - PDU A is buffered
    - PDU B's data in buffer are overwritten.

    On the  transmit confirmation for PDU ...
    - C the buffered PDU A is sent
    - D the buffered PDU D is sent
    - A the buffered PDU B is sent
    - B no more transmission is triggered

    Test pass criteria:
    On subsequent calls to CanIf_TxConfirmation:

    - Can_Write called to send PDU A (highest priority PDU on free HTH).
    - Can_Write called to send PDU D (highest priority PDU on free HTH).
    - Can_Write called to send PDU B (with the most recent data)
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00068</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>541</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00668</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00835</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>713</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00831</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>405</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00836</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>716</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1722</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31235</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>2799</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission with buffering (buffer available).
    Verify that the L-PDUs are transmitted in priority order (correct interpretation of the CAN
    IDs).
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    PDUs with the following CAN IDs are assigned to the same HTH:
    - 0 (standard)
    - 1 (standard)
    - 2 (standard)
    - 0 (extended)
    - 262143 (extended)
    - 262144 (extended)
  
Test Execution: 
    01: Start the controller.
    02: VP (CanIf.SWS_CanIf_00668, CanIf.SWS_CanIf_00063):
        Call CanIf_Transmit for one of those PDUs ("dummy") to occupy the HTH.
    03: VP:
        Call CanIf_Transmit once for each of the 6 PDUs from the precondition and let
        Can_Write return CAN_BUSY to buffer them.
    04: VP (CanIf.SWS_CanIf_00183, CanIf.SWS_CanIf_00386, CanIf.SWS_CanIf_00063):
        Call CanIf_TxConfirmation repeatedly for the correct PDU to flush the queue.
  
Test Input: 
  
Test Output: 
    Expected behaviour:
    The PDUs are sent according to their priority in the following order:
    1) Dummy PDU to fill the HTH
    2) 0 (standard)
    3) 0 (extended)
    4) 262143 (extended)
    5) 1 (standard)
    6) 262144 (extended)
    7) 2 (standard)
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>541</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00668</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1723</internalId></specobject>
    <specobject>
      <id>TS_CANIF_NoBufferingFullCanHth</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>3123</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Repeated transmission of a Tx PDU on a FULL CAN HTH. Verify that the CanIf
    does not perform buffering.
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    - PDU under test is assigned to a FULL CAN HTH
    - Tx buffering is enabled
  
Test Execution: 
    01: Call CanIf_Transmit() for the PDU under test and let Can_Write() return CAN_OK.
    02: VP (CanIf.SWS_CanIf_00063):
        - Can_Write() was called with the correct parameters.
        - CanIf_Transmit() returns E_OK.
    03: Call CanIf_Transmit() again for the same PDU and let Can_Write() return CAN_BUSY.
    04: VP (CanIf.SWS_CanIf_00063):
        - Can_Write() was called with the correct parameters.
        - CanIf_Transmit() returns E_NOT_OK.
    05: Call CanIf_TxConfirmation() for the PDU from 01.
    06: VP (CanIf.SWS_CanIf_00063):
        - No additional call to Can_Write() was performed.
        - Upper layer Tx confirmation called with the correct parameters
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00063</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>428</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1724</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30342</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>3304</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the PDU is not buffered when Can_Write returns CAN_NOT_OK and that CanIf_Transmit
    returns E_NOT_OK in this case.
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    Controller started.
  
Test Execution: 
    - Call CanIf_Transmit to send a PDU, Can_Write returns CAN_OK
    - Call CanIf_Transmit for the same PDU, Can_Write returns CAN_NOT_OK.
    - Call CanIf_TxConfirmation for the PDU
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00005</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>26</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1725</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30408</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>3484</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a dynamic Tx L-PDU is buffered and updated in the buffer if its CAN ID is unchanged
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    Controller started
  
Test Execution: 
    All calls below use the same dynamic Tx L-PDU:
    01: Start a controller.
    02: Call CanIf_Transmit, Can_Write returns E_OK.
    03: VP (CanIf.SWS_CanIf_00068):
        Call CanIf_Transmit and verify if Can_Write returns CAN_BUSY and buffers the data.
    04: VP (CanIf.SWS_CanIf_00068):
        Call CanIf_Transmit (using changed data) and verify if Can_Write returns CAN_BUSY and
        replaces the buffered data with a new one.
    05: VP (CanIf.SWS_CanIf_00068):
        CanTp_TxConfirmation should be invoked for 1st and 3rd transmit.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00068</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1726</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30409</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>3671</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that a dynamic Tx L-PDU is not buffered when its CAN ID changed
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    Controller started
  
Test Execution: 
    All calls below use the same dynamic Tx L-PDU:
    01: Start a controller.
    02: Call CanIf_Transmit, Can_Write returns E_OK.
    03: VP (CanIf.SWS_CanIf_00068):
        Call CanIf_Transmit and verify Can_Write returns CAN_BUSY and buffers the data.
    04: Call CanIf_SetDynamicTxId to change the CAN ID.
    05: VP (CanIf.SWS_CanIf_00068):
        Call CanIf_Transmit (using changed data) and verify Can_Write returns CAN_BUSY.
    06: VP (CanIf.SWS_CanIf_00068):
        verify that CanTp_TxConfirmation is invoked for the 1sta and 2nd data and
        the 3rd transmission is not buffered.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00068</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>430</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1727</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30320</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>3865</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission in CANIF_CS_STOPPED mode.
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
   - CanIf shall be initialized.
   - PDU mode shall be CANIF_ONLINE.
   - Controller shall be in STOPPED mode.
  
Test Execution: 
    01: Call CanIf_Transmit in CANIF_E_STOPPED mode.
    02: VP(CanIf.EB.CANIF723):
        Verify that CanIf_Transmit returns E_NOT_OK.
    03: VP(CanIf.SWS_CanIf_00677):
        Verify that Can_Write is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CANIF723</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>188</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00677</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>634</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1728</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30364</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>3954</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmission in CANIF_CS_SLEEP mode
  
Test Object: 
    CanIf_Transmit()
  
Test Precondition: 
    Controller in sleep mode.
  
Test Execution: 
    01: Switch to SLEEP mode.
    02: Call CanIf_Transmit() for TxLPdu0 (controller 1).
    03: VP (CanIf.EB.SleepModeEStopped):
        Verify that Can_Write is not called and CanIf_Transmit returns E_NOT_OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.SleepModeEStopped</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>189</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1729</internalId></specobject>
    <specobject>
      <id>TS_CANIF_CancelTransmit</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>4035</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_CancelTransmit() returns E_OK if called with a valid Tx
    PDU ID. Dummy test for a dummy function.
  
Test Object: 
    CanIf_CancelTransmit()
  
Test Precondition: 
    - CanIf_CancelTransmit() is configured to be used.
    - At least one Tx PDU is configured.
  
Test Execution: 
    01: Call CanIf_CancelTransmit().
    02: VP (CanIf.ASR40.SWS_CanIf_00520):
        CanIf_CancelTransmit() returns E_OK
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00520</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>123</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1730</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30298</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>4106</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_ReadRxPduData returns the correct data.
  
Test Object: 
    CanIf_ReadRxPduData()
  
Test Precondition: 
    Read data API enabled for a PDU.
  
Test Execution: 
    01: Call CanIf_Init to clear buffers; start controller.
    02: VP (CanIf.ASR40.SWS_CanIf_00194):
        Call CanIf_ReadRxPduData before any reception has happened and
        verify no data is available and returns E_NOT_OK.
    03: Simulate reception of a PDU.
    04: VP (CanIf.ASR40.SWS_CanIf_00194):
        Call CanIf_ReadRxPduData for the PDU which has just been received and
        verify data is available and returns E_OK.
    05: VP (CanIf.SWS_CanIf_00199_1, CanIf.SWS_CanIf_00198):
        Check received data.
    06: Simulate reception of a PDU
    07: Simulate reception same PDU with other data
    08: VP (CanIf.ASR40.SWS_CanIf_00194):
        Call CanIf_ReadRxPduData for the PDU and verify data is available and returns E_OK.
    09: VP (CanIf.SWS_CanIf_00199_1, CanIf.SWS_CanIf_00198):
        Check received data if its overwritten.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00198</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>471</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00199_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>474</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00194</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>61</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.PduIdUsage.Apis</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1731</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30205</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>4248</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanIf_ReadTxNotifStatus
  
Test Object: 
    CanIf_ReadTxNotifStatus()
  
Test Precondition: 
    Notification API enabled for a Tx-PDU.
  
Test Execution: 
    01: Re-Initialize CanIf, start controller.
    02: VP (CanIf.SWS_CanIf_00472, CanIf.ASR40.SWS_CanIf_00202, CanIf.SWS_CanIf_00393):
        Call CanIf_ReadTxNotifStatus for a PDU, it should return CANIF_NO_NOTIFICATION.
    03: Call CanIf_Transmit for the PDU.
    04: VP (CanIf.SWS_CanIf_00472, CanIf.ASR40.SWS_CanIf_00202, CanIf.SWS_CanIf_00393):
        Call CanIf_ReadTxNotifStatus for the PDU, it should return CANIF_NO_NOTIFICATION.
    05: Call CanIf_TxConfirmation for the PDU.
    06: VP (CanIf.SWS_CanIf_00472, CanIf.ASR40.SWS_CanIf_00202, CanIf.SWS_CanIf_00393,
            CanIf.SWS_CanIf_00391, CanIf.ASR40.PduIdUsage.Apis):
        Call CanIf_ReadTxNotifStatus for the PDU, it should return CANIF_TX_RX_NOTIFICATION.
    07: VP (CanIf.SWS_CanIf_00472, CanIf.ASR40.SWS_CanIf_00202, CanIf.SWS_CanIf_00393):
        Call CanIf_ReadTxNotifStatus for the PDU, it should return CANIF_NO_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00472</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>584</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00202</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>243</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00393</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>546</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00391</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>739</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.PduIdUsage.Apis</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1732</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30206</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>4387</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanIf_ReadRxNotifStatus
  
Test Object: 
    CanIf_ReadRxNotifStatus()
  
Test Precondition: 
    Notification API enabled for a Rx-PDU.
  
Test Execution: 
    01: Re-Initialize CanIf, start controller.
    02: VP (CanIf.ASR40.SWS_CanIf_00230, CanIf.SWS_CanIf_00394):
        Call CanIf_ReadRxNotifStatus for a PDU, it should return CANIF_NO_NOTIFICATION.
    03: VP:
        Call CanIf_RxIndication for the PDU.and check if the its successful
    04: VP (CanIf.ASR40.SWS_CanIf_00230, CanIf.SWS_CanIf_00392, CanIf.SWS_CanIf_00472,
            CanIf.SWS_CanIf_00472, CanIf.ASR40.PduIdUsage.Apis):
        Call CanIf_ReadRxNotifStatus for the PDU, it should return CANIF_TX_RX_NOTIFICATION.
    05: VP (CanIf.ASR40.SWS_CanIf_00230, CanIf.SWS_CanIf_00394):
        Call CanIf_ReadRxNotifStatus for the PDU, it should return CANIF_NO_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00230</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>244</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00394</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>547</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00472</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>584</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00473</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>585</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00392</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>545</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.PduIdUsage.Apis</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>29</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1733</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30307</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>4509</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    PDU modes
  
Test Object: 
    - CanIf_SetPduMode()
    - CanIf_GetPduMode()
  
Test Precondition: 
  
Test Execution: 
    01: Re-Initialize CanIf, start controller.
    02: VP (CanIf.SWS_CanIf_00008, CanIf.SWS_CanIf_00009):
        Call CanIf_SetPduMode with every legal PDU mode parameter/current PDU mode combination and
        check resulting PDU mode with CanIf_GetPduMode.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00008</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>414</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00009</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>415</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1734</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30308</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>4610</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    PDU mode OFFLINE (including the deletion of buffered TX requests)
  
Test Object: 
    PDU mode handling
  
Test Precondition: 
    PDU mode is ONLINE
  
Test Execution: 
    01: Re-Initialize CanIf, start controller.
    02: Call CanIf_Transmit repetitively to buffer elements.
    03: Set PDU mode to OFFLINE (CANIF_OFFLINE).
    04: VP (CanIf.SWS_CanIf_00073_1):
        Call CanIf_Transmit and verify if CanIf_Transmit returns E_NOT_OK and
        also there is no change in transmit call counter.
    05: VP (CanIf.SWS_CanIf_00073_3, CanIf.SWS_CanIf_00073_2, CanIf.SWS_CanIf_00489_2):
        Call CanIf_RxIndication and verify that the failed transmission had no effect on
        the upper layers.
    06: Set PDU mode to ONLINE (CANIF_ONLINE)
    07: Call CanIf_TxConfirmation.
  
Test Input: 
  
Test Output: 
    Expected behaviour:
    Neither transmission nor reception is processed after entering OFFLINE-mode.
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00073_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>434</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00073_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>435</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00073_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>436</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>589</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1735</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30309</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>4811</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    PDU mode TX_ONLINE
  
Test Object: 
    Pdu mode handling
  
Test Precondition: 
    CAN Driver simulation does not call TxConfirmation (necessary for the next test)
  
Test Execution: 
    01: Re-Initialize CanIf, start controller and set PDU mode to ONLINE.
    02: VP(CanIf.SWS_CanIf_00075_1):
        Call CanIf_Transmit and verify if the transmission returns E_OK.
    03: Set PDU mode to TX_OFFLINE_ACTIVE (CANIF_TX_OFFLINE_ACTIVE)
    04: VP(CanIf.ASR40.SWS_CanIf_00490):
        Call CanIf_RxIndication and verify if the transmission has no effect on the upper layers.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00075_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00137</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>734</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1736</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30321</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>4944</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Check that PDU mode CANIF_TX_OFFLINE_ACTIVE, enables upper layer forwarding of TxConfirmation callbacks.
  
Test Object: 
    Pdu mode handling
  
Test Precondition: 
  
Test Execution: 
    01: Set PDU mode to ONLINE (CANIF_ONLINE)
    02: Transmit TX LPDU3.
    03: Check if Can_Write is called for the PDU.
    04: Call TxConfirmation for the PDU.
    05: VP(CanIf.SWS_CanIf_00075_3):
        Check if the upper layer TxConfirmation is called.
    06: Set PDU mode to OFFLINE.
    07: Simulate message reception on LPDU3.
    08: Check if the call is ignored and no upper layer callback is called.
    09: Set PDU mode to TX_OFFLINE.
    10: Simulate message reception on LPDU3.
    11: VP(CanIf.SWS_CanIf_00489_4):
        Check that upper layer RxIndication call is made.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00075_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489_4</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>591</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1737</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30310</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>5095</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    PDU mode ONLINE
  
Test Object: 
    PDU mode handling
  
Test Precondition: 
    controller is in mode started and current PDU mode is OFFLINE.
  
Test Execution: 
    01: Set PDU mode to ONLINE (CANIF_ONLINE).
    02: Call CanIf_TxConfirmation for PDU transmitted in last test case.
    03: VP(CanIf.SWS_CanIf_00075_1):
        Call CanIf_Transmit and verify if the transmission returned E_OK and was successful.
    04: VP(CanIf.SWS_CanIf_00075_2):
        Call CanIf_RxIndication and verify if the upper layer Tx confirmation is called.
    05: VP(CanIf.SWS_CanIf_00075_3):
        Call CanIf_TxConfirmation for PDU transmitted and verify message transmission.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00075_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>440</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00075_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>441</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00075_3</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>442</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1738</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30311</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>5278</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    PDU mode TX_OFFLINE_ACTIVE
  
Test Object: 
    PDU mode handling
  
Test Precondition: 
    controller is started and PDU mode is TX_ONLINE
  
Test Execution: 
    01: Re-Initialize CanIf, start controller.
    02: Set PDU mode to TX_OFFLINE_ACTIVE (CANIF_TX_OFFLINE_ACTIVE)
    03: VP(CanIf.SWS_CanIf_00072):
        Call CanIf_Transmit and verify it returns E_OK but the write is not done.
    04: VP:
        Call CanIf_RxIndication and check that no receive indication is triggered.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00072</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1739</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30312</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>5396</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    PDU mode TX_OFFLINE
  
Test Object: 
    PDU mode handling
  
Test Precondition: 
  
Test Execution: 
    01: Re-Initialize CanIf, start controller.
    02: Set PDU mode to CANIF_TX_OFFLINE_ACTIVE (by calling CanIf_SetPduMode with
        CANIF_TX_OFFLINE_ACTIVE)
    03: VP(CanIf.SWS_CanIf_00072):
        Call CanIf_Transmit and verify it returns E_OK but the write is not done.
    04: VP:
        Call CanIf_RxIndication and check that receive indication is not triggered.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00072</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>432</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1740</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30306</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>5532</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    PDU mode TX_OFFLINE
  
Test Object: 
    PDU mode handling
  
Test Precondition: 
  
Test Execution: 
    01: Start a controller.
    02: Set PDU mode to TX_ONLINE by calling CanIf_SetPduMode with CANIF_TX_OFFLINE.
    03: Call CanIf_Transmit to transmit message using TX L-PDU 1. ()
    04: VP (CanIf.SWS_CanIf_00489_1):
        Verify that CanIf_Transmit returns E_NOT_OK.
    05: Call CanIf_RxIndication for reception of RX L-PDU 1.
    06: Check that &lt;user&gt;_RxIndication is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>588</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1741</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30210</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>5660</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanIf_SetDynamicTxId
  
Test Object: 
    CanIf_SetDynamicTxId()
  
Test Precondition: 
  
Test Execution: 
    01: Start a controller.
    Do the following for both standard and extended CAN IDs (differentiated in highest bit of
    Can_IdType):
    02: Call CanIf_Transmit to send a PDU with dynamic CAN ID.
    03: Call CanIf_TxConfirmation for the PDU to acknowledge transmission.
    04: Call CanIf_SetDynamicTxId to change the CAN ID of the PDU.
    05: Call CanIf_Transmit to send a PDU with dynamic CAN ID.
    06: VP (CanIf.ASR40.SWS_CanIf_00189):
        Call CanIf_TxConfirmation and verify if the transmission of PDU with new ID is OK.
    07: Call CanIf_SetDynamicTxId to change the CAN ID of the PDU.
    08: Call CanIf_Transmit again.
    09: VP (CanIf.ASR40.SWS_CanIf_00189):
        Call CanIf_TxConfirmation and verify if the transmission of PDU with new ID is OK.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00189</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>242</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1742</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30209</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>5844</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanIf_GetVersionInfo
  
Test Object: 
    CanIf_GetVersionInfo()
  
Test Precondition: 
  
Test Execution: 
    01: Call CanIf_GetVersionInfo
    02: VP (CanIf.SWS_CanIf_00158, CanIf.ASR40.SWS_CanIf_00350):
        check return values.
         1. vendorID,
         2. moduleID,
         3. sw_major_version,
         4. sw_minor_version,
         5. sw_patch_version.
  
Test Input: 
  
Test Output: 
    The correct information is stored in the structure given to CanIf_GetVersionInfo:
    1. vendorID: 1
    2. moduleID: 60
    3. sw_major_version: M4_SPEC_VERSION_MAJOR
    4. sw_minor_version: M4_SPEC_VERSION_MINOR
    5. sw_patch_version: M4_SPEC_VERSION_PATCH
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00158</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>454</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00350</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>72</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1743</internalId></specobject>
    <specobject>
      <id>TS_CANIF_VersionCheck</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>5923</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify common published information
  
Test Object: 
    Published information
  
Test Precondition: 
  
Test Execution: 
    01: VP (CanIf.ASR40.SWS_CanIf_00725):
        Check that the constants mentioned below are defined and that their values equal the
        expected ones.
        1. CANIF_AR_RELEASE_MAJOR_VERSION,
        2. CANIF_AR_RELEASE_MINOR_VERSION,
        3. CANIF_AR_RELEASE_PATCH_VERSION,
        4. CANIF_SW_MAJOR_VERSION,
        5. CANIF_SW_MINOR_VERSION,
        6. CANIF_SW_PATCH_VERSION,
        7. CANIF_VENDOR_ID and
        8. CANIF_MODULE_ID
  
Test Input: 
  
Test Output: 
    All needed defines are present and their respective values are:
    1. M4_REL_VERSION_MAJOR
    2. M4_REL_VERSION_MINOR
    3. M4_REL_VERSION_PATCH
    4. M4_MODULE_VERSION_MAJOR
    5. M4_MODULE_VERSION_MINOR
    6. M4_MODULE_VERSION_PATCH
    7. 1
    8. 60
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00725</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>190</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1744</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30213</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>6000</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that dispatching CanIf_TxConfirmation is done correctly.
  
Test Object: 
    CanIf_TxConfirmation()
  
Test Precondition: 
  
Test Execution: 
    01: Start controller 0, 1 and 2
    02: VP(CanIf.SWS_CanIf_00383, CanIf.SWS_CanIf_00007, CanIf.EB.User_TxConfirmation.Signature.Result.OFF):
        Call CanIf_TxConfirmation for one PDU per configured upper layer:
        - CanTp.
        - CanNm.
        - PduR.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00383</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>540</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00007</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>413</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.User_TxConfirmation.Signature.Result.OFF</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>959</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1745</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30332</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>6155</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Buffered PDU sent on TX confirmation.
  
Test Object: 
    CanIf_TxConfirmation()
  
Test Precondition: 
  
Test Execution: 
    01: Start a controller
    02: VP (CanIf.SWS_CanIf_00386):
        Call CanIf_Transmit to transmit a PDU and verify if Can_Write returns CAN_OK.
    03: VP (CanIf.SWS_CanIf_00386, CanIf.SWS_CanIf_00668):
        Call CanIf_Transmit to buffer the PDU and verify if Can_Write returns CAN_BUSY and
        buffers the data.
    04: VP (CanIf.SWS_CanIf_00183):
        Call CanIf_TxConfirmation twice and check if both transmitted and
        buffered data are confirmed.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>541</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00668</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1746</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30343</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>6323</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN interface tries to send all buffered PDUs for a HTH when Can_Write returns
    CAN_NOT_OK.  So that if a PDU was invalid, another one can be sent and dead-lock in case of
    permanent failure of the CAN driver is prevented.
  
Test Object: 
    CanIf_TxConfirmation()
  
Test Precondition: 
  
Test Execution: 
    01: Start a controller.
    02: VP (CanIf.SWS_CanIf_00386):
        Call CanIf_Transmit to send a valid PDU over a given HTH
    03: Call CanIf_Transmit to send several invalid PDUs (having high priority) through the same HTH.
    04: VP (CanIf.SWS_CanIf_00386, CanIf.SWS_CanIf_00668):
        Call CanIf_Transmit to send another valid PDU (having low priority) through the former HTH
        and verify if it returns E_OK and a call counter is again incremented
    05: VP (CanIf.SWS_CanIf_00183):
        Call CanIf_TxConfirmation twice and check if both transmitted(1st) and
        buffered(last) data are confirmed.

    (Can_Write returns CAN_NOT_OK when the DLC is invalid and CAN_OK when it is valid).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>541</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00668</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1747</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30808</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>6553</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that TX confirmations are not suppressed in (TX) OFFLINE modes if the transmission was
    started in (TX) ONLINE mode.
  
Test Object: 
    CanIf_TxConfirmation()
  
Test Precondition: 
    Controller is started
  
Test Execution: 
    For the modes
    - Offline
    - Offline Active and
    - TX Offline
    do ...
    01: Start a controller.
    02: Call CanIf_SetPduMode to switch to ONLINE mode.
    03: Call CanIf_Transmit for a message in ONLINE mode.
    04: Switch to the mode to be tested.
    05: Simulate the transmission by calling CanIf_TxConfirmation.
    06: VP (CanIf.SWS_CanIf_00489.PendingConfirmations, CanIf.SWS_CanIf_00073.PendingConfirmations):
        Verify that correct transmit confirmation callback function of the upper layer is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00489.PendingConfirmations</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>592</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00073.PendingConfirmations</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>438</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1748</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30319</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>6716</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Transmit cancellation (data gets back in buffer)
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
    CAN controller is started
  
Test Execution: 
    01: Start a controller.
    02: Call CanIf_Transmit to send a TX L-PDU 3, Can_Write returns CAN_OK.
    03: Call CanIf_Transmit to send a TX L-PDU 1 with higher priority than A, Can_Write returns
        CAN_BUSY (buffered).
    04: Call CanIf_CancelTxConfirmation to indicate cancellation of the TX L-PDU 3 (PDU A).
    05: VP (CanIf.EB.Rev2.CancelTxConfirmation):
        Verify that Can_Write called for implicit transmission of TX L-PDU 1 and TX L-PDU 3 is buffered.
    06: Call CanIf_TxConfirmation to indicate that TX L-PDU 1 has been transmitted and check that
        &amp;lt;user&amp;gt;_TxConfirmation is called.
    07: Verify that Can_Write called for transmission of TX L-PDU 3.
    08: Call CanIf_TxConfirmation to indicate that TX L-PDU 3 has been transmitted and check that
        &amp;lt;user&amp;gt;_TxConfirmation is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.Rev2.CancelTxConfirmation</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>898</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1749</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30203</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>6905</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that old data does not overwrite more recent data in buffer because of TX cancellation.
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
  
Test Execution: 
    01: Start a controller.
    02: Call CanIf_Transmit to send a TX L-PDU 2 (Can_Write returns CAN_OK).
    03: Call CanIf_Transmit to send a TX L-PDU 1(Can_Write returns CAN_BUSY).
    04: Call CanIf_Transmit to send TX L-PDU 2 again with new data (Can_Write return CAN_BUSY).
    05: Call CanIf_CancelTxConfirmation to indicate cancellation of the TX L-PDU 2.
    06: Call CanIf_TxConfirmation to indicate that TX L-PDU 1 has been transmitted and check that
        &amp;lt;user&amp;gt;_TxConfirmation is called.
    07: VP (CanIf.ASR40.SWS_CanIf_00176):
        Verify that old data is not buffered and Can_Write called to send TX L-PDU 2 with newer data.
    08: Call CanIf_TxConfirmation to indicate that TX L-PDU 2 has been transmitted and check that
        &amp;lt;user&amp;gt;_TxConfirmation is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00176</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>60</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1750</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30325</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>7110</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Higher priority data delayed when transmit cancellation is not supported.
  
Test Object: 
    Transmit cancellation
  
Test Precondition: 
    Transmit cancellation disabled/not used (compare headline of associated requirement).
  
Test Execution: 
    TX L-PDU 1 (CAN ID 202) has a higher priority than TX L-PDU 2 (CAN ID 303).

    01: Start a controller.
    02: Call CanIf_Transmit for TX L-PDU 2 (Can_Write returns CAN_OK).
    03: Call CanIf_Transmit for TX L-PDU 1 (Can_Write returns CAN_BUSY).
    04: Call CanIf_TxConfirmation for PDU A.
    05: VP (CanIf.SWS_CanIf_00383):
        Verify that &amp;lt;user&amp;gt;_TxConfirmation is called for TX L-PDU 2.
    06: VP (CanIf.SWS_CanIf_00386, CanIf.SWS_CanIf_00668):
        Verify that CanIf initiates a transmit request for the transmission of buffered TX L-PDU 1.
    07: Call CanIf_TxConfirmation for TX L-PDU 1.
    08: VP (CanIf.SWS_CanIf_00383):
        Verify that &amp;lt;user&amp;gt;_TxConfirmation is called for TX L-PDU 1.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00383</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>540</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00386</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>541</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00668</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>631</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1751</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30344</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>7316</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the CAN interface tries to send all buffered PDUs for a HTH when Can_Write returns
    CAN_NOT_OK. So that if a PDU was invalid, another one can be sent and to prevent dead-lock in
    case of permanent failure of the CAN driver.
  
Test Object: 
    CanIf_CancelTxConfirmation()
  
Test Precondition: 
  
Test Execution: 
    01: Start a controller.
    02: Call CanIf_Transmit to send a valid PDU over a given HTH
    03: Call CanIf_Transmit to send several invalid PDUs (having high priority) through the same HTH.
    04: VP (CanIf.SWS_CanIf_00183):
        Verify that CanIf tries to send all buffered PDUs for a HTH.
    05: Call CanIf_Transmit to send another valid PDU (having low priority) through the former HTH
    06: VP (CanIf.SWS_CanIf_00183):
        Verify that CanIf tries to send all buffered PDUs for a HTH.
    07: Call CanIf_CancelTxConfirmation for the first PDU.
    08: Call CanIf_TxConfirmation for both PDUs successfully sent.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00183</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>465</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1752</internalId></specobject>
    <specobject>
      <id>TS_CANIF_Det_E_PARAM_HRH</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>7549</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    CanIf_RxIndication reports CANIF_E_PARAM_HRH if the given HRH is invalid
    (non-optimized HOH translation).
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    - CanIf is initialized.
    - Test is executed with Det enabled and for a configuration which has
      HOH translation optimization off (i.e. CanIf_ConTest_Basic_2Trcv_DetOn at
      the moment).
  
Test Execution: 
    If development error detection is enabled:
    01: Call CanIf_RxIndication with an invalid value in Hrh (ID &gt; max ID).
    02: VP (CanIf.ASR40.SWS_CanIf_00416, CanIf.SWS_CanIf_00416_1)
        CANIF_E_PARAM_HRH reported to the DET module.
    03: Call CanIf_RxIndication with an invalid value in Hrh (HTH ID).
    04: VP (CanIf.ASR40.SWS_CanIf_00416, CanIf.SWS_CanIf_00416_1)
        CANIF_E_PARAM_HRH reported to the DET module.
    05: Call CanIf_RxIndication with an invalid value in Hrh (unused ID &lt; max
        ID).
    06: VP (CanIf.ASR40.SWS_CanIf_00416, CanIf.SWS_CanIf_00416_1)
        CANIF_E_PARAM_HRH reported to the DET module.
    07: No upper layer Rx indication callouts were made.
    Otherwise, the test will just return "ok".
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00416</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>220</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00416_1</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>559</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1753</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30214</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>7698</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception notification to upper layers.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    This test must be executed for at least two configurations for which one
    must result in an optimized HOH ID to index translation (i.e. HOH IDs are
    zero-based, consecutive and all HRHs have IDs less than the IDs of the HTHs)
    while the other must result in a non-optimized HOH ID to index translation.
    Currently this is fulfilled by the configurations for test sequences
    CanIf_ConTest_Basic_1Trcv_DetOff (optimized translation) and
    CanIf_ConTest_Basic_2Trcv_DetOn (standard translation).
  
Test Execution: 
    01: Start controllers 0 and 1.
    02: Simulate message reception for RX L-PDU 1 (PduR).
    03: VP (CanIf.SWS_CanIf_00135, CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00281, CanIf.SWS_CanIf_00390,
            CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006, CanIf.SWS_CanIf_00415,
            CanIf.SWS_CanIf_00115.HohIdDerivedFromCan):
        Verify that &lt;user&gt;_RxIndication is called.
    04: Simulate message reception for RX L-PDU 3 (PduR, same HRH as RX L-PDU 1)
    05: VP (CanIf.SWS_CanIf_00135, CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00281, CanIf.SWS_CanIf_00390,
            CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006, CanIf.SWS_CanIf_00415,
            CanIf.SWS_CanIf_00115.HohIdDerivedFromCan):
        Verify that &lt;user&gt;_RxIndication is called.
    06: Simulate message reception for RX L-PDU 5 (CanTp, HRH with only one PDU assigned)
    07: VP (CanIf.SWS_CanIf_00135, CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00281, CanIf.SWS_CanIf_00390,
            CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006, CanIf.SWS_CanIf_00415,
            CanIf.SWS_CanIf_00115.HohIdDerivedFromCan):
        Verify that &lt;user&gt;_RxIndication is called.
    08: Simulate message reception for RX L-PDU 4 (CanNm, HRH with only one PDU assigned)
    09: VP (CanIf.SWS_CanIf_00135, CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00281, CanIf.SWS_CanIf_00390,
            CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006, CanIf.SWS_CanIf_00415,
            CanIf.SWS_CanIf_00115.HohIdDerivedFromCan):
        Verify that &lt;user&gt;_RxIndication is called.
    10: Simulate message reception for RX L-PDU 0 (CanTp, extended CAN id)
    11: VP (CanIf.SWS_CanIf_00135, CanIf.SWS_CanIf_00012, CanIf.SWS_CanIf_00281, CanIf.SWS_CanIf_00390,
           CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006, CanIf.SWS_CanIf_00415,
           CanIf.SWS_CanIf_00115.HohIdDerivedFromCan):
        Verify that &lt;user&gt;_RxIndication is called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00135</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>452</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00012</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>417</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00281</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>487</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00390</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>544</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00115.HohIdDerivedFromCan</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>445</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1754</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30795</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>7960</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception notification and handling for reception range objects
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    controller is started
  
Test Execution: 
    Simulate several reception events for a HRH that has a range PDU assigned to it (HRH_0_1)
    including receptions for
    - Last CAN ID before the range
    - First CAN ID of the range
    - Another CAN ID in the range
    - Last CAN ID of the range
    - First CAN ID after the range
    - Mix of standard and extended CAN IDs
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00281</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>487</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00745</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>401</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00744</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>400</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1755</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30327</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>8202</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception in CANIF_CS_STOPPED mode.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Put the controller in CANIF_CS_STOPPED mode.
    02: Call CanIf_RxIndication for the reception of RX L-PDU 1 (PduR).
    03: VP (CanIf.EB.RxIndicationCtrlMode):
        Verify that PduR_CanIfRxIndication is not called.
    04: Call CanIf_RxIndication for the reception of RX L-PDU 5 (CanTp).
    05: VP (CanIf.EB.RxIndicationCtrlMode):
        Verify that CanTp_RxIndication is not called.
    06: Call CanIf_RxIndication for the reception of RX L-PDU 4 (CanNm).
    07: VP (CanIf.EB.RxIndicationCtrlMode):
        Verify that CanNm_RxIndication is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.RxIndicationCtrlMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1756</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30365</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>8286</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Reception in CANIF_CS_SLEEP mode.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    Controller in sleep mode.
  
Test Execution: 
    01: Put controller 1 to sleep mode.
    02: Simulate message reception for RX L-PDU 1 (PduR).
    03: VP (CanIf.EB.RxIndicationCtrlMode):
        Verify that PduR_CanIfRxIndication is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.RxIndicationCtrlMode</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>902</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1757</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30333</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>8361</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that unwanted PDUs are filtered out.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
  
Test Execution: 
    01: Start controller 1
    02: Simulate message reception on HRH_1_0 with CAN ID 0
    03: VP (CanIf.SWS_CanIf_00389, CanIf.SWS_CanIf_00211):
        Verify that &lt;user&gt;_RxIndication function is not called.
    04: Simulate message reception on HRH_1_0 with CAN ID 40
    05: VP (CanIf.SWS_CanIf_00389, CanIf.SWS_CanIf_00211):
        Verify that &lt;user&gt;_RxIndication function is not called.
    06: Simulate message reception on HRH_1_0 with CAN ID 1023
    07: VP (CanIf.SWS_CanIf_00389, CanIf.SWS_CanIf_00211):
        Verify that &lt;user&gt;_RxIndication function is not called.
    08: Simulate message reception on HRH_1_0 with extended CAN ID 65
    09: VP (CanIf.SWS_CanIf_00389, CanIf.SWS_CanIf_00211):
        Verify that &lt;user&gt;_RxIndication function is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SoftwareFilter.RejectPdu</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>230</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00389</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>543</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00211</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>477</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00877_CanId</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>775</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00877_CanIdType</linksto>
          <dstversion>2</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>776</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1758</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30334</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>8499</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that PDUs with a DLC smaller than expected are discarded.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    DLC check enabled in the configuration
  
Test Execution: 
    01: Start controllers 1 and 2.
    02: Simulate reception for RxLPdu3 with dlc 2 (1 less than necessary).
    03: VP (CanIf.SWS_CanIf_00026, CanIf.ASR40.DlcCheck.NoRxIndication):
        Verify that &lt;user&gt;_RxIndication function is not called.
    04: Simulate reception for RxLPdu5 with dlc 0 (special case 0).
    05: VP (CanIf.SWS_CanIf_00026, CanIf.ASR40.DlcCheck.NoRxIndication):
        Verify that &lt;user&gt;_RxIndication function is not called.
    06:Simulate reception for RxLPdu8 with dlc 4 (4 less than necessary).
    07: VP (CanIf.SWS_CanIf_00026, CanIf.ASR40.DlcCheck.NoRxIndication):
        Verify that &lt;user&gt;_RxIndication function is not called.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.DlcCheck.NoRxIndication</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>223</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1759</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30335</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>8618</sourceline>
      <version>1</version>
      <description>Test Synopsis: None.
Test Description: 
    Verify that PDUs with a DLC longer than expected are truncated to the configured length and
    that the callback in upper layer is called.
  
Test Object: 
    CanIf_RxIndication(), CanIf_ReadRxPduData()
  
Test Precondition: 
    DLC check enabled in the configuration
  
Test Execution: 
    01: Start a controller.
    02: Simulate message reception for RX L-PDU 3 (PduR, configured DLC 3) using DLC of 4.
    03: Simulate message reception for RX L-PDU 5 (CanTp, configured DLC 5) using a DLC of 8.
    04: Simulate message reception for RX L-PDU 4 (CanNm, configured DLC 5) using a DLC of 7.
    05: Call CanIf_ReadRxPduData for RX L-PDUs 3.
    06: VP (CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006,
            CanIf.ECUC_CanIf_00599, CanIf.SWS_CanIf_00830):
        Verify that the configured DLC is passed to the upper layer and the DLC and data returned by CanIf_ReadRxPduData are equal to those given by the receive indication callback.
    07: Call CanIf_ReadRxPduData for RX L-PDUs 5.
    08: VP (CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006,
            CanIf.ECUC_CanIf_00599, CanIf.SWS_CanIf_00830):
        Verify that the configured DLC is passed to the upper layer and the DLC and data returned by CanIf_ReadRxPduData are equal to those given by the receive indication callback.
    09: Call CanIf_ReadRxPduData for RX L-PDUs 4.
    10: VP (CanIf.SWS_CanIf_00026, CanIf.ASR40.SWS_CanIf_00006, CanIf.SWS_CanIf_00006,
            CanIf.ECUC_CanIf_00599, CanIf.SWS_CanIf_00830):
        Verify that the configured DLC is passed to the upper layer and the DLC and data returned by CanIf_ReadRxPduData are equal to those given by the receive indication callback.
  
Test Input: 
  
Test Output: 
  </description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00026</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>420</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>221</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00006</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>412</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00599</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>356</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00830</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>712</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1760</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30876</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>8825</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that PDUs with DLC set to 0 are handled and indicated to the upper layer according to
    the received DLC.
  
Test Object: 
    CanIf_RxIndication()
  
Test Precondition: 
    DLC Check enabled in the configuration
    A PDU with expected DLC set to 0 and upper layer set to CanTp in configuration
  
Test Execution: 
    For varying DLCs 0, 1, 4, 8:
    01: Simulate several receptions of an Rx-PDU with expected DLC and upper layer set to
        CanTp.
    02: VP (CanIf.SWS_CanIf_00830, CanIf.ECUC_CanIf_00617), CanIf.SWS_CanIf_00830:
        Verify that CanTp_RxIndication is called and received DLC is passed to the upper layer.
    03: Call CanIf_ReadRxPduData for the PDU.
    04: VP (CanIf.SWS_CanIf_00830, CanIf.ECUC_CanIf_00617, CanIf.SWS_CanIf_00830):
        Verify that CanIf_ReadRxPduData returns the received length and data.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00830</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>712</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00617</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>371</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1761</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30217</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>8999</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Bus Off callbacks and controller mode change.
  
Test Object: 
    CanIf_ControllerBusOff()
  
Test Precondition: 
    All controllers started.
    A PDU stored in tx buffer of chosen controller (necessary CanIf_Transmit calls done).
  
Test Execution: 
    01: Start all controllers.
    02: Transmit TX L-PDU 2 -&gt; message transmission
    03: Transmit TX L-PDU 2 -&gt; buffering
    04: Call CanIf_ControllerBusOff for a STARTED controller.
    05: VP (CanIf.SWS_CanIf_00218, CanIf.SWS_CanIf_00653, CanIf.SWS_CanIf_00014, CanIf.SWS_CanIf_00724):
        Verify that &amp;lt;user&amp;gt;_ControllerBusOff is called with correct parameters.
    06: VP (CanIf.ASR40.SWS_CanIf_00488, CanIf.ASR40.SWS_CanIf_00541):
        Call CanIf_GetControllerMode and CanIf_GetPduMode on all controllers and check that
        controller mode of controller on which the Bus Off happened is set to CANIF_CS_STOPPED
        and pdu mode.
    07: Do Bus Off recovery by calling CanIf_SetControllerMode with CANIF_CS_STARTED.
    08: VP (CanIf.ASR40.SWS_CanIf_00488, CanIf.ASR40.SWS_CanIf_00541):
        Call CanIf_GetControllerMode and CanIf_GetPduMode on all controllers and check that
        controller mode of controller on which the Bus Off happened is set to CANIF_CS_STOPPED
        and pdu mode.
    09: Call CanIf_TxConfirmation() for the hth for which a PDU was buffered at the beginning of the
        test.
    10: Check that Can_Write is not  called since the buffer is emptied during the switch to
        stopped mode.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00488</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>122</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00218</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>478</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00653</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>620</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00014</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>418</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00724</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>659</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00541</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>125</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1762</internalId></specobject>
    <specobject>
      <id>TS_CANIF_30805</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>9236</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that Bus Off notification is propagated in CANIF_OFFLINE mode.
  
Test Object: 
    CanIf_ControllerBusOff()
  
Test Precondition: 
    Controller is started
  
Test Execution: 
    01: Initialize CanIf Module.
    02: Start controller 1.
    03: Switch the controller 1 to OFFLINE mode via CanIf_SetPduMode.
    04: Check pdu mode for controller 1.
    05: Simulate a Bus Off event by calling CanIf_ControllerBusOff().
    06: VP (CanIf.SWS_CanIf_00118_2):
        Verify that CanSM_ControllerBusOff is called when controller is stopped.
    07: Check controller mode for controller 1.
    08: VP (CanIf.SWS_CanIf_00866_2):
        Check that pdu mode for controller 1 is TX_OFFLINE.
    09: Simulate a Bus Off event by calling CanIf_ControllerBusOff().
    10: VP (CanIf.SWS_CanIf_00118_1):
         Verify that CanSM_ControllerBusOff is called when controller is stopped.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00118_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>449</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00118_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>450</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00866_2</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>768</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1763</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetTxConfStateGen</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>9364</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that CanIf_GetTxConfirmationState() returns the correct status,
    depending on whether a Tx confirmation happened before or not.
  
Test Object: 
    CanIf_GetTxConfirmationState()
  
Test Precondition: 
    - CanIf_GetTxConfirmationState() API is enabled.
    - CanIf is initialized, controller under test is started and no Tx
      confirmation was handled until now.
  
Test Execution: 
    01: Call CanIf_GetTxConfirmationState() for the controller under test.
    02: VP (CanIf.SWS_CanIf_00734):
        CanIf_GetTxConfirmationState() returns CANIF_NO_NOTIFICATION.
    03: Call CanIf_Transmit() for a Tx PDU assigned to the controller under
        test. Check that Can_Write() was called.
    04: Call CanIf_GetTxConfirmationState() for the controller under test.
    05: VP (CanIf.SWS_CanIf_00734):
        CanIf_GetTxConfirmationState() returns CANIF_NO_NOTIFICATION.
    06: Call CanIf_TxConfirmation() for the sent Tx PDU send. Check that the
        upper layer Tx confirmation is called.
    07: Call CanIf_GetTxConfirmationState() for the controller under test.
    08: VP (CanIf.SWS_CanIf_00734, CanIf.SWS_CanIf_00740):
        CanIf_GetTxConfirmationState() returns CANIF_TX_RX_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00734</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>661</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00740</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>667</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1764</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetTxConfStateClearStat</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>9486</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the combined Tx confirmation state is cleared after starting a
    controller again.
  
Test Object: 
    CanIf_GetTxConfirmationState()
  
Test Precondition: 
    - CanIf_GetTxConfirmationState() API is enabled.
    - Tx confirmation was received for the controller under tests.
  
Test Execution: 
    01: Call CanIf_GetTxConfirmationState() for the controller under test.
    02: VP (CanIf.SWS_CanIf_00734):
        CanIf_GetTxConfirmationState() returns CANIF_TX_RX_NOTIFICATION.
    03: Stop the controller under test.
    04: Restart the controller under test.
    05: Call CanIf_GetTxConfirmationState() for the controller under test.
    06: VP (CanIf.SWS_CanIf_00734):
        CanIf_GetTxConfirmationState() returns CANIF_NO_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00734</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>661</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1765</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetTxConfStateBusOff</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>9579</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the combined Tx confirmation state is cleared by a bus off
    event.
  
Test Object: 
    CanIf_GetTxConfirmationState()
  
Test Precondition: 
    - CanIf_GetTxConfirmationState() API is enabled.
    - Controller under test is started.
    - No previous Tx confirmation since the last start of the controller.
  
Test Execution: 
    01: Call CanIf_Transmit() for a Tx PDU assigned to the controller under
        test. Check that Can_Write() was called.
    02: Call CanIf_TxConfirmation() for the sent Tx PDU send. Check that the
        upper layer Tx confirmation is called.
    03: Call CanIf_GetTxConfirmationState() for the controller under test.
    04: VP (CanIf.SWS_CanIf_00734, CanIf.SWS_CanIf_00740):
        CanIf_GetTxConfirmationState() returns CANIF_TX_RX_NOTIFICATION.
    05: Call CanIf_ControllerBusOff() for the controller under test.
    06: Call CanIf_GetTxConfirmationState() for the controller under test.
    07: VP (CanIf.ASR40.SWS_CanIf_00739):
        CanIf_GetTxConfirmationState() returns CANIF_NO_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00734</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>661</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00740</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>667</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.SWS_CanIf_00739</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>241</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1766</internalId></specobject>
    <specobject>
      <id>TS_CANIF_GetTxConfStateOffAct</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_Basic_Common/source/application/tests_common.c.m4</sourcefile>
      <sourceline>9698</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Verify that the combined Tx confirmation state is correctly set in offline
    active mode.
  
Test Object: 
    CanIf_GetTxConfirmationState()
  
Test Precondition: 
    - CanIf_GetTxConfirmationState() API is enabled.
    - Controller under test is started.
    - No previous Tx confirmation since the last start of the controller.
  
Test Execution: 
    01: Set PDU mode of the controller to CANIF_OFFLINE_ACTIVE. Check the mode
        via CanIf_GetPduMode().
    02: Call CanIf_GetTxConfirmationState() for the controller under test.
    03: VP:
        CanIf_GetTxConfirmationState() returns CANIF_NO_NOTIFICATION.
    04: Call CanIf_Transmit() for a Tx PDU assigned to the controller under
        test. Check that Can_Write() was not called and that the upper layer
        Tx confirmation is called.
    05: Call CanIf_GetTxConfirmationState() for the controller under test.
    06: VP (CanIf.SWS_CanIf_00734, CanIf.SWS_CanIf_00740):
        CanIf_GetTxConfirmationState() returns CANIF_TX_RX_NOTIFICATION.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00734</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>661</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00740</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>667</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1767</internalId></specobject>
  </specobjects>
    <specobjects doctype="swuts">
    <specobject>
      <id>TS_CANIF_31224</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>320</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    A development error is generated if the translation results in an invalid CAN ID.
  
Test Object: 
    Rx CAN ID translation
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_RxIndication() to simulate reception for CddId_RxPdu_1, for which the translation
        function returns an invalid CAN ID.
    02: VP (CanIf.EB.CanIfTranslateRxCanIdFunc, CanIf.EB.CanIfTranslateRxCanIdFuncDetCheck):
        Verify that Det error CANIF_E_PARAM_CANID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTranslateRxCanIdFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>881</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTranslateRxCanIdFuncDetCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>882</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1768</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31226</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>417</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct reception of a message with a translated CAN ID with an upper layer, that does not
    receive the CAN ID as parameter (standard CAN ID).
  
Test Object: 
    Rx CAN ID translation
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_RxIndication() with a not configured CAN ID, that is translated into one, that is
        accepted by the CanIf.
    02: VP (CanIf.SWS_CanIf_00415, CanIf.ECUC_CanIf_00598):
        Check that PduR_CanIfRxIndication() is called with the correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00598</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1769</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31227</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>504</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct reception of a message with a translated CAN ID with an upper layer, that receives the
    CAN ID as parameter (extended CAN ID).
  
Test Object: 
    Rx CAN ID translation
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_RxIndication() with a not configured CAN ID, that is translated and it is
        accepted by the CanIf.
    02: VP (CanIf.SWS_CanIf_00415, CanIf.ECUC_CanIf_00598):
        Check that PduR_CanIfRxIndication() is called with the correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
        <provcov>
          <linksto>CanIf.ECUC_CanIf_00598</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>355</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1770</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31231</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>586</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct reception of a message with a translated CAN ID (received CAN ID belongs to another Rx
    PDU in the configuration).
  
Test Object: 
    Rx CAN ID translation
  
Test Precondition: 
    - CAN Interface is initialized and network is running.
    - Translated CAN ID 101 is the configured CAN ID for PduR_RxPdu_0 and PduR_RxPdu_1.
  
Test Execution: 
    01: Call CanIf_RxIndication() with PduR_RxPdu_0.
    02: VP(CanIf.SWS_CanIf_00415):
        Verify that PduR_CanIfRxIndication() is called with the correct parameters.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00415</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>557</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1771</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31225</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>666</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    A development error is generated if the translation results in an invalid CAN ID.
  
Test Object: 
    Tx CAN ID translation
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() with CddId_TxPdu_2, for which the translation function returns an
        invalid CAN ID and CanIf_Transmit() returns E_NOT_OK.
    02: VP (CanIf.EB.CanIfTranslateTxCanIdFunc, CanIf.EB.CanIfTranslateTxCanIdFuncDetCheck):
        Verify that Det error CANIF_E_PARAM_CANID is reported.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTranslateTxCanIdFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>879</internalId></provcov>
        <provcov>
          <linksto>CanIf.EB.CanIfTranslateTxCanIdFuncDetCheck</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>880</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1772</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31228</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>750</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct transmission of a message with a translated CAN ID (standard CAN ID).
  
Test Object: 
    Tx CAN ID translation
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() with PDU PduR_TxPdu_0, for which the translation function returns an
        a CAN ID that differs from the CAN ID which was configured for this PDU.
    02: VP (CanIf.EB.CanIfTranslateTxCanIdFunc):
        Check that Can_Write() was called with the correct parameters.
    03: Call CanIf_TxConfirmation() to confirm the correct transmission.
    04: VP(CanIf.SWS_CanIf_00439):
        Check that PduR_CanIfTxConfirmation to the PduR callback function.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.EB.CanIfTranslateTxCanIdFunc</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>879</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00439</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>570</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1773</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31229</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>848</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct buffering and retransmission of messages with translated CAN IDs
    (extended CAN ID).
  
Test Object: 
    Tx CAN ID translation
  
Test Precondition: 
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() for a valid Tx PDU and let Can_Write() return
        CAN_OK.
    02: Check Can_Write() is called with the correct parameters (especially the
        translated CAN ID).
    03: VP (CanIf.SWS_CanIf_00243, CanIf.ASR40.ECUC_CanIf_00590, CanIf.SWS_CanIf_00188_1):
         Check if the MSB of the CanId is set to 1 since it uses extended format.
    04: Call CanIf_Transmit() for the same Tx PDU again and let Can_Write()
        return CAN_BUSY (buffer a message).
    05: VP (CanIf.SWS_CanIf_00243):
        Check Can_Write is called with the correct parameters (especially the translated CAN ID).
    06: Call CanIf_Transmit() for a different Tx PDU assigned to the same HTH
        and a lower priority (higher CAN ID) as the PDU before and let
        Can_Write() return CAN_BUSY (buffer another message).
    07: VP (CanIf.SWS_CanIf_00243):
        Check Can_Write is called with the correct parameters (especially the
        translated CAN ID).
    08: Call CanIf_TxConfirmation() for the PDU from 01.
    09: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is called for the buffered PDU from 03 (with the same
          parameters again).
    10: Call CanIf_TxConfirmation() for the PDU from 08.
    11: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is called for the buffered PDU from 05 (with the same
          parameters again).
    12: Call CanIf_TxConfirmation() for the PDU from 09.
    13: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is not called again.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00590</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00188_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1774</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31230</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>1069</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct retransmission of a cancelled message with a translated CAN ID.
  
Test Object: 
    Tx CAN ID translation
  
Test Precondition: 
    - CAN Interface is initialized and network is running.
    - At least two different Tx PDUs A and B assigned to the same HTH. (Translated) CAN ID of Tx PDU
      B is lower than the translated CAN ID of Tx PDU A.
  
Test Execution: 
    01: Call CanIf_Transmit() for a valid Tx PDU, PduR_TxPdu_1 and let Can_Write() return CAN_OK.
    02: Check Can_Write() is called with the correct parameters (especially the translated CAN ID).
    03: VP (CanIf.SWS_CanIf_00243, CanIf.ASR40.ECUC_CanIf_00590, CanIf.SWS_CanIf_00188_1):
        Check if the MSB of the CanId is set to 0 since it uses standard format.
    04: Call CanIf_Transmit() to request transmission of PDU PduR_TxPdu_0 to cancel PduR_TxPdu_1.
    05: Check Can_Write is called with the correct parameters (especially the translated CAN ID).
    06: Call CanIf_CancelTxConfirmation() to confirm cancellation of PduR_TxPdu_1 transmission.
    07: Call CanIf_CancelTxConfirmation() to confirm cancellation of PduR_TxPdu_0 transmission.
    08: Check Can_Write() is called for PduR_TxPdu_1 with the translated CAN ID and the corresponding upper
        layer Tx confirmation callback is called for PduR_TxPdu_0.
    09: Call CanIf_TxConfirmation() to confirm the correct transmission of PduR_TxPdu_1.
    10: Verify that PduR_CanIfTxConfirmation is called for PduR_TxPdu_1.
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00590</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00188_1</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>467</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1775</internalId></specobject>
    <specobject>
      <id>TS_CANIF_31233</id>
      <status>approved</status>
      <source>EB test case specification (asc_CanIf)</source>
      <sourcefile>/cygdrive/c/work/workspace/LEAD_ACG-9.3.0/asc_CanIf/test/ts5/Include/CanIf_ConTest_TranslateCanIds_Base/source/application/Tests.c</sourcefile>
      <sourceline>1228</sourceline>
      <version>1</version>
      <description>&lt;pre&gt;Test Synopsis: None.
Test Description: 
    Correct buffering and retransmission of messages with translated CAN IDs
    (extended CAN ID) interrupted by a bus-off.
  
Test Object: 
    Tx CAN ID translation
  
Test Precondition: 
    This test is also a regression test to verify the fix of the bug
    described with ASCCANIF-1286.
    CAN Interface is initialized and network is running.
  
Test Execution: 
    01: Call CanIf_Transmit() for a valid Tx PDU and let Can_Write() return
        CAN_OK.
    02: Check Can_Write() is called with the correct parameters (especially the
        translated CAN ID).
    03: Call CanIf_Transmit() for the same Tx PDU again and let Can_Write()
        return CAN_BUSY (buffer a message).
    04: VP (CanIf.SWS_CanIf_00243):
        Check Can_Write is called with the correct parameters (especially the translated CAN ID).
    05: Call CanIf_Transmit() for a different Tx PDU assigned to the same HTH
        and a lower priority (higher CAN ID) as the PDU before and let
        Can_Write() return CAN_BUSY (buffer another message).
    06: VP (CanIf.SWS_CanIf_00243):
        Check Can_Write is called with the correct parameters (especially the
        translated CAN ID).
    07: Call CanIf_TxConfirmation() for the PDU from 01. Can_Write() stub simulates a bus-off request
        when trying to re-send the buffered Pdus.
    08: VP (CanIf.SWS_CanIf_00724):
        Check that CanSM_ControllerBusOff() was called
    09: - Upper layer Tx confirmation is called for the correct PDU.
        - Can_Write() is called for the buffered PDU from 03 (with the same
          parameters again).
  
Test Input: 
  
Test Output: 
  &lt;/pre&gt;</description>
      <providescoverage>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00243</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>486</internalId></provcov>
        <provcov>
          <linksto>CanIf.ASR40.ECUC_CanIf_00590</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>232</internalId></provcov>
        <provcov>
          <linksto>CanIf.SWS_CanIf_00724</linksto>
          <dstversion>1</dstversion>
        <linkstatus>linked</linkstatus><linkdestdoctype>swurs</linkdestdoctype><linkerror/><internalId>659</internalId></provcov>
      </providescoverage>
    <violations/><oreqmViolations/><covstatus>covered</covstatus><internalId>1776</internalId></specobject>
  </specobjects>
  </specdocument>
  <violations/>
  <oreqmViolations/>
</tracingresults>
